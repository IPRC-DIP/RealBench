{"task": "e203_biu", "codeid": 1, "code": "module e203_biu (\n    input wire clk,\n    input wire rst_n,\n    output wire biu_active,\n\n    // ICB interface to LSU\n    input wire lsu_icb_cmd_valid,\n    output wire lsu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] lsu_icb_cmd_addr,\n    input wire lsu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] lsu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] lsu_icb_cmd_wmask,\n    input wire [1:0] lsu_icb_cmd_burst,\n    input wire [1:0] lsu_icb_cmd_beat,\n    input wire lsu_icb_cmd_lock,\n    input wire lsu_icb_cmd_excl,\n    input wire [1:0] lsu_icb_cmd_size,\n    output wire lsu_icb_rsp_valid,\n    input wire lsu_icb_rsp_ready,\n    output wire lsu_icb_rsp_err,\n    output wire lsu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] lsu_icb_rsp_rdata,\n\n    // ICB interface to IFU\n    `ifdef E203_HAS_MEM_ITF\n    input wire ifu_icb_cmd_valid,\n    output wire ifu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] ifu_icb_cmd_addr,\n    input wire ifu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ifu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] ifu_icb_cmd_wmask,\n    input wire [1:0] ifu_icb_cmd_burst,\n    input wire [1:0] ifu_icb_cmd_beat,\n    input wire ifu_icb_cmd_lock,\n    input wire ifu_icb_cmd_excl,\n    input wire [1:0] ifu_icb_cmd_size,\n    output wire ifu_icb_rsp_valid,\n    input wire ifu_icb_rsp_ready,\n    output wire ifu_icb_rsp_err,\n    output wire ifu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] ifu_icb_rsp_rdata,\n    `endif\n\n    // ICB interface to PPI\n    input wire ppi_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] ppi_region_indic,\n\n    // ICB interface to CLINT\n    input wire clint_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] clint_region_indic,\n\n    // ICB interface to PLIC\n    input wire plic_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] plic_region_indic,\n\n    // ICB interface to FIO\n    `ifdef E203_HAS_FIO\n    input wire fio_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] fio_region_indic,\n    `endif\n\n    // ICB interface to MEM\n    `ifdef E203_HAS_MEM_ITF\n    input wire mem_icb_enable,\n    `endif\n\n    // Outputs to external memory system\n    output wire mem_icb_cmd_valid,\n    input wire mem_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] mem_icb_cmd_addr,\n    output wire mem_icb_cmd_read,\n    output wire [E203_XLEN-1:0] mem_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] mem_icb_cmd_wmask,\n    output wire mem_icb_rsp_valid,\n    input wire mem_icb_rsp_ready,\n    output wire mem_icb_rsp_err,\n    output wire mem_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] mem_icb_rsp_rdata\n);\n\n    // Internal signals for arbitration and splitting logic\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_valid;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_ready;\n    wire [BIU_ARBT_I_NUM*E203_ADDR_SIZE-1:0] arbt_icb_cmd_addr;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_read;\n    wire [BIU_ARBT_I_NUM*E203_XLEN-1:0] arbt_icb_cmd_wdata;\n    wire [BIU_ARBT_I_NUM*(E203_XLEN/8)-1:0] arbt_icb_cmd_wmask;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_valid;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_ready;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_err;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_excl_ok;\n    wire [BIU_ARBT_I_NUM*E203_XLEN-1:0] arbt_icb_rsp_rdata;\n\n    // Instantiate the ICB Arbiter\n    sirv_gnrl_icb_arbt #(\n        .AW(E203_ADDR_SIZE),\n        .DW(E203_XLEN),\n        .ARBT_NUM(BIU_ARBT_I_NUM),\n        .ARBT_PTR_W(BIU_ARBT_I_PTR_W),\n        .USR_W(1),\n        .ARBT_SCHEME(0),\n        .ALLOW_0CYCL_RSP(0),\n        .FIFO_OUTS_NUM(E203_BIU_OUTS_NUM),\n        .FIFO_CUT_READY(E203_BIU_CMD_CUT_READY)\n    ) u_icb_arbt (\n        .clk(clk),\n        .rst_n(rst_n),\n        .i_bus_icb_cmd_valid(arbt_icb_cmd_valid),\n        .i_bus_icb_cmd_ready(arbt_icb_cmd_ready),\n        .i_bus_icb_cmd_addr(arbt_icb_cmd_addr),\n        .i_bus_icb_cmd_read(arbt_icb_cmd_read),\n        .i_bus_icb_cmd_wdata(arbt_icb_cmd_wdata),\n        .i_bus_icb_cmd_wmask(arbt_icb_cmd_wmask),\n        .o_icb_cmd_valid(mem_icb_cmd_valid),\n        .o_icb_cmd_ready(mem_icb_cmd_ready),\n        .o_icb_cmd_addr(mem_icb_cmd_addr),\n        .o_icb_cmd_read(mem_icb_cmd_read),\n        .o_icb_cmd_wdata(mem_icb_cmd_wdata),\n        .o_icb_cmd_wmask(mem_icb_cmd_wmask),\n        .o_icb_rsp_valid(mem_icb_rsp_valid),\n        .o_icb_rsp_ready(mem_icb_rsp_ready),\n        .o_icb_rsp_err(mem_icb_rsp_err),\n        .o_icb_rsp_excl_ok(mem_icb_rsp_excl_ok),\n        .o_icb_rsp_rdata(mem_icb_rsp_rdata)\n    );\n\n    // Logic to connect LSU, IFU, and other interfaces to the arbiter\n    assign arbt_icb_cmd_valid = {`ifdef E203_HAS_MEM_ITF ifu_icb_cmd_valid, `endif lsu_icb_cmd_valid};\n    assign {`ifdef E203_HAS_MEM_ITF ifu_icb_cmd_ready, `endif lsu_icb_cmd_ready} = arbt_icb_cmd_ready;\n    assign arbt_icb_cmd_addr = {`ifdef E203_HAS_MEM_ITF ifu_icb_cmd_addr, `endif lsu_icb_cmd_addr};\n    assign arbt_icb_cmd_read = {`ifdef E203_HAS_MEM_ITF ifu_icb_cmd_read, `endif lsu_icb_cmd_read};\n    assign arbt_icb_cmd_wdata = {`ifdef E203_HAS_MEM_ITF ifu_icb_cmd_wdata, `endif lsu_icb_cmd_wdata};\n    assign arbt_icb_cmd_wmask = {`ifdef E203_HAS_MEM_ITF ifu_icb_cmd_wmask, `endif lsu_icb_cmd_wmask};\n    assign {`ifdef E203_HAS_MEM_ITF ifu_icb_rsp_valid, `endif lsu_icb_rsp_valid} = arbt_icb_rsp_valid;\n    assign arbt_icb_rsp_ready = {`ifdef E203_HAS_MEM_ITF ifu_icb_rsp_ready, `endif lsu_icb_rsp_ready};\n    assign {`ifdef E203_HAS_MEM_ITF ifu_icb_rsp_err, `endif lsu_icb_rsp_err} = arbt_icb_rsp_err;\n    assign {`ifdef E203_HAS_MEM_ITF ifu_icb_rsp_excl_ok, `endif lsu_icb_rsp_excl_ok} = arbt_icb_rsp_excl_ok;\n    assign arbt_icb_rsp_rdata = {`ifdef E203_HAS_MEM_ITF ifu_icb_rsp_rdata, `endif lsu_icb_rsp_rdata};\n\n    // Active signal logic\n    assign biu_active = |arbt_icb_cmd_valid | |arbt_icb_rsp_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 1, "code": "`include \"e203_defines.v\"\n\nmodule e203_clkgate(\n    input wire clk_in,\n    input wire test_mode,\n    input wire clock_en,\n    output wire clk_out\n);\n\n`ifdef FPGA_SOURCE\n    // FPGA mode: direct connection\n    assign clk_out = clk_in;\n`else\n    // Gating mode\n    reg enb;\n    always @(negedge clk_in) begin\n        enb <= clock_en | test_mode;\n    end\n\n    assign clk_out = clk_in & enb;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 1, "code": "module e203_extend_csr (\n    input wire clk,\n    input wire rst_n,\n    input wire nice_csr_valid,\n    output wire nice_csr_ready,\n    input wire [31:0] nice_csr_addr,\n    input wire nice_csr_wr,\n    input wire [31:0] nice_csr_wdata,\n    output wire [31:0] nice_csr_rdata\n);\n\n`ifdef E203_HAS_CSR_NICE\n    assign nice_csr_ready = 1'b1;\n    assign nice_csr_rdata = 32'b0;\n`else\n    assign nice_csr_ready = 1'b0;\n    assign nice_csr_rdata = 32'b0;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 2, "code": "`include \"e203_defines.v\"\n\nmodule e203_clkgate(\n    input wire clk_in,\n    input wire test_mode,\n    input wire clock_en,\n    output wire clk_out\n);\n\n`ifdef FPGA_SOURCE\n    // FPGA mode: direct connection\n    assign clk_out = clk_in;\n`else\n    // Gating mode: controlled clock output\n    reg enb;\n    always @(negedge clk_in) begin\n        enb <= clock_en | test_mode;\n    end\n\n    assign clk_out = clk_in & enb;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 3, "code": "`include \"e203_defines.v\"\n\nmodule e203_clkgate(\n    input wire clk_in,\n    input wire test_mode,\n    input wire clock_en,\n    output wire clk_out\n);\n\n`ifdef FPGA_SOURCE\n    // FPGA mode: direct connection\n    assign clk_out = clk_in;\n`else\n    // Gating mode: controlled clock output\n    reg enb;\n    always @(negedge clk_in) begin\n        enb <= clock_en | test_mode;\n    end\n\n    assign clk_out = clk_in & enb;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 4, "code": "`include \"e203_defines.v\"\n\nmodule e203_clkgate(\n    input wire clk_in,\n    input wire test_mode,\n    input wire clock_en,\n    output wire clk_out\n);\n\n`ifdef FPGA_SOURCE\n    // FPGA mode: direct connection\n    assign clk_out = clk_in;\n`else\n    // Gating mode\n    reg enb;\n    always @(negedge clk_in) begin\n        enb <= clock_en | test_mode;\n    end\n\n    assign clk_out = clk_in & enb;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 5, "code": "`include \"e203_defines.v\"\n\nmodule e203_clkgate(\n    input wire clk_in,\n    input wire test_mode,\n    input wire clock_en,\n    output reg clk_out\n);\n\n`ifdef FPGA_SOURCE\n    // FPGA mode: direct connection\n    assign clk_out = clk_in;\n`else\n    // Gating mode\n    reg enb;\n\n    always @(negedge clk_in) begin\n        enb <= clock_en | test_mode;\n    end\n\n    always @(posedge clk_in) begin\n        if (enb)\n            clk_out <= clk_in;\n        else\n            clk_out <= 1'b0;\n    end\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 6, "code": "`include \"e203_defines.v\"\n\nmodule e203_clkgate (\n    input wire clk_in,\n    input wire test_mode,\n    input wire clock_en,\n    output wire clk_out\n);\n\n`ifdef FPGA_SOURCE\n    // FPGA mode: direct connection\n    assign clk_out = clk_in;\n`else\n    // Gating mode: controlled clock output\n    reg enb;\n    always @(negedge clk_in) begin\n        enb <= clock_en | test_mode;\n    end\n\n    assign clk_out = clk_in & enb;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 7, "code": "`include \"e203_defines.v\"\n\nmodule e203_clkgate(\n    input wire clk_in,\n    input wire test_mode,\n    input wire clock_en,\n    output reg clk_out\n);\n\n`ifdef FPGA_SOURCE\n    // FPGA mode: direct connection\n    assign clk_out = clk_in;\n`else\n    // Gating mode\n    reg enb;\n\n    always @(negedge clk_in) begin\n        if (test_mode || clock_en)\n            enb <= 1'b1;\n        else\n            enb <= 1'b0;\n    end\n\n    always @(posedge clk_in) begin\n        if (enb)\n            clk_out <= clk_in;\n        else\n            clk_out <= 1'b0;\n    end\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 8, "code": "`include \"e203_defines.v\"\n\nmodule e203_clkgate(\n    input wire clk_in,\n    input wire test_mode,\n    input wire clock_en,\n    output wire clk_out\n);\n\n`ifdef FPGA_SOURCE\n    // FPGA mode: direct connection\n    assign clk_out = clk_in;\n`else\n    // Gating mode\n    reg enb;\n    always @(negedge clk_in) begin\n        enb <= clock_en | test_mode;\n    end\n\n    assign clk_out = clk_in & enb;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 9, "code": "`include \"e203_defines.v\"\n\nmodule e203_clkgate(\n    input wire clk_in,\n    input wire test_mode,\n    input wire clock_en,\n    output reg clk_out\n);\n\n`ifdef FPGA_SOURCE\n    // FPGA mode: direct connection\n    assign clk_out = clk_in;\n`else\n    // Gating mode\n    reg enb;\n    always @(negedge clk_in) begin\n        enb <= clock_en | test_mode;\n    end\n\n    always @(posedge clk_in) begin\n        if (enb)\n            clk_out <= clk_in;\n        else\n            clk_out <= 1'b0;\n    end\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 10, "code": "`include \"e203_defines.v\"\n\nmodule e203_clkgate (\n    input wire clk_in,\n    input wire test_mode,\n    input wire clock_en,\n    output wire clk_out\n);\n\n`ifdef FPGA_SOURCE\n    // In FPGA mode, directly connect clk_in to clk_out\n    assign clk_out = clk_in;\n`else\n    reg enb;\n    wire enb_next;\n\n    // enb is updated only when clk_in is low to avoid glitches\n    always @(negedge clk_in or posedge test_mode or posedge clock_en)\n    begin\n        if (test_mode || clock_en)\n            enb <= 1'b1;\n        else\n            enb <= 1'b0;\n    end\n\n    // Clock gating logic\n    assign clk_out = clk_in & enb;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 11, "code": "`include \"e203_defines.v\"\n\nmodule e203_clkgate(\n    input wire clk_in,\n    input wire test_mode,\n    input wire clock_en,\n    output reg clk_out\n);\n\n`ifdef FPGA_SOURCE\n    // In FPGA mode, directly connect clk_in to clk_out\n    assign clk_out = clk_in;\n`else\n    reg enb;\n\n    // Clock gating logic\n    always @(negedge clk_in) begin\n        if (test_mode || clock_en)\n            enb <= 1'b1;\n        else\n            enb <= 1'b0;\n    end\n\n    // Output clock generation\n    always @(posedge clk_in) begin\n        if (enb)\n            clk_out <= clk_in;\n        else\n            clk_out <= 1'b0;\n    end\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 12, "code": "`include \"e203_defines.v\"\n\nmodule e203_clkgate(\n    input wire clk_in,\n    input wire test_mode,\n    input wire clock_en,\n    output wire clk_out\n);\n\n`ifdef FPGA_SOURCE\n    // FPGA mode: Direct connection\n    assign clk_out = clk_in;\n`else\n    // Gating mode\n    reg enb;\n    wire enb_next = clock_en | test_mode;\n\n    // Update enable signal only on the falling edge of clk_in\n    always @(negedge clk_in) begin\n        enb <= enb_next;\n    end\n\n    // Gated clock output\n    assign clk_out = clk_in & enb;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 2, "code": "module e203_extend_csr (\n    input wire clk,\n    input wire rst_n,\n    input wire nice_csr_valid,\n    output wire nice_csr_ready,\n    input wire [31:0] nice_csr_addr,\n    input wire nice_csr_wr,\n    input wire [31:0] nice_csr_wdata,\n    output wire [31:0] nice_csr_rdata\n);\n\n`ifdef E203_HAS_CSR_NICE\n    // CSR access ready signal, always 1\n    assign nice_csr_ready = 1'b1;\n\n    // CSR read data, always 0\n    assign nice_csr_rdata = 32'b0;\n\n    // Currently, the address, write enable, and write data are unused\n    // Future implementations can use these inputs for actual CSR operations\n`else\n    assign nice_csr_ready = 1'b0;\n    assign nice_csr_rdata = 32'b0;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 13, "code": "`include \"e203_defines.v\"\n\nmodule e203_clkgate(\n    input wire clk_in,\n    input wire test_mode,\n    input wire clock_en,\n    output reg clk_out\n);\n\n`ifdef FPGA_SOURCE\n    // FPGA mode: direct connection\n    assign clk_out = clk_in;\n`else\n    // Gating mode\n    reg enb;\n\n    always @(negedge clk_in) begin\n        if (test_mode || clock_en)\n            enb <= 1'b1;\n        else\n            enb <= 1'b0;\n    end\n\n    always @(posedge clk_in) begin\n        if (enb)\n            clk_out <= clk_in;\n        else\n            clk_out <= 1'b0;\n    end\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 3, "code": "module e203_extend_csr (\n    input wire clk,\n    input wire rst_n,\n    input wire nice_csr_valid,\n    output wire nice_csr_ready,\n    input wire [31:0] nice_csr_addr,\n    input wire nice_csr_wr,\n    input wire [31:0] nice_csr_wdata,\n    output wire [31:0] nice_csr_rdata\n);\n\n`ifdef E203_HAS_CSR_NICE\n    assign nice_csr_ready = 1'b1; // Always ready\n    assign nice_csr_rdata = 32'b0; // Always return zero\n`else\n    assign nice_csr_ready = 1'b0; // Never ready\n    assign nice_csr_rdata = 32'b0; // Always return zero\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 4, "code": "module e203_extend_csr (\n    input wire clk,\n    input wire rst_n,\n    input wire nice_csr_valid,\n    output wire nice_csr_ready,\n    input wire [31:0] nice_csr_addr,\n    input wire nice_csr_wr,\n    input wire [31:0] nice_csr_wdata,\n    output wire [31:0] nice_csr_rdata\n);\n\n`ifdef E203_HAS_CSR_NICE\n    // CSR access ready signal, always 1\n    assign nice_csr_ready = 1'b1;\n    // CSR read data, always 0\n    assign nice_csr_rdata = 32'b0;\n`else\n    assign nice_csr_ready = 1'b0;\n    assign nice_csr_rdata = 32'b0;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 5, "code": "module e203_extend_csr (\n    input wire clk,\n    input wire rst_n,\n    input wire nice_csr_valid,\n    output wire nice_csr_ready,\n    input wire [31:0] nice_csr_addr,\n    input wire nice_csr_wr,\n    input wire [31:0] nice_csr_wdata,\n    output wire [31:0] nice_csr_rdata\n);\n\n`ifdef E203_HAS_CSR_NICE\n    // CSR access ready signal, always 1\n    assign nice_csr_ready = 1'b1;\n    // CSR read data, always 0\n    assign nice_csr_rdata = 32'b0;\n`else\n    // When the module is disabled, tie off outputs\n    assign nice_csr_ready = 1'b0;\n    assign nice_csr_rdata = 32'b0;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 1, "code": "module e203_dtcm_ram (\n    input wire sd,\n    input wire ds,\n    input wire ls,\n    input wire cs,\n    input wire we,\n    input wire [E203_DTCM_RAM_AW-1:0] addr,\n    input wire [E203_DTCM_RAM_MW-1:0] wem,\n    input wire [E203_DTCM_RAM_DW-1:0] din,\n    input wire rst_n,\n    input wire clk,\n    output wire [E203_DTCM_RAM_DW-1:0] dout\n);\n\n    sirv_gnrl_ram #(\n        .DP(E203_DTCM_RAM_DP),\n        .DW(E203_DTCM_RAM_DW),\n        .FORCE_X2ZERO(1),\n        .MW(E203_DTCM_RAM_MW),\n        .AW(E203_DTCM_RAM_AW)\n    ) u_203_dtcm_gnrl_ram (\n        .sd(sd),\n        .ds(ds),\n        .ls(ls),\n        .rst_n(rst_n),\n        .clk(clk),\n        .cs(cs),\n        .we(we),\n        .addr(addr),\n        .din(din),\n        .wem(wem),\n        .dout(dout)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 6, "code": "module e203_extend_csr (\n    input wire clk,\n    input wire rst_n,\n    input wire nice_csr_valid,\n    output wire nice_csr_ready,\n    input wire [31:0] nice_csr_addr,\n    input wire nice_csr_wr,\n    input wire [31:0] nice_csr_wdata,\n    output wire [31:0] nice_csr_rdata\n);\n\n`ifdef E203_HAS_CSR_NICE\n    // CSR is enabled\n    assign nice_csr_ready = 1'b1; // Always ready\n    assign nice_csr_rdata = 32'b0; // Always return zero\n`else\n    // CSR is disabled\n    assign nice_csr_ready = 1'b0; // Never ready\n    assign nice_csr_rdata = 32'b0; // Always return zero\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 7, "code": "module e203_extend_csr (\n    input wire clk,\n    input wire rst_n,\n    input wire nice_csr_valid,\n    output wire nice_csr_ready,\n    input wire [31:0] nice_csr_addr,\n    input wire nice_csr_wr,\n    input wire [31:0] nice_csr_wdata,\n    output wire [31:0] nice_csr_rdata\n);\n\n`ifdef E203_HAS_CSR_NICE\n    // CSR access ready signal, always 1\n    assign nice_csr_ready = 1'b1;\n    // CSR read data, always 0\n    assign nice_csr_rdata = 32'b0;\n`else\n    assign nice_csr_ready = 1'b0;\n    assign nice_csr_rdata = 32'b0;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 14, "code": "`include \"e203_defines.v\"\n\nmodule e203_clkgate(\n    input wire clk_in,\n    input wire test_mode,\n    input wire clock_en,\n    output wire clk_out\n);\n\n`ifdef FPGA_SOURCE\n    // FPGA mode: direct connection\n    assign clk_out = clk_in;\n`else\n    // Gating mode\n    reg enb;\n    always @(negedge clk_in) begin\n        enb <= clock_en | test_mode;\n    end\n\n    assign clk_out = clk_in & enb;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 15, "code": "`include \"e203_defines.v\"\n\nmodule e203_clkgate(\n    input wire clk_in,\n    input wire test_mode,\n    input wire clock_en,\n    output wire clk_out\n);\n\n`ifdef FPGA_SOURCE\n    // In FPGA mode, directly connect clk_in to clk_out\n    assign clk_out = clk_in;\n`else\n    // In ASIC mode, implement clock gating logic\n    reg enb;\n    always @(negedge clk_in) begin\n        enb <= clock_en | test_mode;\n    end\n\n    assign clk_out = clk_in & enb;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 8, "code": "module e203_extend_csr (\n    input wire clk,\n    input wire rst_n,\n    input wire nice_csr_valid,\n    output wire nice_csr_ready,\n    input wire [31:0] nice_csr_addr,\n    input wire nice_csr_wr,\n    input wire [31:0] nice_csr_wdata,\n    output wire [31:0] nice_csr_rdata\n);\n\n`ifdef E203_HAS_CSR_NICE\n    // CSR access ready signal, always 1\n    assign nice_csr_ready = 1'b1;\n\n    // CSR read data, always 0\n    assign nice_csr_rdata = 32'b0;\n\n    // Currently, the address, write enable, and write data are not used\n    // Future implementations can use these inputs for actual CSR operations\n`else\n    assign nice_csr_ready = 1'b0;\n    assign nice_csr_rdata = 32'b0;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 9, "code": "module e203_extend_csr (\n    input wire clk,\n    input wire rst_n,\n    input wire nice_csr_valid,\n    output wire nice_csr_ready,\n    input wire [31:0] nice_csr_addr,\n    input wire nice_csr_wr,\n    input wire [31:0] nice_csr_wdata,\n    output wire [31:0] nice_csr_rdata\n);\n\n`ifdef E203_HAS_CSR_NICE\n    // CSR access ready signal, always 1\n    assign nice_csr_ready = 1'b1;\n\n    // CSR read data, always 0\n    assign nice_csr_rdata = 32'b0;\n\n    // Currently, the address, write enable, and write data are unused\n    // Future implementations can use these inputs for actual CSR operations\n`else\n    // If the CSR extension is not included, tie off outputs\n    assign nice_csr_ready = 1'b0;\n    assign nice_csr_rdata = 32'b0;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 2, "code": "module e203_dtcm_ram (\n    input wire sd,\n    input wire ds,\n    input wire ls,\n    input wire cs,\n    input wire we,\n    input wire [E203_DTCM_RAM_AW-1:0] addr,\n    input wire [E203_DTCM_RAM_MW-1:0] wem,\n    input wire [E203_DTCM_RAM_DW-1:0] din,\n    input wire rst_n,\n    input wire clk,\n    output wire [E203_DTCM_RAM_DW-1:0] dout\n);\n\n    // Instantiate the generic RAM module\n    sirv_gnrl_ram #(\n        .DP(E203_DTCM_RAM_DP),\n        .DW(E203_DTCM_RAM_DW),\n        .FORCE_X2ZERO(1),\n        .MW(E203_DTCM_RAM_MW),\n        .AW(E203_DTCM_RAM_AW)\n    ) u_203_dtcm_gnrl_ram (\n        .sd(sd),\n        .ds(ds),\n        .ls(ls),\n        .rst_n(rst_n),\n        .clk(clk),\n        .cs(cs),\n        .we(we),\n        .addr(addr),\n        .din(din),\n        .wem(wem),\n        .dout(dout)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 16, "code": "`include \"e203_defines.v\"\n\nmodule e203_clkgate(\n    input wire clk_in,\n    input wire test_mode,\n    input wire clock_en,\n    output wire clk_out\n);\n\n`ifdef FPGA_SOURCE\n    // FPGA mode: direct connection\n    assign clk_out = clk_in;\n`else\n    // Gating mode\n    reg enb;\n    always @(negedge clk_in) begin\n        enb <= clock_en | test_mode;\n    end\n\n    assign clk_out = clk_in & enb;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 17, "code": "`include \"e203_defines.v\"\n\nmodule e203_clkgate(\n    input wire clk_in,\n    input wire test_mode,\n    input wire clock_en,\n    output wire clk_out\n);\n\n`ifdef FPGA_SOURCE\n    // FPGA mode: direct connection\n    assign clk_out = clk_in;\n`else\n    // Gating mode\n    reg enb;\n    always @(negedge clk_in) begin\n        enb <= clock_en | test_mode;\n    end\n\n    assign clk_out = clk_in & enb;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 18, "code": "`include \"e203_defines.v\"\n\nmodule e203_clkgate(\n    input wire clk_in,\n    input wire test_mode,\n    input wire clock_en,\n    output wire clk_out\n);\n\n`ifdef FPGA_SOURCE\n    // FPGA mode: direct connection\n    assign clk_out = clk_in;\n`else\n    // Gating mode: controlled clock gating\n    reg enb;\n    always @(negedge clk_in) begin\n        enb <= clock_en | test_mode;\n    end\n\n    assign clk_out = clk_in & enb;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 10, "code": "`include \"e203_defines.v\"\n\nmodule e203_extend_csr (\n    input wire clk,\n    input wire rst_n,\n    input wire nice_csr_valid,\n    output wire nice_csr_ready,\n    input wire [31:0] nice_csr_addr,\n    input wire nice_csr_wr,\n    input wire [31:0] nice_csr_wdata,\n    output wire [31:0] nice_csr_rdata\n);\n\n`ifdef E203_HAS_CSR_NICE\n    // CSR access ready signal, always 1\n    assign nice_csr_ready = 1'b1;\n\n    // CSR read data, always 0\n    assign nice_csr_rdata = 32'b0;\n\n    // Currently unused input signals\n    // nice_csr_addr, nice_csr_wr, nice_csr_wdata are not used in this stub implementation\n\n`else\n    // When E203_HAS_CSR_NICE is not defined, tie off outputs\n    assign nice_csr_ready = 1'b0;\n    assign nice_csr_rdata = 32'b0;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 3, "code": "`include \"e203_defines.v\"\n\nmodule e203_dtcm_ram (\n    input wire sd,\n    input wire ds,\n    input wire ls,\n    input wire cs,\n    input wire we,\n    input wire [E203_DTCM_RAM_AW-1:0] addr,\n    input wire [E203_DTCM_RAM_MW-1:0] wem,\n    input wire [E203_DTCM_RAM_DW-1:0] din,\n    input wire rst_n,\n    input wire clk,\n    output wire [E203_DTCM_RAM_DW-1:0] dout\n);\n\nsirv_gnrl_ram #(\n    .DP(E203_DTCM_RAM_DP),\n    .DW(E203_DTCM_RAM_DW),\n    .FORCE_X2ZERO(1),\n    .MW(E203_DTCM_RAM_MW),\n    .AW(E203_DTCM_RAM_AW)\n) u_203_dtcm_gnrl_ram (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 4, "code": "module e203_dtcm_ram (\n    input wire sd,\n    input wire ds,\n    input wire ls,\n    input wire cs,\n    input wire we,\n    input wire [E203_DTCM_RAM_AW-1:0] addr,\n    input wire [E203_DTCM_RAM_MW-1:0] wem,\n    input wire [E203_DTCM_RAM_DW-1:0] din,\n    input wire rst_n,\n    input wire clk,\n    output wire [E203_DTCM_RAM_DW-1:0] dout\n);\n\n    sirv_gnrl_ram #(\n        .DP(E203_DTCM_RAM_DP),\n        .DW(E203_DTCM_RAM_DW),\n        .FORCE_X2ZERO(1),\n        .MW(E203_DTCM_RAM_MW),\n        .AW(E203_DTCM_RAM_AW)\n    ) u_203_dtcm_gnrl_ram (\n        .sd(sd),\n        .ds(ds),\n        .ls(ls),\n        .rst_n(rst_n),\n        .clk(clk),\n        .cs(cs),\n        .we(we),\n        .addr(addr),\n        .din(din),\n        .wem(wem),\n        .dout(dout)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 5, "code": "module e203_dtcm_ram (\n    input wire sd,\n    input wire ds,\n    input wire ls,\n    input wire cs,\n    input wire we,\n    input wire [E203_DTCM_RAM_AW-1:0] addr,\n    input wire [E203_DTCM_RAM_MW-1:0] wem,\n    input wire [E203_DTCM_RAM_DW-1:0] din,\n    input wire rst_n,\n    input wire clk,\n    output wire [E203_DTCM_RAM_DW-1:0] dout\n);\n\n`include \"e203_defines.v\"\n\nsirv_gnrl_ram #(\n    .DP(E203_DTCM_RAM_DP),\n    .DW(E203_DTCM_RAM_DW),\n    .FORCE_X2ZERO(1),\n    .MW(E203_DTCM_RAM_MW),\n    .AW(E203_DTCM_RAM_AW)\n) u_203_dtcm_gnrl_ram (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 1, "code": "module e203_clk_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire core_cgstop,\n    input wire core_ifu_active,\n    input wire core_exu_active,\n    input wire core_lsu_active,\n    input wire core_biu_active,\n    input wire core_wfi,\n    output wire clk_aon,\n    output wire clk_core_ifu,\n    output wire clk_core_exu,\n    output wire clk_core_lsu,\n    output wire clk_core_biu,\n`ifdef E203_HAS_ITCM\n    input wire itcm_active,\n    output wire itcm_ls,\n    output wire clk_itcm,\n`endif\n`ifdef E203_HAS_DTCM\n    input wire dtcm_active,\n    output wire dtcm_ls,\n    output wire clk_dtcm,\n`endif\n);\n\n// Always-on clock\nassign clk_aon = clk;\n\n// Clock gating logic for IFU\nassign clk_core_ifu = core_cgstop | (core_ifu_active & ~core_wfi);\n\n// Clock gating logic for other core modules\nassign clk_core_exu = core_cgstop | core_exu_active;\nassign clk_core_lsu = core_cgstop | core_lsu_active;\nassign clk_core_biu = core_cgstop | core_biu_active;\n\n`ifdef E203_HAS_ITCM\n// ITCM clock gating logic\nreg itcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        itcm_active_r <= 1'b0;\n    else\n        itcm_active_r <= itcm_active;\nend\n\nassign clk_itcm = core_cgstop | itcm_active | itcm_active_r;\nassign itcm_ls = ~(itcm_active | itcm_active_r);\n`endif\n\n`ifdef E203_HAS_DTCM\n// DTCM clock gating logic\nreg dtcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        dtcm_active_r <= 1'b0;\n    else\n        dtcm_active_r <= dtcm_active;\nend\n\nassign clk_dtcm = core_cgstop | dtcm_active | dtcm_active_r;\nassign dtcm_ls = ~(dtcm_active | dtcm_active_r);\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 19, "code": "`include \"e203_defines.v\"\n\nmodule e203_clkgate(\n    input wire clk_in,\n    input wire test_mode,\n    input wire clock_en,\n    output reg clk_out\n);\n\n`ifdef FPGA_SOURCE\n    // FPGA mode: direct connection\n    assign clk_out = clk_in;\n`else\n    // Gating mode: controlled clock output\n    reg enb;\n\n    always @(negedge clk_in) begin\n        if (!clk_in) begin\n            enb <= clock_en | test_mode;\n        end\n    end\n\n    always @(*) begin\n        if (enb) begin\n            clk_out = clk_in;\n        end else begin\n            clk_out = 1'b0;\n        end\n    end\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 20, "code": "`include \"e203_defines.v\"\n\nmodule e203_clkgate(\n    input wire clk_in,\n    input wire test_mode,\n    input wire clock_en,\n    output reg clk_out\n);\n\n`ifdef FPGA_SOURCE\n    // FPGA mode: direct connection\n    assign clk_out = clk_in;\n`else\n    // Gating mode: controlled clock gating\n    reg enb;\n\n    always @(negedge clk_in) begin\n        if (!clk_in) begin\n            enb <= clock_en | test_mode;\n        end\n    end\n\n    always @(*) begin\n        if (enb) begin\n            clk_out = clk_in;\n        end else begin\n            clk_out = 1'b0;\n        end\n    end\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 2, "code": "module e203_clk_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire core_cgstop,\n    input wire core_ifu_active,\n    input wire core_exu_active,\n    input wire core_lsu_active,\n    input wire core_biu_active,\n    input wire core_wfi,\n    output wire clk_aon,\n    output wire clk_core_ifu,\n    output wire clk_core_exu,\n    output wire clk_core_lsu,\n    output wire clk_core_biu,\n    `ifdef E203_HAS_ITCM\n    input wire itcm_active,\n    output wire itcm_ls,\n    output wire clk_itcm,\n    `endif\n    `ifdef E203_HAS_DTCM\n    input wire dtcm_active,\n    output wire dtcm_ls,\n    output wire clk_dtcm,\n    `endif\n    output wire clk_core\n);\n\n// Clock always on\nassign clk_aon = clk;\n\n// Clock gating logic\nwire ifu_clk_en = core_cgstop | (core_ifu_active & ~core_wfi);\nwire exu_clk_en = core_cgstop | core_exu_active;\nwire lsu_clk_en = core_cgstop | core_lsu_active;\nwire biu_clk_en = core_cgstop | core_biu_active;\n\n// Clock gating instantiation\nassign clk_core_ifu = ifu_clk_en ? clk : 1'b0;\nassign clk_core_exu = exu_clk_en ? clk : 1'b0;\nassign clk_core_lsu = lsu_clk_en ? clk : 1'b0;\nassign clk_core_biu = biu_clk_en ? clk : 1'b0;\n\n`ifdef E203_HAS_ITCM\nreg itcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        itcm_active_r <= 1'b0;\n    else\n        itcm_active_r <= itcm_active;\nend\nwire itcm_clk_en = core_cgstop | itcm_active | itcm_active_r;\nassign clk_itcm = itcm_clk_en ? clk : 1'b0;\nassign itcm_ls = ~itcm_clk_en;\n`endif\n\n`ifdef E203_HAS_DTCM\nreg dtcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        dtcm_active_r <= 1'b0;\n    else\n        dtcm_active_r <= dtcm_active;\nend\nwire dtcm_clk_en = core_cgstop | dtcm_active | dtcm_active_r;\nassign clk_dtcm = dtcm_clk_en ? clk : 1'b0;\nassign dtcm_ls = ~dtcm_clk_en;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 6, "code": "module e203_dtcm_ram #(\n  parameter E203_DTCM_RAM_DP = 1024, // Depth of the RAM\n  parameter E203_DTCM_RAM_DW = 32,   // Data width\n  parameter E203_DTCM_RAM_MW = 4,    // Write mask width\n  parameter E203_DTCM_RAM_AW = 10    // Address width\n)(\n  input wire sd,\n  input wire ds,\n  input wire ls,\n  input wire cs,\n  input wire we,\n  input wire [E203_DTCM_RAM_AW-1:0] addr,\n  input wire [E203_DTCM_RAM_MW-1:0] wem,\n  input wire [E203_DTCM_RAM_DW-1:0] din,\n  input wire rst_n,\n  input wire clk,\n  output wire [E203_DTCM_RAM_DW-1:0] dout\n);\n\n  // Instantiate the generic RAM module\n  sirv_gnrl_ram #(\n    .DP(E203_DTCM_RAM_DP),\n    .DW(E203_DTCM_RAM_DW),\n    .MW(E203_DTCM_RAM_MW),\n    .AW(E203_DTCM_RAM_AW),\n    .FORCE_X2ZERO(1)\n  ) u_203_dtcm_gnrl_ram (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 1, "code": "module e203_cpu(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC-1:0] pc_rtvec,\n    input wire [E203_HARD_ID_W-1:0] core_mhartid,\n    input wire dbg_irq_a,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    output wire [E203_PC-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire [E203_PC-1:0] cmt_dpc,\n    output wire cmt_dpc_ena,\n    output wire [2:0] cmt_dcause,\n    output wire cmt_dcause_ena,\n    output wire dbg_irq_r,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    output wire [31:0] wr_csr_nxt,\n    input wire [31:0] dcsr_r,\n    input wire [E203_PC-1:0] dpc_r,\n    input wire [31:0] dscratch_r,\n    input wire dbg_mode,\n    input wire dbg_halt_r,\n    input wire dbg_step_r,\n    input wire dbg_ebreakm_r,\n    input wire dbg_stopcycle\n);\n\n// Core logic implementation\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 7, "code": "module e203_dtcm_ram #(\n    parameter E203_DTCM_RAM_DP = 256, // Depth of the RAM\n    parameter E203_DTCM_RAM_DW = 32,  // Data width\n    parameter E203_DTCM_RAM_MW = 4,   // Write mask width\n    parameter E203_DTCM_RAM_AW = 8    // Address width\n)(\n    input wire sd,\n    input wire ds,\n    input wire ls,\n    input wire cs,\n    input wire we,\n    input wire [E203_DTCM_RAM_AW-1:0] addr,\n    input wire [E203_DTCM_RAM_MW-1:0] wem,\n    input wire [E203_DTCM_RAM_DW-1:0] din,\n    input wire rst_n,\n    input wire clk,\n    output wire [E203_DTCM_RAM_DW-1:0] dout\n);\n\n    // Instantiate the generic RAM module\n    sirv_gnrl_ram #(\n        .DP(E203_DTCM_RAM_DP),\n        .DW(E203_DTCM_RAM_DW),\n        .MW(E203_DTCM_RAM_MW),\n        .AW(E203_DTCM_RAM_AW),\n        .FORCE_X2ZERO(1)\n    ) u_203_dtcm_gnrl_ram (\n        .sd(sd),\n        .ds(ds),\n        .ls(ls),\n        .rst_n(rst_n),\n        .clk(clk),\n        .cs(cs),\n        .we(we),\n        .addr(addr),\n        .din(din),\n        .wem(wem),\n        .dout(dout)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 3, "code": "module e203_clk_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire core_cgstop,\n    input wire core_ifu_active,\n    input wire core_exu_active,\n    input wire core_lsu_active,\n    input wire core_biu_active,\n    input wire core_wfi,\n    output wire clk_aon,\n    output wire clk_core_ifu,\n    output wire clk_core_exu,\n    output wire clk_core_lsu,\n    output wire clk_core_biu,\n`ifdef E203_HAS_ITCM\n    input wire itcm_active,\n    output wire itcm_ls,\n    output wire clk_itcm,\n`endif\n`ifdef E203_HAS_DTCM\n    input wire dtcm_active,\n    output wire dtcm_ls,\n    output wire clk_dtcm,\n`endif\n);\n\n// Clock gating logic for IFU\nassign clk_core_ifu = core_cgstop | (core_ifu_active & ~core_wfi);\n\n// Clock gating logic for other core modules\nassign clk_core_exu = core_cgstop | core_exu_active;\nassign clk_core_lsu = core_cgstop | core_lsu_active;\nassign clk_core_biu = core_cgstop | core_biu_active;\n\n// Always on clock\nassign clk_aon = clk;\n\n`ifdef E203_HAS_ITCM\n// ITCM clock gating logic\nreg itcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        itcm_active_r <= 1'b0;\n    else\n        itcm_active_r <= itcm_active;\nend\nassign clk_itcm = core_cgstop | itcm_active | itcm_active_r;\nassign itcm_ls = ~(itcm_active | itcm_active_r);\n`endif\n\n`ifdef E203_HAS_DTCM\n// DTCM clock gating logic\nreg dtcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        dtcm_active_r <= 1'b0;\n    else\n        dtcm_active_r <= dtcm_active;\nend\nassign clk_dtcm = core_cgstop | dtcm_active | dtcm_active_r;\nassign dtcm_ls = ~(dtcm_active | dtcm_active_r);\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 4, "code": "module e203_clk_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire core_cgstop,\n    input wire core_ifu_active,\n    input wire core_exu_active,\n    input wire core_lsu_active,\n    input wire core_biu_active,\n    input wire core_wfi,\n    output wire clk_aon,\n    output wire clk_core_ifu,\n    output wire clk_core_exu,\n    output wire clk_core_lsu,\n    output wire clk_core_biu,\n    `ifdef E203_HAS_ITCM\n    input wire itcm_active,\n    output wire itcm_ls,\n    output wire clk_itcm,\n    `endif\n    `ifdef E203_HAS_DTCM\n    input wire dtcm_active,\n    output wire dtcm_ls,\n    output wire clk_dtcm,\n    `endif\n    output wire clk_core\n);\n\n// Clock gating logic for IFU\nassign clk_core_ifu = core_cgstop | (core_ifu_active & ~core_wfi);\n\n// Clock gating logic for other core modules\nassign clk_core_exu = core_cgstop | core_exu_active;\nassign clk_core_lsu = core_cgstop | core_lsu_active;\nassign clk_core_biu = core_cgstop | core_biu_active;\n\n// Always on clock\nassign clk_aon = clk;\n\n// Clock for the entire core\nassign clk_core = core_cgstop | core_ifu_active | core_exu_active | core_lsu_active | core_biu_active | core_wfi;\n\n`ifdef E203_HAS_ITCM\n// ITCM clock gating logic\nreg itcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        itcm_active_r <= 1'b0;\n    else\n        itcm_active_r <= itcm_active;\nend\nassign clk_itcm = core_cgstop | itcm_active | itcm_active_r;\nassign itcm_ls = ~(itcm_active | itcm_active_r);\n`endif\n\n`ifdef E203_HAS_DTCM\n// DTCM clock gating logic\nreg dtcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        dtcm_active_r <= 1'b0;\n    else\n        dtcm_active_r <= dtcm_active;\nend\nassign clk_dtcm = core_cgstop | dtcm_active | dtcm_active_r;\nassign dtcm_ls = ~(dtcm_active | dtcm_active_r);\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 11, "code": "module e203_extend_csr (\n    input wire clk,\n    input wire rst_n,\n    input wire nice_csr_valid,\n    output wire nice_csr_ready,\n    input wire [31:0] nice_csr_addr,\n    input wire nice_csr_wr,\n    input wire [31:0] nice_csr_wdata,\n    output wire [31:0] nice_csr_rdata\n);\n\n`ifdef E203_HAS_CSR_NICE\n    // CSR access ready signal, always 1\n    assign nice_csr_ready = 1'b1;\n\n    // CSR read data, always 0\n    assign nice_csr_rdata = 32'b0;\n\n    // Unused inputs\n    wire unused = nice_csr_valid | nice_csr_wr | rst_n;\n    wire [31:0] unused_addr = nice_csr_addr;\n    wire [31:0] unused_wdata = nice_csr_wdata;\n`else\n    assign nice_csr_ready = 1'b0;\n    assign nice_csr_rdata = 32'b0;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 2, "code": "module e203_cpu(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC-1:0] pc_rtvec,\n    input wire [E203_HARD_ID_W-1:0] core_mhartid,\n    input wire dbg_irq_a,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    output wire [E203_PC-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire [E203_PC-1:0] cmt_dpc,\n    output wire cmt_dpc_ena,\n    output wire [2:0] cmt_dcause,\n    output wire cmt_dcause_ena,\n    output wire dbg_irq_r,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    output wire [31:0] wr_csr_nxt,\n    input wire [31:0] dcsr_r,\n    input wire [E203_PC-1:0] dpc_r,\n    input wire [31:0] dscratch_r,\n    input wire dbg_mode,\n    input wire dbg_halt_r,\n    input wire dbg_step_r,\n    input wire dbg_ebreakm_r,\n    input wire dbg_stopcycle\n);\n\n    // Core logic and connections will be implemented here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 8, "code": "module e203_dtcm_ram #(\n  parameter E203_DTCM_RAM_DP = 1024, // Depth of the RAM\n  parameter E203_DTCM_RAM_DW = 32,   // Data width\n  parameter E203_DTCM_RAM_MW = 4,    // Write mask width\n  parameter E203_DTCM_RAM_AW = 10    // Address width\n)(\n  input  wire                  sd,\n  input  wire                  ds,\n  input  wire                  ls,\n  input  wire                  cs,\n  input  wire                  we,\n  input  wire [E203_DTCM_RAM_AW-1:0] addr,\n  input  wire [E203_DTCM_RAM_MW-1:0] wem,\n  input  wire [E203_DTCM_RAM_DW-1:0] din,\n  input  wire                  rst_n,\n  input  wire                  clk,\n  output wire [E203_DTCM_RAM_DW-1:0] dout\n);\n\n  // Instantiate the generic RAM module\n  sirv_gnrl_ram #(\n    .DP(E203_DTCM_RAM_DP),\n    .DW(E203_DTCM_RAM_DW),\n    .MW(E203_DTCM_RAM_MW),\n    .AW(E203_DTCM_RAM_AW),\n    .FORCE_X2ZERO(1)\n  ) u_203_dtcm_gnrl_ram (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 12, "code": "module e203_extend_csr (\n    input wire clk,\n    input wire rst_n,\n    input wire nice_csr_valid,\n    output wire nice_csr_ready,\n    input wire [31:0] nice_csr_addr,\n    input wire nice_csr_wr,\n    input wire [31:0] nice_csr_wdata,\n    output wire [31:0] nice_csr_rdata\n);\n\n// CSR access ready signal, always 1\nassign nice_csr_ready = 1'b1;\n\n// CSR read data, always 0\nassign nice_csr_rdata = 32'b0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 9, "code": "module e203_dtcm_ram #(\n  parameter E203_DTCM_RAM_AW = 10, // Address width\n  parameter E203_DTCM_RAM_DW = 32, // Data width\n  parameter E203_DTCM_RAM_MW = 4   // Mask width\n)(\n  input wire sd,\n  input wire ds,\n  input wire ls,\n  input wire cs,\n  input wire we,\n  input wire [E203_DTCM_RAM_AW-1:0] addr,\n  input wire [E203_DTCM_RAM_MW-1:0] wem,\n  input wire [E203_DTCM_RAM_DW-1:0] din,\n  input wire rst_n,\n  input wire clk,\n  output wire [E203_DTCM_RAM_DW-1:0] dout\n);\n\n  // Instantiate the generic RAM module\n  sirv_gnrl_ram #(\n    .DP(1 << E203_DTCM_RAM_AW), // Depth of the RAM\n    .DW(E203_DTCM_RAM_DW),       // Data width\n    .MW(E203_DTCM_RAM_MW),       // Mask width\n    .AW(E203_DTCM_RAM_AW),       // Address width\n    .FORCE_X2ZERO(1)             // Force uninitialized memory to zero\n  ) u_203_dtcm_gnrl_ram (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 5, "code": "module e203_clk_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire core_cgstop,\n\n    input wire core_ifu_active,\n    input wire core_exu_active,\n    input wire core_lsu_active,\n    input wire core_biu_active,\n    input wire core_wfi,\n\n    output wire clk_aon,\n    output wire clk_core_ifu,\n    output wire clk_core_exu,\n    output wire clk_core_lsu,\n    output wire clk_core_biu,\n\n    `ifdef E203_HAS_ITCM\n    input wire itcm_active,\n    output wire itcm_ls,\n    output wire clk_itcm,\n    `endif\n\n    `ifdef E203_HAS_DTCM\n    input wire dtcm_active,\n    output wire dtcm_ls,\n    output wire clk_dtcm,\n    `endif\n);\n\n    // Always on clock\n    assign clk_aon = clk;\n\n    // Clock gating logic for core modules\n    wire ifu_clk_en = core_cgstop | (core_ifu_active & ~core_wfi);\n    wire exu_clk_en = core_cgstop | core_exu_active;\n    wire lsu_clk_en = core_cgstop | core_lsu_active;\n    wire biu_clk_en = core_cgstop | core_biu_active;\n\n    assign clk_core_ifu = ifu_clk_en ? clk : 1'b0;\n    assign clk_core_exu = exu_clk_en ? clk : 1'b0;\n    assign clk_core_lsu = lsu_clk_en ? clk : 1'b0;\n    assign clk_core_biu = biu_clk_en ? clk : 1'b0;\n\n    `ifdef E203_HAS_ITCM\n    reg itcm_active_r;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            itcm_active_r <= 1'b0;\n        else\n            itcm_active_r <= itcm_active;\n    end\n\n    wire itcm_clk_en = core_cgstop | itcm_active | itcm_active_r;\n    assign clk_itcm = itcm_clk_en ? clk : 1'b0;\n    assign itcm_ls = ~itcm_clk_en;\n    `endif\n\n    `ifdef E203_HAS_DTCM\n    reg dtcm_active_r;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            dtcm_active_r <= 1'b0;\n        else\n            dtcm_active_r <= dtcm_active;\n    end\n\n    wire dtcm_clk_en = core_cgstop | dtcm_active | dtcm_active_r;\n    assign clk_dtcm = dtcm_clk_en ? clk : 1'b0;\n    assign dtcm_ls = ~dtcm_clk_en;\n    `endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 6, "code": "module e203_clk_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire core_cgstop,\n    input wire core_ifu_active,\n    input wire core_exu_active,\n    input wire core_lsu_active,\n    input wire core_biu_active,\n    input wire core_wfi,\n    output wire clk_aon,\n    output wire clk_core_ifu,\n    output wire clk_core_exu,\n    output wire clk_core_lsu,\n    output wire clk_core_biu,\n    `ifdef E203_HAS_ITCM\n    input wire itcm_active,\n    output wire clk_itcm,\n    `endif\n    `ifdef E203_HAS_DTCM\n    input wire dtcm_active,\n    output wire clk_dtcm,\n    `endif\n    output wire itcm_ls,\n    output wire dtcm_ls\n);\n\n// Always-on clock\nassign clk_aon = clk;\n\n// Clock gating logic for core modules\nassign clk_core_ifu = core_cgstop | (core_ifu_active & ~core_wfi);\nassign clk_core_exu = core_cgstop | core_exu_active;\nassign clk_core_lsu = core_cgstop | core_lsu_active;\nassign clk_core_biu = core_cgstop | core_biu_active;\n\n`ifdef E203_HAS_ITCM\n// ITCM clock gating\nreg itcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        itcm_active_r <= 1'b0;\n    else\n        itcm_active_r <= itcm_active;\nend\n\nassign clk_itcm = core_cgstop | itcm_active | itcm_active_r;\nassign itcm_ls = ~clk_itcm;\n`endif\n\n`ifdef E203_HAS_DTCM\n// DTCM clock gating\nreg dtcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        dtcm_active_r <= 1'b0;\n    else\n        dtcm_active_r <= dtcm_active;\nend\n\nassign clk_dtcm = core_cgstop | dtcm_active | dtcm_active_r;\nassign dtcm_ls = ~clk_dtcm;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 7, "code": "module e203_clk_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire core_cgstop,\n    input wire core_ifu_active,\n    input wire core_exu_active,\n    input wire core_lsu_active,\n    input wire core_biu_active,\n    input wire core_wfi,\n    output wire clk_aon,\n    output wire clk_core_ifu,\n    output wire clk_core_exu,\n    output wire clk_core_lsu,\n    output wire clk_core_biu,\n    `ifdef E203_HAS_ITCM\n    input wire itcm_active,\n    output wire itcm_ls,\n    output wire clk_itcm,\n    `endif\n    `ifdef E203_HAS_DTCM\n    input wire dtcm_active,\n    output wire dtcm_ls,\n    output wire clk_dtcm,\n    `endif\n    output wire clk_core\n);\n\n// Clock always on\nassign clk_aon = clk;\n\n// Clock gating logic for IFU\nassign clk_core_ifu = (core_cgstop | (core_ifu_active & ~core_wfi)) & ~test_mode;\n\n// Clock gating logic for other core modules\nassign clk_core_exu = (core_cgstop | core_exu_active) & ~test_mode;\nassign clk_core_lsu = (core_cgstop | core_lsu_active) & ~test_mode;\nassign clk_core_biu = (core_cgstop | core_biu_active) & ~test_mode;\n\n// Optional ITCM and DTCM clock gating\n`ifdef E203_HAS_ITCM\nreg itcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        itcm_active_r <= 1'b0;\n    else\n        itcm_active_r <= itcm_active;\nend\nassign clk_itcm = (core_cgstop | itcm_active | itcm_active_r) & ~test_mode;\nassign itcm_ls = ~(itcm_active | itcm_active_r);\n`endif\n\n`ifdef E203_HAS_DTCM\nreg dtcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        dtcm_active_r <= 1'b0;\n    else\n        dtcm_active_r <= dtcm_active;\nend\nassign clk_dtcm = (core_cgstop | dtcm_active | dtcm_active_r) & ~test_mode;\nassign dtcm_ls = ~(dtcm_active | dtcm_active_r);\n`endif\n\n// Core clock logic\nassign clk_core = clk_core_ifu | clk_core_exu | clk_core_lsu | clk_core_biu;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 8, "code": "module e203_clk_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire core_cgstop,\n    input wire core_ifu_active,\n    input wire core_exu_active,\n    input wire core_lsu_active,\n    input wire core_biu_active,\n    input wire core_wfi,\n    output wire clk_aon,\n    output wire clk_core_ifu,\n    output wire clk_core_exu,\n    output wire clk_core_lsu,\n    output wire clk_core_biu,\n    `ifdef E203_HAS_ITCM\n    input wire itcm_active,\n    output wire itcm_ls,\n    output wire clk_itcm,\n    `endif\n    `ifdef E203_HAS_DTCM\n    input wire dtcm_active,\n    output wire dtcm_ls,\n    output wire clk_dtcm\n    `endif\n);\n\n// Always-on clock\nassign clk_aon = clk;\n\n// Clock gating logic for IFU\nwire ifu_clk_en = core_cgstop | (core_ifu_active & ~core_wfi);\nassign clk_core_ifu = clk & ifu_clk_en;\n\n// Clock gating logic for EXU\nwire exu_clk_en = core_cgstop | core_exu_active;\nassign clk_core_exu = clk & exu_clk_en;\n\n// Clock gating logic for LSU\nwire lsu_clk_en = core_cgstop | core_lsu_active;\nassign clk_core_lsu = clk & lsu_clk_en;\n\n// Clock gating logic for BIU\nwire biu_clk_en = core_cgstop | core_biu_active;\nassign clk_core_biu = clk & biu_clk_en;\n\n`ifdef E203_HAS_ITCM\n// ITCM clock gating logic\nreg itcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        itcm_active_r <= 1'b0;\n    else\n        itcm_active_r <= itcm_active;\nend\n\nwire itcm_clk_en = core_cgstop | itcm_active | itcm_active_r;\nassign clk_itcm = clk & itcm_clk_en;\nassign itcm_ls = ~itcm_clk_en;\n`endif\n\n`ifdef E203_HAS_DTCM\n// DTCM clock gating logic\nreg dtcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        dtcm_active_r <= 1'b0;\n    else\n        dtcm_active_r <= dtcm_active;\nend\n\nwire dtcm_clk_en = core_cgstop | dtcm_active | dtcm_active_r;\nassign clk_dtcm = clk & dtcm_clk_en;\nassign dtcm_ls = ~dtcm_clk_en;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 3, "code": "module e203_cpu(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC-1:0] pc_rtvec,\n    input wire [E203_HARD_ID_W-1:0] core_mhartid,\n    input wire dbg_irq_a,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    output wire [E203_PC-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire [E203_PC-1:0] cmt_dpc,\n    output wire cmt_dpc_ena,\n    output wire [2:0] cmt_dcause,\n    output wire cmt_dcause_ena,\n    output wire dbg_irq_r,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    output wire [31:0] wr_csr_nxt,\n    input wire [31:0] dcsr_r,\n    input wire [E203_PC-1:0] dpc_r,\n    input wire [31:0] dscratch_r,\n    input wire dbg_mode,\n    input wire dbg_halt_r,\n    input wire dbg_step_r,\n    input wire dbg_ebreakm_r,\n    input wire dbg_stopcycle\n);\n\n    // Core logic implementation\n    // This is a placeholder for the actual implementation of the core logic.\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 10, "code": "`include \"e203_defines.v\"\n\nmodule e203_dtcm_ram (\n    input wire sd,\n    input wire ds,\n    input wire ls,\n    input wire cs,\n    input wire we,\n    input wire [`E203_DTCM_RAM_AW-1:0] addr,\n    input wire [`E203_DTCM_RAM_MW-1:0] wem,\n    input wire [`E203_DTCM_RAM_DW-1:0] din,\n    input wire rst_n,\n    input wire clk,\n    output wire [`E203_DTCM_RAM_DW-1:0] dout\n);\n\nsirv_gnrl_ram #(\n    .DP(`E203_DTCM_RAM_DP),\n    .DW(`E203_DTCM_RAM_DW),\n    .FORCE_X2ZERO(1),\n    .MW(`E203_DTCM_RAM_MW),\n    .AW(`E203_DTCM_RAM_AW)\n) u_203_dtcm_gnrl_ram (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 9, "code": "module e203_clk_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire core_cgstop,\n    input wire core_ifu_active,\n    input wire core_exu_active,\n    input wire core_lsu_active,\n    input wire core_biu_active,\n    input wire core_wfi,\n    output wire clk_aon,\n    output wire clk_core_ifu,\n    output wire clk_core_exu,\n    output wire clk_core_lsu,\n    output wire clk_core_biu,\n    `ifdef E203_HAS_ITCM\n    input wire itcm_active,\n    output wire itcm_ls,\n    output wire clk_itcm,\n    `endif\n    `ifdef E203_HAS_DTCM\n    input wire dtcm_active,\n    output wire dtcm_ls,\n    output wire clk_dtcm,\n    `endif\n    output wire clk_aon\n);\n\n// Always on clock\nassign clk_aon = clk;\n\n// Clock gating logic for IFU\nassign clk_core_ifu = core_cgstop | (core_ifu_active & ~core_wfi);\n\n// Clock gating logic for other core modules\nassign clk_core_exu = core_cgstop | core_exu_active;\nassign clk_core_lsu = core_cgstop | core_lsu_active;\nassign clk_core_biu = core_cgstop | core_biu_active;\n\n`ifdef E203_HAS_ITCM\n// ITCM clock gating logic\nreg itcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        itcm_active_r <= 1'b0;\n    else\n        itcm_active_r <= itcm_active;\nend\n\nassign clk_itcm = core_cgstop | itcm_active | itcm_active_r;\nassign itcm_ls = ~(itcm_active | itcm_active_r);\n`endif\n\n`ifdef E203_HAS_DTCM\n// DTCM clock gating logic\nreg dtcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        dtcm_active_r <= 1'b0;\n    else\n        dtcm_active_r <= dtcm_active;\nend\n\nassign clk_dtcm = core_cgstop | dtcm_active | dtcm_active_r;\nassign dtcm_ls = ~(dtcm_active | dtcm_active_r);\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 4, "code": "module e203_cpu(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC-1:0] pc_rtvec,\n    input wire [E203_HARD_ID_W-1:0] core_mhartid,\n    input wire dbg_irq_a,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    output wire [E203_PC-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire [E203_PC-1:0] cmt_dpc,\n    output wire cmt_dpc_ena,\n    output wire [2:0] cmt_dcause,\n    output wire cmt_dcause_ena,\n    output wire dbg_irq_r,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    output wire [31:0] wr_csr_nxt,\n    input wire [31:0] dcsr_r,\n    input wire [E203_PC-1:0] dpc_r,\n    input wire [31:0] dscratch_r,\n    input wire dbg_mode,\n    input wire dbg_halt_r,\n    input wire dbg_step_r,\n    input wire dbg_ebreakm_r,\n    input wire dbg_stopcycle\n);\n\n// Core logic implementation here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 10, "code": "module e203_clk_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire core_cgstop,\n    input wire core_ifu_active,\n    input wire core_exu_active,\n    input wire core_lsu_active,\n    input wire core_biu_active,\n    input wire core_wfi,\n    output wire clk_aon,\n    output wire clk_core_ifu,\n    output wire clk_core_exu,\n    output wire clk_core_lsu,\n    output wire clk_core_biu,\n    `ifdef E203_HAS_ITCM\n    input wire itcm_active,\n    output wire clk_itcm,\n    output wire itcm_ls,\n    `endif\n    `ifdef E203_HAS_DTCM\n    input wire dtcm_active,\n    output wire clk_dtcm,\n    output wire dtcm_ls\n    `endif\n);\n\n// Always-on clock\nassign clk_aon = clk;\n\n// Clock gating logic for core modules\nassign clk_core_ifu = (core_cgstop | (core_ifu_active & ~core_wfi)) & ~test_mode;\nassign clk_core_exu = (core_cgstop | core_exu_active) & ~test_mode;\nassign clk_core_lsu = (core_cgstop | core_lsu_active) & ~test_mode;\nassign clk_core_biu = (core_cgstop | core_biu_active) & ~test_mode;\n\n`ifdef E203_HAS_ITCM\n// ITCM clock gating logic\nreg itcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        itcm_active_r <= 1'b0;\n    else\n        itcm_active_r <= itcm_active;\nend\n\nassign clk_itcm = (core_cgstop | itcm_active | itcm_active_r) & ~test_mode;\nassign itcm_ls = ~(itcm_active | itcm_active_r);\n`endif\n\n`ifdef E203_HAS_DTCM\n// DTCM clock gating logic\nreg dtcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        dtcm_active_r <= 1'b0;\n    else\n        dtcm_active_r <= dtcm_active;\nend\n\nassign clk_dtcm = (core_cgstop | dtcm_active | dtcm_active_r) & ~test_mode;\nassign dtcm_ls = ~(dtcm_active | dtcm_active_r);\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 13, "code": "`include \"e203_defines.v\"\n\nmodule e203_extend_csr (\n    input wire clk,\n    input wire rst_n,\n    input wire nice_csr_valid,\n    output wire nice_csr_ready,\n    input wire [31:0] nice_csr_addr,\n    input wire nice_csr_wr,\n    input wire [31:0] nice_csr_wdata,\n    output wire [31:0] nice_csr_rdata\n);\n\n`ifdef E203_HAS_CSR_NICE\n    // CSR access ready signal, always 1\n    assign nice_csr_ready = 1'b1;\n    \n    // CSR read data, always 0\n    assign nice_csr_rdata = 32'b0;\n    \n    // Currently, the address, write enable and write data are unused\n    // Future implementations can use these inputs for actual CSR operations\n`else\n    // When the module is disabled, tie off outputs\n    assign nice_csr_ready = 1'b0;\n    assign nice_csr_rdata = 32'b0;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 11, "code": "module e203_clk_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire core_cgstop,\n    input wire core_ifu_active,\n    input wire core_exu_active,\n    input wire core_lsu_active,\n    input wire core_biu_active,\n    input wire core_wfi,\n    output wire clk_aon,\n    output wire clk_core_ifu,\n    output wire clk_core_exu,\n    output wire clk_core_lsu,\n    output wire clk_core_biu,\n    `ifdef E203_HAS_ITCM\n    input wire itcm_active,\n    output wire itcm_ls,\n    output wire clk_itcm,\n    `endif\n    `ifdef E203_HAS_DTCM\n    input wire dtcm_active,\n    output wire dtcm_ls,\n    output wire clk_dtcm\n    `endif\n);\n\n// Always-on clock\nassign clk_aon = clk;\n\n// Clock gating logic\nwire ifu_clk_en = core_cgstop | (core_ifu_active & ~core_wfi);\nwire exu_clk_en = core_cgstop | core_exu_active;\nwire lsu_clk_en = core_cgstop | core_lsu_active;\nwire biu_clk_en = core_cgstop | core_biu_active;\n\n// Clock output assignments\nassign clk_core_ifu = ifu_clk_en ? clk : 1'b0;\nassign clk_core_exu = exu_clk_en ? clk : 1'b0;\nassign clk_core_lsu = lsu_clk_en ? clk : 1'b0;\nassign clk_core_biu = biu_clk_en ? clk : 1'b0;\n\n`ifdef E203_HAS_ITCM\nreg itcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        itcm_active_r <= 1'b0;\n    else\n        itcm_active_r <= itcm_active;\nend\nwire itcm_clk_en = core_cgstop | itcm_active | itcm_active_r;\nassign clk_itcm = itcm_clk_en ? clk : 1'b0;\nassign itcm_ls = ~itcm_clk_en;\n`endif\n\n`ifdef E203_HAS_DTCM\nreg dtcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        dtcm_active_r <= 1'b0;\n    else\n        dtcm_active_r <= dtcm_active;\nend\nwire dtcm_clk_en = core_cgstop | dtcm_active | dtcm_active_r;\nassign clk_dtcm = dtcm_clk_en ? clk : 1'b0;\nassign dtcm_ls = ~dtcm_clk_en;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 11, "code": "`include \"e203_defines.v\"\n\nmodule e203_dtcm_ram (\n    input wire sd,\n    input wire ds,\n    input wire ls,\n    input wire cs,\n    input wire we,\n    input wire [`E203_DTCM_RAM_AW-1:0] addr,\n    input wire [`E203_DTCM_RAM_MW-1:0] wem,\n    input wire [`E203_DTCM_RAM_DW-1:0] din,\n    input wire rst_n,\n    input wire clk,\n    output wire [`E203_DTCM_RAM_DW-1:0] dout\n);\n\n// Instantiate the generic RAM module\nsirv_gnrl_ram #(\n    .DP(`E203_DTCM_RAM_DP),\n    .DW(`E203_DTCM_RAM_DW),\n    .FORCE_X2ZERO(1),\n    .MW(`E203_DTCM_RAM_MW),\n    .AW(`E203_DTCM_RAM_AW)\n) u_203_dtcm_gnrl_ram (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 12, "code": "module e203_clk_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire core_cgstop,\n    input wire core_ifu_active,\n    input wire core_exu_active,\n    input wire core_lsu_active,\n    input wire core_biu_active,\n    input wire core_wfi,\n    output wire clk_aon,\n    output wire clk_core_ifu,\n    output wire clk_core_exu,\n    output wire clk_core_lsu,\n    output wire clk_core_biu,\n    `ifdef E203_HAS_ITCM\n    input wire itcm_active,\n    output wire itcm_ls,\n    output wire clk_itcm,\n    `endif\n    `ifdef E203_HAS_DTCM\n    input wire dtcm_active,\n    output wire dtcm_ls,\n    output wire clk_dtcm,\n    `endif\n    output wire clk_core\n);\n\n// Clock gating logic\nassign clk_aon = clk; // AON clock is always on\n\n// Clock enable signals\nwire ifu_clk_en = core_cgstop | (core_ifu_active & ~core_wfi);\nwire exu_clk_en = core_cgstop | core_exu_active;\nwire lsu_clk_en = core_cgstop | core_lsu_active;\nwire biu_clk_en = core_cgstop | core_biu_active;\n\n// Clock gating implementation\nassign clk_core_ifu = ifu_clk_en ? clk : 1'b0;\nassign clk_core_exu = exu_clk_en ? clk : 1'b0;\nassign clk_core_lsu = lsu_clk_en ? clk : 1'b0;\nassign clk_core_biu = biu_clk_en ? clk : 1'b0;\n\n// Optional ITCM and DTCM clock gating\n`ifdef E203_HAS_ITCM\nreg itcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        itcm_active_r <= 1'b0;\n    else\n        itcm_active_r <= itcm_active;\nend\nassign clk_itcm = core_cgstop | itcm_active | itcm_active_r;\nassign itcm_ls = ~(itcm_active | itcm_active_r);\n`endif\n\n`ifdef E203_HAS_DTCM\nreg dtcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        dtcm_active_r <= 1'b0;\n    else\n        dtcm_active_r <= dtcm_active;\nend\nassign clk_dtcm = core_cgstop | dtcm_active | dtcm_active_r;\nassign dtcm_ls = ~(dtcm_active | dtcm_active_r);\n`endif\n\n// Core clock is the OR of all individual clocks\nassign clk_core = clk_core_ifu | clk_core_exu | clk_core_lsu | clk_core_biu\n                  `ifdef E203_HAS_ITCM\n                  | clk_itcm\n                  `endif\n                  `ifdef E203_HAS_DTCM\n                  | clk_dtcm\n                  `endif\n                  ;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 14, "code": "module e203_extend_csr (\n    input wire clk,\n    input wire rst_n,\n    input wire nice_csr_valid,\n    output wire nice_csr_ready,\n    input wire [31:0] nice_csr_addr,\n    input wire nice_csr_wr,\n    input wire [31:0] nice_csr_wdata,\n    output wire [31:0] nice_csr_rdata\n);\n\n// Stub implementation for CSR extension\nassign nice_csr_ready = 1'b1; // Always ready\nassign nice_csr_rdata = 32'b0; // Always return zero\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 1, "code": "module e203_exu_alu_muldiv(\n    input mdv_nob2b,\n    input muldiv_i_valid,\n    output reg muldiv_i_ready,\n    input [E203_XLEN-1:0] muldiv_i_rs1,\n    input [E203_XLEN-1:0] muldiv_i_rs2,\n    input [E203_XLEN-1:0] muldiv_i_imm,\n    input [E203_DECINFO_MULDIV_WIDTH-1:0] muldiv_i_info,\n    input [E203_ITAG_WIDTH-1:0] muldiv_i_itag,\n    output reg muldiv_i_longpipe,\n    input flush_pulse,\n    output reg muldiv_o_valid,\n    input muldiv_o_ready,\n    output reg [E203_XLEN-1:0] muldiv_o_wbck_wdat,\n    output reg muldiv_o_wbck_err,\n    output reg [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    output reg [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    output reg muldiv_req_alu_add,\n    output reg muldiv_req_alu_sub,\n    input [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output reg muldiv_sbf_0_ena,\n    output reg [32:0] muldiv_sbf_0_nxt,\n    input [32:0] muldiv_sbf_0_r,\n    output reg muldiv_sbf_1_ena,\n    output reg [32:0] muldiv_sbf_1_nxt,\n    input [32:0] muldiv_sbf_1_r,\n    input clk,\n    input rst_n\n);\n\n// Implementation of the module's internal logic\n// This is a placeholder for the actual implementation\n// which would include the state machine and other logic\n// to perform multiplication and division as specified.\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 5, "code": "module e203_cpu(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC-1:0] pc_rtvec,\n    input wire [E203_HARD_ID_W-1:0] core_mhartid,\n    input wire dbg_irq_a,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    output wire [E203_PC-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop\n);\n\n    // Core logic\n    wire core_clk = clk;\n    wire core_rst_n = rst_n;\n\n    // Debug and interrupt synchronization\n    wire dbg_irq_r;\n    wire ext_irq_r;\n    wire sft_irq_r;\n    wire tmr_irq_r;\n\n    e203_irq_sync irq_sync_inst(\n        .clk(core_clk),\n        .rst_n(core_rst_n),\n        .dbg_irq_a(dbg_irq_a),\n        .ext_irq_a(ext_irq_a),\n        .sft_irq_a(sft_irq_a),\n        .tmr_irq_a(tmr_irq_a),\n        .dbg_irq_r(dbg_irq_r),\n        .ext_irq_r(ext_irq_r),\n        .sft_irq_r(sft_irq_r),\n        .tmr_irq_r(tmr_irq_r)\n    );\n\n    // Core module instantiation\n    e203_core core_inst(\n        .clk(core_clk),\n        .rst_n(core_rst_n),\n        .pc_rtvec(pc_rtvec),\n        .mhartid(core_mhartid),\n        .dbg_irq(dbg_irq_r),\n        .ext_irq(ext_irq_r),\n        .sft_irq(sft_irq_r),\n        .tmr_irq(tmr_irq_r),\n        .inspect_pc(inspect_pc),\n        .core_wfi(core_wfi),\n        .tm_stop(tm_stop)\n    );\n\n    // Memory interface inspection signals\n    assign inspect_dbg_irq = dbg_irq_r;\n    assign inspect_core_clk = core_clk;\n\n    // Placeholder for memory command and response signals\n    assign inspect_mem_cmd_valid = 1'b0;\n    assign inspect_mem_cmd_ready = 1'b1;\n    assign inspect_mem_rsp_valid = 1'b0;\n    assign inspect_mem_rsp_ready = 1'b1;\n\n    // CSR clock (same as core clock in this simplified example)\n    assign core_csr_clk = core_clk;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 1, "code": "module e203_cpu_top(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire tcm_sd,\n    input wire tcm_ds,\n    input wire [E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input wire ext2itcm_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ext2itcm_icb_cmd_wdata,\n    input wire [E203_XLEN/8-1:0] ext2itcm_icb_cmd_wmask,\n    input wire ext2itcm_icb_cmd_valid,\n    output wire ext2itcm_icb_cmd_ready,\n    output wire [E203_XLEN-1:0] ext2itcm_icb_rsp_rdata,\n    output wire ext2itcm_icb_rsp_err,\n    output wire ext2itcm_icb_rsp_valid,\n    input wire ext2itcm_icb_rsp_ready,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire dbg_irq_r\n);\n\n    // Instantiate the e203_cpu core\n    e203_cpu #(\n        .E203_PC_SIZE(E203_PC_SIZE)\n    ) u_e203_cpu (\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ext_irq_a(ext_irq_a),\n        .sft_irq_a(sft_irq_a),\n        .tmr_irq_a(tmr_irq_a),\n        .inspect_pc(inspect_pc),\n        .inspect_dbg_irq(inspect_dbg_irq),\n        .inspect_mem_cmd_valid(inspect_mem_cmd_valid),\n        .inspect_mem_cmd_ready(inspect_mem_cmd_ready),\n        .inspect_mem_rsp_valid(inspect_mem_rsp_valid),\n        .inspect_mem_rsp_ready(inspect_mem_rsp_ready),\n        .inspect_core_clk(inspect_core_clk),\n        .core_csr_clk(core_csr_clk),\n        .core_wfi(core_wfi),\n        .tm_stop(tm_stop),\n        .dbg_irq_r(dbg_irq_r)\n    );\n\n    // Instantiate the e203_srams for ITCM and DTCM management\n    e203_srams #(\n        .E203_ITCM_ADDR_WIDTH(E203_ITCM_ADDR_WIDTH),\n        .E203_XLEN(E203_XLEN)\n    ) u_e203_srams (\n        .clk(clk),\n        .rst_n(rst_n),\n        .tcm_sd(tcm_sd),\n        .tcm_ds(tcm_ds),\n        .ext2itcm_icb_cmd_addr(ext2itcm_icb_cmd_addr),\n        .ext2itcm_icb_cmd_read(ext2itcm_icb_cmd_read),\n        .ext2itcm_icb_cmd_wdata(ext2itcm_icb_cmd_wdata),\n        .ext2itcm_icb_cmd_wmask(ext2itcm_icb_cmd_wmask),\n        .ext2itcm_icb_cmd_valid(ext2itcm_icb_cmd_valid),\n        .ext2itcm_icb_cmd_ready(ext2itcm_icb_cmd_ready),\n        .ext2itcm_icb_rsp_rdata(ext2itcm_icb_rsp_rdata),\n        .ext2itcm_icb_rsp_err(ext2itcm_icb_rsp_err),\n        .ext2itcm_icb_rsp_valid(ext2itcm_icb_rsp_valid),\n        .ext2itcm_icb_rsp_ready(ext2itcm_icb_rsp_ready)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 6, "code": "module e203_cpu(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC-1:0] pc_rtvec,\n    input wire [E203_HARD_ID_W-1:0] core_mhartid,\n    input wire dbg_irq_a,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    output wire [E203_PC-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire dbg_irq_r,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    output wire [31:0] wr_csr_nxt,\n    input wire [31:0] dcsr_r,\n    input wire [E203_PC-1:0] dpc_r,\n    input wire [31:0] dscratch_r,\n    input wire dbg_mode,\n    input wire dbg_halt_r,\n    input wire dbg_step_r,\n    input wire dbg_ebreakm_r,\n    input wire dbg_stopcycle\n);\n\n    // Core logic implementation\n    // This is a placeholder for the actual implementation of the core logic\n    // including instruction fetch, decode, execute, memory access, and write-back stages.\n\n    // Debug and inspection signals\n    assign inspect_pc = pc_rtvec; // Just a simple assignment for demonstration\n    assign inspect_dbg_irq = dbg_irq_r;\n    assign inspect_mem_cmd_valid = 1'b0; // Placeholder\n    assign inspect_mem_cmd_ready = 1'b1; // Placeholder\n    assign inspect_mem_rsp_valid = 1'b0; // Placeholder\n    assign inspect_mem_rsp_ready = 1'b1; // Placeholder\n    assign inspect_core_clk = clk;\n    assign core_csr_clk = clk;\n    assign core_wfi = 1'b0; // Placeholder\n    assign tm_stop = 1'b0; // Placeholder\n\n    // Debug related outputs\n    assign dbg_irq_r = dbg_irq_a; // Simple pass-through for demonstration\n    assign wr_dcsr_ena = 1'b0; // Placeholder\n    assign wr_dpc_ena = 1'b0; // Placeholder\n    assign wr_dscratch_ena = 1'b0; // Placeholder\n    assign wr_csr_nxt = 32'b0; // Placeholder\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 2, "code": "module e203_cpu_top (\n    input wire clk,\n    input wire rst_n,\n\n    // Program Counter Inspection\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n\n    // Reset and Interrupt Vectors\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    output wire dbg_irq_r,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n\n    // TCM Signals\n    input wire tcm_sd,\n    input wire tcm_ds,\n\n    // External Interface to ITCM\n    input wire ext2itcm_icb_cmd_valid,\n    output wire ext2itcm_icb_cmd_ready,\n    input wire [E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input wire ext2itcm_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ext2itcm_icb_cmd_wdata,\n    input wire [E203_XLEN/8-1:0] ext2itcm_icb_cmd_wmask,\n    output wire ext2itcm_icb_rsp_valid,\n    input wire ext2itcm_icb_rsp_ready,\n    output wire ext2itcm_icb_rsp_err,\n    output wire [E203_XLEN-1:0] ext2itcm_icb_rsp_rdata\n);\n\n    // Core instantiation\n    e203_cpu u_e203_cpu(\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .inspect_pc(inspect_pc),\n        .inspect_dbg_irq(inspect_dbg_irq),\n        .inspect_mem_cmd_valid(inspect_mem_cmd_valid),\n        .inspect_mem_cmd_ready(inspect_mem_cmd_ready),\n        .inspect_mem_rsp_valid(inspect_mem_rsp_valid),\n        .inspect_mem_rsp_ready(inspect_mem_rsp_ready),\n        .inspect_core_clk(inspect_core_clk),\n        .core_csr_clk(core_csr_clk),\n        .core_wfi(core_wfi),\n        .tm_stop(tm_stop),\n        .dbg_irq_r(dbg_irq_r),\n        .ext_irq_a(ext_irq_a),\n        .sft_irq_a(sft_irq_a),\n        .tmr_irq_a(tmr_irq_a)\n    );\n\n    // SRAM controller instantiation\n    e203_srams u_e203_srams(\n        .clk(clk),\n        .rst_n(rst_n),\n        .tcm_sd(tcm_sd),\n        .tcm_ds(tcm_ds),\n        .ext2itcm_icb_cmd_valid(ext2itcm_icb_cmd_valid),\n        .ext2itcm_icb_cmd_ready(ext2itcm_icb_cmd_ready),\n        .ext2itcm_icb_cmd_addr(ext2itcm_icb_cmd_addr),\n        .ext2itcm_icb_cmd_read(ext2itcm_icb_cmd_read),\n        .ext2itcm_icb_cmd_wdata(ext2itcm_icb_cmd_wdata),\n        .ext2itcm_icb_cmd_wmask(ext2itcm_icb_cmd_wmask),\n        .ext2itcm_icb_rsp_valid(ext2itcm_icb_rsp_valid),\n        .ext2itcm_icb_rsp_ready(ext2itcm_icb_rsp_ready),\n        .ext2itcm_icb_rsp_err(ext2itcm_icb_rsp_err),\n        .ext2itcm_icb_rsp_rdata(ext2itcm_icb_rsp_rdata)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 13, "code": "module e203_clk_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire core_cgstop,\n    input wire core_ifu_active,\n    input wire core_exu_active,\n    input wire core_lsu_active,\n    input wire core_biu_active,\n    input wire core_wfi,\n    output wire clk_aon,\n    output wire clk_core_ifu,\n    output wire clk_core_exu,\n    output wire clk_core_lsu,\n    output wire clk_core_biu,\n    `ifdef E203_HAS_ITCM\n    input wire itcm_active,\n    output wire itcm_ls,\n    output wire clk_itcm,\n    `endif\n    `ifdef E203_HAS_DTCM\n    input wire dtcm_active,\n    output wire dtcm_ls,\n    output wire clk_dtcm,\n    `endif\n    output wire clk_core\n);\n\n// Clock always on\nassign clk_aon = clk;\n\n// Clock gating logic for IFU\nwire ifu_cg_en = core_cgstop | (core_ifu_active & ~core_wfi);\nassign clk_core_ifu = clk & ifu_cg_en;\n\n// Clock gating logic for EXU\nwire exu_cg_en = core_cgstop | core_exu_active;\nassign clk_core_exu = clk & exu_cg_en;\n\n// Clock gating logic for LSU\nwire lsu_cg_en = core_cgstop | core_lsu_active;\nassign clk_core_lsu = clk & lsu_cg_en;\n\n// Clock gating logic for BIU\nwire biu_cg_en = core_cgstop | core_biu_active;\nassign clk_core_biu = clk & biu_cg_en;\n\n// Global core clock (example, might not be used directly)\nassign clk_core = clk & (ifu_cg_en | exu_cg_en | lsu_cg_en | biu_cg_en);\n\n`ifdef E203_HAS_ITCM\n// ITCM clock gating logic\nreg itcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        itcm_active_r <= 1'b0;\n    else\n        itcm_active_r <= itcm_active;\nend\nwire itcm_cg_en = core_cgstop | itcm_active | itcm_active_r;\nassign clk_itcm = clk & itcm_cg_en;\nassign itcm_ls = ~itcm_cg_en;\n`endif\n\n`ifdef E203_HAS_DTCM\n// DTCM clock gating logic\nreg dtcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        dtcm_active_r <= 1'b0;\n    else\n        dtcm_active_r <= dtcm_active;\nend\nwire dtcm_cg_en = core_cgstop | dtcm_active | dtcm_active_r;\nassign clk_dtcm = clk & dtcm_cg_en;\nassign dtcm_ls = ~dtcm_cg_en;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 12, "code": "module e203_dtcm_ram #(\n  parameter E203_DTCM_RAM_DP = 1024, // Depth of the RAM\n  parameter E203_DTCM_RAM_DW = 32,   // Data width\n  parameter E203_DTCM_RAM_MW = 4,    // Write mask width\n  parameter E203_DTCM_RAM_AW = 10    // Address width\n)(\n  input wire sd,\n  input wire ds,\n  input wire ls,\n  input wire cs,\n  input wire we,\n  input wire [E203_DTCM_RAM_AW-1:0] addr,\n  input wire [E203_DTCM_RAM_MW-1:0] wem,\n  input wire [E203_DTCM_RAM_DW-1:0] din,\n  input wire rst_n,\n  input wire clk,\n  output wire [E203_DTCM_RAM_DW-1:0] dout\n);\n\n  // Instantiate the generic RAM module\n  sirv_gnrl_ram #(\n    .DP(E203_DTCM_RAM_DP),\n    .DW(E203_DTCM_RAM_DW),\n    .MW(E203_DTCM_RAM_MW),\n    .AW(E203_DTCM_RAM_AW),\n    .FORCE_X2ZERO(1)\n  ) u_203_dtcm_gnrl_ram (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 7, "code": "module e203_cpu(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC-1:0] pc_rtvec,\n    input wire [E203_HARD_ID_W-1:0] core_mhartid,\n    input wire dbg_irq_a,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    output wire [E203_PC-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire [E203_PC-1:0] cmt_dpc,\n    output wire cmt_dpc_ena,\n    output wire [2:0] cmt_dcause,\n    output wire cmt_dcause_ena,\n    output wire dbg_irq_r,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    output wire [31:0] wr_csr_nxt,\n    input wire [31:0] dcsr_r,\n    input wire [E203_PC-1:0] dpc_r,\n    input wire [31:0] dscratch_r,\n    input wire dbg_mode,\n    input wire dbg_halt_r,\n    input wire dbg_step_r,\n    input wire dbg_ebreakm_r,\n    input wire dbg_stopcycle\n    `ifdef E203_HAS_ITCM\n    ,output wire itcm_ls,\n    output wire itcm_ram_cs,\n    output wire itcm_ram_we,\n    output wire [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n    output wire [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n    output wire [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n    input wire [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n    output wire clk_itcm_ram\n    `endif\n    `ifdef E203_HAS_DTCM\n    ,output wire rst_dtcm,\n    output wire dtcm_ls,\n    output wire dtcm_ram_cs,\n    output wire dtcm_ram_we,\n    output wire [E203_ITCM_RAM_AW-1:0] dtcm_ram_addr,\n    output wire [E203_ITCM_RAM_MW-1:0] dtcm_ram_wem,\n    output wire [E203_ITCM_RAM_DW-1:0] dtcm_ram_din,\n    input wire [E203_ITCM_RAM_DW-1:0] dtcm_ram_dout\n    `endif\n);\n\n// Core logic implementation here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 1, "code": "module e203_exu_regfile (\n    input [E203_RFIDX_WIDTH-1:0] read_src1_idx,\n    input [E203_RFIDX_WIDTH-1:0] read_src2_idx,\n    output [E203_XLEN-1:0] read_src1_dat,\n    output [E203_XLEN-1:0] read_src2_dat,\n    input wbck_dest_wen,\n    input [E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n    input [E203_XLEN-1:0] wbck_dest_dat,\n    output [E203_XLEN-1:0] x1_r,\n    input test_mode,\n    input clk,\n    input rst_n\n);\n\n// Register file storage\nreg [E203_XLEN-1:0] regfile [0:E203_RFREG_NUM-1];\n\n// Read logic\nassign read_src1_dat = (read_src1_idx == 0) ? 0 : regfile[read_src1_idx];\nassign read_src2_dat = (read_src2_idx == 0) ? 0 : regfile[read_src2_idx];\n\n// Write logic\nalways @(posedge clk) begin\n    if (wbck_dest_wen && wbck_dest_idx != 0) begin\n        regfile[wbck_dest_idx] <= wbck_dest_dat;\n    end\nend\n\n// Output register x1\nassign x1_r = regfile[1];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 1, "code": "module e203_reset_ctrl #(\n    parameter MASTER = 1,\n    parameter RST_SYNC_LEVEL = `E203_ASYNC_FF_LEVELS\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    output wire rst_core,\n    output wire rst_itcm,\n    output wire rst_dtcm,\n    output wire rst_aon\n);\n\nreg [RST_SYNC_LEVEL-1:0] rst_sync;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        rst_sync <= {RST_SYNC_LEVEL{1'b1}};\n    end else begin\n        rst_sync <= {rst_sync[RST_SYNC_LEVEL-2:0], 1'b0};\n    end\nend\n\nwire internal_rst_n = test_mode ? rst_n : rst_sync[RST_SYNC_LEVEL-1];\n\nassign rst_core = !internal_rst_n;\nassign rst_itcm = !internal_rst_n;\nassign rst_dtcm = !internal_rst_n;\nassign rst_aon = !internal_rst_n;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 15, "code": "module e203_extend_csr (\n    input wire clk,\n    input wire rst_n,\n    input wire nice_csr_valid,\n    output wire nice_csr_ready,\n    input wire [31:0] nice_csr_addr,\n    input wire nice_csr_wr,\n    input wire [31:0] nice_csr_wdata,\n    output wire [31:0] nice_csr_rdata\n);\n\n`ifdef E203_HAS_CSR_NICE\n    // CSR access ready signal, always 1\n    assign nice_csr_ready = 1'b1;\n    // CSR read data, always 0\n    assign nice_csr_rdata = 32'b0;\n`else\n    assign nice_csr_ready = 1'b0;\n    assign nice_csr_rdata = 32'b0;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 8, "code": "module e203_cpu(\n    input  wire        clk,\n    input  wire        rst_n,\n    input  wire [31:0] pc_rtvec,\n    input  wire [31:0] core_mhartid,\n    input  wire        dbg_irq_a,\n    input  wire        ext_irq_a,\n    input  wire        sft_irq_a,\n    input  wire        tmr_irq_a,\n    output wire [31:0] inspect_pc,\n    output wire        inspect_dbg_irq,\n    output wire        inspect_mem_cmd_valid,\n    output wire        inspect_mem_cmd_ready,\n    output wire        inspect_mem_rsp_valid,\n    output wire        inspect_mem_rsp_ready,\n    output wire        inspect_core_clk,\n    output wire        core_csr_clk,\n    output wire        core_wfi,\n    output wire        tm_stop\n);\n\n    // Internal signals\n    wire dbg_irq_r;\n    wire ext_irq_r;\n    wire sft_irq_r;\n    wire tmr_irq_r;\n    wire core_clk;\n    wire reset_core;\n\n    // Clock and reset control\n    e203_clk_ctrl clk_ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .core_cgstop(core_wfi),\n        .clk_core(core_clk),\n        .clk_csr(core_csr_clk)\n    );\n\n    e203_reset_ctrl reset_ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .rst_core(reset_core)\n    );\n\n    // Interrupt synchronization\n    e203_irq_sync irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .dbg_irq_a(dbg_irq_a),\n        .ext_irq_a(ext_irq_a),\n        .sft_irq_a(sft_irq_a),\n        .tmr_irq_a(tmr_irq_a),\n        .dbg_irq_r(dbg_irq_r),\n        .ext_irq_r(ext_irq_r),\n        .sft_irq_r(sft_irq_r),\n        .tmr_irq_r(tmr_irq_r)\n    );\n\n    // Core module\n    e203_core core (\n        .clk(core_clk),\n        .rst_n(reset_core),\n        .pc_rtvec(pc_rtvec),\n        .mhartid(core_mhartid),\n        .dbg_irq(dbg_irq_r),\n        .ext_irq(ext_irq_r),\n        .sft_irq(sft_irq_r),\n        .tmr_irq(tmr_irq_r),\n        .inspect_pc(inspect_pc),\n        .core_wfi(core_wfi),\n        .tm_stop(tm_stop)\n    );\n\n    // Debug and inspection outputs\n    assign inspect_dbg_irq = dbg_irq_r;\n    assign inspect_core_clk = core_clk;\n\n    // Memory interface inspection (placeholders)\n    assign inspect_mem_cmd_valid = 1'b0;\n    assign inspect_mem_cmd_ready = 1'b1;\n    assign inspect_mem_rsp_valid = 1'b0;\n    assign inspect_mem_rsp_ready = 1'b1;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 1, "code": "module e203_core(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_ADDR_SIZE-1:0] pc_rtvec,\n    input wire [E203_HART_ID_W-1:0] core_mhartid,\n    input wire dbg_irq_r,\n    input wire [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input wire [E203_EVT_NUM-1:0] evt_r,\n    input wire ext_irq_r,\n    input wire sft_irq_r,\n    input wire tmr_irq_r,\n    input wire dbg_mode,\n    input wire dbg_halt_r,\n    input wire dbg_step_r,\n    input wire dbg_ebreakm_r,\n    input wire dbg_stopcycle,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire core_cgstop,\n    output wire tcm_cgstop,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    output wire [31:0] wr_csr_nxt,\n    output wire [E203_PC_SIZE-1:0] cmt_dpc,\n    output wire cmt_dpc_ena,\n    output wire [2:0] cmt_dcause,\n    output wire cmt_dcause_ena,\n    input wire [31:0] dcsr_r,\n    input wire [E203_PC_SIZE-1:0] dpc_r,\n    input wire [31:0] dscratch_r,\n    // ICB protocol interface signals\n    input wire icb_enable,\n    output wire icb_cmd_valid,\n    input wire icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] icb_cmd_addr,\n    output wire icb_cmd_read,\n    output wire [E203_XLEN-1:0] icb_cmd_wdata,\n    output wire [E203_XLEN/8-1:0] icb_cmd_wmask,\n    output wire icb_cmd_lock,\n    output wire icb_cmd_excl,\n    output wire [1:0] icb_cmd_size,\n    input wire icb_rsp_valid,\n    output wire icb_rsp_ready,\n    input wire icb_rsp_err,\n    input wire icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] icb_rsp_rdata\n);\n\n    // Core internal logic and connections\n    // Instantiate IFU, EXU, LSU, BIU, etc.\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 13, "code": "module e203_dtcm_ram #(\n  parameter E203_DTCM_RAM_DP = 1024, // Depth of the RAM\n  parameter E203_DTCM_RAM_DW = 32,   // Data width\n  parameter E203_DTCM_RAM_MW = 4,    // Write mask width\n  parameter E203_DTCM_RAM_AW = 10    // Address width\n)(\n  input wire sd,\n  input wire ds,\n  input wire ls,\n  input wire cs,\n  input wire we,\n  input wire [E203_DTCM_RAM_AW-1:0] addr,\n  input wire [E203_DTCM_RAM_MW-1:0] wem,\n  input wire [E203_DTCM_RAM_DW-1:0] din,\n  input wire rst_n,\n  input wire clk,\n  output wire [E203_DTCM_RAM_DW-1:0] dout\n);\n\n  // Instantiate the generic RAM module\n  sirv_gnrl_ram #(\n    .DP(E203_DTCM_RAM_DP),\n    .DW(E203_DTCM_RAM_DW),\n    .MW(E203_DTCM_RAM_MW),\n    .AW(E203_DTCM_RAM_AW),\n    .FORCE_X2ZERO(1)\n  ) u_203_dtcm_gnrl_ram (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 2, "code": "module e203_core (\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire [E203_HART_ID_W-1:0] core_mhartid,\n    input wire dbg_irq_r,\n    input wire [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input wire [E203_EVT_NUM-1:0] evt_r,\n    input wire ext_irq_r,\n    input wire sft_irq_r,\n    input wire tmr_irq_r,\n    input wire dbg_mode,\n    input wire dbg_halt_r,\n    input wire dbg_step_r,\n    input wire dbg_ebreakm_r,\n    input wire dbg_stopcycle,\n    input wire [31:0] dcsr_r,\n    input wire [E203_PC_SIZE-1:0] dpc_r,\n    input wire [31:0] dscratch_r,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire core_cgstop,\n    output wire tcm_cgstop,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    output wire [31:0] wr_csr_nxt,\n    output wire [E203_PC_SIZE-1:0] cmt_dpc,\n    output wire cmt_dpc_ena,\n    output wire [2:0] cmt_dcause,\n    output wire cmt_dcause_ena\n);\n\n    // Internal signals for core logic\n    wire [E203_PC_SIZE-1:0] next_pc;\n    wire [31:0] exec_result;\n    wire exception;\n    wire [2:0] exception_code;\n\n    // Example of core logic (simplified)\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            inspect_pc <= pc_rtvec;\n            core_wfi <= 1'b0;\n            tm_stop <= 1'b0;\n            core_cgstop <= 1'b0;\n            tcm_cgstop <= 1'b0;\n            wr_dcsr_ena <= 1'b0;\n            wr_dpc_ena <= 1'b0;\n            wr_dscratch_ena <= 1'b0;\n            wr_csr_nxt <= 32'b0;\n            cmt_dpc <= pc_rtvec;\n            cmt_dpc_ena <= 1'b0;\n            cmt_dcause <= 3'b0;\n            cmt_dcause_ena <= 1'b0;\n        end else begin\n            // Fetch, decode, execute cycles\n            // Handle exceptions and interrupts\n            // Update program counter and registers\n            // This is a simplified placeholder logic\n        end\n    end\n\n    // Additional logic for debug, interrupts, and exception handling\n    // would be implemented here.\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 9, "code": "module e203_cpu(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC-1:0] pc_rtvec,\n    input wire [E203_HARD_ID_W-1:0] core_mhartid,\n    input wire dbg_irq_a,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    output wire [E203_PC-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n    // Optional ITCM Interface\n    `ifdef E203_HAS_ITCM\n    output wire itcm_ls,\n    output wire itcm_ram_cs,\n    output wire itcm_ram_we,\n    output wire [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n    output wire [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n    output wire [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n    input wire [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n    output wire clk_itcm_ram,\n    `endif\n    // Optional DTCM Interface\n    `ifdef E203_HAS_DTCM\n    output wire rst_dtcm,\n    output wire dtcm_ls,\n    output wire dtcm_ram_cs,\n    output wire dtcm_ram_we,\n    output wire [E203_ITCM_RAM_AW-1:0] dtcm_ram_addr,\n    output wire [E203_ITCM_RAM_MW-1:0] dtcm_ram_wem,\n    output wire [E203_ITCM_RAM_DW-1:0] dtcm_ram_din,\n    input wire [E203_ITCM_RAM_DW-1:0] dtcm_ram_dout,\n    `endif\n    // Debug Interface\n    output wire [E203_PC-1:0] cmt_dpc,\n    output wire cmt_dpc_ena,\n    output wire [2:0] cmt_dcause,\n    output wire cmt_dcause_ena,\n    output wire dbg_irq_r,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    output wire [31:0] wr_csr_nxt,\n    input wire [31:0] dcsr_r,\n    input wire [E203_PC-1:0] dpc_r,\n    input wire [31:0] dscratch_r,\n    input wire dbg_mode,\n    input wire dbg_halt_r,\n    input wire dbg_step_r,\n    input wire dbg_ebreakm_r,\n    input wire dbg_stopcycle\n);\n    // Core logic implementation\n    // Instantiate submodules, connect internal signals, and implement the core functionality\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 1, "code": "module e203_exu_alu_csrctrl (\n    input wire csr_i_valid,\n    output reg csr_i_ready,\n    input wire [E203_XLEN-1:0] csr_i_rs1,\n    input wire [E203_DECINFO_CSR_WIDTH-1:0] csr_i_info,\n    input wire csr_i_rdwen,\n    output reg csr_ena,\n    output reg csr_wr_en,\n    output reg csr_rd_en,\n    output reg [11:0] csr_idx,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output reg [E203_XLEN-1:0] wbck_csr_dat,\n    output reg csr_o_valid,\n    input wire csr_o_ready,\n    output reg [E203_XLEN-1:0] csr_o_wbck_wdat,\n    output reg csr_o_wbck_err,\n    input wire clk,\n    input wire rst_n\n);\n\n    wire csrrw = csr_i_info[E203_DECINFO_CSR_CSRRW];\n    wire csrrs = csr_i_info[E203_DECINFO_CSR_CSRRS];\n    wire csrrc = csr_i_info[E203_DECINFO_CSR_CSRRC];\n    wire rs1imm = csr_i_info[E203_DECINFO_CSR_RS1IMM];\n    wire rs1is0 = csr_i_info[E203_DECINFO_CSR_RS1IS0];\n    wire [11:0] csr_index = csr_i_info[E203_DECINFO_CSR_CSRIDX];\n\n    reg [E203_XLEN-1:0] csr_op1;\n\n    always @(*) begin\n        if (rs1imm) begin\n            csr_op1 = {E203_XLEN{1'b0}} | csr_i_info[E203_DECINFO_CSR_ZIMMM];\n        end else begin\n            csr_op1 = csr_i_rs1;\n        end\n    end\n\n    always @(*) begin\n        csr_idx = csr_index;\n        csr_wr_en = 0;\n        csr_rd_en = 0;\n        csr_ena = 0;\n        csr_i_ready = csr_o_ready;\n        csr_o_valid = csr_i_valid && csr_o_ready;\n        csr_o_wbck_wdat = read_csr_dat;\n        csr_o_wbck_err = csr_access_ilgl;\n\n        if (csr_i_valid) begin\n            if (csrrw) begin\n                csr_wr_en = 1;\n                csr_rd_en = csr_i_rdwen;\n            end\n            if (csrrs) begin\n                csr_wr_en = !rs1is0;\n                csr_rd_en = 1;\n            end\n            if (csrrc) begin\n                csr_wr_en = !rs1is0;\n                csr_rd_en = 1;\n            end\n            csr_ena = csr_o_valid && csr_o_ready;\n        end\n    end\n\n    always @(*) begin\n        case (1'b1)\n            csrrw: wbck_csr_dat = csr_op1;\n            csrrs: wbck_csr_dat = read_csr_dat | csr_op1;\n            csrrc: wbck_csr_dat = read_csr_dat & ~csr_op1;\n            default: wbck_csr_dat = {E203_XLEN{1'b0}};\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 10, "code": "module e203_cpu(\n    input wire clk,\n    input wire rst_n,\n\n    // Core Interfaces\n    output wire [E203_PC-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n    input wire [E203_PC-1:0] pc_rtvec,\n    input wire [E203_HARD_ID_W-1:0] core_mhartid,\n    input wire dbg_irq_a,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n\n    // ITCM Interfaces\n    `ifdef E203_HAS_ITCM\n    output wire itcm_ls,\n    output wire itcm_ram_cs,\n    output wire itcm_ram_we,\n    output wire [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n    output wire [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n    output wire [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n    input wire [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n    output wire clk_itcm_ram,\n    `endif\n\n    // DTCM Interfaces\n    `ifdef E203_HAS_DTCM\n    output wire rst_dtcm,\n    output wire dtcm_ls,\n    output wire dtcm_ram_cs,\n    output wire dtcm_ram_we,\n    output wire [E203_ITCM_RAM_AW-1:0] dtcm_ram_addr,\n    output wire [E203_ITCM_RAM_MW-1:0] dtcm_ram_wem,\n    output wire [E203_ITCM_RAM_DW-1:0] dtcm_ram_din,\n    input wire [E203_ITCM_RAM_DW-1:0] dtcm_ram_dout,\n    `endif\n\n    // Debug Related Interface\n    output wire [E203_PC-1:0] cmt_dpc,\n    output wire cmt_dpc_ena,\n    output wire [2:0] cmt_dcause,\n    output wire cmt_dcause_ena,\n    output wire dbg_irq_r,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    output wire [31:0] wr_csr_nxt,\n    input wire [31:0] dcsr_r,\n    input wire [E203_PC-1:0] dpc_r,\n    input wire [31:0] dscratch_r,\n    input wire dbg_mode,\n    input wire dbg_halt_r,\n    input wire dbg_step_r,\n    input wire dbg_ebreakm_r,\n    input wire dbg_stopcycle\n);\n    // Core logic implementation\n    // Instantiate submodules, connect signals, and implement the core functionality\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 14, "code": "module e203_clk_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire core_cgstop,\n    input wire core_ifu_active,\n    input wire core_exu_active,\n    input wire core_lsu_active,\n    input wire core_biu_active,\n    input wire core_wfi,\n    output wire clk_aon,\n    output wire clk_core_ifu,\n    output wire clk_core_exu,\n    output wire clk_core_lsu,\n    output wire clk_core_biu,\n    `ifdef E203_HAS_ITCM\n    input wire itcm_active,\n    output wire itcm_ls,\n    output wire clk_itcm,\n    `endif\n    `ifdef E203_HAS_DTCM\n    input wire dtcm_active,\n    output wire dtcm_ls,\n    output wire clk_dtcm,\n    `endif\n    output wire clk_core\n);\n\n// Clock always on\nassign clk_aon = clk;\n\n// Clock gating logic for IFU\nassign clk_core_ifu = (core_cgstop | (core_ifu_active & ~core_wfi)) & ~test_mode;\n\n// Clock gating logic for other core modules\nassign clk_core_exu = (core_cgstop | core_exu_active) & ~test_mode;\nassign clk_core_lsu = (core_cgstop | core_lsu_active) & ~test_mode;\nassign clk_core_biu = (core_cgstop | core_biu_active) & ~test_mode;\n\n// Optional ITCM and DTCM clock gating\n`ifdef E203_HAS_ITCM\nreg itcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        itcm_active_r <= 1'b0;\n    else\n        itcm_active_r <= itcm_active;\nend\nassign clk_itcm = (core_cgstop | itcm_active | itcm_active_r) & ~test_mode;\nassign itcm_ls = ~(itcm_active | itcm_active_r);\n`endif\n\n`ifdef E203_HAS_DTCM\nreg dtcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        dtcm_active_r <= 1'b0;\n    else\n        dtcm_active_r <= dtcm_active;\nend\nassign clk_dtcm = (core_cgstop | dtcm_active | dtcm_active_r) & ~test_mode;\nassign dtcm_ls = ~(dtcm_active | dtcm_active_r);\n`endif\n\n// Global core clock (example, could be used for debug or other purposes)\nassign clk_core = clk_core_ifu | clk_core_exu | clk_core_lsu | clk_core_biu;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 14, "code": "`include \"e203_defines.v\"\n\nmodule e203_dtcm_ram (\n    input wire sd,\n    input wire ds,\n    input wire ls,\n    input wire cs,\n    input wire we,\n    input wire [E203_DTCM_RAM_AW-1:0] addr,\n    input wire [E203_DTCM_RAM_MW-1:0] wem,\n    input wire [E203_DTCM_RAM_DW-1:0] din,\n    input wire rst_n,\n    input wire clk,\n    output wire [E203_DTCM_RAM_DW-1:0] dout\n);\n\n    sirv_gnrl_ram #(\n        .DP(E203_DTCM_RAM_DP),\n        .DW(E203_DTCM_RAM_DW),\n        .FORCE_X2ZERO(1),\n        .MW(E203_DTCM_RAM_MW),\n        .AW(E203_DTCM_RAM_AW)\n    ) u_203_dtcm_gnrl_ram (\n        .sd(sd),\n        .ds(ds),\n        .ls(ls),\n        .rst_n(rst_n),\n        .clk(clk),\n        .cs(cs),\n        .we(we),\n        .addr(addr),\n        .din(din),\n        .wem(wem),\n        .dout(dout)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 3, "code": "module e203_core (\n    // System Interface\n    output [`E203_PC_SIZE-1:0] inspect_pc,\n    output core_wfi,\n    output tm_stop,\n    output core_cgstop,\n    output tcm_cgstop,\n    input [`E203_PC_SIZE-1:0] pc_rtvec,\n    input [`E203_HART_ID_W-1:0] core_mhartid,\n    input dbg_irq_r,\n    input [`E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input [`E203_EVT_NUM-1:0] evt_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    output wr_dcsr_ena,\n    output wr_dpc_ena,\n    output wr_dscratch_ena,\n    output [31:0] wr_csr_nxt,\n    input [31:0] dcsr_r,\n    input [`E203_PC_SIZE-1:0] dpc_r,\n    input [31:0] dscratch_r,\n    output [`E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input dbg_stopcycle,\n\n    // ICB Protocol Interface\n    input *_icb_enable,\n    output *_icb_cmd_valid,\n    input *_icb_cmd_ready,\n    output [`E203_ADDR_SIZE-1:0] *_icb_cmd_addr,\n    output *_icb_cmd_read,\n    output [`E203_XLEN-1:0] *_icb_cmd_wdata,\n    output [`E203_XLEN/8-1:0] *_icb_cmd_wmask,\n    output *_icb_cmd_lock,\n    output *_icb_cmd_excl,\n    output [1:0] *_icb_cmd_size,\n    input *_icb_rsp_valid,\n    output *_icb_rsp_ready,\n    input *_icb_rsp_err,\n    input *_icb_rsp_excl_ok,\n    input [`E203_XLEN-1:0] *_icb_rsp_rdata,\n\n    // NICE Interface\n    input nice_mem_holdup,\n    output nice_req_valid,\n    input nice_req_ready,\n    output [`E203_XLEN-1:0] nice_req_inst,\n    output [`E203_XLEN-1:0] nice_req_rs1,\n    output [`E203_XLEN-1:0] nice_req_rs2,\n    input nice_rsp_multicyc_valid,\n    output nice_rsp_multicyc_ready,\n    input [`E203_XLEN-1:0] nice_rsp_multicyc_dat,\n    input nice_rsp_multicyc_err,\n    input nice_icb_cmd_valid,\n    output nice_icb_cmd_ready,\n    input [`E203_XLEN-1:0] nice_icb_cmd_addr,\n    input nice_icb_cmd_read,\n    input [`E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input [1:0] nice_icb_cmd_size,\n    output nice_icb_rsp_valid,\n    input nice_icb_rsp_ready,\n    output [`E203_XLEN-1:0] nice_icb_rsp_rdata,\n    output nice_icb_rsp_err\n);\n    // Core implementation details would be here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 4, "code": "module e203_core (\n    // System Interface\n    output [E203_PC_SIZE-1:0] inspect_pc,\n    output core_wfi,\n    output tm_stop,\n    output core_cgstop,\n    output tcm_cgstop,\n    input  [E203_PC_SIZE-1:0] pc_rtvec,\n    input  [E203_HART_ID_W-1:0] core_mhartid,\n    input  dbg_irq_r,\n    input  [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input  [E203_EVT_NUM-1:0] evt_r,\n    input  ext_irq_r,\n    input  sft_irq_r,\n    input  tmr_irq_r,\n    output wr_dcsr_ena,\n    output wr_dpc_ena,\n    output wr_dscratch_ena,\n    output [31:0] wr_csr_nxt,\n    input  [31:0] dcsr_r,\n    input  [E203_PC_SIZE-1:0] dpc_r,\n    input  [31:0] dscratch_r,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    input  dbg_mode,\n    input  dbg_halt_r,\n    input  dbg_step_r,\n    input  dbg_ebreakm_r,\n    input  dbg_stopcycle,\n\n    // ICB Protocol Interface\n    input  *_icb_enable,\n    output *_icb_cmd_valid,\n    input  *_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] *_icb_cmd_addr,\n    output *_icb_cmd_read,\n    output [E203_XLEN-1:0] *_icb_cmd_wdata,\n    output [E203_XLEN/8-1:0] *_icb_cmd_wmask,\n    output *_icb_cmd_lock,\n    output *_icb_cmd_excl,\n    output [1:0] *_icb_cmd_size,\n    input  *_icb_rsp_valid,\n    output *_icb_rsp_ready,\n    input  *_icb_rsp_err,\n    input  *_icb_rsp_excl_ok,\n    input  [E203_XLEN-1:0] *_icb_rsp_rdata,\n\n    // NICE Interface\n    input  nice_mem_holdup,\n    output nice_req_valid,\n    input  nice_req_ready,\n    output [E203_XLEN-1:0] nice_req_inst,\n    output [E203_XLEN-1:0] nice_req_rs1,\n    output [E203_XLEN-1:0] nice_req_rs2,\n    input  nice_rsp_multicyc_valid,\n    output nice_rsp_multicyc_ready,\n    input  [E203_XLEN-1:0] nice_rsp_multicyc_dat,\n    input  nice_rsp_multicyc_err,\n    input  nice_icb_cmd_valid,\n    output nice_icb_cmd_ready,\n    input  [E203_XLEN-1:0] nice_icb_cmd_addr,\n    input  nice_icb_cmd_read,\n    input  [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input  [1:0] nice_icb_cmd_size,\n    output nice_icb_rsp_valid,\n    input  nice_icb_rsp_ready,\n    output [E203_XLEN-1:0] nice_icb_rsp_rdata,\n    output nice_icb_rsp_err\n);\n    // Core implementation details would be here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 1, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_branchslv(\n    input wire cmt_i_valid,\n    output wire cmt_i_ready,\n    input wire cmt_i_rv32,\n    input wire cmt_i_dret,\n    input wire cmt_i_mret,\n    input wire cmt_i_fencei,\n    input wire cmt_i_bjp,\n    input wire cmt_i_bjp_prdt,\n    input wire cmt_i_bjp_rslv,\n    input wire [`E203_PC_SIZE-1:0] cmt_i_pc,\n    input wire [`E203_XLEN-1:0] cmt_i_imm,\n    input wire [`E203_PC_SIZE-1:0] csr_epc_r,\n    input wire [`E203_PC_SIZE-1:0] csr_dpc_r,\n    input wire nonalu_excpirq_flush_req_raw,\n    input wire brchmis_flush_ack,\n    output wire brchmis_flush_req,\n    output wire [`E203_PC_SIZE-1:0] brchmis_flush_add_op1,\n    output wire [`E203_PC_SIZE-1:0] brchmis_flush_add_op2,\n    output wire [`E203_PC_SIZE-1:0] brchmis_flush_pc,\n    output wire cmt_mret_ena,\n    output wire cmt_dret_ena,\n    output wire cmt_fencei_ena,\n    input wire clk,\n    input wire rst_n\n);\n\n    wire flush_needed = (cmt_i_bjp & (cmt_i_bjp_prdt != cmt_i_bjp_rslv)) | cmt_i_fencei | cmt_i_mret | cmt_i_dret;\n    wire flush_ack_received = brchmis_flush_ack;\n    wire nonalu_flush_active = nonalu_excpirq_flush_req_raw;\n\n    assign brchmis_flush_req = flush_needed & cmt_i_valid & ~nonalu_flush_active;\n    assign cmt_i_ready = ~flush_needed & ~nonalu_flush_active | flush_ack_received;\n\n    assign cmt_mret_ena = cmt_i_mret & flush_needed & flush_ack_received;\n    assign cmt_dret_ena = cmt_i_dret & flush_needed & flush_ack_received;\n    assign cmt_fencei_ena = cmt_i_fencei & flush_needed & flush_ack_received;\n\n    `ifdef E203_TIMING_BOOST\n        assign brchmis_flush_pc = (cmt_i_fencei | (cmt_i_bjp & cmt_i_bjp_prdt)) ? (cmt_i_pc + (cmt_i_rv32 ? 4 : 2)) :\n                                  (cmt_i_bjp & ~cmt_i_bjp_prdt) ? (cmt_i_pc + cmt_i_imm[`E203_PC_SIZE-1:0]) :\n                                  cmt_i_dret ? csr_dpc_r :\n                                  csr_epc_r;\n    `else\n        assign brchmis_flush_add_op1 = cmt_i_pc;\n        assign brchmis_flush_add_op2 = cmt_i_rv32 ? 4 : 2;\n    `endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 3, "code": "module e203_cpu_top(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire tcm_sd,\n    input wire tcm_ds,\n    input wire [E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input wire ext2itcm_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ext2itcm_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] ext2itcm_icb_cmd_wmask,\n    input wire ext2itcm_icb_cmd_valid,\n    input wire ext2itcm_icb_rsp_ready,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire dbg_irq_r,\n    output wire ext2itcm_icb_cmd_ready,\n    output wire [E203_XLEN-1:0] ext2itcm_icb_rsp_rdata,\n    output wire ext2itcm_icb_rsp_valid,\n    output wire ext2itcm_icb_rsp_err\n);\n\n    // Internal signals\n    wire core_clk;\n    wire core_rst_n;\n    wire [E203_PC_SIZE-1:0] core_pc;\n    wire core_dbg_irq;\n    wire core_mem_cmd_valid;\n    wire core_mem_cmd_ready;\n    wire core_mem_rsp_valid;\n    wire core_mem_rsp_ready;\n    wire core_core_clk;\n    wire core_csr_clk_signal;\n    wire core_core_wfi;\n    wire core_tm_stop;\n    wire core_dbg_irq_sync;\n    wire [E203_XLEN-1:0] itcm_data_out;\n    wire itcm_ready;\n    wire itcm_valid;\n    wire itcm_error;\n\n    // Clock and reset\n    assign core_clk = clk;\n    assign core_rst_n = rst_n;\n\n    // Core instantiation\n    e203_cpu core_inst (\n        .clk(core_clk),\n        .rst_n(core_rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ext_irq_a(ext_irq_a),\n        .sft_irq_a(sft_irq_a),\n        .tmr_irq_a(tmr_irq_a),\n        .tcm_sd(tcm_sd),\n        .tcm_ds(tcm_ds),\n        .ext2itcm_icb_cmd_addr(ext2itcm_icb_cmd_addr),\n        .ext2itcm_icb_cmd_read(ext2itcm_icb_cmd_read),\n        .ext2itcm_icb_cmd_wdata(ext2itcm_icb_cmd_wdata),\n        .ext2itcm_icb_cmd_wmask(ext2itcm_icb_cmd_wmask),\n        .ext2itcm_icb_cmd_valid(ext2itcm_icb_cmd_valid),\n        .ext2itcm_icb_rsp_ready(ext2itcm_icb_rsp_ready),\n        .inspect_pc(core_pc),\n        .inspect_dbg_irq(core_dbg_irq),\n        .inspect_mem_cmd_valid(core_mem_cmd_valid),\n        .inspect_mem_cmd_ready(core_mem_cmd_ready),\n        .inspect_mem_rsp_valid(core_mem_rsp_valid),\n        .inspect_mem_rsp_ready(core_mem_rsp_ready),\n        .inspect_core_clk(core_core_clk),\n        .core_csr_clk(core_csr_clk_signal),\n        .core_wfi(core_core_wfi),\n        .tm_stop(core_tm_stop),\n        .dbg_irq_r(core_dbg_irq_sync),\n        .ext2itcm_icb_cmd_ready(itcm_ready),\n        .ext2itcm_icb_rsp_rdata(itcm_data_out),\n        .ext2itcm_icb_rsp_valid(itcm_valid),\n        .ext2itcm_icb_rsp_err(itcm_error)\n    );\n\n    // Output assignments\n    assign inspect_pc = core_pc;\n    assign inspect_dbg_irq = core_dbg_irq;\n    assign inspect_mem_cmd_valid = core_mem_cmd_valid;\n    assign inspect_mem_cmd_ready = core_mem_cmd_ready;\n    assign inspect_mem_rsp_valid = core_mem_rsp_valid;\n    assign inspect_mem_rsp_ready = core_mem_rsp_ready;\n    assign inspect_core_clk = core_core_clk;\n    assign core_csr_clk = core_csr_clk_signal;\n    assign core_wfi = core_core_wfi;\n    assign tm_stop = core_tm_stop;\n    assign dbg_irq_r = core_dbg_irq_sync;\n    assign ext2itcm_icb_cmd_ready = itcm_ready;\n    assign ext2itcm_icb_rsp_rdata = itcm_data_out;\n    assign ext2itcm_icb_rsp_valid = itcm_valid;\n    assign ext2itcm_icb_rsp_err = itcm_error;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 4, "code": "module e203_cpu_top(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire tcm_sd,\n    input wire tcm_ds,\n    input wire [E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input wire ext2itcm_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ext2itcm_icb_cmd_wdata,\n    input wire [E203_XLEN/8-1:0] ext2itcm_icb_cmd_wmask,\n    input wire ext2itcm_icb_cmd_valid,\n    output wire ext2itcm_icb_cmd_ready,\n    output wire [E203_XLEN-1:0] ext2itcm_icb_rsp_rdata,\n    output wire ext2itcm_icb_rsp_err,\n    output wire ext2itcm_icb_rsp_valid,\n    input wire ext2itcm_icb_rsp_ready\n);\n\n    wire [E203_PC_SIZE-1:0] inspect_pc;\n    wire inspect_dbg_irq;\n    wire inspect_mem_cmd_valid;\n    wire inspect_mem_cmd_ready;\n    wire inspect_mem_rsp_valid;\n    wire inspect_mem_rsp_ready;\n    wire inspect_core_clk;\n    wire core_csr_clk;\n    wire core_wfi;\n    wire tm_stop;\n    wire dbg_irq_r;\n\n    // Instantiate the e203_cpu core\n    e203_cpu u_e203_cpu(\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ext_irq_a(ext_irq_a),\n        .sft_irq_a(sft_irq_a),\n        .tmr_irq_a(tmr_irq_a),\n        .inspect_pc(inspect_pc),\n        .inspect_dbg_irq(inspect_dbg_irq),\n        .inspect_mem_cmd_valid(inspect_mem_cmd_valid),\n        .inspect_mem_cmd_ready(inspect_mem_cmd_ready),\n        .inspect_mem_rsp_valid(inspect_mem_rsp_valid),\n        .inspect_mem_rsp_ready(inspect_mem_rsp_ready),\n        .inspect_core_clk(inspect_core_clk),\n        .core_csr_clk(core_csr_clk),\n        .core_wfi(core_wfi),\n        .tm_stop(tm_stop),\n        .dbg_irq_r(dbg_irq_r)\n    );\n\n    // SRAM control logic\n    e203_srams u_e203_srams(\n        .clk(clk),\n        .rst_n(rst_n),\n        .tcm_sd(tcm_sd),\n        .tcm_ds(tcm_ds),\n        .ext2itcm_icb_cmd_addr(ext2itcm_icb_cmd_addr),\n        .ext2itcm_icb_cmd_read(ext2itcm_icb_cmd_read),\n        .ext2itcm_icb_cmd_wdata(ext2itcm_icb_cmd_wdata),\n        .ext2itcm_icb_cmd_wmask(ext2itcm_icb_cmd_wmask),\n        .ext2itcm_icb_cmd_valid(ext2itcm_icb_cmd_valid),\n        .ext2itcm_icb_cmd_ready(ext2itcm_icb_cmd_ready),\n        .ext2itcm_icb_rsp_rdata(ext2itcm_icb_rsp_rdata),\n        .ext2itcm_icb_rsp_err(ext2itcm_icb_rsp_err),\n        .ext2itcm_icb_rsp_valid(ext2itcm_icb_rsp_valid),\n        .ext2itcm_icb_rsp_ready(ext2itcm_icb_rsp_ready)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 5, "code": "module e203_core (\n    // System Interface\n    output [E203_PC_SIZE-1:0] inspect_pc,\n    output core_wfi,\n    output tm_stop,\n    output core_cgstop,\n    output tcm_cgstop,\n    input  [E203_PC_SIZE-1:0] pc_rtvec,\n    input  [E203_HART_ID_W-1:0] core_mhartid,\n    input  dbg_irq_r,\n    input  [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input  [E203_EVT_NUM-1:0] evt_r,\n    input  ext_irq_r,\n    input  sft_irq_r,\n    input  tmr_irq_r,\n    output wr_dcsr_ena,\n    output wr_dpc_ena,\n    output wr_dscratch_ena,\n    output [31:0] wr_csr_nxt,\n    input  [31:0] dcsr_r,\n    input  [E203_PC_SIZE-1:0] dpc_r,\n    input  [31:0] dscratch_r,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    input  dbg_mode,\n    input  dbg_halt_r,\n    input  dbg_step_r,\n    input  dbg_ebreakm_r,\n    input  dbg_stopcycle,\n\n    // ICB Protocol Interface - Example for one interface, expand as needed\n    input  *_icb_enable,\n    output *_icb_cmd_valid,\n    input  *_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] *_icb_cmd_addr,\n    output *_icb_cmd_read,\n    output [E203_XLEN-1:0] *_icb_cmd_wdata,\n    output [E203_XLEN/8-1:0] *_icb_cmd_wmask,\n    output *_icb_cmd_lock,\n    output *_icb_cmd_excl,\n    output [1:0] *_icb_cmd_size,\n    input  *_icb_rsp_valid,\n    output *_icb_rsp_ready,\n    input  *_icb_rsp_err,\n    input  *_icb_rsp_excl_ok,\n    input  [E203_XLEN-1:0] *_icb_rsp_rdata,\n\n    // NICE Interface\n    input  nice_mem_holdup,\n    output nice_req_valid,\n    input  nice_req_ready,\n    output [E203_XLEN-1:0] nice_req_inst,\n    output [E203_XLEN-1:0] nice_req_rs1,\n    output [E203_XLEN-1:0] nice_req_rs2,\n    input  nice_rsp_multicyc_valid,\n    output nice_rsp_multicyc_ready,\n    input  [E203_XLEN-1:0] nice_rsp_multicyc_dat,\n    input  nice_rsp_multicyc_err,\n    input  nice_icb_cmd_valid,\n    output nice_icb_cmd_ready,\n    input  [E203_XLEN-1:0] nice_icb_cmd_addr,\n    input  nice_icb_cmd_read,\n    input  [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input  [1:0] nice_icb_cmd_size,\n    output nice_icb_rsp_valid,\n    input  nice_icb_rsp_ready,\n    output [E203_XLEN-1:0] nice_icb_rsp_rdata,\n    output nice_icb_rsp_err\n);\n    // Core implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 5, "code": "module e203_cpu_top (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire [`E203_ADDR_SIZE-1:0] pc_rtvec,\n    output wire [`E203_PC_SIZE-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire dbg_irq_r,\n    input  wire ext_irq_a,\n    input  wire sft_irq_a,\n    input  wire tmr_irq_a,\n    input  wire tcm_sd,\n    input  wire tcm_ds,\n    input  wire ext2itcm_icb_cmd_valid,\n    output wire ext2itcm_icb_cmd_ready,\n    input  wire [`E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input  wire ext2itcm_icb_cmd_read,\n    input  wire [`E203_XLEN-1:0] ext2itcm_icb_cmd_wdata,\n    input  wire [`E203_XLEN/8-1:0] ext2itcm_icb_cmd_wmask,\n    output wire ext2itcm_icb_rsp_valid,\n    input  wire ext2itcm_icb_rsp_ready,\n    output wire ext2itcm_icb_rsp_err,\n    output wire [`E203_XLEN-1:0] ext2itcm_icb_rsp_rdata\n);\n\n    // Instantiate the e203_cpu core\n    e203_cpu u_e203_cpu (\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .inspect_pc(inspect_pc),\n        .inspect_dbg_irq(inspect_dbg_irq),\n        .inspect_mem_cmd_valid(inspect_mem_cmd_valid),\n        .inspect_mem_cmd_ready(inspect_mem_cmd_ready),\n        .inspect_mem_rsp_valid(inspect_mem_rsp_valid),\n        .inspect_mem_rsp_ready(inspect_mem_rsp_ready),\n        .inspect_core_clk(inspect_core_clk),\n        .core_csr_clk(core_csr_clk),\n        .core_wfi(core_wfi),\n        .tm_stop(tm_stop),\n        .dbg_irq_r(dbg_irq_r),\n        .ext_irq_a(ext_irq_a),\n        .sft_irq_a(sft_irq_a),\n        .tmr_irq_a(tmr_irq_a)\n    );\n\n    // Instantiate the e203_srams for ITCM and DTCM management\n    e203_srams u_e203_srams (\n        .clk(clk),\n        .rst_n(rst_n),\n        .tcm_sd(tcm_sd),\n        .tcm_ds(tcm_ds),\n        .ext2itcm_icb_cmd_valid(ext2itcm_icb_cmd_valid),\n        .ext2itcm_icb_cmd_ready(ext2itcm_icb_cmd_ready),\n        .ext2itcm_icb_cmd_addr(ext2itcm_icb_cmd_addr),\n        .ext2itcm_icb_cmd_read(ext2itcm_icb_cmd_read),\n        .ext2itcm_icb_cmd_wdata(ext2itcm_icb_cmd_wdata),\n        .ext2itcm_icb_cmd_wmask(ext2itcm_icb_cmd_wmask),\n        .ext2itcm_icb_rsp_valid(ext2itcm_icb_rsp_valid),\n        .ext2itcm_icb_rsp_ready(ext2itcm_icb_rsp_ready),\n        .ext2itcm_icb_rsp_err(ext2itcm_icb_rsp_err),\n        .ext2itcm_icb_rsp_rdata(ext2itcm_icb_rsp_rdata)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 6, "code": "module e203_cpu_top(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire tcm_sd,\n    input wire tcm_ds,\n    input wire [E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input wire ext2itcm_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ext2itcm_icb_cmd_wdata,\n    input wire [E203_XLEN/8-1:0] ext2itcm_icb_cmd_wmask,\n    input wire ext2itcm_icb_cmd_valid,\n    input wire ext2itcm_icb_rsp_ready,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire dbg_irq_r,\n    output wire ext2itcm_icb_cmd_ready,\n    output wire [E203_XLEN-1:0] ext2itcm_icb_rsp_rdata,\n    output wire ext2itcm_icb_rsp_valid,\n    output wire ext2itcm_icb_rsp_err\n);\n\n    // Core instantiation\n    e203_cpu core (\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ext_irq_a(ext_irq_a),\n        .sft_irq_a(sft_irq_a),\n        .tmr_irq_a(tmr_irq_a),\n        .inspect_pc(inspect_pc),\n        .inspect_dbg_irq(inspect_dbg_irq),\n        .inspect_mem_cmd_valid(inspect_mem_cmd_valid),\n        .inspect_mem_cmd_ready(inspect_mem_cmd_ready),\n        .inspect_mem_rsp_valid(inspect_mem_rsp_valid),\n        .inspect_mem_rsp_ready(inspect_mem_rsp_ready),\n        .inspect_core_clk(inspect_core_clk),\n        .core_csr_clk(core_csr_clk),\n        .core_wfi(core_wfi),\n        .tm_stop(tm_stop),\n        .dbg_irq_r(dbg_irq_r)\n    );\n\n    // SRAMs instantiation\n    e203_srams srams (\n        .clk(clk),\n        .rst_n(rst_n),\n        .tcm_sd(tcm_sd),\n        .tcm_ds(tcm_ds),\n        .ext2itcm_icb_cmd_addr(ext2itcm_icb_cmd_addr),\n        .ext2itcm_icb_cmd_read(ext2itcm_icb_cmd_read),\n        .ext2itcm_icb_cmd_wdata(ext2itcm_icb_cmd_wdata),\n        .ext2itcm_icb_cmd_wmask(ext2itcm_icb_cmd_wmask),\n        .ext2itcm_icb_cmd_valid(ext2itcm_icb_cmd_valid),\n        .ext2itcm_icb_rsp_ready(ext2itcm_icb_rsp_ready),\n        .ext2itcm_icb_cmd_ready(ext2itcm_icb_cmd_ready),\n        .ext2itcm_icb_rsp_rdata(ext2itcm_icb_rsp_rdata),\n        .ext2itcm_icb_rsp_valid(ext2itcm_icb_rsp_valid),\n        .ext2itcm_icb_rsp_err(ext2itcm_icb_rsp_err)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 1, "code": "module e203_exu_csr(\n    input nonflush_cmt_ena,\n    input csr_ena,\n    input csr_wr_en,\n    input csr_rd_en,\n    input [11:0] csr_idx,\n    output csr_access_ilgl,\n    output tm_stop,\n    output core_cgstop,\n    output tcm_cgstop,\n    output itcm_nohold,\n    output mdv_nob2b,\n    output [E203_XLEN-1:0] read_csr_dat,\n    input [E203_XLEN-1:0] wbck_csr_dat,\n    input [E203_HART_ID_W-1:0] core_mhartid,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    output status_mie_r,\n    output mtie_r,\n    output msie_r,\n    output meie_r,\n    output wr_dcsr_ena,\n    output wr_dpc_ena,\n    output wr_dscratch_ena,\n    input [E203_XLEN-1:0] dcsr_r,\n    input [E203_PC_SIZE-1:0] dpc_r,\n    input [E203_XLEN-1:0] dscratch_r,\n    output u_mode,\n    output s_mode,\n    output h_mode,\n    output m_mode,\n    input [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    input cmt_badaddr_ena,\n    input [E203_PC_SIZE-1:0] cmt_epc,\n    input cmt_epc_ena,\n    input [E203_XLEN-1:0] cmt_cause,\n    input cmt_cause_ena,\n    input cmt_status_ena,\n    input cmt_instret_ena,\n    input cmt_mret_ena,\n    output [E203_PC_SIZE-1:0] csr_epc_r,\n    output [E203_PC_SIZE-1:0] csr_dpc_r,\n    output [E203_XLEN-1:0] csr_mtvec_r,\n    input clk_aon,\n    input clk,\n    input rst_n\n);\n\n// CSR logic implementation here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 2, "code": "module e203_exu_branchslv (\n    input wire cmt_i_valid,\n    output wire cmt_i_ready,\n    input wire cmt_i_rv32,\n    input wire cmt_i_dret,\n    input wire cmt_i_mret,\n    input wire cmt_i_fencei,\n    input wire cmt_i_bjp,\n    input wire cmt_i_bjp_prdt,\n    input wire cmt_i_bjp_rslv,\n    input wire [E203_PC_SIZE-1:0] cmt_i_pc,\n    input wire [E203_XLEN-1:0] cmt_i_imm,\n    input wire [E203_PC_SIZE-1:0] csr_epc_r,\n    input wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    input wire nonalu_excpirq_flush_req_raw,\n    input wire brchmis_flush_ack,\n    output wire brchmis_flush_req,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op1,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op2,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_pc,\n    output wire cmt_mret_ena,\n    output wire cmt_dret_ena,\n    output wire cmt_fencei_ena,\n    input wire clk,\n    input wire rst_n\n);\n\n    wire flush_needed;\n    wire flush_target_mret;\n    wire flush_target_dret;\n    wire flush_target_fencei;\n    wire flush_target_bjp_mispredict;\n\n    assign flush_needed = (cmt_i_bjp & (cmt_i_bjp_prdt ^ cmt_i_bjp_rslv)) | cmt_i_fencei | cmt_i_mret | cmt_i_dret;\n\n    assign flush_target_mret = cmt_i_mret;\n    assign flush_target_dret = cmt_i_dret;\n    assign flush_target_fencei = cmt_i_fencei;\n    assign flush_target_bjp_mispredict = cmt_i_bjp & (cmt_i_bjp_prdt ^ cmt_i_bjp_rslv);\n\n    assign brchmis_flush_req = flush_needed & cmt_i_valid & ~nonalu_excpirq_flush_req_raw;\n\n    assign brchmis_flush_add_op1 = (flush_target_dret ? csr_dpc_r :\n                                    flush_target_mret ? csr_epc_r :\n                                    cmt_i_pc);\n\n    assign brchmis_flush_add_op2 = (flush_target_bjp_mispredict & ~cmt_i_bjp_prdt) ? cmt_i_imm : \n                                   (cmt_i_rv32 ? 32'd4 : 32'd2);\n\n    assign brchmis_flush_pc = (flush_target_fencei | (flush_target_bjp_mispredict & cmt_i_bjp_prdt)) ? (cmt_i_pc + (cmt_i_rv32 ? 32'd4 : 32'd2)) :\n                              (flush_target_bjp_mispredict & ~cmt_i_bjp_prdt) ? (cmt_i_pc + cmt_i_imm) :\n                              (flush_target_dret ? csr_dpc_r : csr_epc_r);\n\n    assign cmt_i_ready = ~flush_needed & ~nonalu_excpirq_flush_req_raw | brchmis_flush_ack;\n\n    assign cmt_mret_ena = cmt_i_mret & brchmis_flush_req & brchmis_flush_ack;\n    assign cmt_dret_ena = cmt_i_dret & brchmis_flush_req & brchmis_flush_ack;\n    assign cmt_fencei_ena = cmt_i_fencei & brchmis_flush_req & brchmis_flush_ack;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 1, "code": "module e203_dtcm_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n    output wire dtcm_active,\n\n    // LSU ICB Interface\n    input wire lsu2dtcm_icb_cmd_valid,\n    output wire lsu2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] lsu2dtcm_icb_cmd_addr,\n    input wire lsu2dtcm_icb_cmd_read,\n    input wire [31:0] lsu2dtcm_icb_cmd_wdata,\n    input wire [3:0] lsu2dtcm_icb_cmd_wmask,\n    output wire lsu2dtcm_icb_rsp_valid,\n    input wire lsu2dtcm_icb_rsp_ready,\n    output wire lsu2dtcm_icb_rsp_err,\n    output wire [31:0] lsu2dtcm_icb_rsp_rdata,\n\n    // External ICB Interface (Optional)\n    `ifdef E203_HAS_DTCM_EXTITF\n    input wire ext2dtcm_icb_cmd_valid,\n    output wire ext2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] ext2dtcm_icb_cmd_addr,\n    input wire ext2dtcm_icb_cmd_read,\n    input wire [31:0] ext2dtcm_icb_cmd_wdata,\n    input wire [3:0] ext2dtcm_icb_cmd_wmask,\n    output wire ext2dtcm_icb_rsp_valid,\n    input wire ext2dtcm_icb_rsp_ready,\n    output wire ext2dtcm_icb_rsp_err,\n    output wire [31:0] ext2dtcm_icb_rsp_rdata,\n    `endif\n\n    // DTCM RAM Interface\n    output wire dtcm_ram_cs,\n    output wire dtcm_ram_we,\n    output wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    output wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    output wire clk_dtcm_ram\n);\n\n    // Internal signals\n    wire arb_cmd_valid;\n    wire arb_cmd_ready;\n    wire arb_cmd_read;\n    wire [E203_DTCM_ADDR_WIDTH-1:0] arb_cmd_addr;\n    wire [31:0] arb_cmd_wdata;\n    wire [3:0] arb_cmd_wmask;\n    wire arb_rsp_valid;\n    wire arb_rsp_ready;\n    wire arb_rsp_err;\n    wire [31:0] arb_rsp_rdata;\n\n    // Instantiate the bus arbiter\n    sirv_gnrl_icb_arbt #(\n        .ARBT_SCHEME(0),\n        .ALLOW_0CYCL_RSP(0),\n        .FIFO_OUTS_NUM(E203_DTCM_OUTS_NUM),\n        .FIFO_CUT_READY(0),\n        .USR_W(1),\n        .ARBT_NUM(DTCM_ARBT_I_NUM),\n        .AW(E203_DTCM_ADDR_WIDTH),\n        .DW(32),\n        .ARBT_PTR_W(DTCM_ARBT_I_PTR_W)\n    ) u_arbiter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .i_bus_icb_cmd_valid({ext2dtcm_icb_cmd_valid, lsu2dtcm_icb_cmd_valid}),\n        .i_bus_icb_cmd_ready({ext2dtcm_icb_cmd_ready, lsu2dtcm_icb_cmd_ready}),\n        .i_bus_icb_cmd_read({ext2dtcm_icb_cmd_read, lsu2dtcm_icb_cmd_read}),\n        .i_bus_icb_cmd_addr({ext2dtcm_icb_cmd_addr, lsu2dtcm_icb_cmd_addr}),\n        .i_bus_icb_cmd_wdata({ext2dtcm_icb_cmd_wdata, lsu2dtcm_icb_cmd_wdata}),\n        .i_bus_icb_cmd_wmask({ext2dtcm_icb_cmd_wmask, lsu2dtcm_icb_cmd_wmask}),\n        .i_bus_icb_rsp_valid({ext2dtcm_icb_rsp_valid, lsu2dtcm_icb_rsp_valid}),\n        .i_bus_icb_rsp_ready({ext2dtcm_icb_rsp_ready, lsu2dtcm_icb_rsp_ready}),\n        .i_bus_icb_rsp_err({ext2dtcm_icb_rsp_err, lsu2dtcm_icb_rsp_err}),\n        .i_bus_icb_rsp_rdata({ext2dtcm_icb_rsp_rdata, lsu2dtcm_icb_rsp_rdata}),\n        .o_icb_cmd_valid(arb_cmd_valid),\n        .o_icb_cmd_ready(arb_cmd_ready),\n        .o_icb_cmd_read(arb_cmd_read),\n        .o_icb_cmd_addr(arb_cmd_addr),\n        .o_icb_cmd_wdata(arb_cmd_wdata),\n        .o_icb_cmd_wmask(arb_cmd_wmask),\n        .o_icb_rsp_valid(arb_rsp_valid),\n        .o_icb_rsp_ready(arb_rsp_ready),\n        .o_icb_rsp_err(arb_rsp_err),\n        .o_icb_rsp_rdata(arb_rsp_rdata)\n    );\n\n    // SRAM controller logic\n    assign dtcm_ram_cs = arb_cmd_valid && arb_cmd_ready;\n    assign dtcm_ram_we = !arb_cmd_read;\n    assign dtcm_ram_addr = arb_cmd_addr[E203_DTCM_RAM_AW-1:0];\n    assign dtcm_ram_wem = arb_cmd_wmask;\n    assign dtcm_ram_din = arb_cmd_wdata;\n    assign clk_dtcm_ram = clk;\n\n    // Response logic\n    assign arb_rsp_valid = dtcm_ram_cs;\n    assign arb_rsp_rdata = dtcm_ram_dout;\n    assign arb_rsp_err = 0; // No error handling in this example\n\n    // Activity indicator\n    assign dtcm_active = arb_cmd_valid || arb_rsp_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 15, "code": "module e203_dtcm_ram #(\n  parameter E203_DTCM_RAM_DP = 256, // Depth of the RAM\n  parameter E203_DTCM_RAM_DW = 32,  // Data width\n  parameter E203_DTCM_RAM_MW = 4,   // Write mask width\n  parameter E203_DTCM_RAM_AW = 8    // Address width\n)(\n  input wire sd,\n  input wire ds,\n  input wire ls,\n  input wire cs,\n  input wire we,\n  input wire [E203_DTCM_RAM_AW-1:0] addr,\n  input wire [E203_DTCM_RAM_MW-1:0] wem,\n  input wire [E203_DTCM_RAM_DW-1:0] din,\n  input wire rst_n,\n  input wire clk,\n  output wire [E203_DTCM_RAM_DW-1:0] dout\n);\n\n  // Instantiate the generic RAM module\n  sirv_gnrl_ram #(\n    .DP(E203_DTCM_RAM_DP),\n    .DW(E203_DTCM_RAM_DW),\n    .MW(E203_DTCM_RAM_MW),\n    .AW(E203_DTCM_RAM_AW),\n    .FORCE_X2ZERO(1)\n  ) u_203_dtcm_gnrl_ram (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 6, "code": "module e203_core(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_ADDR_SIZE-1:0] pc_rtvec,\n    input wire [E203_HART_ID_W-1:0] core_mhartid,\n    input wire dbg_irq_r,\n    input wire [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input wire [E203_EVT_NUM-1:0] evt_r,\n    input wire ext_irq_r,\n    input wire sft_irq_r,\n    input wire tmr_irq_r,\n    input wire dbg_mode,\n    input wire dbg_halt_r,\n    input wire dbg_step_r,\n    input wire dbg_ebreakm_r,\n    input wire dbg_stopcycle,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire core_cgstop,\n    output wire tcm_cgstop,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    output wire [31:0] wr_csr_nxt,\n    output wire [E203_PC_SIZE-1:0] cmt_dpc,\n    output wire cmt_dpc_ena,\n    output wire [2:0] cmt_dcause,\n    output wire cmt_dcause_ena,\n    input wire [31:0] dcsr_r,\n    input wire [E203_PC_SIZE-1:0] dpc_r,\n    input wire [31:0] dscratch_r\n);\n\n    // Core internal signals\n    wire [E203_PC_SIZE-1:0] next_pc;\n    wire [31:0] instruction;\n    wire instruction_valid;\n    wire [E203_PC_SIZE-1:0] executed_pc;\n    wire [31:0] result;\n    wire result_valid;\n\n    // Instantiate IFU\n    e203_ifu u_ifu (\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .next_pc(next_pc),\n        .instruction(instruction),\n        .instruction_valid(instruction_valid),\n        .executed_pc(executed_pc)\n    );\n\n    // Instantiate EXU\n    e203_exu u_exu (\n        .clk(clk),\n        .rst_n(rst_n),\n        .instruction(instruction),\n        .instruction_valid(instruction_valid),\n        .executed_pc(executed_pc),\n        .result(result),\n        .result_valid(result_valid),\n        .next_pc(next_pc)\n    );\n\n    // Instantiate LSU\n    e203_lsu u_lsu (\n        .clk(clk),\n        .rst_n(rst_n),\n        .result(result),\n        .result_valid(result_valid)\n    );\n\n    // Instantiate BIU\n    e203_biu u_biu (\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\n    // Debug and control logic\n    assign inspect_pc = executed_pc;\n    assign core_wfi = 1'b0; // Placeholder for WFI status\n    assign tm_stop = dbg_stopcycle;\n    assign core_cgstop = 1'b0; // Placeholder for clock gating control\n    assign tcm_cgstop = 1'b0; // Placeholder for TCM clock gating control\n\n    // CSR and debug interface logic\n    assign wr_dcsr_ena = 1'b0; // Placeholder for CSR write enable\n    assign wr_dpc_ena = 1'b0; // Placeholder for DPC write enable\n    assign wr_dscratch_ena = 1'b0; // Placeholder for DSCRATCH write enable\n    assign wr_csr_nxt = 32'b0; // Placeholder for next CSR value\n    assign cmt_dpc = dpc_r;\n    assign cmt_dpc_ena = 1'b0; // Placeholder for commit DPC enable\n    assign cmt_dcause = 3'b0; // Placeholder for commit cause\n    assign cmt_dcause_ena = 1'b0; // Placeholder for commit cause enable\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 15, "code": "module e203_clk_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire core_cgstop,\n    input wire core_ifu_active,\n    input wire core_exu_active,\n    input wire core_lsu_active,\n    input wire core_biu_active,\n    input wire core_wfi,\n    output wire clk_aon,\n    output wire clk_core_ifu,\n    output wire clk_core_exu,\n    output wire clk_core_lsu,\n    output wire clk_core_biu,\n    `ifdef E203_HAS_ITCM\n    input wire itcm_active,\n    output wire itcm_ls,\n    output wire clk_itcm,\n    `endif\n    `ifdef E203_HAS_DTCM\n    input wire dtcm_active,\n    output wire dtcm_ls,\n    output wire clk_dtcm,\n    `endif\n    output wire clk_core\n);\n\n// Clock always on\nassign clk_aon = clk;\n\n// Clock gating logic for core modules\nassign clk_core_ifu = core_cgstop | (core_ifu_active & ~core_wfi);\nassign clk_core_exu = core_cgstop | core_exu_active;\nassign clk_core_lsu = core_cgstop | core_lsu_active;\nassign clk_core_biu = core_cgstop | core_biu_active;\n\n// Generate clocks for ITCM and DTCM if they are present\n`ifdef E203_HAS_ITCM\nreg itcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        itcm_active_r <= 1'b0;\n    else\n        itcm_active_r <= itcm_active;\nend\nassign clk_itcm = core_cgstop | itcm_active | itcm_active_r;\nassign itcm_ls = ~clk_itcm;\n`endif\n\n`ifdef E203_HAS_DTCM\nreg dtcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        dtcm_active_r <= 1'b0;\n    else\n        dtcm_active_r <= dtcm_active;\nend\nassign clk_dtcm = core_cgstop | dtcm_active | dtcm_active_r;\nassign dtcm_ls = ~clk_dtcm;\n`endif\n\n// Global core clock\nassign clk_core = clk_core_ifu | clk_core_exu | clk_core_lsu | clk_core_biu;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 16, "code": "module e203_dtcm_ram (\n    input wire sd,\n    input wire ds,\n    input wire ls,\n    input wire cs,\n    input wire we,\n    input wire [E203_DTCM_RAM_AW-1:0] addr,\n    input wire [E203_DTCM_RAM_MW-1:0] wem,\n    input wire [E203_DTCM_RAM_DW-1:0] din,\n    input wire rst_n,\n    input wire clk,\n    output wire [E203_DTCM_RAM_DW-1:0] dout\n);\n\n  sirv_gnrl_ram #(\n    .DP(E203_DTCM_RAM_DP),\n    .DW(E203_DTCM_RAM_DW),\n    .FORCE_X2ZERO(1),\n    .MW(E203_DTCM_RAM_MW),\n    .AW(E203_DTCM_RAM_AW)\n  ) u_203_dtcm_gnrl_ram (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 2, "code": "module e203_biu(\n    input wire clk,\n    input wire rst_n,\n    output wire biu_active,\n\n    // ICB Command Interface (input)\n    input wire lsu_icb_cmd_valid,\n    output wire lsu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] lsu_icb_cmd_addr,\n    input wire lsu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] lsu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] lsu_icb_cmd_wmask,\n    input wire [1:0] lsu_icb_cmd_burst,\n    input wire [1:0] lsu_icb_cmd_beat,\n    input wire lsu_icb_cmd_lock,\n    input wire lsu_icb_cmd_excl,\n    input wire [1:0] lsu_icb_cmd_size,\n\n    // ICB Response Interface (output)\n    output wire lsu_icb_rsp_valid,\n    input wire lsu_icb_rsp_ready,\n    output wire lsu_icb_rsp_err,\n    output wire lsu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] lsu_icb_rsp_rdata,\n\n    // Additional signals for IFU, PPI, CLINT, PLIC, FIO, MEM\n    `ifdef E203_HAS_MEM_ITF\n    input wire ifu_icb_cmd_valid,\n    output wire ifu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] ifu_icb_cmd_addr,\n    input wire ifu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ifu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] ifu_icb_cmd_wmask,\n    input wire [1:0] ifu_icb_cmd_burst,\n    input wire [1:0] ifu_icb_cmd_beat,\n    input wire ifu_icb_cmd_lock,\n    input wire ifu_icb_cmd_excl,\n    input wire [1:0] ifu_icb_cmd_size,\n\n    output wire ifu_icb_rsp_valid,\n    input wire ifu_icb_rsp_ready,\n    output wire ifu_icb_rsp_err,\n    output wire ifu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] ifu_icb_rsp_rdata,\n    `endif\n\n    input wire ppi_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] ppi_region_indic,\n\n    input wire clint_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] clint_region_indic,\n\n    input wire plic_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] plic_region_indic,\n\n    `ifdef E203_HAS_FIO\n    input wire fio_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] fio_region_indic,\n    `endif\n\n    `ifdef E203_HAS_MEM_ITF\n    input wire mem_icb_enable,\n    `endif\n\n    // Outputs to memory and peripherals\n    output wire mem_icb_cmd_valid,\n    input wire mem_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] mem_icb_cmd_addr,\n    output wire mem_icb_cmd_read,\n    output wire [E203_XLEN-1:0] mem_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] mem_icb_cmd_wmask,\n    output wire [1:0] mem_icb_cmd_burst,\n    output wire [1:0] mem_icb_cmd_beat,\n    output wire mem_icb_cmd_lock,\n    output wire mem_icb_cmd_excl,\n    output wire [1:0] mem_icb_cmd_size,\n\n    output wire mem_icb_rsp_valid,\n    input wire mem_icb_rsp_ready,\n    output wire mem_icb_rsp_err,\n    output wire mem_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] mem_icb_rsp_rdata\n);\n    // Internal signals and logic to implement the BIU functionality\n    // including arbitration, buffering, and splitting as described in the design document.\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 7, "code": "module e203_cpu_top(\n    input  wire clk,\n    input  wire rst_n,\n    input  wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input  wire ext_irq_a,\n    input  wire sft_irq_a,\n    input  wire tmr_irq_a,\n    input  wire tcm_sd,\n    input  wire tcm_ds,\n    input  wire [E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input  wire ext2itcm_icb_cmd_valid,\n    input  wire ext2itcm_icb_cmd_read,\n    input  wire [E203_XLEN-1:0] ext2itcm_icb_cmd_wdata,\n    input  wire [(E203_XLEN/8)-1:0] ext2itcm_icb_cmd_wmask,\n    input  wire ext2itcm_icb_rsp_ready,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire dbg_irq_r,\n    output wire ext2itcm_icb_cmd_ready,\n    output wire ext2itcm_icb_rsp_valid,\n    output wire ext2itcm_icb_rsp_err,\n    output wire [E203_XLEN-1:0] ext2itcm_icb_rsp_rdata\n);\n\n    // Core instantiation\n    e203_cpu u_e203_cpu(\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ext_irq_a(ext_irq_a),\n        .sft_irq_a(sft_irq_a),\n        .tmr_irq_a(tmr_irq_a),\n        .inspect_pc(inspect_pc),\n        .inspect_dbg_irq(inspect_dbg_irq),\n        .inspect_mem_cmd_valid(inspect_mem_cmd_valid),\n        .inspect_mem_cmd_ready(inspect_mem_cmd_ready),\n        .inspect_mem_rsp_valid(inspect_mem_rsp_valid),\n        .inspect_mem_rsp_ready(inspect_mem_rsp_ready),\n        .inspect_core_clk(inspect_core_clk),\n        .core_csr_clk(core_csr_clk),\n        .core_wfi(core_wfi),\n        .tm_stop(tm_stop),\n        .dbg_irq_r(dbg_irq_r)\n    );\n\n    // SRAMs instantiation\n    e203_srams u_e203_srams(\n        .clk(clk),\n        .rst_n(rst_n),\n        .tcm_sd(tcm_sd),\n        .tcm_ds(tcm_ds),\n        .ext2itcm_icb_cmd_addr(ext2itcm_icb_cmd_addr),\n        .ext2itcm_icb_cmd_valid(ext2itcm_icb_cmd_valid),\n        .ext2itcm_icb_cmd_read(ext2itcm_icb_cmd_read),\n        .ext2itcm_icb_cmd_wdata(ext2itcm_icb_cmd_wdata),\n        .ext2itcm_icb_cmd_wmask(ext2itcm_icb_cmd_wmask),\n        .ext2itcm_icb_rsp_ready(ext2itcm_icb_rsp_ready),\n        .ext2itcm_icb_cmd_ready(ext2itcm_icb_cmd_ready),\n        .ext2itcm_icb_rsp_valid(ext2itcm_icb_rsp_valid),\n        .ext2itcm_icb_rsp_err(ext2itcm_icb_rsp_err),\n        .ext2itcm_icb_rsp_rdata(ext2itcm_icb_rsp_rdata)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 11, "code": "module e203_cpu (\n    input wire clk,\n    input wire rst_n,\n\n    // Core Interfaces\n    output wire [E203_PC-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n    input wire [E203_PC-1:0] pc_rtvec,\n    input wire [E203_HARD_ID_W-1:0] core_mhartid,\n    input wire dbg_irq_a,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n\n    // ITCM Interfaces\n    `ifdef E203_HAS_ITCM\n    output wire itcm_ls,\n    output wire itcm_ram_cs,\n    output wire itcm_ram_we,\n    output wire [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n    output wire [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n    output wire [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n    input wire [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n    output wire clk_itcm_ram,\n    `endif\n\n    // DTCM Interfaces\n    `ifdef E203_HAS_DTCM\n    output wire rst_dtcm,\n    output wire dtcm_ls,\n    output wire dtcm_ram_cs,\n    output wire dtcm_ram_we,\n    output wire [E203_ITCM_RAM_AW-1:0] dtcm_ram_addr,\n    output wire [E203_ITCM_RAM_MW-1:0] dtcm_ram_wem,\n    output wire [E203_ITCM_RAM_DW-1:0] dtcm_ram_din,\n    input wire [E203_ITCM_RAM_DW-1:0] dtcm_ram_dout,\n    `endif\n\n    // Debug Related Interface\n    output wire [E203_PC-1:0] cmt_dpc,\n    output wire cmt_dpc_ena,\n    output wire [2:0] cmt_dcause,\n    output wire cmt_dcause_ena,\n    output wire dbg_irq_r,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    output wire [31:0] wr_csr_nxt,\n    input wire [31:0] dcsr_r,\n    input wire [E203_PC-1:0] dpc_r,\n    input wire [31:0] dscratch_r,\n    input wire dbg_mode,\n    input wire dbg_halt_r,\n    input wire dbg_step_r,\n    input wire dbg_ebreakm_r,\n    input wire dbg_stopcycle\n);\n    // Core logic implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 8, "code": "module e203_cpu_top(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire tcm_sd,\n    input wire tcm_ds,\n    input wire [E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input wire ext2itcm_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ext2itcm_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] ext2itcm_icb_cmd_wmask,\n    input wire ext2itcm_icb_cmd_valid,\n    input wire ext2itcm_icb_rsp_ready,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire dbg_irq_r,\n    output wire ext2itcm_icb_cmd_ready,\n    output wire ext2itcm_icb_rsp_valid,\n    output wire ext2itcm_icb_rsp_err,\n    output wire [E203_XLEN-1:0] ext2itcm_icb_rsp_rdata\n);\n\n    // Instantiate the E203 CPU core\n    e203_cpu u_e203_cpu(\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ext_irq_a(ext_irq_a),\n        .sft_irq_a(sft_irq_a),\n        .tmr_irq_a(tmr_irq_a),\n        .tcm_sd(tcm_sd),\n        .tcm_ds(tcm_ds),\n        .ext2itcm_icb_cmd_addr(ext2itcm_icb_cmd_addr),\n        .ext2itcm_icb_cmd_read(ext2itcm_icb_cmd_read),\n        .ext2itcm_icb_cmd_wdata(ext2itcm_icb_cmd_wdata),\n        .ext2itcm_icb_cmd_wmask(ext2itcm_icb_cmd_wmask),\n        .ext2itcm_icb_cmd_valid(ext2itcm_icb_cmd_valid),\n        .ext2itcm_icb_rsp_ready(ext2itcm_icb_rsp_ready),\n        .inspect_pc(inspect_pc),\n        .inspect_dbg_irq(inspect_dbg_irq),\n        .inspect_mem_cmd_valid(inspect_mem_cmd_valid),\n        .inspect_mem_cmd_ready(inspect_mem_cmd_ready),\n        .inspect_mem_rsp_valid(inspect_mem_rsp_valid),\n        .inspect_mem_rsp_ready(inspect_mem_rsp_ready),\n        .inspect_core_clk(inspect_core_clk),\n        .core_csr_clk(core_csr_clk),\n        .core_wfi(core_wfi),\n        .tm_stop(tm_stop),\n        .dbg_irq_r(dbg_irq_r),\n        .ext2itcm_icb_cmd_ready(ext2itcm_icb_cmd_ready),\n        .ext2itcm_icb_rsp_valid(ext2itcm_icb_rsp_valid),\n        .ext2itcm_icb_rsp_err(ext2itcm_icb_rsp_err),\n        .ext2itcm_icb_rsp_rdata(ext2itcm_icb_rsp_rdata)\n    );\n\n    // Additional logic for handling resets, clocks, and other signals can be added here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 2, "code": "module e203_exu_csr (\n    input wire nonflush_cmt_ena,\n    input wire csr_ena,\n    input wire csr_wr_en,\n    input wire csr_rd_en,\n    input wire [11:0] csr_idx,\n    output wire csr_access_ilgl,\n    output wire tm_stop,\n    output wire core_cgstop,\n    output wire tcm_cgstop,\n    output wire itcm_nohold,\n    output wire mdv_nob2b,\n    output wire [E203_XLEN-1:0] read_csr_dat,\n    input wire [E203_XLEN-1:0] wbck_csr_dat,\n    input wire [E203_HART_ID_W-1:0] core_mhartid,\n    input wire ext_irq_r,\n    input wire sft_irq_r,\n    input wire tmr_irq_r,\n    output wire status_mie_r,\n    output wire mtie_r,\n    output wire msie_r,\n    output wire meie_r,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    input wire [E203_XLEN-1:0] dcsr_r,\n    input wire [E203_PC_SIZE-1:0] dpc_r,\n    input wire [E203_XLEN-1:0] dscratch_r,\n    output wire u_mode,\n    output wire s_mode,\n    output wire h_mode,\n    output wire m_mode,\n    input wire [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    input wire cmt_badaddr_ena,\n    input wire [E203_PC_SIZE-1:0] cmt_epc,\n    input wire cmt_epc_ena,\n    input wire [E203_XLEN-1:0] cmt_cause,\n    input wire cmt_cause_ena,\n    input wire cmt_status_ena,\n    input wire cmt_instret_ena,\n    input wire cmt_mret_ena,\n    output wire [E203_PC_SIZE-1:0] csr_epc_r,\n    output wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    output wire [E203_XLEN-1:0] csr_mtvec_r,\n    input wire clk_aon,\n    input wire clk,\n    input wire rst_n\n);\n\n// CSR logic implementation here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 9, "code": "module e203_cpu_top(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire tcm_sd,\n    input wire tcm_ds,\n    input wire [E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input wire ext2itcm_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ext2itcm_icb_cmd_wdata,\n    input wire [E203_XLEN/8-1:0] ext2itcm_icb_cmd_wmask,\n    input wire ext2itcm_icb_cmd_valid,\n    input wire ext2itcm_icb_rsp_ready,\n    output wire [E203_XLEN-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire dbg_irq_r,\n    output wire ext2itcm_icb_cmd_ready,\n    output wire [E203_XLEN-1:0] ext2itcm_icb_rsp_rdata,\n    output wire ext2itcm_icb_rsp_valid,\n    output wire ext2itcm_icb_rsp_err\n);\n\n    // Internal signals\n    wire core_clk = clk;\n    wire core_rst_n = rst_n;\n\n    // Instantiate the E203 CPU core\n    e203_cpu u_e203_cpu(\n        .clk(core_clk),\n        .rst_n(core_rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ext_irq_a(ext_irq_a),\n        .sft_irq_a(sft_irq_a),\n        .tmr_irq_a(tmr_irq_a),\n        .inspect_pc(inspect_pc),\n        .inspect_dbg_irq(inspect_dbg_irq),\n        .inspect_mem_cmd_valid(inspect_mem_cmd_valid),\n        .inspect_mem_cmd_ready(inspect_mem_cmd_ready),\n        .inspect_mem_rsp_valid(inspect_mem_rsp_valid),\n        .inspect_mem_rsp_ready(inspect_mem_rsp_ready),\n        .inspect_core_clk(inspect_core_clk),\n        .core_csr_clk(core_csr_clk),\n        .core_wfi(core_wfi),\n        .tm_stop(tm_stop),\n        .dbg_irq_r(dbg_irq_r)\n    );\n\n    // Instantiate the SRAM controller\n    e203_srams u_e203_srams(\n        .clk_itcm_ram(core_clk),\n        .rst_itcm(rst_n),\n        .tcm_sd(tcm_sd),\n        .tcm_ds(tcm_ds),\n        .ext2itcm_icb_cmd_addr(ext2itcm_icb_cmd_addr),\n        .ext2itcm_icb_cmd_read(ext2itcm_icb_cmd_read),\n        .ext2itcm_icb_cmd_wdata(ext2itcm_icb_cmd_wdata),\n        .ext2itcm_icb_cmd_wmask(ext2itcm_icb_cmd_wmask),\n        .ext2itcm_icb_cmd_valid(ext2itcm_icb_cmd_valid),\n        .ext2itcm_icb_rsp_ready(ext2itcm_icb_rsp_ready),\n        .ext2itcm_icb_cmd_ready(ext2itcm_icb_cmd_ready),\n        .ext2itcm_icb_rsp_rdata(ext2itcm_icb_rsp_rdata),\n        .ext2itcm_icb_rsp_valid(ext2itcm_icb_rsp_valid),\n        .ext2itcm_icb_rsp_err(ext2itcm_icb_rsp_err)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 12, "code": "// E203 Processor Configuration File\n// This file contains macro definitions for configuring the E203 processor.\n\n// Debug and Interrupt Configuration\n`define E203_CFG_DEBUG_HAS_JTAG 1  // Enable JTAG debug interface\n`define E203_CFG_IRQ_NEED_SYNC 1   // Enable interrupt synchronization mechanism\n\n// Address Space Configuration\n// Only one of these should be enabled at a time.\n// `define E203_CFG_ADDR_SIZE_IS_16 1 // 16-bit address space\n// `define E203_CFG_ADDR_SIZE_IS_24 1 // 24-bit address space\n`define E203_CFG_ADDR_SIZE_IS_32 1 // 32-bit address space (currently selected)\n\n// CPU Function Configuration\n`define E203_CFG_SUPPORT_MCYCLE_MINSTRET 1 // Enable MCYCLE and MINSTRET counters\n`define E203_CFG_REGNUM_IS_32 1            // Use 32 registers\n`define E203_CFG_HAS_ECC 1                 // Enable ECC (Error Correction Code)\n`define E203_CFG_HAS_NICE 1                // Enable NICE instruction extension\n`define E203_CFG_SUPPORT_SHARE_MULDIV 1    // Enable shared MULDIV unit\n`define E203_CFG_SUPPORT_AMO 1             // Enable atomic memory operations\n\n// Memory System Configuration\n// Instruction Tightly Coupled Memory (ITCM)\n`define E203_CFG_HAS_ITCM 1                // Enable ITCM\n`define E203_CFG_ITCM_ADDR_WIDTH 16        // Set ITCM address width to 16 bits\n\n// Data Tightly Coupled Memory (DTCM)\n`define E203_CFG_HAS_DTCM 1                // Enable DTCM\n`define E203_CFG_DTCM_ADDR_WIDTH 16        // Set DTCM address width to 16 bits\n\n// Memory Mapping Configuration\n// Define base addresses for memory regions\n`define E203_CFG_ITCM_ADDR_BASE 32'h8000_0000 // Base address for ITCM\n`define E203_CFG_DTCM_ADDR_BASE 32'h9000_0000 // Base address for DTCM\n\n// Peripheral Interface Regions\n`define E203_CFG_PPI_ADDR_BASE 32'h1000_0000  // Base address for PPI\n`define E203_CFG_PPI_BASE_REGION 16           // Region size for PPI\n\n// System Controller Regions\n`define E203_CFG_CLINT_ADDR_BASE 32'h0200_0000 // Base address for CLINT\n`define E203_CFG_CLINT_BASE_REGION 16          // Region size for CLINT\n`define E203_CFG_PLIC_ADDR_BASE 32'h0C00_0000  // Base address for PLIC\n`define E203_CFG_PLIC_BASE_REGION 8            // Region size for PLIC\n\n// Fast IO Region\n`define E203_CFG_FIO_ADDR_BASE 32'hF000_0000   // Base address for Fast IO\n`define E203_CFG_FIO_BASE_REGION 16            // Region size for Fast IO\n\n// Notes:\n// - Only one address width configuration should be enabled at a time.\n// - TCM configurations should be selected based on available hardware resources.\n// - Memory mapping configurations must avoid address overlap.\n// - Evaluate system resource requirements and performance demands when modifying configurations.", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 7, "code": "module e203_core(\n    input wire clk,\n    input wire rst_n,\n    // System Interface\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire core_cgstop,\n    output wire tcm_cgstop,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire [E203_HART_ID_W-1:0] core_mhartid,\n    input wire dbg_irq_r,\n    input wire [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input wire [E203_EVT_NUM-1:0] evt_r,\n    input wire ext_irq_r,\n    input wire sft_irq_r,\n    input wire tmr_irq_r,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    output wire [31:0] wr_csr_nxt,\n    input wire [31:0] dcsr_r,\n    input wire [E203_PC_SIZE-1:0] dpc_r,\n    input wire [31:0] dscratch_r,\n    output wire [E203_PC_SIZE-1:0] cmt_dpc,\n    output wire cmt_dpc_ena,\n    output wire [2:0] cmt_dcause,\n    output wire cmt_dcause_ena,\n    input wire dbg_mode,\n    input wire dbg_halt_r,\n    input wire dbg_step_r,\n    input wire dbg_ebreakm_r,\n    input wire dbg_stopcycle,\n    // ICB Protocol Interface\n    input wire icb_enable,\n    output wire icb_cmd_valid,\n    input wire icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] icb_cmd_addr,\n    output wire icb_cmd_read,\n    output wire [E203_XLEN-1:0] icb_cmd_wdata,\n    output wire [E203_XLEN/8-1:0] icb_cmd_wmask,\n    output wire icb_cmd_lock,\n    output wire icb_cmd_excl,\n    output wire [1:0] icb_cmd_size,\n    input wire icb_rsp_valid,\n    output wire icb_rsp_ready,\n    input wire icb_rsp_err,\n    input wire icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] icb_rsp_rdata,\n    // NICE Interface\n    input wire nice_mem_holdup,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_inst,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    input wire [E203_XLEN-1:0] nice_rsp_multicyc_dat,\n    input wire nice_rsp_multicyc_err,\n    input wire nice_icb_cmd_valid,\n    output wire nice_icb_cmd_ready,\n    input wire [E203_XLEN-1:0] nice_icb_cmd_addr,\n    input wire nice_icb_cmd_read,\n    input wire [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input wire [1:0] nice_icb_cmd_size,\n    output wire nice_icb_rsp_valid,\n    input wire nice_icb_rsp_ready,\n    output wire [E203_XLEN-1:0] nice_icb_rsp_rdata,\n    output wire nice_icb_rsp_err\n);\n    // Core implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 16, "code": "module e203_clk_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire core_cgstop,\n    input wire core_ifu_active,\n    input wire core_exu_active,\n    input wire core_lsu_active,\n    input wire core_biu_active,\n    input wire core_wfi,\n    output wire clk_aon,\n    output wire clk_core_ifu,\n    output wire clk_core_exu,\n    output wire clk_core_lsu,\n    output wire clk_core_biu,\n    `ifdef E203_HAS_ITCM\n    input wire itcm_active,\n    output wire itcm_ls,\n    output wire clk_itcm,\n    `endif\n    `ifdef E203_HAS_DTCM\n    input wire dtcm_active,\n    output wire dtcm_ls,\n    output wire clk_dtcm,\n    `endif\n    output wire clk_core\n);\n\n// Clock always on\nassign clk_aon = clk;\n\n// Generate clock for IFU\nassign clk_core_ifu = (core_cgstop | (core_ifu_active & ~core_wfi)) & ~test_mode;\n\n// Generate clock for other core modules\nassign clk_core_exu = (core_cgstop | core_exu_active) & ~test_mode;\nassign clk_core_lsu = (core_cgstop | core_lsu_active) & ~test_mode;\nassign clk_core_biu = (core_cgstop | core_biu_active) & ~test_mode;\n\n// Optional ITCM and DTCM clock control\n`ifdef E203_HAS_ITCM\nreg itcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        itcm_active_r <= 1'b0;\n    else\n        itcm_active_r <= itcm_active;\nend\nassign clk_itcm = core_cgstop | itcm_active | itcm_active_r;\nassign itcm_ls = ~(itcm_active | itcm_active_r);\n`endif\n\n`ifdef E203_HAS_DTCM\nreg dtcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        dtcm_active_r <= 1'b0;\n    else\n        dtcm_active_r <= dtcm_active;\nend\nassign clk_dtcm = core_cgstop | dtcm_active | dtcm_active_r;\nassign dtcm_ls = ~(dtcm_active | dtcm_active_r);\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 3, "code": "module e203_biu(\n    input wire clk,\n    input wire rst_n,\n    output wire biu_active,\n    // ICB Interface - LSU\n    input wire lsu_icb_cmd_valid,\n    output wire lsu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] lsu_icb_cmd_addr,\n    input wire lsu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] lsu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] lsu_icb_cmd_wmask,\n    input wire [1:0] lsu_icb_cmd_burst,\n    input wire [1:0] lsu_icb_cmd_beat,\n    input wire lsu_icb_cmd_lock,\n    input wire lsu_icb_cmd_excl,\n    input wire [1:0] lsu_icb_cmd_size,\n    output wire lsu_icb_rsp_valid,\n    input wire lsu_icb_rsp_ready,\n    output wire lsu_icb_rsp_err,\n    output wire lsu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] lsu_icb_rsp_rdata,\n    // ICB Interface - IFU\n    input wire ifu_icb_cmd_valid,\n    output wire ifu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] ifu_icb_cmd_addr,\n    input wire ifu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ifu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] ifu_icb_cmd_wmask,\n    input wire [1:0] ifu_icb_cmd_burst,\n    input wire [1:0] ifu_icb_cmd_beat,\n    input wire ifu_icb_cmd_lock,\n    input wire ifu_icb_cmd_excl,\n    input wire [1:0] ifu_icb_cmd_size,\n    output wire ifu_icb_rsp_valid,\n    input wire ifu_icb_rsp_ready,\n    output wire ifu_icb_rsp_err,\n    output wire ifu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] ifu_icb_rsp_rdata,\n    // PPI Interface\n    input wire [E203_ADDR_SIZE-1:0] ppi_region_indic,\n    input wire ppi_icb_enable,\n    // CLINT Interface\n    input wire [E203_ADDR_SIZE-1:0] clint_region_indic,\n    input wire clint_icb_enable,\n    // PLIC Interface\n    input wire [E203_ADDR_SIZE-1:0] plic_region_indic,\n    input wire plic_icb_enable,\n    // FIO Interface\n    input wire [E203_ADDR_SIZE-1:0] fio_region_indic,\n    input wire fio_icb_enable,\n    // MEM Interface\n    input wire mem_icb_enable\n);\n\n    // Internal signals\n    wire [E203_ADDR_SIZE-1:0] icb_cmd_addr_mux;\n    wire icb_cmd_read_mux;\n    wire [E203_XLEN-1:0] icb_cmd_wdata_mux;\n    wire [(E203_XLEN/8)-1:0] icb_cmd_wmask_mux;\n    wire [1:0] icb_cmd_burst_mux;\n    wire [1:0] icb_cmd_beat_mux;\n    wire icb_cmd_lock_mux;\n    wire icb_cmd_excl_mux;\n    wire [1:0] icb_cmd_size_mux;\n    wire icb_cmd_valid_mux;\n    wire icb_cmd_ready_mux;\n    wire icb_rsp_valid_mux;\n    wire icb_rsp_ready_mux;\n    wire icb_rsp_err_mux;\n    wire icb_rsp_excl_ok_mux;\n    wire [E203_XLEN-1:0] icb_rsp_rdata_mux;\n\n    // Arbitration logic\n    assign icb_cmd_addr_mux = lsu_icb_cmd_valid ? lsu_icb_cmd_addr : ifu_icb_cmd_addr;\n    assign icb_cmd_read_mux = lsu_icb_cmd_valid ? lsu_icb_cmd_read : ifu_icb_cmd_read;\n    assign icb_cmd_wdata_mux = lsu_icb_cmd_valid ? lsu_icb_cmd_wdata : ifu_icb_cmd_wdata;\n    assign icb_cmd_wmask_mux = lsu_icb_cmd_valid ? lsu_icb_cmd_wmask : ifu_icb_cmd_wmask;\n    assign icb_cmd_burst_mux = lsu_icb_cmd_valid ? lsu_icb_cmd_burst : ifu_icb_cmd_burst;\n    assign icb_cmd_beat_mux = lsu_icb_cmd_valid ? lsu_icb_cmd_beat : ifu_icb_cmd_beat;\n    assign icb_cmd_lock_mux = lsu_icb_cmd_valid ? lsu_icb_cmd_lock : ifu_icb_cmd_lock;\n    assign icb_cmd_excl_mux = lsu_icb_cmd_valid ? lsu_icb_cmd_excl : ifu_icb_cmd_excl;\n    assign icb_cmd_size_mux = lsu_icb_cmd_valid ? lsu_icb_cmd_size : ifu_icb_cmd_size;\n    assign icb_cmd_valid_mux = lsu_icb_cmd_valid || ifu_icb_cmd_valid;\n    assign lsu_icb_cmd_ready = icb_cmd_ready_mux;\n    assign ifu_icb_cmd_ready = icb_cmd_ready_mux;\n\n    // Response multiplexing\n    assign lsu_icb_rsp_valid = icb_rsp_valid_mux;\n    assign ifu_icb_rsp_valid = icb_rsp_valid_mux;\n    assign lsu_icb_rsp_err = icb_rsp_err_mux;\n    assign ifu_icb_rsp_err = icb_rsp_err_mux;\n    assign lsu_icb_rsp_excl_ok = icb_rsp_excl_ok_mux;\n    assign ifu_icb_rsp_excl_ok = icb_rsp_excl_ok_mux;\n    assign lsu_icb_rsp_rdata = icb_rsp_rdata_mux;\n    assign ifu_icb_rsp_rdata = icb_rsp_rdata_mux;\n\n    // Add more logic here for handling different interfaces and their specific signals\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 10, "code": "module e203_cpu_top(\n    input wire clk,\n    input wire rst_n,\n\n    // Interface: PC Inspection\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n\n    // Interface: CSR and Clock\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n\n    // Interface: Reset and Interrupt Vectors\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    output wire dbg_irq_r,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n\n    // Interface: TCM Control\n    input wire tcm_sd,\n    input wire tcm_ds,\n\n    // Interface: External to ITCM\n    input wire ext2itcm_icb_cmd_valid,\n    output wire ext2itcm_icb_cmd_ready,\n    input wire [E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input wire ext2itcm_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ext2itcm_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] ext2itcm_icb_cmd_wmask,\n    output wire ext2itcm_icb_rsp_valid,\n    input wire ext2itcm_icb_rsp_ready,\n    output wire ext2itcm_icb_rsp_err,\n    output wire [E203_XLEN-1:0] ext2itcm_icb_rsp_rdata\n);\n\n    // Core module instantiation\n    e203_cpu #(\n        .E203_PC_SIZE(E203_PC_SIZE),\n        .E203_ITCM_ADDR_WIDTH(E203_ITCM_ADDR_WIDTH),\n        .E203_XLEN(E203_XLEN)\n    ) core_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .inspect_pc(inspect_pc),\n        .inspect_dbg_irq(inspect_dbg_irq),\n        .inspect_mem_cmd_valid(inspect_mem_cmd_valid),\n        .inspect_mem_cmd_ready(inspect_mem_cmd_ready),\n        .inspect_mem_rsp_valid(inspect_mem_rsp_valid),\n        .inspect_mem_rsp_ready(inspect_mem_rsp_ready),\n        .inspect_core_clk(inspect_core_clk),\n        .core_csr_clk(core_csr_clk),\n        .core_wfi(core_wfi),\n        .tm_stop(tm_stop),\n        .dbg_irq_r(dbg_irq_r),\n        .ext_irq_a(ext_irq_a),\n        .sft_irq_a(sft_irq_a),\n        .tmr_irq_a(tmr_irq_a),\n        .tcm_sd(tcm_sd),\n        .tcm_ds(tcm_ds),\n        .ext2itcm_icb_cmd_valid(ext2itcm_icb_cmd_valid),\n        .ext2itcm_icb_cmd_ready(ext2itcm_icb_cmd_ready),\n        .ext2itcm_icb_cmd_addr(ext2itcm_icb_cmd_addr),\n        .ext2itcm_icb_cmd_read(ext2itcm_icb_cmd_read),\n        .ext2itcm_icb_cmd_wdata(ext2itcm_icb_cmd_wdata),\n        .ext2itcm_icb_cmd_wmask(ext2itcm_icb_cmd_wmask),\n        .ext2itcm_icb_rsp_valid(ext2itcm_icb_rsp_valid),\n        .ext2itcm_icb_rsp_ready(ext2itcm_icb_rsp_ready),\n        .ext2itcm_icb_rsp_err(ext2itcm_icb_rsp_err),\n        .ext2itcm_icb_rsp_rdata(ext2itcm_icb_rsp_rdata)\n    );\n\n    // Additional logic, connections, and modules can be added here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 1, "code": "module e203_exu_nice(\n    input wire nice_i_xs_off,\n    input wire nice_i_valid,\n    output wire nice_i_ready,\n    input wire [E203_XLEN-1:0] nice_i_instr,\n    input wire [E203_XLEN-1:0] nice_i_rs1,\n    input wire [E203_XLEN-1:0] nice_i_rs2,\n    input wire [E203_ITAG_WIDTH-1:0] nice_i_itag,\n    output wire nice_o_longpipe,\n    output wire nice_o_valid,\n    input wire nice_o_ready,\n    output wire nice_o_itag_valid,\n    input wire nice_o_itag_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire clk,\n    input wire rst_n\n);\n\n// Internal signals\nwire fifo_push, fifo_pop;\nwire [E203_ITAG_WIDTH-1:0] fifo_data_in, fifo_data_out;\nwire fifo_full, fifo_empty;\n\n// FIFO for instruction tags\nsirv_gnrl_fifo #(\n    .CUT_READY(1),\n    .DP(4),\n    .DW(E203_ITAG_WIDTH)\n) itag_fifo (\n    .i_vld(fifo_push),\n    .i_rdy(!fifo_full),\n    .i_dat(fifo_data_in),\n    .o_vld(fifo_pop),\n    .o_rdy(!fifo_empty),\n    .o_dat(fifo_data_out),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// Control logic for pushing to and popping from FIFO\nassign fifo_push = nice_i_valid && nice_i_ready && !nice_i_xs_off;\nassign fifo_pop = nice_rsp_multicyc_valid && nice_rsp_multicyc_ready;\nassign fifo_data_in = nice_i_itag;\n\n// Handshaking and control signals\nassign nice_i_ready = !fifo_full && nice_o_ready && !nice_i_xs_off;\nassign nice_o_valid = nice_i_valid && nice_i_ready;\nassign nice_o_longpipe = !nice_i_xs_off;\n\n// Request to accelerator\nassign nice_req_valid = nice_i_valid && nice_i_ready && !nice_i_xs_off;\nassign nice_req_instr = nice_i_instr;\nassign nice_req_rs1 = nice_i_rs1;\nassign nice_req_rs2 = nice_i_rs2;\n\n// Response from accelerator\nassign nice_rsp_multicyc_ready = !fifo_empty;\nassign nice_o_itag_valid = fifo_pop && nice_o_itag_ready;\nassign nice_o_itag = fifo_data_out;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 1, "code": "module e203_srams #(\n  parameter E203_ITCM_RAM_AW = 12, // Address width for ITCM\n  parameter E203_ITCM_RAM_MW = 4,  // Mask width for ITCM\n  parameter E203_ITCM_RAM_DW = 32, // Data width for ITCM\n  parameter E203_DTCM_RAM_AW = 12, // Address width for DTCM\n  parameter E203_DTCM_RAM_MW = 4,  // Mask width for DTCM\n  parameter E203_DTCM_RAM_DW = 32  // Data width for DTCM\n)(\n  input  wire                     clk,\n  input  wire                     rst_n,\n\n  // ITCM Interface\n  input  wire                     itcm_ram_cs,\n  input  wire                     itcm_ram_we,\n  input  wire [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n  input  wire [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n  input  wire [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n  output wire [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n\n  // DTCM Interface\n  input  wire                     dtcm_ram_cs,\n  input  wire                     dtcm_ram_we,\n  input  wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n  input  wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n  input  wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n  output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout\n);\n\n`ifdef E203_HAS_ITCM\n  // ITCM Memory Array\n  reg [E203_ITCM_RAM_DW-1:0] itcm_mem [(1<<E203_ITCM_RAM_AW)-1:0];\n\n  always @(posedge clk) begin\n    if (itcm_ram_cs && itcm_ram_we) begin\n      for (int i = 0; i < E203_ITCM_RAM_MW; i++) begin\n        if (itcm_ram_wem[i]) begin\n          itcm_mem[itcm_ram_addr][8*i+:8] <= itcm_ram_din[8*i+:8];\n        end\n      end\n    end\n  end\n\n  assign itcm_ram_dout = itcm_mem[itcm_ram_addr];\n`endif\n\n`ifdef E203_HAS_DTCM\n  // DTCM Memory Array\n  reg [E203_DTCM_RAM_DW-1:0] dtcm_mem [(1<<E203_DTCM_RAM_AW)-1:0];\n\n  always @(posedge clk) begin\n    if (dtcm_ram_cs && dtcm_ram_we) begin\n      for (int i = 0; i < E203_DTCM_RAM_MW; i++) begin\n        if (dtcm_ram_wem[i]) begin\n          dtcm_mem[dtcm_ram_addr][8*i+:8] <= dtcm_ram_din[8*i+:8];\n        end\n      end\n    end\n  end\n\n  assign dtcm_ram_dout = dtcm_mem[dtcm_ram_addr];\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 17, "code": "module e203_clk_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire core_cgstop,\n    input wire core_ifu_active,\n    input wire core_exu_active,\n    input wire core_lsu_active,\n    input wire core_biu_active,\n    input wire core_wfi,\n    output wire clk_aon,\n    output wire clk_core_ifu,\n    output wire clk_core_exu,\n    output wire clk_core_lsu,\n    output wire clk_core_biu,\n    `ifdef E203_HAS_ITCM\n    input wire itcm_active,\n    output wire itcm_ls,\n    output wire clk_itcm,\n    `endif\n    `ifdef E203_HAS_DTCM\n    input wire dtcm_active,\n    output wire dtcm_ls,\n    output wire clk_dtcm,\n    `endif\n    output wire clk_core\n);\n\n// Clock always on\nassign clk_aon = clk;\n\n// Clock gating logic for IFU\nwire ifu_cg_en = core_cgstop | (core_ifu_active & ~core_wfi);\nassign clk_core_ifu = clk & ifu_cg_en;\n\n// Clock gating logic for EXU\nwire exu_cg_en = core_cgstop | core_exu_active;\nassign clk_core_exu = clk & exu_cg_en;\n\n// Clock gating logic for LSU\nwire lsu_cg_en = core_cgstop | core_lsu_active;\nassign clk_core_lsu = clk & lsu_cg_en;\n\n// Clock gating logic for BIU\nwire biu_cg_en = core_cgstop | core_biu_active;\nassign clk_core_biu = clk & biu_cg_en;\n\n// Combined core clock\nassign clk_core = clk_core_ifu | clk_core_exu | clk_core_lsu | clk_core_biu;\n\n`ifdef E203_HAS_ITCM\n// ITCM clock gating logic\nreg itcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        itcm_active_r <= 1'b0;\n    else\n        itcm_active_r <= itcm_active;\nend\n\nwire itcm_cg_en = core_cgstop | itcm_active | itcm_active_r;\nassign clk_itcm = clk & itcm_cg_en;\nassign itcm_ls = ~itcm_cg_en;\n`endif\n\n`ifdef E203_HAS_DTCM\n// DTCM clock gating logic\nreg dtcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        dtcm_active_r <= 1'b0;\n    else\n        dtcm_active_r <= dtcm_active;\nend\n\nwire dtcm_cg_en = core_cgstop | dtcm_active | dtcm_active_r;\nassign clk_dtcm = clk & dtcm_cg_en;\nassign dtcm_ls = ~dtcm_cg_en;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 18, "code": "module e203_clk_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire core_cgstop,\n    input wire core_ifu_active,\n    input wire core_exu_active,\n    input wire core_lsu_active,\n    input wire core_biu_active,\n    input wire core_wfi,\n    output wire clk_aon,\n    output wire clk_core_ifu,\n    output wire clk_core_exu,\n    output wire clk_core_lsu,\n    output wire clk_core_biu,\n    `ifdef E203_HAS_ITCM\n    input wire itcm_active,\n    output wire itcm_ls,\n    output wire clk_itcm,\n    `endif\n    `ifdef E203_HAS_DTCM\n    input wire dtcm_active,\n    output wire dtcm_ls,\n    output wire clk_dtcm,\n    `endif\n    );\n\n    // Always on clock\n    assign clk_aon = clk;\n\n    // Clock gating logic for IFU\n    wire ifu_cg_en = core_cgstop | (core_ifu_active & ~core_wfi);\n    // Clock gating logic for other cores\n    wire exu_cg_en = core_cgstop | core_exu_active;\n    wire lsu_cg_en = core_cgstop | core_lsu_active;\n    wire biu_cg_en = core_cgstop | core_biu_active;\n\n    // Clock gating instantiation for IFU\n    e203_clkgate u_ifu_clkgate (\n        .clk_in(clk),\n        .enable(ifu_cg_en),\n        .test_mode(test_mode),\n        .clk_out(clk_core_ifu)\n    );\n\n    // Clock gating instantiation for EXU\n    e203_clkgate u_exu_clkgate (\n        .clk_in(clk),\n        .enable(exu_cg_en),\n        .test_mode(test_mode),\n        .clk_out(clk_core_exu)\n    );\n\n    // Clock gating instantiation for LSU\n    e203_clkgate u_lsu_clkgate (\n        .clk_in(clk),\n        .enable(lsu_cg_en),\n        .test_mode(test_mode),\n        .clk_out(clk_core_lsu)\n    );\n\n    // Clock gating instantiation for BIU\n    e203_clkgate u_biu_clkgate (\n        .clk_in(clk),\n        .enable(biu_cg_en),\n        .test_mode(test_mode),\n        .clk_out(clk_core_biu)\n    );\n\n    `ifdef E203_HAS_ITCM\n    // ITCM clock control logic\n    reg itcm_active_r;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            itcm_active_r <= 1'b0;\n        else\n            itcm_active_r <= itcm_active;\n    end\n\n    wire itcm_cg_en = core_cgstop | itcm_active | itcm_active_r;\n    e203_clkgate u_itcm_clkgate (\n        .clk_in(clk),\n        .enable(itcm_cg_en),\n        .test_mode(test_mode),\n        .clk_out(clk_itcm)\n    );\n\n    assign itcm_ls = ~itcm_cg_en;\n    `endif\n\n    `ifdef E203_HAS_DTCM\n    // DTCM clock control logic\n    reg dtcm_active_r;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            dtcm_active_r <= 1'b0;\n        else\n            dtcm_active_r <= dtcm_active;\n    end\n\n    wire dtcm_cg_en = core_cgstop | dtcm_active | dtcm_active_r;\n    e203_clkgate u_dtcm_clkgate (\n        .clk_in(clk),\n        .enable(dtcm_cg_en),\n        .test_mode(test_mode),\n        .clk_out(clk_dtcm)\n    );\n\n    assign dtcm_ls = ~dtcm_cg_en;\n    `endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 8, "code": "module e203_core(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_ADDR_SIZE-1:0] pc_rtvec,\n    input wire [E203_HART_ID_W-1:0] core_mhartid,\n    input wire dbg_irq_r,\n    input wire [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input wire [E203_EVT_NUM-1:0] evt_r,\n    input wire ext_irq_r,\n    input wire sft_irq_r,\n    input wire tmr_irq_r,\n    input wire dbg_mode,\n    input wire dbg_halt_r,\n    input wire dbg_step_r,\n    input wire dbg_ebreakm_r,\n    input wire dbg_stopcycle,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire core_cgstop,\n    output wire tcm_cgstop,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    output wire [31:0] wr_csr_nxt,\n    output wire [E203_PC_SIZE-1:0] cmt_dpc,\n    output wire cmt_dpc_ena,\n    output wire [2:0] cmt_dcause,\n    output wire cmt_dcause_ena,\n    input wire [31:0] dcsr_r,\n    input wire [E203_PC_SIZE-1:0] dpc_r,\n    input wire [31:0] dscratch_r\n);\n\n    // Internal signals\n    wire ifu_active;\n    wire [E203_PC_SIZE-1:0] ifu_pc;\n    wire ifu_valid;\n    wire [31:0] ifu_instr;\n    wire exu_active;\n    wire [31:0] exu_result;\n    wire lsu_active;\n    wire [E203_ADDR_SIZE-1:0] lsu_addr;\n    wire [31:0] lsu_data;\n    wire lsu_we;\n    wire [3:0] lsu_wstrb;\n    wire lsu_valid;\n    wire lsu_ready;\n    wire [31:0] lsu_rdata;\n    wire lsu_rvalid;\n\n    // Instantiate IFU\n    e203_ifu u_ifu (\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ifu_active(ifu_active),\n        .ifu_pc(ifu_pc),\n        .ifu_valid(ifu_valid),\n        .ifu_instr(ifu_instr)\n    );\n\n    // Instantiate EXU\n    e203_exu u_exu (\n        .clk(clk),\n        .rst_n(rst_n),\n        .exu_active(exu_active),\n        .exu_result(exu_result)\n    );\n\n    // Instantiate LSU\n    e203_lsu u_lsu (\n        .clk(clk),\n        .rst_n(rst_n),\n        .lsu_active(lsu_active),\n        .lsu_addr(lsu_addr),\n        .lsu_data(lsu_data),\n        .lsu_we(lsu_we),\n        .lsu_wstrb(lsu_wstrb),\n        .lsu_valid(lsu_valid),\n        .lsu_ready(lsu_ready),\n        .lsu_rdata(lsu_rdata),\n        .lsu_rvalid(lsu_rvalid)\n    );\n\n    // Core logic\n    assign inspect_pc = ifu_pc;\n    assign core_wfi = !ifu_active && !exu_active && !lsu_active;\n    assign tm_stop = dbg_stopcycle;\n    assign core_cgstop = !core_wfi;\n    assign tcm_cgstop = !core_wfi;\n\n    // Debug logic\n    assign wr_dcsr_ena = dbg_mode && dbg_step_r;\n    assign wr_dpc_ena = dbg_mode && dbg_halt_r;\n    assign wr_dscratch_ena = dbg_mode && dbg_ebreakm_r;\n    assign wr_csr_nxt = dscratch_r; // Example assignment\n    assign cmt_dpc = dpc_r;\n    assign cmt_dpc_ena = dbg_mode;\n    assign cmt_dcause = 3'b000; // Example cause\n    assign cmt_dcause_ena = dbg_mode;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 2, "code": "module e203_srams (\n    input wire itcm_ram_sd,\n    input wire itcm_ram_ds,\n    input wire itcm_ram_ls,\n    input wire itcm_ram_cs,\n    input wire itcm_ram_we,\n    input wire [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n    input wire [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n    input wire [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n    output wire [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n    input wire clk_itcm_ram,\n    input wire rst_itcm,\n    \n    input wire dtcm_ram_sd,\n    input wire dtcm_ram_ds,\n    input wire dtcm_ram_ls,\n    input wire dtcm_ram_cs,\n    input wire dtcm_ram_we,\n    input wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    input wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    input wire clk_dtcm_ram,\n    input wire rst_dtcm\n);\n\n`ifdef E203_HAS_ITCM\n    e203_itcm_ram itcm_ram (\n        .sd(itcm_ram_sd),\n        .ds(itcm_ram_ds),\n        .ls(itcm_ram_ls),\n        .cs(itcm_ram_cs),\n        .we(itcm_ram_we),\n        .addr(itcm_ram_addr),\n        .wem(itcm_ram_wem),\n        .din(itcm_ram_din),\n        .dout(itcm_ram_dout),\n        .clk(clk_itcm_ram),\n        .rst_n(rst_itcm)\n    );\n`endif\n\n`ifdef E203_HAS_DTCM\n    e203_dtcm_ram dtcm_ram (\n        .sd(dtcm_ram_sd),\n        .ds(dtcm_ram_ds),\n        .ls(dtcm_ram_ls),\n        .cs(dtcm_ram_cs),\n        .we(dtcm_ram_we),\n        .addr(dtcm_ram_addr),\n        .wem(dtcm_ram_wem),\n        .din(dtcm_ram_din),\n        .dout(dtcm_ram_dout),\n        .clk(clk_dtcm_ram),\n        .rst_n(rst_dtcm)\n    );\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 1, "code": "module e203_exu_wbck (\n    input wire alu_wbck_i_valid,\n    output reg alu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] alu_wbck_i_wdat,\n    input wire [E203_RFIDX_WIDTH-1:0] alu_wbck_i_rdidx,\n    input wire longp_wbck_i_valid,\n    output reg longp_wbck_i_ready,\n    input wire [E203_FLEN-1:0] longp_wbck_i_wdat,\n    input wire [4:0] longp_wbck_i_flags,\n    input wire [E203_RFIDX_WIDTH-1:0] longp_wbck_i_rdidx,\n    input wire longp_wbck_i_rdfpu,\n    output reg rf_wbck_o_ena,\n    output reg [E203_XLEN-1:0] rf_wbck_o_wdat,\n    output reg [E203_RFIDX_WIDTH-1:0] rf_wbck_o_rdidx,\n    input wire clk,\n    input wire rst_n\n);\n\n    always @(*) begin\n        // Default assignments\n        alu_wbck_i_ready = 1'b0;\n        longp_wbck_i_ready = 1'b0;\n        rf_wbck_o_ena = 1'b0;\n        rf_wbck_o_wdat = {E203_XLEN{1'b0}};\n        rf_wbck_o_rdidx = {E203_RFIDX_WIDTH{1'b0}};\n\n        // Arbitration logic\n        if (longp_wbck_i_valid) begin\n            longp_wbck_i_ready = 1'b1;\n            rf_wbck_o_ena = ~longp_wbck_i_rdfpu;\n            rf_wbck_o_wdat = longp_wbck_i_wdat[E203_XLEN-1:0]; // Assuming FLEN >= XLEN\n            rf_wbck_o_rdidx = longp_wbck_i_rdidx;\n        end else if (alu_wbck_i_valid) begin\n            alu_wbck_i_ready = 1'b1;\n            rf_wbck_o_ena = 1'b1;\n            rf_wbck_o_wdat = alu_wbck_i_wdat;\n            rf_wbck_o_rdidx = alu_wbck_i_rdidx;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 9, "code": "module e203_core (\n    // System Interface\n    output [E203_PC_SIZE-1:0] inspect_pc,\n    output core_wfi,\n    output tm_stop,\n    output core_cgstop,\n    output tcm_cgstop,\n    input  [E203_PC_SIZE-1:0] pc_rtvec,\n    input  [E203_HART_ID_W-1:0] core_mhartid,\n    input  dbg_irq_r,\n    input  [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input  [E203_EVT_NUM-1:0] evt_r,\n    input  ext_irq_r,\n    input  sft_irq_r,\n    input  tmr_irq_r,\n    output wr_dcsr_ena,\n    output wr_dpc_ena,\n    output wr_dscratch_ena,\n    output [31:0] wr_csr_nxt,\n    input  [31:0] dcsr_r,\n    input  [E203_PC_SIZE-1:0] dpc_r,\n    input  [31:0] dscratch_r,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    input  dbg_mode,\n    input  dbg_halt_r,\n    input  dbg_step_r,\n    input  dbg_ebreakm_r,\n    input  dbg_stopcycle,\n\n    // ICB Protocol Interface\n    input  *_icb_enable,\n    output *_icb_cmd_valid,\n    input  *_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] *_icb_cmd_addr,\n    output *_icb_cmd_read,\n    output [E203_XLEN-1:0] *_icb_cmd_wdata,\n    output [E203_XLEN/8-1:0] *_icb_cmd_wmask,\n    output *_icb_cmd_lock,\n    output *_icb_cmd_excl,\n    output [1:0] *_icb_cmd_size,\n    input  *_icb_rsp_valid,\n    output *_icb_rsp_ready,\n    input  *_icb_rsp_err,\n    input  *_icb_rsp_excl_ok,\n    input  [E203_XLEN-1:0] *_icb_rsp_rdata,\n\n    // NICE Interface\n    input  nice_mem_holdup,\n    output nice_req_valid,\n    input  nice_req_ready,\n    output [E203_XLEN-1:0] nice_req_inst,\n    output [E203_XLEN-1:0] nice_req_rs1,\n    output [E203_XLEN-1:0] nice_req_rs2,\n    input  nice_rsp_multicyc_valid,\n    output nice_rsp_multicyc_ready,\n    input  [E203_XLEN-1:0] nice_rsp_multicyc_dat,\n    input  nice_rsp_multicyc_err,\n    input  nice_icb_cmd_valid,\n    output nice_icb_cmd_ready,\n    input  [E203_XLEN-1:0] nice_icb_cmd_addr,\n    input  nice_icb_cmd_read,\n    input  [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input  [1:0] nice_icb_cmd_size,\n    output nice_icb_rsp_valid,\n    input  nice_icb_rsp_ready,\n    output [E203_XLEN-1:0] nice_icb_rsp_rdata,\n    output nice_icb_rsp_err\n);\n    // Core implementation details would be here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 11, "code": "module e203_cpu_top (\n    input wire clk,\n    input wire rst_n,\n\n    // Interface to Instruction Tightly Coupled Memory (ITCM)\n    input wire ext2itcm_icb_cmd_valid,\n    output wire ext2itcm_icb_cmd_ready,\n    input wire [E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input wire ext2itcm_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ext2itcm_icb_cmd_wdata,\n    input wire [E203_XLEN/8-1:0] ext2itcm_icb_cmd_wmask,\n    output wire ext2itcm_icb_rsp_valid,\n    input wire ext2itcm_icb_rsp_ready,\n    output wire ext2itcm_icb_rsp_err,\n    output wire [E203_XLEN-1:0] ext2itcm_icb_rsp_rdata,\n\n    // Interface to Data Tightly Coupled Memory (DTCM)\n    input wire ext2dtcm_icb_cmd_valid,\n    output wire ext2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] ext2dtcm_icb_cmd_addr,\n    input wire ext2dtcm_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ext2dtcm_icb_cmd_wdata,\n    input wire [E203_XLEN/8-1:0] ext2dtcm_icb_cmd_wmask,\n    output wire ext2dtcm_icb_rsp_valid,\n    input wire ext2dtcm_icb_rsp_ready,\n    output wire ext2dtcm_icb_rsp_err,\n    output wire [E203_XLEN-1:0] ext2dtcm_icb_rsp_rdata,\n\n    // Debug interface\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n\n    // Reset and Interrupts\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    output wire dbg_irq_r,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n\n    // Power management\n    input wire tcm_sd,\n    input wire tcm_ds\n);\n\n    // Core instantiation\n    e203_cpu core (\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ext_irq_a(ext_irq_a),\n        .sft_irq_a(sft_irq_a),\n        .tmr_irq_a(tmr_irq_a),\n        .inspect_pc(inspect_pc),\n        .inspect_dbg_irq(inspect_dbg_irq),\n        .inspect_mem_cmd_valid(inspect_mem_cmd_valid),\n        .inspect_mem_cmd_ready(inspect_mem_cmd_ready),\n        .inspect_mem_rsp_valid(inspect_mem_rsp_valid),\n        .inspect_mem_rsp_ready(inspect_mem_rsp_ready),\n        .inspect_core_clk(inspect_core_clk),\n        .core_csr_clk(core_csr_clk),\n        .core_wfi(core_wfi),\n        .tm_stop(tm_stop),\n        .dbg_irq_r(dbg_irq_r)\n    );\n\n    // SRAMs instantiation\n    e203_srams srams (\n        .clk(clk),\n        .rst_n(rst_n),\n        .tcm_sd(tcm_sd),\n        .tcm_ds(tcm_ds),\n        .ext2itcm_icb_cmd_valid(ext2itcm_icb_cmd_valid),\n        .ext2itcm_icb_cmd_ready(ext2itcm_icb_cmd_ready),\n        .ext2itcm_icb_cmd_addr(ext2itcm_icb_cmd_addr),\n        .ext2itcm_icb_cmd_read(ext2itcm_icb_cmd_read),\n        .ext2itcm_icb_cmd_wdata(ext2itcm_icb_cmd_wdata),\n        .ext2itcm_icb_cmd_wmask(ext2itcm_icb_cmd_wmask),\n        .ext2itcm_icb_rsp_valid(ext2itcm_icb_rsp_valid),\n        .ext2itcm_icb_rsp_ready(ext2itcm_icb_rsp_ready),\n        .ext2itcm_icb_rsp_err(ext2itcm_icb_rsp_err),\n        .ext2itcm_icb_rsp_rdata(ext2itcm_icb_rsp_rdata),\n        .ext2dtcm_icb_cmd_valid(ext2dtcm_icb_cmd_valid),\n        .ext2dtcm_icb_cmd_ready(ext2dtcm_icb_cmd_ready),\n        .ext2dtcm_icb_cmd_addr(ext2dtcm_icb_cmd_addr),\n        .ext2dtcm_icb_cmd_read(ext2dtcm_icb_cmd_read),\n        .ext2dtcm_icb_cmd_wdata(ext2dtcm_icb_cmd_wdata),\n        .ext2dtcm_icb_cmd_wmask(ext2dtcm_icb_cmd_wmask),\n        .ext2dtcm_icb_rsp_valid(ext2dtcm_icb_rsp_valid),\n        .ext2dtcm_icb_rsp_ready(ext2dtcm_icb_rsp_ready),\n        .ext2dtcm_icb_rsp_err(ext2dtcm_icb_rsp_err),\n        .ext2dtcm_icb_rsp_rdata(ext2dtcm_icb_rsp_rdata)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 3, "code": "module e203_exu_csr (\n    input wire nonflush_cmt_ena,\n    input wire csr_ena,\n    input wire csr_wr_en,\n    input wire csr_rd_en,\n    input wire [11:0] csr_idx,\n    output wire csr_access_ilgl,\n    output wire tm_stop,\n    output wire core_cgstop,\n    output wire tcm_cgstop,\n    output wire itcm_nohold,\n    output wire mdv_nob2b,\n    output wire [E203_XLEN-1:0] read_csr_dat,\n    input wire [E203_XLEN-1:0] wbck_csr_dat,\n    input wire [E203_HART_ID_W-1:0] core_mhartid,\n    input wire ext_irq_r,\n    input wire sft_irq_r,\n    input wire tmr_irq_r,\n    output wire status_mie_r,\n    output wire mtie_r,\n    output wire msie_r,\n    output wire meie_r,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    input wire [E203_XLEN-1:0] dcsr_r,\n    input wire [E203_PC_SIZE-1:0] dpc_r,\n    input wire [E203_XLEN-1:0] dscratch_r,\n    output wire u_mode,\n    output wire s_mode,\n    output wire h_mode,\n    output wire m_mode,\n    input wire [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    input wire cmt_badaddr_ena,\n    input wire [E203_PC_SIZE-1:0] cmt_epc,\n    input wire cmt_epc_ena,\n    input wire [E203_XLEN-1:0] cmt_cause,\n    input wire cmt_cause_ena,\n    input wire cmt_status_ena,\n    input wire cmt_instret_ena,\n    input wire cmt_mret_ena,\n    output wire [E203_PC_SIZE-1:0] csr_epc_r,\n    output wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    output wire [E203_XLEN-1:0] csr_mtvec_r,\n    input wire clk_aon,\n    input wire clk,\n    input wire rst_n\n);\n\n// Implementation of CSR logic here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 13, "code": "// E203 Processor Configuration Document\n\n// 1. Introduction\n// This document describes the configuration system for the E203 processor. The E203 is a RISC-V architecture-based processor core that can be configured with various features and functional modules via macro definitions. This configuration file is licensed under the Apache 2.0 open-source license and is maintained by Nuclei System Technology.\n\n// 2. Basic Configuration Items\n\n// 2.1 Debug and Interrupt Configuration\n// **`E203_CFG_DEBUG_HAS_JTAG`**: Enables support for JTAG debug interface.\n// **`E203_CFG_IRQ_NEED_SYNC`**: Enables interrupt synchronization mechanism.\n\n// 2.2 Address Space Configuration\n// The system supports three address width configurations, and only one can be selected at a time:\n// - **`E203_CFG_ADDR_SIZE_IS_16`**: 16-bit address space.\n// - **`E203_CFG_ADDR_SIZE_IS_24`**: 24-bit address space.\n// - **`E203_CFG_ADDR_SIZE_IS_32`**: 32-bit address space (currently selected configuration).\n\n// The address size is unified through the **`E203_CFG_ADDR_SIZE`** macro, which is automatically set based on the chosen configuration.\n\n// 2.3 CPU Function Configuration\n// - **`E203_CFG_SUPPORT_MCYCLE_MINSTRET`**: Enables support for MCYCLE and MINSTRET counters.\n// - **`E203_CFG_REGNUM_IS_32`**: Configures the number of registers to 32.\n// - **`E203_CFG_HAS_ECC`**: Enables ECC (Error Correction Code) functionality.\n// - **`E203_CFG_HAS_NICE`**: Enables the NICE instruction extension.\n// - **`E203_CFG_SUPPORT_SHARE_MULDIV`**: Enables shared multiplication and division units.\n// - **`E203_CFG_SUPPORT_AMO`**: Enables support for atomic memory operations (AMO).\n\n// 2.4 Memory System Configuration\n\n// Instruction TCM (ITCM)\n// - **`E203_CFG_HAS_ITCM`**: Enables Instruction Tightly Coupled Memory (ITCM).\n// - **`E203_CFG_ITCM_ADDR_WIDTH`**: Configures the ITCM address width. The current setting is 16 bits.\n//   - Supports a 64KB configuration (16-bit address width, 8192 depth).\n//   - Optional 1024KB configuration (20-bit address width).\n//   - Optional 2048KB configuration (21-bit address width).\n\n// Data TCM (DTCM)\n// - **`E203_CFG_HAS_DTCM`**: Enables Data Tightly Coupled Memory (DTCM).\n// - **`E203_CFG_DTCM_ADDR_WIDTH`**: Configures the DTCM address width. The current setting is 16 bits.\n//   - Supports a 16KB configuration (14-bit address width, 4096 depth).\n//   - Supports a 256KB configuration (18-bit address width, 65536 depth).\n//   - Optional 1MB configuration (20-bit address width, 262144 depth).\n\n// 2.5 Memory Mapping Configuration\n\n// The system defines the base addresses for the following memory regions:\n\n// 1. **ITCM Region**:\n//    - Base address: `0x8000_0000`\n//    - Defined through **`E203_CFG_ITCM_ADDR_BASE`**.\n// 2. **DTCM Region**:\n//    - Base address: `0x9000_0000`\n//    - Defined through **`E203_CFG_DTCM_ADDR_BASE`**.\n// 3. **Peripheral Interface Regions**:\n//    - **PPI Region**: `0x1000_0000 - 0x1FFF_FFFF`\n//    - Defined through **`E203_CFG_PPI_ADDR_BASE`** and **`E203_CFG_PPI_BASE_REGION`**.\n// 4. **System Controller Regions**:\n//    - **CLINT Region**: `0x0200_0000 - 0x0200_FFFF`\n//    - Base Address of CLINT is defined through **`E203_CFG_CLINT_ADDR_BASE`**.(`E203_CFG_ADDR_SIZE'h0200_0000`)\n//    -  **`E203_CFG_CLINT_BASE_REGION`** macro defines the high address range used to determine whether an address belongs to CLINT REGION (`E203_CFG_ADDR_SIZE-1:E203_CFG_ADDR_SIZE-16`)\n//    - **PLIC Region**: `0x0C00_0000 - 0x0CFF_FFFF`\n//    - Base Address of PLIC is defined through **`E203_CFG_PLIC_ADDR_BASE`**.(`E203_CFG_ADDR_SIZE'h0C00_0000`)\n//    -  **`E203_CFG_PLIC_BASE_REGION`** macro defines the high address range used to determine whether an address belongs to PLIC REGION (`E203_CFG_ADDR_SIZE-1:E203_CFG_ADDR_SIZE-8`)\n// 5. **Fast IO Region**:\n//    - Base address: `0xF000_0000`\n//    - Defined through **`E203_CFG_FIO_ADDR_BASE`** and **`E203_CFG_FIO_BASE_REGION`**.\n\n// 3. Notes\n\n// 1. Only one address width configuration should be enabled at a time.\n// 2. TCM configurations should be selected based on available hardware resources.\n// 3. Memory mapping configurations must avoid address overlap.\n// 4. It is recommended to carefully evaluate the system's resource requirements and performance demands when modifying configurations.", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 10, "code": "module e203_core(\n    input wire clk,\n    input wire rst_n,\n    // System Interface\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire core_cgstop,\n    output wire tcm_cgstop,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire [E203_HART_ID_W-1:0] core_mhartid,\n    input wire dbg_irq_r,\n    input wire [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input wire [E203_EVT_NUM-1:0] evt_r,\n    input wire ext_irq_r,\n    input wire sft_irq_r,\n    input wire tmr_irq_r,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    output wire [31:0] wr_csr_nxt,\n    input wire [31:0] dcsr_r,\n    input wire [E203_PC_SIZE-1:0] dpc_r,\n    input wire [31:0] dscratch_r,\n    output wire [E203_PC_SIZE-1:0] cmt_dpc,\n    output wire cmt_dpc_ena,\n    output wire [2:0] cmt_dcause,\n    output wire cmt_dcause_ena,\n    input wire dbg_mode,\n    input wire dbg_halt_r,\n    input wire dbg_step_r,\n    input wire dbg_ebreakm_r,\n    input wire dbg_stopcycle,\n    // ICB Protocol Interface\n    input wire icb_enable,\n    output wire icb_cmd_valid,\n    input wire icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] icb_cmd_addr,\n    output wire icb_cmd_read,\n    output wire [E203_XLEN-1:0] icb_cmd_wdata,\n    output wire [E203_XLEN/8-1:0] icb_cmd_wmask,\n    output wire icb_cmd_lock,\n    output wire icb_cmd_excl,\n    output wire [1:0] icb_cmd_size,\n    input wire icb_rsp_valid,\n    output wire icb_rsp_ready,\n    input wire icb_rsp_err,\n    input wire icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] icb_rsp_rdata,\n    // NICE Interface\n    input wire nice_mem_holdup,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_inst,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    input wire [E203_XLEN-1:0] nice_rsp_multicyc_dat,\n    input wire nice_rsp_multicyc_err,\n    input wire nice_icb_cmd_valid,\n    output wire nice_icb_cmd_ready,\n    input wire [E203_XLEN-1:0] nice_icb_cmd_addr,\n    input wire nice_icb_cmd_read,\n    input wire [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input wire [1:0] nice_icb_cmd_size,\n    output wire nice_icb_rsp_valid,\n    input wire nice_icb_rsp_ready,\n    output wire [E203_XLEN-1:0] nice_icb_rsp_rdata,\n    output wire nice_icb_rsp_err\n);\n    // Core implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 1, "code": "module e203_exu(\n    output commit_mret,\n    output commit_trap,\n    output exu_active,\n    output excp_active,\n    output core_wfi,\n    output tm_stop,\n    output itcm_nohold,\n    output core_cgstop,\n    output tcm_cgstop,\n    input [E203_HART_ID_W-1:0] core_mhartid,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    output wfi_halt_ifu_req,\n    input wfi_halt_ifu_ack,\n    output oitf_empty,\n    output [E203_XLEN-1:0] rf2ifu_x1,\n    output [E203_XLEN-1:0] rf2ifu_rs1,\n    output dec2ifu_rden,\n    output dec2ifu_rs1en,\n    output [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    output dec2ifu_mulhsu,\n    output dec2ifu_div,\n    output dec2ifu_rem,\n    output dec2ifu_divu,\n    output dec2ifu_remu,\n    input test_mode,\n    input clk_aon,\n    input clk,\n    input rst_n,\n    output cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output wr_dcsr_ena,\n    output wr_dpc_ena,\n    output wr_dscratch_ena,\n    output [E203_XLEN-1:0] wr_csr_nxt,\n    input [E203_XLEN-1:0] dcsr_r,\n    input [E203_PC_SIZE-1:0] dpc_r,\n    input [E203_XLEN-1:0] dscratch_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input dbg_stopcycle,\n    input i_valid,\n    output i_ready,\n    input [E203_INSTR_SIZE-1:0] i_ir,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_pc_vld,\n    input i_misalgn,\n    input i_buserr,\n    input i_prdt_taken,\n    input i_muldiv_b2b,\n    input [E203_RFIDX_WIDTH-1:0] i_rs1idx,\n    input [E203_RFIDX_WIDTH-1:0] i_rs2idx,\n    input pipe_flush_ack,\n    output pipe_flush_req,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input lsu_o_valid,\n    output lsu_o_ready,\n    input [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    input [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    input lsu_o_wbck_err,\n    input lsu_o_cmt_ld,\n    input lsu_o_cmt_st,\n    input [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    input lsu_o_cmt_buserr,\n    output agu_icb_cmd_valid,\n    input agu_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output agu_icb_cmd_read,\n    output [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    output agu_icb_cmd_lock,\n    output agu_icb_cmd_excl,\n    output [1:0] agu_icb_cmd_size,\n    output agu_icb_cmd_back2agu,\n    output agu_icb_cmd_usign,\n    output [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input agu_icb_rsp_valid,\n    output agu_icb_rsp_ready,\n    input agu_icb_rsp_err,\n    input agu_icb_rsp_excl_ok,\n    input [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output nice_csr_valid,\n    input nice_csr_ready,\n    output [31:0] nice_csr_addr,\n    output nice_csr_wr,\n    output [31:0] nice_csr_wdata,\n    input [31:0] nice_csr_rdata\n);\n    // Implementation of the e203_exu module's internal logic\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 19, "code": "module e203_clk_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire core_cgstop,\n    input wire core_ifu_active,\n    input wire core_exu_active,\n    input wire core_lsu_active,\n    input wire core_biu_active,\n    input wire core_wfi,\n    output wire clk_aon,\n    output wire clk_core_ifu,\n    output wire clk_core_exu,\n    output wire clk_core_lsu,\n    output wire clk_core_biu,\n    `ifdef E203_HAS_ITCM\n    input wire itcm_active,\n    output wire itcm_ls,\n    output wire clk_itcm,\n    `endif\n    `ifdef E203_HAS_DTCM\n    input wire dtcm_active,\n    output wire dtcm_ls,\n    output wire clk_dtcm,\n    `endif\n    output wire clk_core\n);\n\n// Clock always on\nassign clk_aon = clk;\n\n// Clock gating logic for IFU\nassign clk_core_ifu = (core_cgstop | (core_ifu_active & ~core_wfi)) & ~test_mode;\n\n// Clock gating logic for other core modules\nassign clk_core_exu = (core_cgstop | core_exu_active) & ~test_mode;\nassign clk_core_lsu = (core_cgstop | core_lsu_active) & ~test_mode;\nassign clk_core_biu = (core_cgstop | core_biu_active) & ~test_mode;\n\n// Optional ITCM and DTCM clock gating\n`ifdef E203_HAS_ITCM\nreg itcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        itcm_active_r <= 1'b0;\n    else\n        itcm_active_r <= itcm_active;\nend\nassign clk_itcm = (core_cgstop | itcm_active | itcm_active_r) & ~test_mode;\nassign itcm_ls = ~(itcm_active | itcm_active_r);\n`endif\n\n`ifdef E203_HAS_DTCM\nreg dtcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        dtcm_active_r <= 1'b0;\n    else\n        dtcm_active_r <= dtcm_active;\nend\nassign clk_dtcm = (core_cgstop | dtcm_active | dtcm_active_r) & ~test_mode;\nassign dtcm_ls = ~(dtcm_active | dtcm_active_r);\n`endif\n\n// Core clock is the OR of all individual clocks\nassign clk_core = clk_core_ifu | clk_core_exu | clk_core_lsu | clk_core_biu\n                  `ifdef E203_HAS_ITCM\n                  | clk_itcm\n                  `endif\n                  `ifdef E203_HAS_DTCM\n                  | clk_dtcm\n                  `endif\n                  ;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 12, "code": "module e203_cpu_top (\n    input wire clk,\n    input wire rst_n,\n\n    // Interface: PC Inspection\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n\n    // Interface: Reset and Interrupts\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    output wire dbg_irq_r,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n\n    // Interface: TCM Control\n    input wire tcm_sd,\n    input wire tcm_ds,\n\n    // Interface: External to ITCM\n    input wire ext2itcm_icb_cmd_valid,\n    output wire ext2itcm_icb_cmd_ready,\n    input wire [E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input wire ext2itcm_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ext2itcm_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] ext2itcm_icb_cmd_wmask,\n    output wire ext2itcm_icb_rsp_valid,\n    input wire ext2itcm_icb_rsp_ready,\n    output wire ext2itcm_icb_rsp_err,\n    output wire [E203_XLEN-1:0] ext2itcm_icb_rsp_rdata\n);\n\n    // Core instantiation\n    e203_cpu u_e203_cpu (\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .inspect_pc(inspect_pc),\n        .inspect_dbg_irq(inspect_dbg_irq),\n        .inspect_mem_cmd_valid(inspect_mem_cmd_valid),\n        .inspect_mem_cmd_ready(inspect_mem_cmd_ready),\n        .inspect_mem_rsp_valid(inspect_mem_rsp_valid),\n        .inspect_mem_rsp_ready(inspect_mem_rsp_ready),\n        .inspect_core_clk(inspect_core_clk),\n        .core_csr_clk(core_csr_clk),\n        .core_wfi(core_wfi),\n        .tm_stop(tm_stop),\n        .dbg_irq_r(dbg_irq_r),\n        .ext_irq_a(ext_irq_a),\n        .sft_irq_a(sft_irq_a),\n        .tmr_irq_a(tmr_irq_a),\n        .tcm_sd(tcm_sd),\n        .tcm_ds(tcm_ds),\n        .ext2itcm_icb_cmd_valid(ext2itcm_icb_cmd_valid),\n        .ext2itcm_icb_cmd_ready(ext2itcm_icb_cmd_ready),\n        .ext2itcm_icb_cmd_addr(ext2itcm_icb_cmd_addr),\n        .ext2itcm_icb_cmd_read(ext2itcm_icb_cmd_read),\n        .ext2itcm_icb_cmd_wdata(ext2itcm_icb_cmd_wdata),\n        .ext2itcm_icb_cmd_wmask(ext2itcm_icb_cmd_wmask),\n        .ext2itcm_icb_rsp_valid(ext2itcm_icb_rsp_valid),\n        .ext2itcm_icb_rsp_ready(ext2itcm_icb_rsp_ready),\n        .ext2itcm_icb_rsp_err(ext2itcm_icb_rsp_err),\n        .ext2itcm_icb_rsp_rdata(ext2itcm_icb_rsp_rdata)\n    );\n\n    // SRAMs instantiation\n    e203_srams u_e203_srams (\n        .clk(clk),\n        .rst_n(rst_n),\n        .tcm_sd(tcm_sd),\n        .tcm_ds(tcm_ds),\n        .itcm_ram_cs(ext2itcm_icb_cmd_valid),\n        .itcm_ram_we(ext2itcm_icb_cmd_read),\n        .itcm_ram_addr(ext2itcm_icb_cmd_addr),\n        .itcm_ram_wem(ext2itcm_icb_cmd_wmask),\n        .itcm_ram_din(ext2itcm_icb_cmd_wdata),\n        .itcm_ram_dout(ext2itcm_icb_rsp_rdata)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 11, "code": "module e203_core(\n    input wire clk,\n    input wire rst_n,\n\n    // System Interface\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire core_cgstop,\n    output wire tcm_cgstop,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire [E203_HART_ID_W-1:0] core_mhartid,\n    input wire dbg_irq_r,\n    input wire [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input wire [E203_EVT_NUM-1:0] evt_r,\n    input wire ext_irq_r,\n    input wire sft_irq_r,\n    input wire tmr_irq_r,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    output wire [31:0] wr_csr_nxt,\n    input wire [31:0] dcsr_r,\n    input wire [E203_PC_SIZE-1:0] dpc_r,\n    input wire [31:0] dscratch_r,\n    output wire [E203_PC_SIZE-1:0] cmt_dpc,\n    output wire cmt_dpc_ena,\n    output wire [2:0] cmt_dcause,\n    output wire cmt_dcause_ena,\n    input wire dbg_mode,\n    input wire dbg_halt_r,\n    input wire dbg_step_r,\n    input wire dbg_ebreakm_r,\n    input wire dbg_stopcycle,\n\n    // ICB Protocol Interface\n    input wire icb_enable,\n    output wire icb_cmd_valid,\n    input wire icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] icb_cmd_addr,\n    output wire icb_cmd_read,\n    output wire [E203_XLEN-1:0] icb_cmd_wdata,\n    output wire [E203_XLEN/8-1:0] icb_cmd_wmask,\n    output wire icb_cmd_lock,\n    output wire icb_cmd_excl,\n    output wire [1:0] icb_cmd_size,\n    input wire icb_rsp_valid,\n    output wire icb_rsp_ready,\n    input wire icb_rsp_err,\n    input wire icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] icb_rsp_rdata,\n\n    // NICE Interface\n    input wire nice_mem_holdup,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_inst,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    input wire [E203_XLEN-1:0] nice_rsp_multicyc_dat,\n    input wire nice_rsp_multicyc_err,\n    input wire nice_icb_cmd_valid,\n    output wire nice_icb_cmd_ready,\n    input wire [E203_XLEN-1:0] nice_icb_cmd_addr,\n    input wire nice_icb_cmd_read,\n    input wire [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input wire [1:0] nice_icb_cmd_size,\n    output wire nice_icb_rsp_valid,\n    input wire nice_icb_rsp_ready,\n    output wire [E203_XLEN-1:0] nice_icb_rsp_rdata,\n    output wire nice_icb_rsp_err\n);\n    // Core implementation details would be here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 1, "code": "module e203_exu_alu_bjp (\n    input wire bjp_i_valid,\n    output reg bjp_i_ready,\n    input wire [E203_XLEN-1:0] bjp_i_rs1,\n    input wire [E203_XLEN-1:0] bjp_i_rs2,\n    input wire [E203_XLEN-1:0] bjp_i_imm,\n    input wire [E203_PC_SIZE-1:0] bjp_i_pc,\n    input wire [E203_DECINFO_BJP_WIDTH-1:0] bjp_i_info,\n    output reg bjp_o_valid,\n    input wire bjp_o_ready,\n    output reg [E203_XLEN-1:0] bjp_o_wbck_wdat,\n    output reg bjp_o_wbck_err,\n    output reg bjp_o_cmt_bjp,\n    output reg bjp_o_cmt_mret,\n    output reg bjp_o_cmt_dret,\n    output reg bjp_o_cmt_fencei,\n    output reg bjp_o_cmt_prdt,\n    output reg bjp_o_cmt_rslv,\n    output reg [E203_XLEN-1:0] bjp_req_alu_op1,\n    output reg [E203_XLEN-1:0] bjp_req_alu_op2,\n    output reg bjp_req_alu_cmp_eq,\n    output reg bjp_req_alu_cmp_ne,\n    output reg bjp_req_alu_cmp_lt,\n    output reg bjp_req_alu_cmp_gt,\n    output reg bjp_req_alu_cmp_ltu,\n    output reg bjp_req_alu_cmp_gtu,\n    output reg bjp_req_alu_add,\n    input wire bjp_req_alu_cmp_res,\n    input wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Handshake mechanism\n    always @(*) begin\n        bjp_i_ready = bjp_o_ready;\n        bjp_o_valid = bjp_i_valid;\n    end\n\n    // ALU request generation based on instruction type\n    always @(*) begin\n        bjp_req_alu_op1 = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? bjp_i_pc : bjp_i_rs1;\n        bjp_req_alu_op2 = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? bjp_i_imm : bjp_i_rs2;\n        bjp_req_alu_cmp_eq = bjp_i_info[E203_DECINFO_BJP_BEQ];\n        bjp_req_alu_cmp_ne = bjp_i_info[E203_DECINFO_BJP_BNE];\n        bjp_req_alu_cmp_lt = bjp_i_info[E203_DECINFO_BJP_BLT];\n        bjp_req_alu_cmp_gt = bjp_i_info[E203_DECINFO_BJP_BGT];\n        bjp_req_alu_cmp_ltu = bjp_i_info[E203_DECINFO_BJP_BLTU];\n        bjp_req_alu_cmp_gtu = bjp_i_info[E203_DECINFO_BJP_BGTU];\n        bjp_req_alu_add = bjp_i_info[E203_DECINFO_BJP_JUMP];\n    end\n\n    // Commit signals and write-back data handling\n    always @(*) begin\n        bjp_o_wbck_wdat = bjp_req_alu_add_res;\n        bjp_o_wbck_err = 1'b0;\n        bjp_o_cmt_bjp = bjp_i_info[E203_DECINFO_BJP_BXX] | bjp_i_info[E203_DECINFO_BJP_JUMP];\n        bjp_o_cmt_mret = bjp_i_info[E203_DECINFO_BJP_MRET];\n        bjp_o_cmt_dret = bjp_i_info[E203_DECINFO_BJP_DRET];\n        bjp_o_cmt_fencei = bjp_i_info[E203_DECINFO_BJP_FENCEI];\n        bjp_o_cmt_prdt = bjp_i_info[E203_DECINFO_BJP_BPRDT];\n        bjp_o_cmt_rslv = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? 1'b1 : bjp_req_alu_cmp_res;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 3, "code": "module e203_exu_branchslv(\n    input wire cmt_i_valid,\n    output wire cmt_i_ready,\n    input wire cmt_i_rv32,\n    input wire cmt_i_dret,\n    input wire cmt_i_mret,\n    input wire cmt_i_fencei,\n    input wire cmt_i_bjp,\n    input wire cmt_i_bjp_prdt,\n    input wire cmt_i_bjp_rslv,\n    input wire [E203_PC_SIZE-1:0] cmt_i_pc,\n    input wire [E203_XLEN-1:0] cmt_i_imm,\n    input wire [E203_PC_SIZE-1:0] csr_epc_r,\n    input wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    input wire nonalu_excpirq_flush_req_raw,\n    input wire brchmis_flush_ack,\n    output wire brchmis_flush_req,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op1,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op2,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_pc,\n    output wire cmt_mret_ena,\n    output wire cmt_dret_ena,\n    output wire cmt_fencei_ena,\n    input wire clk,\n    input wire rst_n\n);\n\n    wire flush_need;\n    wire flush_target_calc;\n    wire pipeline_flush_control;\n    wire prioritizing_flush_sources;\n    wire special_signal_commit;\n\n    // Flush Need Generation\n    assign flush_need = (cmt_i_bjp & (cmt_i_bjp_prdt != cmt_i_bjp_rslv)) | cmt_i_fencei | cmt_i_mret | cmt_i_dret;\n\n    // Flush Target Calculation\n    always @(*) begin\n        if (cmt_i_dret) begin\n            brchmis_flush_add_op1 = csr_dpc_r;\n        end else if (cmt_i_mret) begin\n            brchmis_flush_add_op1 = csr_epc_r;\n        end else if (cmt_i_bjp & cmt_i_bjp_prdt & ~cmt_i_bjp_rslv) begin\n            brchmis_flush_add_op1 = cmt_i_rv32 ? cmt_i_pc + 4 : cmt_i_pc + 2;\n        end else if (cmt_i_bjp & ~cmt_i_bjp_prdt & cmt_i_bjp_rslv) begin\n            brchmis_flush_add_op1 = cmt_i_pc + cmt_i_imm;\n        end else begin\n            brchmis_flush_add_op1 = csr_epc_r;\n        end\n    end\n\n    // Pipeline Flush Control\n    assign brchmis_flush_req = flush_need & cmt_i_valid & ~nonalu_excpirq_flush_req_raw;\n\n    // Prioritizing Flush Sources\n    assign brchmis_flush_add_op2 = nonalu_excpirq_flush_req_raw ? csr_epc_r : brchmis_flush_add_op1;\n\n    // Controls the ready signal for the instruction\n    assign cmt_i_ready = ~flush_need & ~nonalu_excpirq_flush_req_raw & brchmis_flush_ack;\n\n    // Special Signal Commit\n    assign cmt_mret_ena = cmt_i_mret & flush_need & brchmis_flush_ack;\n    assign cmt_dret_ena = cmt_i_dret & flush_need & brchmis_flush_ack;\n    assign cmt_fencei_ena = cmt_i_fencei & flush_need & brchmis_flush_ack;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 20, "code": "module e203_clk_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire core_cgstop,\n    input wire core_ifu_active,\n    input wire core_exu_active,\n    input wire core_lsu_active,\n    input wire core_biu_active,\n    input wire core_wfi,\n    output wire clk_aon,\n    output wire clk_core_ifu,\n    output wire clk_core_exu,\n    output wire clk_core_lsu,\n    output wire clk_core_biu,\n    `ifdef E203_HAS_ITCM\n    input wire itcm_active,\n    output wire itcm_ls,\n    output wire clk_itcm,\n    `endif\n    `ifdef E203_HAS_DTCM\n    input wire dtcm_active,\n    output wire dtcm_ls,\n    output wire clk_dtcm,\n    `endif\n    output wire clk_core\n);\n\n// Clock always on\nassign clk_aon = clk;\n\n// Clock gating logic\nwire clk_ifu_en = core_cgstop | (core_ifu_active & ~core_wfi);\nwire clk_exu_en = core_cgstop | core_exu_active;\nwire clk_lsu_en = core_cgstop | core_lsu_active;\nwire clk_biu_en = core_cgstop | core_biu_active;\n\n// Clock output assignments\nassign clk_core_ifu = clk_ifu_en ? clk : 1'b0;\nassign clk_core_exu = clk_exu_en ? clk : 1'b0;\nassign clk_core_lsu = clk_lsu_en ? clk : 1'b0;\nassign clk_core_biu = clk_biu_en ? clk : 1'b0;\n\n`ifdef E203_HAS_ITCM\nreg itcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        itcm_active_r <= 1'b0;\n    else\n        itcm_active_r <= itcm_active;\nend\nwire clk_itcm_en = core_cgstop | itcm_active | itcm_active_r;\nassign clk_itcm = clk_itcm_en ? clk : 1'b0;\nassign itcm_ls = ~clk_itcm_en;\n`endif\n\n`ifdef E203_HAS_DTCM\nreg dtcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        dtcm_active_r <= 1'b0;\n    else\n        dtcm_active_r <= dtcm_active;\nend\nwire clk_dtcm_en = core_cgstop | dtcm_active | dtcm_active_r;\nassign clk_dtcm = clk_dtcm_en ? clk : 1'b0;\nassign dtcm_ls = ~clk_dtcm_en;\n`endif\n\n// Core clock is the OR of all individual clocks\nassign clk_core = clk_core_ifu | clk_core_exu | clk_core_lsu | clk_core_biu\n                  `ifdef E203_HAS_ITCM\n                  | clk_itcm\n                  `endif\n                  `ifdef E203_HAS_DTCM\n                  | clk_dtcm\n                  `endif\n                  ;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 2, "code": "module e203_exu_nice (\n    input wire nice_i_xs_off,\n    input wire nice_i_valid,\n    output wire nice_i_ready,\n    input wire [E203_XLEN-1:0] nice_i_instr,\n    input wire [E203_XLEN-1:0] nice_i_rs1,\n    input wire [E203_XLEN-1:0] nice_i_rs2,\n    input wire [E203_ITAG_WIDTH-1:0] nice_i_itag,\n    output wire nice_o_longpipe,\n    output wire nice_o_valid,\n    input wire nice_o_ready,\n    output wire nice_o_itag_valid,\n    input wire nice_o_itag_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire clk,\n    input wire rst_n\n);\n\n// Internal signals\nwire fifo_push, fifo_pop;\nwire [E203_ITAG_WIDTH-1:0] fifo_data_in, fifo_data_out;\nwire fifo_full, fifo_empty;\n\n// FIFO instantiation for instruction tags\nsirv_gnrl_fifo #(\n    .CUT_READY(1),\n    .MSKO(0),\n    .DP(4),\n    .DW(E203_ITAG_WIDTH)\n) itag_fifo (\n    .i_vld(fifo_push),\n    .i_rdy(fifo_pop),\n    .i_dat(fifo_data_in),\n    .o_vld(nice_o_itag_valid),\n    .o_rdy(nice_o_itag_ready),\n    .o_dat(nice_o_itag),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// Control logic for pushing to and popping from FIFO\nassign fifo_push = nice_i_valid & nice_i_ready & ~nice_i_xs_off;\nassign fifo_pop = nice_rsp_multicyc_valid & nice_rsp_multicyc_ready;\nassign fifo_data_in = nice_i_itag;\n\n// Ready signals and valid signals handling\nassign nice_i_ready = ~fifo_full & nice_o_ready & ~nice_i_xs_off;\nassign nice_o_valid = nice_i_valid & nice_i_ready;\nassign nice_req_valid = nice_i_valid & nice_i_ready & ~nice_i_xs_off;\nassign nice_rsp_multicyc_ready = ~fifo_empty;\n\n// Forwarding instruction and operands to accelerator\nassign nice_req_instr = nice_i_instr;\nassign nice_req_rs1 = nice_i_rs1;\nassign nice_req_rs2 = nice_i_rs2;\n\n// Long pipeline signal handling\nassign nice_o_longpipe = ~nice_i_xs_off;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 1, "code": "module e203_exu_alu_lsuagu (\n    input wire agu_i_valid,\n    output wire agu_i_ready,\n    input wire [E203_XLEN-1:0] agu_i_rs1,\n    input wire [E203_XLEN-1:0] agu_i_rs2,\n    input wire [E203_XLEN-1:0] agu_i_imm,\n    input wire [E203_DECINFO_AGU_WIDTH-1:0] agu_i_info,\n    input wire [E203_ITAG_WIDTH-1:0] agu_i_itag,\n    output wire agu_i_longpipe,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire amo_wait,\n    input wire oitf_empty,\n    output wire agu_o_valid,\n    input wire agu_o_ready,\n    output wire [E203_XLEN-1:0] agu_o_wbck_wdat,\n    output wire agu_o_wbck_err,\n    output wire agu_o_cmt_misalgn,\n    output wire agu_o_cmt_ld,\n    output wire agu_o_cmt_stamo,\n    output wire agu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] agu_o_cmt_badaddr,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_cmd_usign,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire [E203_XLEN-1:0] agu_req_alu_op1,\n    output wire [E203_XLEN-1:0] agu_req_alu_op2,\n    output wire agu_req_alu_swap,\n    output wire agu_req_alu_add,\n    output wire agu_req_alu_and,\n    output wire agu_req_alu_or,\n    output wire agu_req_alu_xor,\n    output wire agu_req_alu_max,\n    output wire agu_req_alu_min,\n    output wire agu_req_alu_maxu,\n    output wire agu_req_alu_minu,\n    input wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire agu_sbf_0_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_0_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_0_r,\n    output wire agu_sbf_1_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_1_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_1_r,\n    input wire clk,\n    input wire rst_n\n);\n    // Implementation of AGU logic goes here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 3, "code": "module e203_srams #(\n  parameter E203_ITCM_RAM_AW = 12, // Address width for ITCM\n  parameter E203_ITCM_RAM_MW = 4,  // Write mask width for ITCM\n  parameter E203_ITCM_RAM_DW = 32, // Data width for ITCM\n  parameter E203_DTCM_RAM_AW = 12, // Address width for DTCM\n  parameter E203_DTCM_RAM_MW = 4,  // Write mask width for DTCM\n  parameter E203_DTCM_RAM_DW = 32  // Data width for DTCM\n)(\n  input  wire                     clk,\n  input  wire                     rst_n,\n\n  // ITCM Interface\n  input  wire                     itcm_ram_cs,\n  input  wire                     itcm_ram_we,\n  input  wire [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n  input  wire [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n  input  wire [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n  output wire [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n\n  // DTCM Interface\n  input  wire                     dtcm_ram_cs,\n  input  wire                     dtcm_ram_we,\n  input  wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n  input  wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n  input  wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n  output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout\n);\n\n`ifdef E203_HAS_ITCM\n  // ITCM Memory Array\n  reg [E203_ITCM_RAM_DW-1:0] itcm_mem [0:(1<<E203_ITCM_RAM_AW)-1];\n\n  always @(posedge clk) begin\n    if (itcm_ram_cs && itcm_ram_we) begin\n      for (int i = 0; i < E203_ITCM_RAM_MW; i++) begin\n        if (itcm_ram_wem[i]) begin\n          itcm_mem[itcm_ram_addr][8*i +: 8] <= itcm_ram_din[8*i +: 8];\n        end\n      end\n    end\n  end\n\n  assign itcm_ram_dout = itcm_mem[itcm_ram_addr];\n`endif\n\n`ifdef E203_HAS_DTCM\n  // DTCM Memory Array\n  reg [E203_DTCM_RAM_DW-1:0] dtcm_mem [0:(1<<E203_DTCM_RAM_AW)-1];\n\n  always @(posedge clk) begin\n    if (dtcm_ram_cs && dtcm_ram_we) begin\n      for (int i = 0; i < E203_DTCM_RAM_MW; i++) begin\n        if (dtcm_ram_wem[i]) begin\n          dtcm_mem[dtcm_ram_addr][8*i +: 8] <= dtcm_ram_din[8*i +: 8];\n        end\n      end\n    end\n  end\n\n  assign dtcm_ram_dout = dtcm_mem[dtcm_ram_addr];\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 1, "code": "module e203_itcm_ram #(\n  parameter FORCE_X2ZERO = 0,\n  parameter DP = `E203_ITCM_RAM_DP,\n  parameter DW = `E203_ITCM_RAM_DW,\n  parameter MW = `E203_ITCM_RAM_MW,\n  parameter AW = `E203_ITCM_RAM_AW\n)(\n  input wire sd,\n  input wire ds,\n  input wire ls,\n  input wire cs,\n  input wire we,\n  input wire [AW-1:0] addr,\n  input wire [MW-1:0] wem,\n  input wire [DW-1:0] din,\n  input wire rst_n,\n  input wire clk,\n  output wire [DW-1:0] dout\n);\n\n  // Internal RAM instantiation\n  sirv_gnrl_ram #(\n    .FORCE_X2ZERO(FORCE_X2ZERO),\n    .DP(DP),\n    .DW(DW),\n    .MW(MW),\n    .AW(AW)\n  ) ram_inst (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 2, "code": "`include \"e203_defines.v\"\n\nmodule e203_itcm_ram #(\n  parameter FORCE_X2ZERO = 0,\n  parameter DP = `E203_ITCM_RAM_DP,\n  parameter DW = `E203_ITCM_RAM_DW,\n  parameter MW = `E203_ITCM_RAM_MW,\n  parameter AW = `E203_ITCM_RAM_AW\n)(\n  input wire sd,\n  input wire ds,\n  input wire ls,\n  input wire cs,\n  input wire we,\n  input wire [AW-1:0] addr,\n  input wire [MW-1:0] wem,\n  input wire [DW-1:0] din,\n  input wire rst_n,\n  input wire clk,\n  output wire [DW-1:0] dout\n);\n\n  sirv_gnrl_ram #(\n    .FORCE_X2ZERO(FORCE_X2ZERO),\n    .DP(DP),\n    .DW(DW),\n    .MW(MW),\n    .AW(AW)\n  ) u_sirv_gnrl_ram (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 4, "code": "module e203_exu_csr(\n    input wire nonflush_cmt_ena,\n    input wire csr_ena,\n    input wire csr_wr_en,\n    input wire csr_rd_en,\n    input wire [11:0] csr_idx,\n    output reg csr_access_ilgl,\n    output reg tm_stop,\n    output reg core_cgstop,\n    output reg tcm_cgstop,\n    output reg itcm_nohold,\n    output reg mdv_nob2b,\n    output reg [E203_XLEN-1:0] read_csr_dat,\n    input wire [E203_XLEN-1:0] wbck_csr_dat,\n    input wire [E203_HART_ID_W-1:0] core_mhartid,\n    input wire ext_irq_r,\n    input wire sft_irq_r,\n    input wire tmr_irq_r,\n    output reg status_mie_r,\n    output reg mtie_r,\n    output reg msie_r,\n    output reg meie_r,\n    output reg wr_dcsr_ena,\n    output reg wr_dpc_ena,\n    output reg wr_dscratch_ena,\n    input wire [E203_XLEN-1:0] dcsr_r,\n    input wire [E203_PC_SIZE-1:0] dpc_r,\n    input wire [E203_XLEN-1:0] dscratch_r,\n    output reg u_mode,\n    output reg s_mode,\n    output reg h_mode,\n    output reg m_mode,\n    input wire [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    input wire cmt_badaddr_ena,\n    input wire [E203_PC_SIZE-1:0] cmt_epc,\n    input wire cmt_epc_ena,\n    input wire [E203_XLEN-1:0] cmt_cause,\n    input wire cmt_cause_ena,\n    input wire cmt_status_ena,\n    input wire cmt_instret_ena,\n    input wire cmt_mret_ena,\n    output reg [E203_PC_SIZE-1:0] csr_epc_r,\n    output reg [E203_PC_SIZE-1:0] csr_dpc_r,\n    output reg [E203_XLEN-1:0] csr_mtvec_r,\n    input wire clk_aon,\n    input wire clk,\n    input wire rst_n\n);\n\n    // CSR logic implementation here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 2, "code": "module e203_exu_alu_muldiv(\n    input mdv_nob2b,\n    input muldiv_i_valid,\n    output muldiv_i_ready,\n    input [E203_XLEN-1:0] muldiv_i_rs1,\n    input [E203_XLEN-1:0] muldiv_i_rs2,\n    input [E203_XLEN-1:0] muldiv_i_imm,\n    input [E203_DECINFO_MULDIV_WIDTH-1:0] muldiv_i_info,\n    input [E203_ITAG_WIDTH-1:0] muldiv_i_itag,\n    output muldiv_i_longpipe,\n    input flush_pulse,\n    output muldiv_o_valid,\n    input muldiv_o_ready,\n    output [E203_XLEN-1:0] muldiv_o_wbck_wdat,\n    output muldiv_o_wbck_err,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    output muldiv_req_alu_add,\n    output muldiv_req_alu_sub,\n    input [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output muldiv_sbf_0_ena,\n    output [32:0] muldiv_sbf_0_nxt,\n    input [32:0] muldiv_sbf_0_r,\n    output muldiv_sbf_1_ena,\n    output [32:0] muldiv_sbf_1_nxt,\n    input [32:0] muldiv_sbf_1_r,\n    input clk,\n    input rst_n\n);\n\n// Internal signals and registers\nreg [4:0] state;\nreg [E203_XLEN-1:0] result;\nwire [E203_XLEN-1:0] op1, op2;\nassign op1 = muldiv_i_rs1;\nassign op2 = muldiv_i_rs2;\n\n// State machine for handling multiplication and division\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        state <= MULDIV_STATE_0TH;\n        result <= 0;\n    end else begin\n        case (state)\n            MULDIV_STATE_0TH: begin\n                if (muldiv_i_valid && !flush_pulse) begin\n                    if (muldiv_i_info[0]) // Assuming info[0] is mul/div select\n                        state <= MULDIV_STATE_EXEC;\n                end\n            end\n            MULDIV_STATE_EXEC: begin\n                if (muldiv_i_info[0]) begin // Multiplication\n                    result <= op1 * op2;\n                    state <= MULDIV_STATE_0TH;\n                end else begin // Division\n                    if (op2 != 0) begin\n                        result <= op1 / op2;\n                        state <= MULDIV_STATE_REMD_CHCK;\n                    end else begin\n                        result <= {E203_XLEN{1'bX}}; // Division by zero\n                        state <= MULDIV_STATE_0TH;\n                    end\n                end\n            end\n            MULDIV_STATE_REMD_CHCK: begin\n                if (muldiv_i_info[1]) // Assuming info[1] is remainder calculation\n                    result <= op1 % op2;\n                state <= MULDIV_STATE_0TH;\n            end\n            default: state <= MULDIV_STATE_0TH;\n        endcase\n    end\nend\n\n// Output assignments\nassign muldiv_o_valid = (state == MULDIV_STATE_0TH) && muldiv_o_ready;\nassign muldiv_o_wbck_wdat = result;\nassign muldiv_o_wbck_err = 0; // No error handling in this example\nassign muldiv_i_ready = (state == MULDIV_STATE_0TH);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 16, "code": "`ifdef E203_HAS_CSR_NICE\nmodule e203_extend_csr (\n    input wire clk,\n    input wire rst_n,\n    input wire nice_csr_valid,\n    output wire nice_csr_ready,\n    input wire [31:0] nice_csr_addr,\n    input wire nice_csr_wr,\n    input wire [31:0] nice_csr_wdata,\n    output wire [31:0] nice_csr_rdata\n);\n\n  // CSR access ready signal, always 1\n  assign nice_csr_ready = 1'b1;\n\n  // CSR read data, always 0\n  assign nice_csr_rdata = 32'b0;\n\nendmodule\n`endif", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 3, "code": "module e203_exu_nice(\n    input wire nice_i_xs_off,\n    input wire nice_i_valid,\n    output wire nice_i_ready,\n    input wire [E203_XLEN-1:0] nice_i_instr,\n    input wire [E203_XLEN-1:0] nice_i_rs1,\n    input wire [E203_XLEN-1:0] nice_i_rs2,\n    input wire [E203_ITAG_WIDTH-1:0] nice_i_itag,\n    output wire nice_o_longpipe,\n    output wire nice_o_valid,\n    input wire nice_o_ready,\n    output wire nice_o_itag_valid,\n    input wire nice_o_itag_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Internal signals\n    wire fifo_full, fifo_empty;\n    wire fifo_push, fifo_pop;\n    wire [E203_ITAG_WIDTH-1:0] fifo_data_in, fifo_data_out;\n\n    // Control signals\n    assign fifo_push = nice_i_valid && nice_i_ready && !nice_i_xs_off;\n    assign fifo_pop = nice_rsp_multicyc_valid && nice_rsp_multicyc_ready && !fifo_empty;\n\n    // FIFO instantiation for instruction tags\n    sirv_gnrl_fifo #(\n        .CUT_READY(1),\n        .MSKO(0),\n        .DP(4),\n        .DW(E203_ITAG_WIDTH)\n    ) itag_fifo (\n        .i_vld(fifo_push),\n        .i_rdy(nice_i_ready),\n        .i_dat(nice_i_itag),\n        .o_vld(nice_o_itag_valid),\n        .o_rdy(nice_o_itag_ready),\n        .o_dat(nice_o_itag),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\n    // Handling of NICE requests and responses\n    assign nice_req_valid = nice_i_valid && !nice_i_xs_off && nice_req_ready;\n    assign nice_req_instr = nice_i_instr;\n    assign nice_req_rs1 = nice_i_rs1;\n    assign nice_req_rs2 = nice_i_rs2;\n\n    // Response handling\n    assign nice_rsp_multicyc_ready = !fifo_full;\n\n    // Long pipeline signal\n    assign nice_o_longpipe = !nice_i_xs_off;\n\n    // Commit valid signal\n    assign nice_o_valid = nice_i_valid && nice_o_ready && !nice_i_xs_off;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 12, "code": "module e203_core (\n    input  wire        clk,\n    input  wire        rst_n,\n    input  wire [31:0] pc_rtvec,\n    input  wire [31:0] core_mhartid,\n    input  wire        dbg_irq_r,\n    input  wire [15:0] lcl_irq_r,\n    input  wire [31:0] evt_r,\n    input  wire        ext_irq_r,\n    input  wire        sft_irq_r,\n    input  wire        tmr_irq_r,\n    output wire [31:0] inspect_pc,\n    output wire        core_wfi,\n    output wire        tm_stop,\n    output wire        core_cgstop,\n    output wire        tcm_cgstop,\n    output wire        wr_dcsr_ena,\n    output wire        wr_dpc_ena,\n    output wire        wr_dscratch_ena,\n    output wire [31:0] wr_csr_nxt,\n    input  wire [31:0] dcsr_r,\n    input  wire [31:0] dpc_r,\n    input  wire [31:0] dscratch_r,\n    output wire [31:0] cmt_dpc,\n    output wire        cmt_dpc_ena,\n    output wire [2:0]  cmt_dcause,\n    output wire        cmt_dcause_ena,\n    input  wire        dbg_mode,\n    input  wire        dbg_halt_r,\n    input  wire        dbg_step_r,\n    input  wire        dbg_ebreakm_r,\n    input  wire        dbg_stopcycle\n);\n\n    // Internal signals\n    wire [31:0] next_pc;\n    wire        pc_sel;\n    wire        pc_ld;\n    wire        pc_inc;\n    wire [31:0] ir;\n    wire        ir_valid;\n    wire [31:0] alu_out;\n    wire        alu_valid;\n    wire        branch_taken;\n    wire [31:0] branch_target;\n    wire        mem_req;\n    wire        mem_we;\n    wire [31:0] mem_addr;\n    wire [31:0] mem_wdata;\n    wire [31:0] mem_rdata;\n    wire        mem_ready;\n\n    // Instruction Fetch Unit\n    e203_ifu ifu (\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .next_pc(next_pc),\n        .pc_sel(pc_sel),\n        .pc_ld(pc_ld),\n        .pc_inc(pc_inc),\n        .ir(ir),\n        .ir_valid(ir_valid),\n        .branch_taken(branch_taken),\n        .branch_target(branch_target)\n    );\n\n    // Execution Unit\n    e203_exu exu (\n        .clk(clk),\n        .rst_n(rst_n),\n        .ir(ir),\n        .ir_valid(ir_valid),\n        .alu_out(alu_out),\n        .alu_valid(alu_valid),\n        .branch_taken(branch_taken),\n        .branch_target(branch_target),\n        .mem_req(mem_req),\n        .mem_we(mem_we),\n        .mem_addr(mem_addr),\n        .mem_wdata(mem_wdata)\n    );\n\n    // Memory Unit\n    e203_lsu lsu (\n        .clk(clk),\n        .rst_n(rst_n),\n        .mem_req(mem_req),\n        .mem_we(mem_we),\n        .mem_addr(mem_addr),\n        .mem_wdata(mem_wdata),\n        .mem_rdata(mem_rdata),\n        .mem_ready(mem_ready)\n    );\n\n    // Control and Status Registers\n    e203_csr csr (\n        .clk(clk),\n        .rst_n(rst_n),\n        .dcsr_r(dcsr_r),\n        .dpc_r(dpc_r),\n        .dscratch_r(dscratch_r),\n        .wr_dcsr_ena(wr_dcsr_ena),\n        .wr_dpc_ena(wr_dpc_ena),\n        .wr_dscratch_ena(wr_dscratch_ena),\n        .wr_csr_nxt(wr_csr_nxt),\n        .cmt_dpc(cmt_dpc),\n        .cmt_dpc_ena(cmt_dpc_ena),\n        .cmt_dcause(cmt_dcause),\n        .cmt_dcause_ena(cmt_dcause_ena)\n    );\n\n    // Debug and Exception Handling\n    e203_dbg dbg (\n        .clk(clk),\n        .rst_n(rst_n),\n        .dbg_mode(dbg_mode),\n        .dbg_halt_r(dbg_halt_r),\n        .dbg_step_r(dbg_step_r),\n        .dbg_ebreakm_r(dbg_ebreakm_r),\n        .dbg_stopcycle(dbg_stopcycle),\n        .dbg_irq_r(dbg_irq_r),\n        .lcl_irq_r(lcl_irq_r),\n        .evt_r(evt_r),\n        .ext_irq_r(ext_irq_r),\n        .sft_irq_r(sft_irq_r),\n        .tmr_irq_r(tmr_irq_r),\n        .core_wfi(core_wfi),\n        .tm_stop(tm_stop),\n        .core_cgstop(core_cgstop),\n        .tcm_cgstop(tcm_cgstop)\n    );\n\n    // Program Counter Management\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            next_pc <= pc_rtvec;\n        end else if (pc_ld) begin\n            next_pc <= branch_target;\n        end else if (pc_inc) begin\n            next_pc <= next_pc + 4;\n        end\n    end\n\n    // Output the current PC for inspection\n    assign inspect_pc = next_pc;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 1, "code": "module e203_ifu_minidec #(\n  parameter E203_INSTR_SIZE = 32,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_XLEN = 32\n)(\n  input [E203_INSTR_SIZE-1:0] instr,\n  output reg dec_rs1en,\n  output reg dec_rs2en,\n  output reg [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n  output reg [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n  output reg dec_mulhsu,\n  output reg dec_mul,\n  output reg dec_div,\n  output reg dec_rem,\n  output reg dec_divu,\n  output reg dec_remu,\n  output reg dec_rv32,\n  output reg dec_bjp,\n  output reg dec_jal,\n  output reg dec_jalr,\n  output reg dec_bxx,\n  output reg [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  output reg [E203_XLEN-1:0] dec_bjp_imm\n);\n\n  // Internal signals for decoding\n  wire [6:0] opcode = instr[6:0];\n  wire [2:0] funct3 = instr[14:12];\n  wire [6:0] funct7 = instr[31:25];\n\n  always @(*) begin\n    // Default assignments\n    dec_rs1en = 1'b0;\n    dec_rs2en = 1'b0;\n    dec_rs1idx = instr[19:15];\n    dec_rs2idx = instr[24:20];\n    dec_mulhsu = 1'b0;\n    dec_mul = 1'b0;\n    dec_div = 1'b0;\n    dec_rem = 1'b0;\n    dec_divu = 1'b0;\n    dec_remu = 1'b0;\n    dec_rv32 = 1'b1; // Assuming RV32 ISA\n    dec_bjp = 1'b0;\n    dec_jal = 1'b0;\n    dec_jalr = 1'b0;\n    dec_bxx = 1'b0;\n    dec_jalr_rs1idx = instr[19:15];\n    dec_bjp_imm = {E203_XLEN{1'b0}};\n\n    case (opcode)\n      7'b0110011: begin // R-type\n        dec_rs1en = 1'b1;\n        dec_rs2en = 1'b1;\n        case (funct3)\n          3'b000: begin\n            if (funct7 == 7'b0000001) begin\n              dec_mul = 1'b1; // MUL\n            end\n          end\n          3'b001: begin\n            if (funct7 == 7'b0000001) begin\n              dec_mulhsu = 1'b1; // MULHSU\n            end\n          end\n          3'b100: begin\n            if (funct7 == 7'b0000001) begin\n              dec_div = 1'b1; // DIV\n            end\n          end\n          3'b110: begin\n            if (funct7 == 7'b0000001) begin\n              dec_divu = 1'b1; // DIVU\n            end\n          end\n          3'b101: begin\n            if (funct7 == 7'b0000001) begin\n              dec_rem = 1'b1; // REM\n            end\n          end\n          3'b111: begin\n            if (funct7 == 7'b0000001) begin\n              dec_remu = 1'b1; // REMU\n            end\n          end\n        endcase\n      end\n      7'b1101111: begin // JAL\n        dec_jal = 1'b1;\n        dec_bjp = 1'b1;\n        dec_bjp_imm = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0};\n      end\n      7'b1100111: begin // JALR\n        dec_jalr = 1'b1;\n        dec_bjp = 1'b1;\n        dec_bjp_imm = {{20{instr[31]}}, instr[31:20]};\n      end\n      7'b1100011: begin // B-type\n        dec_bxx = 1'b1;\n        dec_bjp = 1'b1;\n        dec_bjp_imm = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};\n      end\n    endcase\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 1, "code": "module e203_irq_sync (\n    input wire clk,\n    input wire rst_n,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire dbg_irq_a,\n    output wire ext_irq_r,\n    output wire sft_irq_r,\n    output wire tmr_irq_r,\n    output wire dbg_irq_r\n);\n\n// Synchronization instances for each interrupt type\nsirv_gnrl_sync #(\n    .DP(2),\n    .DW(1)\n) u_ext_sync (\n    .clk(clk),\n    .rst_n(rst_n),\n    .din_a(ext_irq_a),\n    .dout(ext_irq_r)\n);\n\nsirv_gnrl_sync #(\n    .DP(2),\n    .DW(1)\n) u_sft_sync (\n    .clk(clk),\n    .rst_n(rst_n),\n    .din_a(sft_irq_a),\n    .dout(sft_irq_r)\n);\n\nsirv_gnrl_sync #(\n    .DP(2),\n    .DW(1)\n) u_tmr_sync (\n    .clk(clk),\n    .rst_n(rst_n),\n    .din_a(tmr_irq_a),\n    .dout(tmr_irq_r)\n);\n\nsirv_gnrl_sync #(\n    .DP(2),\n    .DW(1)\n) u_dbg_sync (\n    .clk(clk),\n    .rst_n(rst_n),\n    .din_a(dbg_irq_a),\n    .dout(dbg_irq_r)\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 13, "code": "module e203_core(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire [E203_HART_ID_W-1:0] core_mhartid,\n    input wire dbg_irq_r,\n    input wire [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input wire [E203_EVT_NUM-1:0] evt_r,\n    input wire ext_irq_r,\n    input wire sft_irq_r,\n    input wire tmr_irq_r,\n    input wire dbg_mode,\n    input wire dbg_halt_r,\n    input wire dbg_step_r,\n    input wire dbg_ebreakm_r,\n    input wire dbg_stopcycle,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire core_cgstop,\n    output wire tcm_cgstop,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    output wire [31:0] wr_csr_nxt,\n    output wire [E203_PC_SIZE-1:0] cmt_dpc,\n    output wire cmt_dpc_ena,\n    output wire [2:0] cmt_dcause,\n    output wire cmt_dcause_ena,\n    input wire [31:0] dcsr_r,\n    input wire [E203_PC_SIZE-1:0] dpc_r,\n    input wire [31:0] dscratch_r\n);\n\n    // Core internal signals and registers\n    reg [E203_PC_SIZE-1:0] pc;\n    reg [E203_PC_SIZE-1:0] next_pc;\n    reg [31:0] csr [0:4095]; // CSR file\n    reg [31:0] gpr [0:31];   // General purpose registers\n\n    // Core initialization\n    initial begin\n        pc = pc_rtvec;\n    end\n\n    // Core main sequential logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            pc <= pc_rtvec;\n        end else begin\n            pc <= next_pc;\n        end\n    end\n\n    // Core combinational logic\n    always @(*) begin\n        next_pc = pc + 4; // Simple sequential fetch for demonstration\n    end\n\n    // Output assignments\n    assign inspect_pc = pc;\n    assign core_wfi = 1'b0; // Example static assignment\n    assign tm_stop = 1'b0; // Example static assignment\n    assign core_cgstop = 1'b0; // Example static assignment\n    assign tcm_cgstop = 1'b0; // Example static assignment\n    assign wr_dcsr_ena = 1'b0; // Example static assignment\n    assign wr_dpc_ena = 1'b0; // Example static assignment\n    assign wr_dscratch_ena = 1'b0; // Example static assignment\n    assign wr_csr_nxt = 32'b0; // Example static assignment\n    assign cmt_dpc = 32'b0; // Example static assignment\n    assign cmt_dpc_ena = 1'b0; // Example static assignment\n    assign cmt_dcause = 3'b0; // Example static assignment\n    assign cmt_dcause_ena = 1'b0; // Example static assignment\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 4, "code": "module e203_biu(\n    input wire clk,\n    input wire rst_n,\n    output wire biu_active,\n\n    // ICB Command Interface (input)\n    input wire lsu_icb_cmd_valid,\n    input wire [E203_ADDR_SIZE-1:0] lsu_icb_cmd_addr,\n    input wire lsu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] lsu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] lsu_icb_cmd_wmask,\n    input wire [1:0] lsu_icb_cmd_burst,\n    input wire [1:0] lsu_icb_cmd_beat,\n    input wire lsu_icb_cmd_lock,\n    input wire lsu_icb_cmd_excl,\n    input wire [1:0] lsu_icb_cmd_size,\n    output wire lsu_icb_cmd_ready,\n\n    // ICB Response Interface (output)\n    output wire lsu_icb_rsp_valid,\n    output wire lsu_icb_rsp_err,\n    output wire lsu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] lsu_icb_rsp_rdata,\n    input wire lsu_icb_rsp_ready,\n\n    // Additional peripheral signals\n    input wire [E203_ADDR_SIZE-1:0] ppi_region_indic,\n    input wire ppi_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] clint_region_indic,\n    input wire clint_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] plic_region_indic,\n    input wire plic_icb_enable\n);\n\n    // Internal signals for arbitration and buffering\n    wire arbt_icb_cmd_valid;\n    wire arbt_icb_cmd_ready;\n    wire [E203_ADDR_SIZE-1:0] arbt_icb_cmd_addr;\n    wire arbt_icb_cmd_read;\n    wire [E203_XLEN-1:0] arbt_icb_cmd_wdata;\n    wire [(E203_XLEN/8)-1:0] arbt_icb_cmd_wmask;\n    wire arbt_icb_rsp_valid;\n    wire arbt_icb_rsp_ready;\n    wire arbt_icb_rsp_err;\n    wire arbt_icb_rsp_excl_ok;\n    wire [E203_XLEN-1:0] arbt_icb_rsp_rdata;\n\n    // Instantiate the ICB Arbiter\n    sirv_gnrl_icb_arbt #(\n        .AW(E203_ADDR_SIZE),\n        .DW(E203_XLEN),\n        .ARBT_NUM(BIU_ARBT_I_NUM),\n        .ARBT_PTR_W(BIU_ARBT_I_PTR_W),\n        .USR_W(1),\n        .ARBT_SCHEME(0),\n        .ALLOW_0CYCL_RSP(0),\n        .FIFO_OUTS_NUM(E203_BIU_OUTS_NUM),\n        .FIFO_CUT_READY(E203_BIU_CMD_CUT_READY)\n    ) u_icb_arbt (\n        .clk(clk),\n        .rst_n(rst_n),\n        .i_icb_cmd_valid(lsu_icb_cmd_valid),\n        .i_icb_cmd_ready(lsu_icb_cmd_ready),\n        .i_icb_cmd_addr(lsu_icb_cmd_addr),\n        .i_icb_cmd_read(lsu_icb_cmd_read),\n        .i_icb_cmd_wdata(lsu_icb_cmd_wdata),\n        .i_icb_cmd_wmask(lsu_icb_cmd_wmask),\n        .o_icb_cmd_valid(arbt_icb_cmd_valid),\n        .o_icb_cmd_ready(arbt_icb_cmd_ready),\n        .o_icb_cmd_addr(arbt_icb_cmd_addr),\n        .o_icb_cmd_read(arbt_icb_cmd_read),\n        .o_icb_cmd_wdata(arbt_icb_cmd_wdata),\n        .o_icb_cmd_wmask(arbt_icb_cmd_wmask),\n        .o_icb_rsp_valid(arbt_icb_rsp_valid),\n        .o_icb_rsp_ready(arbt_icb_rsp_ready),\n        .o_icb_rsp_err(arbt_icb_rsp_err),\n        .o_icb_rsp_excl_ok(arbt_icb_rsp_excl_ok),\n        .o_icb_rsp_rdata(arbt_icb_rsp_rdata),\n        .i_icb_rsp_valid(lsu_icb_rsp_valid),\n        .i_icb_rsp_ready(lsu_icb_rsp_ready),\n        .i_icb_rsp_err(lsu_icb_rsp_err),\n        .i_icb_rsp_excl_ok(lsu_icb_rsp_excl_ok),\n        .i_icb_rsp_rdata(lsu_icb_rsp_rdata)\n    );\n\n    // Logic to handle peripheral region indications and enable signals\n    wire ppi_access = (arbt_icb_cmd_addr >= ppi_region_indic) && ppi_icb_enable;\n    wire clint_access = (arbt_icb_cmd_addr >= clint_region_indic) && clint_icb_enable;\n    wire plic_access = (arbt_icb_cmd_addr >= plic_region_indic) && plic_icb_enable;\n\n    // Output logic to drive the BIU active signal\n    assign biu_active = arbt_icb_cmd_valid || arbt_icb_rsp_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 2, "code": "module e203_exu_alu_bjp (\n    input wire bjp_i_valid,\n    output wire bjp_i_ready,\n    input wire [E203_XLEN-1:0] bjp_i_rs1,\n    input wire [E203_XLEN-1:0] bjp_i_rs2,\n    input wire [E203_XLEN-1:0] bjp_i_imm,\n    input wire [E203_PC_SIZE-1:0] bjp_i_pc,\n    input wire [E203_DECINFO_BJP_WIDTH-1:0] bjp_i_info,\n    output wire bjp_o_valid,\n    input wire bjp_o_ready,\n    output wire [E203_XLEN-1:0] bjp_o_wbck_wdat,\n    output wire bjp_o_wbck_err,\n    output wire bjp_o_cmt_bjp,\n    output wire bjp_o_cmt_mret,\n    output wire bjp_o_cmt_dret,\n    output wire bjp_o_cmt_fencei,\n    output wire bjp_o_cmt_prdt,\n    output wire bjp_o_cmt_rslv,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    output wire bjp_req_alu_cmp_eq,\n    output wire bjp_req_alu_cmp_ne,\n    output wire bjp_req_alu_cmp_lt,\n    output wire bjp_req_alu_cmp_gt,\n    output wire bjp_req_alu_cmp_ltu,\n    output wire bjp_req_alu_cmp_gtu,\n    output wire bjp_req_alu_add,\n    input wire bjp_req_alu_cmp_res,\n    input wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Handshake mechanism\n    assign bjp_i_ready = bjp_o_ready;\n    assign bjp_o_valid = bjp_i_valid;\n\n    // Default assignments\n    assign bjp_o_wbck_err = 1'b0;\n    assign bjp_o_cmt_mret = 1'b0;\n    assign bjp_o_cmt_dret = 1'b0;\n    assign bjp_o_cmt_fencei = 1'b0;\n\n    // Operand selection\n    assign bjp_req_alu_op1 = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? bjp_i_pc : bjp_i_rs1;\n    assign bjp_req_alu_op2 = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? bjp_i_imm : bjp_i_rs2;\n\n    // ALU operation requests\n    assign bjp_req_alu_cmp_eq  = bjp_i_info[E203_DECINFO_BJP_BEQ];\n    assign bjp_req_alu_cmp_ne  = bjp_i_info[E203_DECINFO_BJP_BNE];\n    assign bjp_req_alu_cmp_lt  = bjp_i_info[E203_DECINFO_BJP_BLT];\n    assign bjp_req_alu_cmp_gt  = bjp_i_info[E203_DECINFO_BJP_BGT];\n    assign bjp_req_alu_cmp_ltu = bjp_i_info[E203_DECINFO_BJP_BLTU];\n    assign bjp_req_alu_cmp_gtu = bjp_i_info[E203_DECINFO_BJP_BGTU];\n    assign bjp_req_alu_add     = bjp_i_info[E203_DECINFO_BJP_JUMP];\n\n    // Commit signals\n    assign bjp_o_cmt_bjp = bjp_i_valid & (bjp_i_info[E203_DECINFO_BJP_BXX] | bjp_i_info[E203_DECINFO_BJP_JUMP]);\n    assign bjp_o_cmt_prdt = bjp_i_info[E203_DECINFO_BJP_BPRDT];\n    assign bjp_o_cmt_rslv = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? 1'b1 : bjp_req_alu_cmp_res;\n\n    // Write back data\n    assign bjp_o_wbck_wdat = bjp_req_alu_add_res;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 4, "code": "module e203_srams #(\n  parameter E203_ITCM_RAM_AW = 12, // Address width for ITCM\n  parameter E203_ITCM_RAM_MW = 4,  // Mask width for ITCM\n  parameter E203_ITCM_RAM_DW = 32, // Data width for ITCM\n  parameter E203_DTCM_RAM_AW = 12, // Address width for DTCM\n  parameter E203_DTCM_RAM_MW = 4,  // Mask width for DTCM\n  parameter E203_DTCM_RAM_DW = 32  // Data width for DTCM\n)(\n  input  wire                     clk,\n  input  wire                     rst_n,\n\n  // ITCM Interface\n  input  wire                     itcm_ram_cs,\n  input  wire                     itcm_ram_we,\n  input  wire [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n  input  wire [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n  input  wire [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n  output wire [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n\n  // DTCM Interface\n  input  wire                     dtcm_ram_cs,\n  input  wire                     dtcm_ram_we,\n  input  wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n  input  wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n  input  wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n  output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout\n);\n\n`ifdef E203_HAS_ITCM\n  // ITCM Memory Array\n  reg [E203_ITCM_RAM_DW-1:0] itcm_mem [0:(1<<E203_ITCM_RAM_AW)-1];\n\n  always @(posedge clk) begin\n    if (itcm_ram_cs && itcm_ram_we) begin\n      for (int i = 0; i < E203_ITCM_RAM_MW; i++) begin\n        if (itcm_ram_wem[i]) begin\n          itcm_mem[itcm_ram_addr][8*i +: 8] <= itcm_ram_din[8*i +: 8];\n        end\n      end\n    end\n  end\n\n  assign itcm_ram_dout = itcm_mem[itcm_ram_addr];\n`endif\n\n`ifdef E203_HAS_DTCM\n  // DTCM Memory Array\n  reg [E203_DTCM_RAM_DW-1:0] dtcm_mem [0:(1<<E203_DTCM_RAM_AW)-1];\n\n  always @(posedge clk) begin\n    if (dtcm_ram_cs && dtcm_ram_we) begin\n      for (int i = 0; i < E203_DTCM_RAM_MW; i++) begin\n        if (dtcm_ram_wem[i]) begin\n          dtcm_mem[dtcm_ram_addr][8*i +: 8] <= dtcm_ram_din[8*i +: 8];\n        end\n      end\n    end\n  end\n\n  assign dtcm_ram_dout = dtcm_mem[dtcm_ram_addr];\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 14, "code": "module e203_core (\n    // System Interface\n    output [E203_PC_SIZE-1:0] inspect_pc,\n    output core_wfi,\n    output tm_stop,\n    output core_cgstop,\n    output tcm_cgstop,\n    input  [E203_PC_SIZE-1:0] pc_rtvec,\n    input  [E203_HART_ID_W-1:0] core_mhartid,\n    input  dbg_irq_r,\n    input  [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input  [E203_EVT_NUM-1:0] evt_r,\n    input  ext_irq_r,\n    input  sft_irq_r,\n    input  tmr_irq_r,\n    output wr_dcsr_ena,\n    output wr_dpc_ena,\n    output wr_dscratch_ena,\n    output [31:0] wr_csr_nxt,\n    input  [31:0] dcsr_r,\n    input  [E203_PC_SIZE-1:0] dpc_r,\n    input  [31:0] dscratch_r,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    input  dbg_mode,\n    input  dbg_halt_r,\n    input  dbg_step_r,\n    input  dbg_ebreakm_r,\n    input  dbg_stopcycle,\n\n    // ICB Protocol Interface\n    input  *_icb_enable,\n    output *_icb_cmd_valid,\n    input  *_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] *_icb_cmd_addr,\n    output *_icb_cmd_read,\n    output [E203_XLEN-1:0] *_icb_cmd_wdata,\n    output [E203_XLEN/8-1:0] *_icb_cmd_wmask,\n    output *_icb_cmd_lock,\n    output *_icb_cmd_excl,\n    output [1:0] *_icb_cmd_size,\n    input  *_icb_rsp_valid,\n    output *_icb_rsp_ready,\n    input  *_icb_rsp_err,\n    input  *_icb_rsp_excl_ok,\n    input  [E203_XLEN-1:0] *_icb_rsp_rdata,\n\n    // NICE Interface\n    input  nice_mem_holdup,\n    output nice_req_valid,\n    input  nice_req_ready,\n    output [E203_XLEN-1:0] nice_req_inst,\n    output [E203_XLEN-1:0] nice_req_rs1,\n    output [E203_XLEN-1:0] nice_req_rs2,\n    input  nice_rsp_multicyc_valid,\n    output nice_rsp_multicyc_ready,\n    input  [E203_XLEN-1:0] nice_rsp_multicyc_dat,\n    input  nice_rsp_multicyc_err,\n    input  nice_icb_cmd_valid,\n    output nice_icb_cmd_ready,\n    input  [E203_XLEN-1:0] nice_icb_cmd_addr,\n    input  nice_icb_cmd_read,\n    input  [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input  [1:0] nice_icb_cmd_size,\n    output nice_icb_rsp_valid,\n    input  nice_icb_rsp_ready,\n    output [E203_XLEN-1:0] nice_icb_rsp_rdata,\n    output nice_icb_rsp_err\n);\n    // Core implementation details would be here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 5, "code": "module e203_srams #(\n  parameter E203_ITCM_RAM_AW = 12,\n  parameter E203_ITCM_RAM_MW = 4,\n  parameter E203_ITCM_RAM_DW = 32,\n  parameter E203_DTCM_RAM_AW = 12,\n  parameter E203_DTCM_RAM_MW = 4,\n  parameter E203_DTCM_RAM_DW = 32\n)(\n  input  wire                     itcm_ram_sd,\n  input  wire                     itcm_ram_ds,\n  input  wire                     itcm_ram_ls,\n  input  wire                     itcm_ram_cs,\n  input  wire                     itcm_ram_we,\n  input  wire [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n  input  wire [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n  input  wire [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n  output wire [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n  input  wire                     clk_itcm_ram,\n  input  wire                     rst_itcm,\n\n  input  wire                     dtcm_ram_sd,\n  input  wire                     dtcm_ram_ds,\n  input  wire                     dtcm_ram_ls,\n  input  wire                     dtcm_ram_cs,\n  input  wire                     dtcm_ram_we,\n  input  wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n  input  wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n  input  wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n  output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n  input  wire                     clk_dtcm_ram,\n  input  wire                     rst_dtcm\n);\n\n`ifdef E203_HAS_ITCM\n  e203_itcm_ram #(\n    .AW(E203_ITCM_RAM_AW),\n    .MW(E203_ITCM_RAM_MW),\n    .DW(E203_ITCM_RAM_DW)\n  ) u_itcm_ram (\n    .sd(itcm_ram_sd),\n    .ds(itcm_ram_ds),\n    .ls(itcm_ram_ls),\n    .cs(itcm_ram_cs),\n    .we(itcm_ram_we),\n    .addr(itcm_ram_addr),\n    .wem(itcm_ram_wem),\n    .din(itcm_ram_din),\n    .dout(itcm_ram_dout),\n    .clk(clk_itcm_ram),\n    .rst_n(rst_itcm)\n  );\n`endif\n\n`ifdef E203_HAS_DTCM\n  e203_dtcm_ram #(\n    .AW(E203_DTCM_RAM_AW),\n    .MW(E203_DTCM_RAM_MW),\n    .DW(E203_DTCM_RAM_DW)\n  ) u_dtcm_ram (\n    .sd(dtcm_ram_sd),\n    .ds(dtcm_ram_ds),\n    .ls(dtcm_ram_ls),\n    .cs(dtcm_ram_cs),\n    .we(dtcm_ram_we),\n    .addr(dtcm_ram_addr),\n    .wem(dtcm_ram_wem),\n    .din(dtcm_ram_din),\n    .dout(dtcm_ram_dout),\n    .clk(clk_dtcm_ram),\n    .rst_n(rst_dtcm)\n  );\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 5, "code": "module e203_biu(\n    input wire clk,\n    input wire rst_n,\n    output wire biu_active,\n\n    // ICB interface to LSU\n    input wire lsu_icb_cmd_valid,\n    output wire lsu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] lsu_icb_cmd_addr,\n    input wire lsu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] lsu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] lsu_icb_cmd_wmask,\n    input wire [1:0] lsu_icb_cmd_burst,\n    input wire [1:0] lsu_icb_cmd_beat,\n    input wire lsu_icb_cmd_lock,\n    input wire lsu_icb_cmd_excl,\n    input wire [1:0] lsu_icb_cmd_size,\n    output wire lsu_icb_rsp_valid,\n    input wire lsu_icb_rsp_ready,\n    output wire lsu_icb_rsp_err,\n    output wire lsu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] lsu_icb_rsp_rdata,\n\n    // ICB interface to IFU\n    input wire ifu_icb_cmd_valid,\n    output wire ifu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] ifu_icb_cmd_addr,\n    input wire ifu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ifu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] ifu_icb_cmd_wmask,\n    input wire [1:0] ifu_icb_cmd_burst,\n    input wire [1:0] ifu_icb_cmd_beat,\n    input wire ifu_icb_cmd_lock,\n    input wire ifu_icb_cmd_excl,\n    input wire [1:0] ifu_icb_cmd_size,\n    output wire ifu_icb_rsp_valid,\n    input wire ifu_icb_rsp_ready,\n    output wire ifu_icb_rsp_err,\n    output wire ifu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] ifu_icb_rsp_rdata,\n\n    // ICB interface to PPI\n    input wire ppi_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] ppi_region_indic,\n\n    // ICB interface to CLINT\n    input wire clint_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] clint_region_indic,\n\n    // ICB interface to PLIC\n    input wire plic_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] plic_region_indic,\n\n    // ICB interface to FIO\n    input wire fio_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] fio_region_indic,\n\n    // ICB interface to MEM\n    input wire mem_icb_enable\n);\n\n    // Internal signals for arbitration and splitting\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_valid;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_ready;\n    wire [BIU_ARBT_I_NUM*E203_ADDR_SIZE-1:0] arbt_icb_cmd_addr;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_read;\n    wire [BIU_ARBT_I_NUM*E203_XLEN-1:0] arbt_icb_cmd_wdata;\n    wire [BIU_ARBT_I_NUM*(E203_XLEN/8)-1:0] arbt_icb_cmd_wmask;\n    wire [BIU_ARBT_I_NUM*2-1:0] arbt_icb_cmd_burst;\n    wire [BIU_ARBT_I_NUM*2-1:0] arbt_icb_cmd_beat;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_lock;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_excl;\n    wire [BIU_ARBT_I_NUM*2-1:0] arbt_icb_cmd_size;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_valid;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_ready;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_err;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_excl_ok;\n    wire [BIU_ARBT_I_NUM*E203_XLEN-1:0] arbt_icb_rsp_rdata;\n\n    // Instantiate the ICB Arbiter\n    sirv_gnrl_icb_arbt #(\n        .AW(E203_ADDR_SIZE),\n        .DW(E203_XLEN),\n        .ARBT_NUM(BIU_ARBT_I_NUM),\n        .ARBT_PTR_W(BIU_ARBT_I_PTR_W),\n        .USR_W(1),\n        .ARBT_SCHEME(0),\n        .ALLOW_0CYCL_RSP(0),\n        .FIFO_OUTS_NUM(E203_BIU_OUTS_NUM),\n        .FIFO_CUT_READY(E203_BIU_CMD_CUT_READY)\n    ) u_icb_arbt (\n        .clk(clk),\n        .rst_n(rst_n),\n        .i_bus_icb_cmd_valid({ifu_icb_cmd_valid, lsu_icb_cmd_valid}),\n        .i_bus_icb_cmd_ready({ifu_icb_cmd_ready, lsu_icb_cmd_ready}),\n        .i_bus_icb_cmd_addr({ifu_icb_cmd_addr, lsu_icb_cmd_addr}),\n        .i_bus_icb_cmd_read({ifu_icb_cmd_read, lsu_icb_cmd_read}),\n        .i_bus_icb_cmd_wdata({ifu_icb_cmd_wdata, lsu_icb_cmd_wdata}),\n        .i_bus_icb_cmd_wmask({ifu_icb_cmd_wmask, lsu_icb_cmd_wmask}),\n        .i_bus_icb_cmd_burst({ifu_icb_cmd_burst, lsu_icb_cmd_burst}),\n        .i_bus_icb_cmd_beat({ifu_icb_cmd_beat, lsu_icb_cmd_beat}),\n        .i_bus_icb_cmd_lock({ifu_icb_cmd_lock, lsu_icb_cmd_lock}),\n        .i_bus_icb_cmd_excl({ifu_icb_cmd_excl, lsu_icb_cmd_excl}),\n        .i_bus_icb_cmd_size({ifu_icb_cmd_size, lsu_icb_cmd_size}),\n        .o_bus_icb_rsp_valid({ifu_icb_rsp_valid, lsu_icb_rsp_valid}),\n        .o_bus_icb_rsp_ready({ifu_icb_rsp_ready, lsu_icb_rsp_ready}),\n        .o_bus_icb_rsp_err({ifu_icb_rsp_err, lsu_icb_rsp_err}),\n        .o_bus_icb_rsp_excl_ok({ifu_icb_rsp_excl_ok, lsu_icb_rsp_excl_ok}),\n        .o_bus_icb_rsp_rdata({ifu_icb_rsp_rdata, lsu_icb_rsp_rdata})\n    );\n\n    // Additional logic for BIU operation, splitting, buffering, and interfacing with peripherals would be here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 13, "code": "module e203_cpu_top(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire tcm_sd,\n    input wire tcm_ds,\n    input wire [E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input wire ext2itcm_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ext2itcm_icb_cmd_wdata,\n    input wire [E203_XLEN/8-1:0] ext2itcm_icb_cmd_wmask,\n    input wire ext2itcm_icb_cmd_valid,\n    input wire ext2itcm_icb_rsp_ready,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire dbg_irq_r,\n    output wire ext2itcm_icb_cmd_ready,\n    output wire [E203_XLEN-1:0] ext2itcm_icb_rsp_rdata,\n    output wire ext2itcm_icb_rsp_valid,\n    output wire ext2itcm_icb_rsp_err\n);\n\n    // Core instantiation\n    e203_cpu core (\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ext_irq_a(ext_irq_a),\n        .sft_irq_a(sft_irq_a),\n        .tmr_irq_a(tmr_irq_a),\n        .inspect_pc(inspect_pc),\n        .inspect_dbg_irq(inspect_dbg_irq),\n        .inspect_mem_cmd_valid(inspect_mem_cmd_valid),\n        .inspect_mem_cmd_ready(inspect_mem_cmd_ready),\n        .inspect_mem_rsp_valid(inspect_mem_rsp_valid),\n        .inspect_mem_rsp_ready(inspect_mem_rsp_ready),\n        .inspect_core_clk(inspect_core_clk),\n        .core_csr_clk(core_csr_clk),\n        .core_wfi(core_wfi),\n        .tm_stop(tm_stop),\n        .dbg_irq_r(dbg_irq_r)\n    );\n\n    // SRAMs instantiation\n    e203_srams srams (\n        .clk(clk),\n        .rst_n(rst_n),\n        .tcm_sd(tcm_sd),\n        .tcm_ds(tcm_ds),\n        .ext2itcm_icb_cmd_addr(ext2itcm_icb_cmd_addr),\n        .ext2itcm_icb_cmd_read(ext2itcm_icb_cmd_read),\n        .ext2itcm_icb_cmd_wdata(ext2itcm_icb_cmd_wdata),\n        .ext2itcm_icb_cmd_wmask(ext2itcm_icb_cmd_wmask),\n        .ext2itcm_icb_cmd_valid(ext2itcm_icb_cmd_valid),\n        .ext2itcm_icb_rsp_ready(ext2itcm_icb_rsp_ready),\n        .ext2itcm_icb_cmd_ready(ext2itcm_icb_cmd_ready),\n        .ext2itcm_icb_rsp_rdata(ext2itcm_icb_rsp_rdata),\n        .ext2itcm_icb_rsp_valid(ext2itcm_icb_rsp_valid),\n        .ext2itcm_icb_rsp_err(ext2itcm_icb_rsp_err)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 15, "code": "module e203_core(\n    input  wire        clk,\n    input  wire        rst_n,\n    input  wire [31:0] pc_rtvec,\n    input  wire        core_mhartid,\n    input  wire        dbg_irq_r,\n    input  wire [15:0] lcl_irq_r,\n    input  wire [31:0] evt_r,\n    input  wire        ext_irq_r,\n    input  wire        sft_irq_r,\n    input  wire        tmr_irq_r,\n    output wire        core_wfi,\n    output wire        tm_stop,\n    output wire        core_cgstop,\n    output wire        tcm_cgstop,\n    output wire [31:0] inspect_pc,\n    output wire        wr_dcsr_ena,\n    output wire        wr_dpc_ena,\n    output wire        wr_dscratch_ena,\n    output wire [31:0] wr_csr_nxt,\n    input  wire [31:0] dcsr_r,\n    input  wire [31:0] dpc_r,\n    input  wire [31:0] dscratch_r,\n    output wire [31:0] cmt_dpc,\n    output wire        cmt_dpc_ena,\n    output wire [2:0]  cmt_dcause,\n    output wire        cmt_dcause_ena,\n    input  wire        dbg_mode,\n    input  wire        dbg_halt_r,\n    input  wire        dbg_step_r,\n    input  wire        dbg_ebreakm_r,\n    input  wire        dbg_stopcycle\n);\n\n    // Internal signals\n    wire ifu_active;\n    wire lsu_active;\n    wire exu_active;\n    wire biu_active;\n\n    // Instantiate IFU\n    e203_ifu u_ifu (\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .inspect_pc(inspect_pc),\n        .ifu_active(ifu_active)\n    );\n\n    // Instantiate EXU\n    e203_exu u_exu (\n        .clk(clk),\n        .rst_n(rst_n),\n        .core_mhartid(core_mhartid),\n        .dbg_irq_r(dbg_irq_r),\n        .lcl_irq_r(lcl_irq_r),\n        .evt_r(evt_r),\n        .ext_irq_r(ext_irq_r),\n        .sft_irq_r(sft_irq_r),\n        .tmr_irq_r(tmr_irq_r),\n        .core_wfi(core_wfi),\n        .tm_stop(tm_stop),\n        .core_cgstop(core_cgstop),\n        .tcm_cgstop(tcm_cgstop),\n        .exu_active(exu_active)\n    );\n\n    // Instantiate LSU\n    e203_lsu u_lsu (\n        .clk(clk),\n        .rst_n(rst_n),\n        .lsu_active(lsu_active)\n    );\n\n    // Instantiate BIU\n    e203_biu u_biu (\n        .clk(clk),\n        .rst_n(rst_n),\n        .biu_active(biu_active)\n    );\n\n    // Control and status register logic\n    assign wr_dcsr_ena = dbg_mode;\n    assign wr_dpc_ena = dbg_mode;\n    assign wr_dscratch_ena = dbg_mode;\n    assign wr_csr_nxt = {32{dbg_mode}} & dscratch_r; // Example logic\n\n    // Debug and exception handling\n    assign cmt_dpc = dpc_r;\n    assign cmt_dpc_ena = dbg_halt_r;\n    assign cmt_dcause = 3'b000; // Example cause\n    assign cmt_dcause_ena = dbg_halt_r;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 6, "code": "module e203_srams #(\n  parameter E203_ITCM_RAM_AW = 12,\n  parameter E203_ITCM_RAM_MW = 4,\n  parameter E203_ITCM_RAM_DW = 32,\n  parameter E203_DTCM_RAM_AW = 12,\n  parameter E203_DTCM_RAM_MW = 4,\n  parameter E203_DTCM_RAM_DW = 32\n)(\n  input itcm_ram_sd,\n  input itcm_ram_ds,\n  input itcm_ram_ls,\n  input itcm_ram_cs,\n  input itcm_ram_we,\n  input [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n  input [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n  input [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n  output [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n  input clk_itcm_ram,\n  input rst_itcm,\n\n  input dtcm_ram_sd,\n  input dtcm_ram_ds,\n  input dtcm_ram_ls,\n  input dtcm_ram_cs,\n  input dtcm_ram_we,\n  input [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n  input [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n  input [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n  output [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n  input clk_dtcm_ram,\n  input rst_dtcm\n);\n\n`ifdef E203_HAS_ITCM\n  // ITCM instantiation\n  ram #(\n    .ADDR_WIDTH(E203_ITCM_RAM_AW),\n    .DATA_WIDTH(E203_ITCM_RAM_DW),\n    .MASK_WIDTH(E203_ITCM_RAM_MW)\n  ) itcm_ram (\n    .clk(clk_itcm_ram),\n    .rst(rst_itcm),\n    .cs(itcm_ram_cs),\n    .we(itcm_ram_we),\n    .addr(itcm_ram_addr),\n    .wem(itcm_ram_wem),\n    .din(itcm_ram_din),\n    .dout(itcm_ram_dout),\n    .sd(itcm_ram_sd),\n    .ds(itcm_ram_ds),\n    .ls(itcm_ram_ls)\n  );\n`endif\n\n`ifdef E203_HAS_DTCM\n  // DTCM instantiation\n  ram #(\n    .ADDR_WIDTH(E203_DTCM_RAM_AW),\n    .DATA_WIDTH(E203_DTCM_RAM_DW),\n    .MASK_WIDTH(E203_DTCM_RAM_MW)\n  ) dtcm_ram (\n    .clk(clk_dtcm_ram),\n    .rst(rst_dtcm),\n    .cs(dtcm_ram_cs),\n    .we(dtcm_ram_we),\n    .addr(dtcm_ram_addr),\n    .wem(dtcm_ram_wem),\n    .din(dtcm_ram_din),\n    .dout(dtcm_ram_dout),\n    .sd(dtcm_ram_sd),\n    .ds(dtcm_ram_ds),\n    .ls(dtcm_ram_ls)\n  );\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 3, "code": "module e203_exu_alu_bjp (\n    input wire bjp_i_valid,\n    output wire bjp_i_ready,\n    input wire [E203_XLEN-1:0] bjp_i_rs1,\n    input wire [E203_XLEN-1:0] bjp_i_rs2,\n    input wire [E203_XLEN-1:0] bjp_i_imm,\n    input wire [E203_PC_SIZE-1:0] bjp_i_pc,\n    input wire [E203_DECINFO_BJP_WIDTH-1:0] bjp_i_info,\n    output wire bjp_o_valid,\n    input wire bjp_o_ready,\n    output wire [E203_XLEN-1:0] bjp_o_wbck_wdat,\n    output wire bjp_o_wbck_err,\n    output wire bjp_o_cmt_bjp,\n    output wire bjp_o_cmt_mret,\n    output wire bjp_o_cmt_dret,\n    output wire bjp_o_cmt_fencei,\n    output wire bjp_o_cmt_prdt,\n    output wire bjp_o_cmt_rslv,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    output wire bjp_req_alu_cmp_eq,\n    output wire bjp_req_alu_cmp_ne,\n    output wire bjp_req_alu_cmp_lt,\n    output wire bjp_req_alu_cmp_gt,\n    output wire bjp_req_alu_cmp_ltu,\n    output wire bjp_req_alu_cmp_gtu,\n    output wire bjp_req_alu_add,\n    input wire bjp_req_alu_cmp_res,\n    input wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    input wire clk,\n    input wire rst_n\n);\n\n// Handshake mechanism\nassign bjp_i_ready = bjp_o_ready;\nassign bjp_o_valid = bjp_i_valid;\n\n// Operand selection\nassign bjp_req_alu_op1 = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? bjp_i_pc : bjp_i_rs1;\nassign bjp_req_alu_op2 = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? E203_XLEN'(4) : bjp_i_rs2;\n\n// ALU operation requests\nassign bjp_req_alu_cmp_eq  = bjp_i_info[E203_DECINFO_BJP_BEQ];\nassign bjp_req_alu_cmp_ne  = bjp_i_info[E203_DECINFO_BJP_BNE];\nassign bjp_req_alu_cmp_lt  = bjp_i_info[E203_DECINFO_BJP_BLT];\nassign bjp_req_alu_cmp_gt  = bjp_i_info[E203_DECINFO_BJP_BGT];\nassign bjp_req_alu_cmp_ltu = bjp_i_info[E203_DECINFO_BJP_BLTU];\nassign bjp_req_alu_cmp_gtu = bjp_i_info[E203_DECINFO_BJP_BGTU];\nassign bjp_req_alu_add     = bjp_i_info[E203_DECINFO_BJP_JUMP];\n\n// Commit signals\nassign bjp_o_cmt_bjp    = bjp_i_info[E203_DECINFO_BJP_BXX] | bjp_i_info[E203_DECINFO_BJP_JUMP];\nassign bjp_o_cmt_mret   = bjp_i_info[E203_DECINFO_BJP_MRET];\nassign bjp_o_cmt_dret   = bjp_i_info[E203_DECINFO_BJP_DRET];\nassign bjp_o_cmt_fencei = bjp_i_info[E203_DECINFO_BJP_FENCEI];\n\n// Predicted and resolved results\nassign bjp_o_cmt_prdt = bjp_i_info[E203_DECINFO_BJP_BPRDT];\nassign bjp_o_cmt_rslv = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? 1'b1 : bjp_req_alu_cmp_res;\n\n// Write-back data and error\nassign bjp_o_wbck_wdat = bjp_req_alu_add_res;\nassign bjp_o_wbck_err = 1'b0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 16, "code": "module e203_core (\n    // System Interface\n    output [E203_PC_SIZE-1:0] inspect_pc,\n    output core_wfi,\n    output tm_stop,\n    output core_cgstop,\n    output tcm_cgstop,\n    input [E203_PC_SIZE-1:0] pc_rtvec,\n    input [E203_HART_ID_W-1:0] core_mhartid,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    output wr_dcsr_ena,\n    output wr_dpc_ena,\n    output wr_dscratch_ena,\n    output [31:0] wr_csr_nxt,\n    input [31:0] dcsr_r,\n    input [E203_PC_SIZE-1:0] dpc_r,\n    input [31:0] dscratch_r,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input dbg_stopcycle,\n\n    // ICB Protocol Interface\n    input *_icb_enable,\n    output *_icb_cmd_valid,\n    input *_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] *_icb_cmd_addr,\n    output *_icb_cmd_read,\n    output [E203_XLEN-1:0] *_icb_cmd_wdata,\n    output [E203_XLEN/8-1:0] *_icb_cmd_wmask,\n    output *_icb_cmd_lock,\n    output *_icb_cmd_excl,\n    output [1:0] *_icb_cmd_size,\n    input *_icb_rsp_valid,\n    output *_icb_rsp_ready,\n    input *_icb_rsp_err,\n    input *_icb_rsp_excl_ok,\n    input [E203_XLEN-1:0] *_icb_rsp_rdata,\n\n    // NICE Interface\n    input nice_mem_holdup,\n    output nice_req_valid,\n    input nice_req_ready,\n    output [E203_XLEN-1:0] nice_req_inst,\n    output [E203_XLEN-1:0] nice_req_rs1,\n    output [E203_XLEN-1:0] nice_req_rs2,\n    input nice_rsp_multicyc_valid,\n    output nice_rsp_multicyc_ready,\n    input [E203_XLEN-1:0] nice_rsp_multicyc_dat,\n    input nice_rsp_multicyc_err,\n    input nice_icb_cmd_valid,\n    output nice_icb_cmd_ready,\n    input [E203_XLEN-1:0] nice_icb_cmd_addr,\n    input nice_icb_cmd_read,\n    input [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input [1:0] nice_icb_cmd_size,\n    output nice_icb_rsp_valid,\n    input nice_icb_rsp_ready,\n    output [E203_XLEN-1:0] nice_icb_rsp_rdata,\n    output nice_icb_rsp_err\n);\n    // Core implementation details would be here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 17, "code": "module e203_core (\n    input  wire        clk,\n    input  wire        rst_n,\n    input  wire [31:0] pc_rtvec,\n    input  wire [31:0] core_mhartid,\n    input  wire        dbg_irq_r,\n    input  wire [15:0] lcl_irq_r,\n    input  wire [31:0] evt_r,\n    input  wire        ext_irq_r,\n    input  wire        sft_irq_r,\n    input  wire        tmr_irq_r,\n    input  wire        dbg_mode,\n    input  wire        dbg_halt_r,\n    input  wire        dbg_step_r,\n    input  wire        dbg_ebreakm_r,\n    input  wire        dbg_stopcycle,\n    input  wire [31:0] dcsr_r,\n    input  wire [31:0] dpc_r,\n    input  wire [31:0] dscratch_r,\n    output wire [31:0] inspect_pc,\n    output wire        core_wfi,\n    output wire        tm_stop,\n    output wire        core_cgstop,\n    output wire        tcm_cgstop,\n    output wire        wr_dcsr_ena,\n    output wire        wr_dpc_ena,\n    output wire        wr_dscratch_ena,\n    output wire [31:0] wr_csr_nxt,\n    output wire [31:0] cmt_dpc,\n    output wire        cmt_dpc_ena,\n    output wire [2:0]  cmt_dcause,\n    output wire        cmt_dcause_ena\n);\n\n    // Internal signals for core logic\n    wire [31:0] next_pc;\n    wire        fetch_valid;\n    wire        decode_valid;\n    wire        execute_valid;\n    wire        load_store_valid;\n    wire        write_back_valid;\n    wire [31:0] fetched_instr;\n    wire [31:0] decoded_instr;\n    wire [31:0] executed_data;\n    wire [31:0] load_data;\n    wire [31:0] write_back_data;\n    wire        exception_flag;\n    wire [2:0]  exception_cause;\n\n    // Instruction Fetch Unit (IFU)\n    e203_ifu u_ifu (\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .fetch_valid(fetch_valid),\n        .fetched_instr(fetched_instr),\n        .next_pc(next_pc)\n    );\n\n    // Instruction Decode Unit (IDU)\n    e203_idu u_idu (\n        .clk(clk),\n        .rst_n(rst_n),\n        .fetched_instr(fetched_instr),\n        .decode_valid(decode_valid),\n        .decoded_instr(decoded_instr)\n    );\n\n    // Execution Unit (EXU)\n    e203_exu u_exu (\n        .clk(clk),\n        .rst_n(rst_n),\n        .decoded_instr(decoded_instr),\n        .execute_valid(execute_valid),\n        .executed_data(executed_data),\n        .exception_flag(exception_flag),\n        .exception_cause(exception_cause)\n    );\n\n    // Load/Store Unit (LSU)\n    e203_lsu u_lsu (\n        .clk(clk),\n        .rst_n(rst_n),\n        .executed_data(executed_data),\n        .load_store_valid(load_store_valid),\n        .load_data(load_data)\n    );\n\n    // Write Back Unit (WBU)\n    e203_wbu u_wbu (\n        .clk(clk),\n        .rst_n(rst_n),\n        .load_data(load_data),\n        .write_back_valid(write_back_valid),\n        .write_back_data(write_back_data)\n    );\n\n    // Exception and Interrupt Management\n    e203_eiu u_eiu (\n        .clk(clk),\n        .rst_n(rst_n),\n        .exception_flag(exception_flag),\n        .exception_cause(exception_cause),\n        .ext_irq_r(ext_irq_r),\n        .sft_irq_r(sft_irq_r),\n        .tmr_irq_r(tmr_irq_r),\n        .cmt_dcause(cmt_dcause),\n        .cmt_dcause_ena(cmt_dcause_ena)\n    );\n\n    // Debug and Control\n    e203_dbg u_dbg (\n        .clk(clk),\n        .rst_n(rst_n),\n        .dbg_mode(dbg_mode),\n        .dbg_halt_r(dbg_halt_r),\n        .dbg_step_r(dbg_step_r),\n        .dbg_ebreakm_r(dbg_ebreakm_r),\n        .dbg_stopcycle(dbg_stopcycle),\n        .dcsr_r(dcsr_r),\n        .dpc_r(dpc_r),\n        .dscratch_r(dscratch_r),\n        .wr_dcsr_ena(wr_dcsr_ena),\n        .wr_dpc_ena(wr_dpc_ena),\n        .wr_dscratch_ena(wr_dscratch_ena),\n        .wr_csr_nxt(wr_csr_nxt)\n    );\n\n    // Output assignments\n    assign inspect_pc = next_pc;\n    assign core_wfi = (execute_valid && decoded_instr == 32'h10500073); // WFI instruction code\n    assign tm_stop = dbg_stopcycle;\n    assign core_cgstop = !clk; // Example: stop clock gating when clock is not active\n    assign tcm_cgstop = !clk; // Example: stop TCM clock gating when clock is not active\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 18, "code": "module e203_core (\n    input wire clk,\n    input wire rst_n,\n\n    // System Interface\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire core_cgstop,\n    output wire tcm_cgstop,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire [E203_HART_ID_W-1:0] core_mhartid,\n    input wire dbg_irq_r,\n    input wire [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input wire [E203_EVT_NUM-1:0] evt_r,\n    input wire ext_irq_r,\n    input wire sft_irq_r,\n    input wire tmr_irq_r,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    output wire [31:0] wr_csr_nxt,\n    input wire [31:0] dcsr_r,\n    input wire [E203_PC_SIZE-1:0] dpc_r,\n    input wire [31:0] dscratch_r,\n    output wire [E203_PC_SIZE-1:0] cmt_dpc,\n    output wire cmt_dpc_ena,\n    output wire [2:0] cmt_dcause,\n    output wire cmt_dcause_ena,\n    input wire dbg_mode,\n    input wire dbg_halt_r,\n    input wire dbg_step_r,\n    input wire dbg_ebreakm_r,\n    input wire dbg_stopcycle,\n\n    // ICB Protocol Interface\n    input wire icb_enable,\n    output wire icb_cmd_valid,\n    input wire icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] icb_cmd_addr,\n    output wire icb_cmd_read,\n    output wire [E203_XLEN-1:0] icb_cmd_wdata,\n    output wire [E203_XLEN/8-1:0] icb_cmd_wmask,\n    output wire icb_cmd_lock,\n    output wire icb_cmd_excl,\n    output wire [1:0] icb_cmd_size,\n    input wire icb_rsp_valid,\n    output wire icb_rsp_ready,\n    input wire icb_rsp_err,\n    input wire icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] icb_rsp_rdata,\n\n    // NICE Interface\n    input wire nice_mem_holdup,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_inst,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    input wire [E203_XLEN-1:0] nice_rsp_multicyc_dat,\n    input wire nice_rsp_multicyc_err,\n    input wire nice_icb_cmd_valid,\n    output wire nice_icb_cmd_ready,\n    input wire [E203_XLEN-1:0] nice_icb_cmd_addr,\n    input wire nice_icb_cmd_read,\n    input wire [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input wire [1:0] nice_icb_cmd_size,\n    output wire nice_icb_rsp_valid,\n    input wire nice_icb_rsp_ready,\n    output wire [E203_XLEN-1:0] nice_icb_rsp_rdata,\n    output wire nice_icb_rsp_err\n);\n    // Core implementation details would be here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 2, "code": "module e203_exu_regfile (\n    input  wire                     clk,\n    input  wire                     rst_n,\n    input  wire [E203_RFIDX_WIDTH-1:0] read_src1_idx,\n    input  wire [E203_RFIDX_WIDTH-1:0] read_src2_idx,\n    output wire [E203_XLEN-1:0]     read_src1_dat,\n    output wire [E203_XLEN-1:0]     read_src2_dat,\n    input  wire                     wbck_dest_wen,\n    input  wire [E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n    input  wire [E203_XLEN-1:0]     wbck_dest_dat,\n    output wire [E203_XLEN-1:0]     x1_r,\n    input  wire                     test_mode\n);\n\n`include \"e203_defines.v\"\n\n// Register file storage\nreg [E203_XLEN-1:0] regfile [0:E203_RFREG_NUM-1];\n\n// Read logic\nassign read_src1_dat = (read_src1_idx == 0) ? 0 : regfile[read_src1_idx];\nassign read_src2_dat = (read_src2_idx == 0) ? 0 : regfile[read_src2_idx];\n\n// Write logic\nalways @(posedge clk) begin\n    if (wbck_dest_wen && wbck_dest_idx != 0) begin\n        regfile[wbck_dest_idx] <= wbck_dest_dat;\n    end\nend\n\n// Special register x1 output\nassign x1_r = regfile[1];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 14, "code": "module e203_cpu_top(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire tcm_sd,\n    input wire tcm_ds,\n    input wire [E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input wire ext2itcm_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ext2itcm_icb_cmd_wdata,\n    input wire [E203_XLEN/8-1:0] ext2itcm_icb_cmd_wmask,\n    input wire ext2itcm_icb_cmd_valid,\n    input wire ext2itcm_icb_rsp_ready,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire dbg_irq_r,\n    output wire ext2itcm_icb_cmd_ready,\n    output wire [E203_XLEN-1:0] ext2itcm_icb_rsp_rdata,\n    output wire ext2itcm_icb_rsp_valid,\n    output wire ext2itcm_icb_rsp_err\n);\n\n    // Core instantiation\n    e203_cpu u_e203_cpu(\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ext_irq_a(ext_irq_a),\n        .sft_irq_a(sft_irq_a),\n        .tmr_irq_a(tmr_irq_a),\n        .inspect_pc(inspect_pc),\n        .inspect_dbg_irq(inspect_dbg_irq),\n        .inspect_mem_cmd_valid(inspect_mem_cmd_valid),\n        .inspect_mem_cmd_ready(inspect_mem_cmd_ready),\n        .inspect_mem_rsp_valid(inspect_mem_rsp_valid),\n        .inspect_mem_rsp_ready(inspect_mem_rsp_ready),\n        .inspect_core_clk(inspect_core_clk),\n        .core_csr_clk(core_csr_clk),\n        .core_wfi(core_wfi),\n        .tm_stop(tm_stop),\n        .dbg_irq_r(dbg_irq_r)\n    );\n\n    // SRAM controller instantiation\n    e203_srams u_e203_srams(\n        .clk(clk),\n        .rst_n(rst_n),\n        .tcm_sd(tcm_sd),\n        .tcm_ds(tcm_ds),\n        .ext2itcm_icb_cmd_addr(ext2itcm_icb_cmd_addr),\n        .ext2itcm_icb_cmd_read(ext2itcm_icb_cmd_read),\n        .ext2itcm_icb_cmd_wdata(ext2itcm_icb_cmd_wdata),\n        .ext2itcm_icb_cmd_wmask(ext2itcm_icb_cmd_wmask),\n        .ext2itcm_icb_cmd_valid(ext2itcm_icb_cmd_valid),\n        .ext2itcm_icb_rsp_ready(ext2itcm_icb_rsp_ready),\n        .ext2itcm_icb_cmd_ready(ext2itcm_icb_cmd_ready),\n        .ext2itcm_icb_rsp_rdata(ext2itcm_icb_rsp_rdata),\n        .ext2itcm_icb_rsp_valid(ext2itcm_icb_rsp_valid),\n        .ext2itcm_icb_rsp_err(ext2itcm_icb_rsp_err)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 4, "code": "module e203_exu_alu_bjp (\n    input wire bjp_i_valid,\n    output wire bjp_i_ready,\n    input wire [E203_XLEN-1:0] bjp_i_rs1,\n    input wire [E203_XLEN-1:0] bjp_i_rs2,\n    input wire [E203_XLEN-1:0] bjp_i_imm,\n    input wire [E203_PC_SIZE-1:0] bjp_i_pc,\n    input wire [E203_DECINFO_BJP_WIDTH-1:0] bjp_i_info,\n    output wire bjp_o_valid,\n    input wire bjp_o_ready,\n    output wire [E203_XLEN-1:0] bjp_o_wbck_wdat,\n    output wire bjp_o_wbck_err,\n    output wire bjp_o_cmt_bjp,\n    output wire bjp_o_cmt_mret,\n    output wire bjp_o_cmt_dret,\n    output wire bjp_o_cmt_fencei,\n    output wire bjp_o_cmt_prdt,\n    output wire bjp_o_cmt_rslv,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    output wire bjp_req_alu_cmp_eq,\n    output wire bjp_req_alu_cmp_ne,\n    output wire bjp_req_alu_cmp_lt,\n    output wire bjp_req_alu_cmp_gt,\n    output wire bjp_req_alu_cmp_ltu,\n    output wire bjp_req_alu_cmp_gtu,\n    output wire bjp_req_alu_add,\n    input wire bjp_req_alu_cmp_res,\n    input wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Handshake signals\n    assign bjp_i_ready = bjp_o_ready;\n    assign bjp_o_valid = bjp_i_valid;\n\n    // Default assignments\n    assign bjp_o_wbck_err = 1'b0;\n    assign bjp_o_wbck_wdat = bjp_req_alu_add_res;\n\n    // Commit signals\n    assign bjp_o_cmt_bjp = bjp_i_info[E203_DECINFO_BJP_BXX] | bjp_i_info[E203_DECINFO_BJP_JUMP];\n    assign bjp_o_cmt_mret = bjp_i_info[E203_DECINFO_BJP_MRET];\n    assign bjp_o_cmt_dret = bjp_i_info[E203_DECINFO_BJP_DRET];\n    assign bjp_o_cmt_fencei = bjp_i_info[E203_DECINFO_BJP_FENCEI];\n\n    // ALU operation requests\n    assign bjp_req_alu_cmp_eq = bjp_i_info[E203_DECINFO_BJP_BEQ];\n    assign bjp_req_alu_cmp_ne = bjp_i_info[E203_DECINFO_BJP_BNE];\n    assign bjp_req_alu_cmp_lt = bjp_i_info[E203_DECINFO_BJP_BLT];\n    assign bjp_req_alu_cmp_gt = bjp_i_info[E203_DECINFO_BJP_BGT];\n    assign bjp_req_alu_cmp_ltu = bjp_i_info[E203_DECINFO_BJP_BLTU];\n    assign bjp_req_alu_cmp_gtu = bjp_i_info[E203_DECINFO_BJP_BGTU];\n    assign bjp_req_alu_add = bjp_i_info[E203_DECINFO_BJP_JUMP];\n\n    // Operand selection\n    assign bjp_req_alu_op1 = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? bjp_i_pc : bjp_i_rs1;\n    assign bjp_req_alu_op2 = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? bjp_i_imm : bjp_i_rs2;\n\n    // Resolved and predicted results\n    assign bjp_o_cmt_prdt = bjp_i_info[E203_DECINFO_BJP_BPRDT];\n    assign bjp_o_cmt_rslv = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? 1'b1 : bjp_req_alu_cmp_res;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 3, "code": "module e203_exu_alu_muldiv(\n    input mdv_nob2b,\n    input muldiv_i_valid,\n    output reg muldiv_i_ready,\n    input [E203_XLEN-1:0] muldiv_i_rs1,\n    input [E203_XLEN-1:0] muldiv_i_rs2,\n    input [E203_XLEN-1:0] muldiv_i_imm,\n    input [E203_DECINFO_MULDIV_WIDTH-1:0] muldiv_i_info,\n    input [E203_ITAG_WIDTH-1:0] muldiv_i_itag,\n    output reg muldiv_i_longpipe,\n    input flush_pulse,\n    output reg muldiv_o_valid,\n    input muldiv_o_ready,\n    output reg [E203_XLEN-1:0] muldiv_o_wbck_wdat,\n    output reg muldiv_o_wbck_err,\n    output reg [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    output reg [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    output reg muldiv_req_alu_add,\n    output reg muldiv_req_alu_sub,\n    input [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output reg muldiv_sbf_0_ena,\n    output reg [32:0] muldiv_sbf_0_nxt,\n    input [32:0] muldiv_sbf_0_r,\n    output reg muldiv_sbf_1_ena,\n    output reg [32:0] muldiv_sbf_1_nxt,\n    input [32:0] muldiv_sbf_1_r,\n    input clk,\n    input rst_n\n);\n\n// Internal signals\nreg [4:0] state;\nlocalparam MULDIV_STATE_0TH = 0,\n           MULDIV_STATE_EXEC = 1,\n           MULDIV_STATE_REMD_CHCK = 2,\n           MULDIV_STATE_QUOT_CORR = 3,\n           MULDIV_STATE_REMD_CORR = 4;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        state <= MULDIV_STATE_0TH;\n        muldiv_i_ready <= 1'b0;\n        muldiv_o_valid <= 1'b0;\n        muldiv_o_wbck_wdat <= {E203_XLEN{1'b0}};\n        muldiv_o_wbck_err <= 1'b0;\n    end else begin\n        case (state)\n            MULDIV_STATE_0TH: begin\n                if (muldiv_i_valid && muldiv_i_ready) begin\n                    state <= MULDIV_STATE_EXEC;\n                    muldiv_i_ready <= 1'b0;\n                end\n            end\n            MULDIV_STATE_EXEC: begin\n                if (/* execution complete */) begin\n                    state <= MULDIV_STATE_REMD_CHCK;\n                    muldiv_o_valid <= 1'b1;\n                end\n            end\n            MULDIV_STATE_REMD_CHCK: begin\n                if (/* remainder check */) begin\n                    state <= MULDIV_STATE_QUOT_CORR;\n                end else begin\n                    state <= MULDIV_STATE_0TH;\n                    muldiv_o_valid <= 1'b0;\n                end\n            end\n            MULDIV_STATE_QUOT_CORR: begin\n                state <= MULDIV_STATE_REMD_CORR;\n            end\n            MULDIV_STATE_REMD_CORR: begin\n                state <= MULDIV_STATE_0TH;\n                muldiv_o_valid <= 1'b0;\n            end\n        endcase\n\n        if (flush_pulse) begin\n            state <= MULDIV_STATE_0TH;\n            muldiv_o_valid <= 1'b0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 4, "code": "module e203_exu_branchslv(\n    input wire cmt_i_valid,\n    output wire cmt_i_ready,\n    input wire cmt_i_rv32,\n    input wire cmt_i_dret,\n    input wire cmt_i_mret,\n    input wire cmt_i_fencei,\n    input wire cmt_i_bjp,\n    input wire cmt_i_bjp_prdt,\n    input wire cmt_i_bjp_rslv,\n    input wire [E203_PC_SIZE-1:0] cmt_i_pc,\n    input wire [E203_XLEN-1:0] cmt_i_imm,\n    input wire [E203_PC_SIZE-1:0] csr_epc_r,\n    input wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    input wire nonalu_excpirq_flush_req_raw,\n    input wire brchmis_flush_ack,\n    output wire brchmis_flush_req,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op1,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op2,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_pc,\n    output wire cmt_mret_ena,\n    output wire cmt_dret_ena,\n    output wire cmt_fencei_ena,\n    input wire clk,\n    input wire rst_n\n);\n\n    wire flush_need;\n    wire flush_target_mret;\n    wire flush_target_dret;\n    wire flush_target_fencei;\n    wire flush_target_bjp_mispredict;\n\n    assign flush_target_mret = cmt_i_mret;\n    assign flush_target_dret = cmt_i_dret;\n    assign flush_target_fencei = cmt_i_fencei;\n    assign flush_target_bjp_mispredict = cmt_i_bjp & (cmt_i_bjp_prdt ^ cmt_i_bjp_rslv);\n\n    assign flush_need = (flush_target_mret | flush_target_dret | flush_target_fencei | flush_target_bjp_mispredict) & cmt_i_valid;\n\n    assign brchmis_flush_req = flush_need & ~nonalu_excpirq_flush_req_raw;\n\n    assign cmt_i_ready = ~flush_need | brchmis_flush_ack;\n\n    assign cmt_mret_ena = cmt_i_mret & flush_need;\n    assign cmt_dret_ena = cmt_i_dret & flush_need;\n    assign cmt_fencei_ena = cmt_i_fencei & flush_need;\n\n    // Calculate flush target address\n    always @(*) begin\n        if (cmt_i_fencei | (cmt_i_bjp & cmt_i_bjp_prdt & ~cmt_i_bjp_rslv)) begin\n            brchmis_flush_add_op1 = cmt_i_pc;\n            brchmis_flush_add_op2 = cmt_i_rv32 ? 32'd4 : 32'd2;\n        end else if (cmt_i_bjp & ~cmt_i_bjp_prdt & cmt_i_bjp_rslv) begin\n            brchmis_flush_add_op1 = cmt_i_pc;\n            brchmis_flush_add_op2 = cmt_i_imm[E203_PC_SIZE-1:0];\n        end else if (cmt_i_dret) begin\n            brchmis_flush_pc = csr_dpc_r;\n        end else begin\n            brchmis_flush_pc = csr_epc_r;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 1, "code": "module e203_exu_commit(\n    output commit_mret,\n    output commit_trap,\n    output core_wfi,\n    output nonflush_cmt_ena,\n    output excp_active,\n    input amo_wait,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input alu_cmt_i_valid,\n    output alu_cmt_i_ready,\n    input [E203_PC_SIZE-1:0] alu_cmt_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_cmt_i_instr,\n    input alu_cmt_i_pc_vld,\n    input [E203_XLEN-1:0] alu_cmt_i_imm,\n    input alu_cmt_i_rv32,\n    input alu_cmt_i_bjp,\n    input alu_cmt_i_wfi,\n    input alu_cmt_i_fencei,\n    input alu_cmt_i_mret,\n    input alu_cmt_i_dret,\n    input alu_cmt_i_ecall,\n    input alu_cmt_i_ebreak,\n    input alu_cmt_i_ifu_misalgn,\n    input alu_cmt_i_ifu_buserr,\n    input alu_cmt_i_ifu_ilegl,\n    input alu_cmt_i_bjp_prdt,\n    input alu_cmt_i_bjp_rslv,\n    input alu_cmt_i_misalgn,\n    input alu_cmt_i_ld,\n    input alu_cmt_i_stamo,\n    input alu_cmt_i_buserr,\n    input [E203_ADDR_SIZE-1:0] alu_cmt_i_badaddr,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output cmt_badaddr_ena,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output cmt_epc_ena,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_cause_ena,\n    output cmt_instret_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output cmt_mret_ena,\n    input [E203_PC_SIZE-1:0] csr_epc_r,\n    input [E203_PC_SIZE-1:0] csr_dpc_r,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output longp_excp_i_ready,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input longp_excp_i_insterr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input clk,\n    input rst_n\n);\n    // Module implementation\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 5, "code": "module e203_exu_alu_bjp (\n    input wire bjp_i_valid,\n    output wire bjp_i_ready,\n    input wire [E203_XLEN-1:0] bjp_i_rs1,\n    input wire [E203_XLEN-1:0] bjp_i_rs2,\n    input wire [E203_XLEN-1:0] bjp_i_imm,\n    input wire [E203_PC_SIZE-1:0] bjp_i_pc,\n    input wire [E203_DECINFO_BJP_WIDTH-1:0] bjp_i_info,\n    output wire bjp_o_valid,\n    input wire bjp_o_ready,\n    output wire [E203_XLEN-1:0] bjp_o_wbck_wdat,\n    output wire bjp_o_wbck_err,\n    output wire bjp_o_cmt_bjp,\n    output wire bjp_o_cmt_mret,\n    output wire bjp_o_cmt_dret,\n    output wire bjp_o_cmt_fencei,\n    output wire bjp_o_cmt_prdt,\n    output wire bjp_o_cmt_rslv,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    output wire bjp_req_alu_cmp_eq,\n    output wire bjp_req_alu_cmp_ne,\n    output wire bjp_req_alu_cmp_lt,\n    output wire bjp_req_alu_cmp_gt,\n    output wire bjp_req_alu_cmp_ltu,\n    output wire bjp_req_alu_cmp_gtu,\n    output wire bjp_req_alu_add,\n    input wire bjp_req_alu_cmp_res,\n    input wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    assign bjp_i_ready = bjp_o_ready;\n    assign bjp_o_valid = bjp_i_valid;\n\n    wire is_jump = bjp_i_info[E203_DECINFO_BJP_JUMP];\n    wire is_beq = bjp_i_info[E203_DECINFO_BJP_BEQ];\n    wire is_bne = bjp_i_info[E203_DECINFO_BJP_BNE];\n    wire is_blt = bjp_i_info[E203_DECINFO_BJP_BLT];\n    wire is_bgt = bjp_i_info[E203_DECINFO_BJP_BGT];\n    wire is_bltu = bjp_i_info[E203_DECINFO_BJP_BLTU];\n    wire is_bgtu = bjp_i_info[E203_DECINFO_BJP_BGTU];\n    wire is_mret = bjp_i_info[E203_DECINFO_BJP_MRET];\n    wire is_dret = bjp_i_info[E203_DECINFO_BJP_DRET];\n    wire is_fencei = bjp_i_info[E203_DECINFO_BJP_FENCEI];\n\n    assign bjp_o_cmt_bjp = bjp_i_valid && (is_jump || is_beq || is_bne || is_blt || is_bgt || is_bltu || is_bgtu);\n    assign bjp_o_cmt_mret = is_mret;\n    assign bjp_o_cmt_dret = is_dret;\n    assign bjp_o_cmt_fencei = is_fencei;\n    assign bjp_o_cmt_prdt = bjp_i_info[E203_DECINFO_BJP_BPRDT];\n    assign bjp_o_cmt_rslv = is_jump ? 1'b1 : bjp_req_alu_cmp_res;\n\n    assign bjp_o_wbck_wdat = bjp_req_alu_add_res;\n    assign bjp_o_wbck_err = 1'b0;\n\n    assign bjp_req_alu_op1 = is_jump ? bjp_i_pc : bjp_i_rs1;\n    assign bjp_req_alu_op2 = is_jump ? bjp_i_imm : bjp_i_rs2;\n\n    assign bjp_req_alu_cmp_eq = is_beq;\n    assign bjp_req_alu_cmp_ne = is_bne;\n    assign bjp_req_alu_cmp_lt = is_blt;\n    assign bjp_req_alu_cmp_gt = is_bgt;\n    assign bjp_req_alu_cmp_ltu = is_bltu;\n    assign bjp_req_alu_cmp_gtu = is_bgtu;\n    assign bjp_req_alu_add = is_jump;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 2, "code": "module e203_reset_ctrl #(\n    parameter MASTER = 1,\n    parameter RST_SYNC_LEVEL = `E203_ASYNC_FF_LEVELS\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    output wire rst_core,\n    output wire rst_itcm,\n    output wire rst_dtcm,\n    output wire rst_aon\n);\n\n// Internal signals for reset synchronization\nreg [RST_SYNC_LEVEL-1:0] rst_sync_reg;\n\n// Reset synchronization logic\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        rst_sync_reg <= {RST_SYNC_LEVEL{1'b1}};\n    end else begin\n        rst_sync_reg <= {rst_sync_reg[RST_SYNC_LEVEL-2:0], 1'b0};\n    end\nend\n\n// Output reset signals\nassign rst_core = test_mode ? rst_n : rst_sync_reg[RST_SYNC_LEVEL-1];\nassign rst_aon = rst_n; // AON reset is directly connected to rst_n\n\n// Conditional compilation for ITCM and DTCM resets\n`ifdef E203_HAS_ITCM\n    assign rst_itcm = test_mode ? rst_n : rst_sync_reg[RST_SYNC_LEVEL-1];\n`else\n    assign rst_itcm = 1'b1; // De-asserted when ITCM is not present\n`endif\n\n`ifdef E203_HAS_DTCM\n    assign rst_dtcm = test_mode ? rst_n : rst_sync_reg[RST_SYNC_LEVEL-1];\n`else\n    assign rst_dtcm = 1'b1; // De-asserted when DTCM is not present\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 1, "code": "module e203_exu_alu(\n    input wire clk,\n    input wire rst_n,\n    input wire i_valid,\n    output wire i_ready,\n    input wire [E203_XLEN-1:0] i_rs1,\n    input wire [E203_XLEN-1:0] i_rs2,\n    input wire [E203_XLEN-1:0] i_imm,\n    input wire [E203_DECINFO_WIDTH-1:0] i_info,\n    input wire [E203_PC_SIZE-1:0] i_pc,\n    input wire [E203_INSTR_SIZE-1:0] i_instr,\n    input wire i_pc_vld,\n    input wire [E203_RFIDX_WIDTH-1:0] i_rdidx,\n    input wire i_rdwen,\n    input wire i_ilegl,\n    input wire i_buserr,\n    input wire i_misalgn,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire cmt_o_valid,\n    input wire cmt_o_ready,\n    output wire [E203_PC_SIZE-1:0] cmt_o_pc,\n    output wire [E203_INSTR_SIZE-1:0] cmt_o_instr,\n    output wire [E203_XLEN-1:0] cmt_o_imm,\n    output wire cmt_o_rv32,\n    output wire cmt_o_bjp,\n    output wire cmt_o_mret,\n    output wire cmt_o_dret,\n    output wire cmt_o_ecall,\n    output wire cmt_o_ebreak,\n    output wire cmt_o_fencei,\n    output wire cmt_o_wfi,\n    output wire cmt_o_ifu_misalgn,\n    output wire cmt_o_ifu_buserr,\n    output wire cmt_o_ifu_ilegl,\n    output wire cmt_o_bjp_prdt,\n    output wire cmt_o_bjp_rslv,\n    output wire cmt_o_misalgn,\n    output wire cmt_o_ld,\n    output wire cmt_o_stamo,\n    output wire cmt_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] cmt_o_badaddr,\n    output wire wbck_o_valid,\n    input wire wbck_o_ready,\n    output wire [E203_XLEN-1:0] wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] wbck_o_rdidx,\n    input wire mdv_nob2b,\n    output wire csr_ena,\n    output wire csr_wr_en,\n    output wire csr_rd_en,\n    output wire [11:0] csr_idx,\n    input wire nonflush_cmt_ena,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output wire [E203_XLEN-1:0] wbck_csr_dat,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_usign,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_longp_wbck_valid,\n    input wire nice_longp_wbck_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire i_nice_cmt_off_ilgl\n);\n    // ALU core logic implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 14, "code": "module e203_cpu (\n    input wire clk,\n    input wire rst_n,\n\n    // Core interfaces\n    output wire [E203_PC-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n\n    input wire [E203_PC-1:0] pc_rtvec,\n    input wire [E203_HARD_ID_W-1:0] core_mhartid,\n    input wire dbg_irq_a,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n\n    // ITCM interfaces\n    `ifdef E203_HAS_ITCM\n    output wire itcm_ls,\n    output wire itcm_ram_cs,\n    output wire itcm_ram_we,\n    output wire [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n    output wire [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n    output wire [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n    input wire [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n    output wire clk_itcm_ram,\n    `endif\n\n    // DTCM interfaces\n    `ifdef E203_HAS_DTCM\n    output wire rst_dtcm,\n    output wire dtcm_ls,\n    output wire dtcm_ram_cs,\n    output wire dtcm_ram_we,\n    output wire [E203_ITCM_RAM_AW-1:0] dtcm_ram_addr,\n    output wire [E203_ITCM_RAM_MW-1:0] dtcm_ram_wem,\n    output wire [E203_ITCM_RAM_DW-1:0] dtcm_ram_din,\n    input wire [E203_ITCM_RAM_DW-1:0] dtcm_ram_dout,\n    `endif\n\n    // Debug related interface\n    output wire [E203_PC-1:0] cmt_dpc,\n    output wire cmt_dpc_ena,\n    output wire [2:0] cmt_dcause,\n    output wire cmt_dcause_ena,\n    output wire dbg_irq_r,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    output wire [31:0] wr_csr_nxt,\n    input wire [31:0] dcsr_r,\n    input wire [E203_PC-1:0] dpc_r,\n    input wire [31:0] dscratch_r,\n    input wire dbg_mode,\n    input wire dbg_halt_r,\n    input wire dbg_step_r,\n    input wire dbg_ebreakm_r,\n    input wire dbg_stopcycle\n);\n    // Core logic implementation\n    // Instantiate submodules, connect internal signals, and implement the core functionality\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 2, "code": "module e203_exu_alu_lsuagu (\n    input wire agu_i_valid,\n    output wire agu_i_ready,\n    input wire [E203_XLEN-1:0] agu_i_rs1,\n    input wire [E203_XLEN-1:0] agu_i_rs2,\n    input wire [E203_XLEN-1:0] agu_i_imm,\n    input wire [E203_DECINFO_AGU_WIDTH-1:0] agu_i_info,\n    input wire [E203_ITAG_WIDTH-1:0] agu_i_itag,\n    output wire agu_i_longpipe,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire amo_wait,\n    input wire oitf_empty,\n    output wire agu_o_valid,\n    input wire agu_o_ready,\n    output wire [E203_XLEN-1:0] agu_o_wbck_wdat,\n    output wire agu_o_wbck_err,\n    output wire agu_o_cmt_misalgn,\n    output wire agu_o_cmt_ld,\n    output wire agu_o_cmt_stamo,\n    output wire agu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] agu_o_cmt_badaddr,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_cmd_usign,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire [E203_XLEN-1:0] agu_req_alu_op1,\n    output wire [E203_XLEN-1:0] agu_req_alu_op2,\n    output wire agu_req_alu_swap,\n    output wire agu_req_alu_add,\n    output wire agu_req_alu_and,\n    output wire agu_req_alu_or,\n    output wire agu_req_alu_xor,\n    output wire agu_req_alu_max,\n    output wire agu_req_alu_min,\n    output wire agu_req_alu_maxu,\n    output wire agu_req_alu_minu,\n    input wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire agu_sbf_0_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_0_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_0_r,\n    output wire agu_sbf_1_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_1_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_1_r,\n    input wire clk,\n    input wire rst_n\n);\n    // Implementation of the AGU logic goes here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 3, "code": "module e203_reset_ctrl #(\n    parameter MASTER = 1,\n    parameter RST_SYNC_LEVEL = `E203_ASYNC_FF_LEVELS\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    output reg rst_core,\n    output reg rst_itcm,\n    output reg rst_dtcm,\n    output reg rst_aon\n);\n\n// Internal registers for reset synchronization\nreg [RST_SYNC_LEVEL-1:0] rst_sync_reg;\n\n// Reset synchronization logic\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        rst_sync_reg <= {RST_SYNC_LEVEL{1'b1}};\n    end else begin\n        rst_sync_reg <= {rst_sync_reg[RST_SYNC_LEVEL-2:0], 1'b0};\n    end\nend\n\n// Output reset logic\nalways @(*) begin\n    if (test_mode) begin\n        // In test mode, output the asynchronous reset directly\n        rst_core = rst_n;\n        rst_itcm = rst_n;\n        rst_dtcm = rst_n;\n        rst_aon = rst_n;\n    end else if (MASTER == 1) begin\n        // In master mode, use the synchronized reset signal\n        rst_core = rst_sync_reg[RST_SYNC_LEVEL-1];\n        rst_itcm = rst_sync_reg[RST_SYNC_LEVEL-1];\n        rst_dtcm = rst_sync_reg[RST_SYNC_LEVEL-1];\n        rst_aon = rst_sync_reg[RST_SYNC_LEVEL-1];\n    end else begin\n        // In slave mode, pass the reset signal directly\n        rst_core = rst_n;\n        rst_itcm = rst_n;\n        rst_dtcm = rst_n;\n        rst_aon = rst_n;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 2, "code": "module e203_exu_wbck (\n    input wire alu_wbck_i_valid,\n    output wire alu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] alu_wbck_i_wdat,\n    input wire [E203_RFIDX_WIDTH-1:0] alu_wbck_i_rdidx,\n    input wire longp_wbck_i_valid,\n    output wire longp_wbck_i_ready,\n    input wire [E203_FLEN-1:0] longp_wbck_i_wdat,\n    input wire [4:0] longp_wbck_i_flags,\n    input wire [E203_RFIDX_WIDTH-1:0] longp_wbck_i_rdidx,\n    input wire longp_wbck_i_rdfpu,\n    output wire rf_wbck_o_ena,\n    output wire [E203_XLEN-1:0] rf_wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] rf_wbck_o_rdidx,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Arbitration logic\n    assign alu_wbck_i_ready = !longp_wbck_i_valid && alu_wbck_i_valid;\n    assign longp_wbck_i_ready = longp_wbck_i_valid;\n\n    // Write-back data selection\n    wire [E203_XLEN-1:0] selected_wdat = longp_wbck_i_valid ? longp_wbck_i_wdat : alu_wbck_i_wdat;\n    wire [E203_RFIDX_WIDTH-1:0] selected_rdidx = longp_wbck_i_valid ? longp_wbck_i_rdidx : alu_wbck_i_rdidx;\n    wire selected_rdfpu = longp_wbck_i_valid ? longp_wbck_i_rdfpu : 1'b0;\n\n    // Write-back enable\n    assign rf_wbck_o_ena = (alu_wbck_i_valid || longp_wbck_i_valid) && !selected_rdfpu;\n\n    // Write-back data and register index output\n    assign rf_wbck_o_wdat = selected_wdat;\n    assign rf_wbck_o_rdidx = selected_rdidx;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 2, "code": "module e203_dtcm_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n    output wire dtcm_active,\n\n    // LSU ICB Interface\n    input wire lsu2dtcm_icb_cmd_valid,\n    output wire lsu2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] lsu2dtcm_icb_cmd_addr,\n    input wire lsu2dtcm_icb_cmd_read,\n    input wire [31:0] lsu2dtcm_icb_cmd_wdata,\n    input wire [3:0] lsu2dtcm_icb_cmd_wmask,\n    output wire lsu2dtcm_icb_rsp_valid,\n    input wire lsu2dtcm_icb_rsp_ready,\n    output wire lsu2dtcm_icb_rsp_err,\n    output wire [31:0] lsu2dtcm_icb_rsp_rdata,\n\n    // External ICB Interface (Optional)\n    input wire ext2dtcm_icb_cmd_valid,\n    output wire ext2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] ext2dtcm_icb_cmd_addr,\n    input wire ext2dtcm_icb_cmd_read,\n    input wire [31:0] ext2dtcm_icb_cmd_wdata,\n    input wire [3:0] ext2dtcm_icb_cmd_wmask,\n    output wire ext2dtcm_icb_rsp_valid,\n    input wire ext2dtcm_icb_rsp_ready,\n    output wire ext2dtcm_icb_rsp_err,\n    output wire [31:0] ext2dtcm_icb_rsp_rdata,\n\n    // DTCM RAM Interface\n    output wire dtcm_ram_cs,\n    output wire dtcm_ram_we,\n    output wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    output wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    output wire clk_dtcm_ram\n);\n\n    // Internal signals\n    wire arbiter_select;\n    wire [E203_DTCM_ADDR_WIDTH-1:0] selected_addr;\n    wire [31:0] selected_wdata;\n    wire [3:0] selected_wmask;\n    wire selected_read;\n    wire selected_cmd_valid;\n    wire selected_cmd_ready;\n    wire selected_rsp_valid;\n    wire selected_rsp_ready;\n    wire selected_rsp_err;\n    wire [31:0] selected_rsp_rdata;\n\n    // Arbitration logic (simplified example)\n    assign arbiter_select = ext2dtcm_icb_cmd_valid && !lsu2dtcm_icb_cmd_valid;\n\n    assign selected_addr = arbiter_select ? ext2dtcm_icb_cmd_addr : lsu2dtcm_icb_cmd_addr;\n    assign selected_wdata = arbiter_select ? ext2dtcm_icb_cmd_wdata : lsu2dtcm_icb_cmd_wdata;\n    assign selected_wmask = arbiter_select ? ext2dtcm_icb_cmd_wmask : lsu2dtcm_icb_cmd_wmask;\n    assign selected_read = arbiter_select ? ext2dtcm_icb_cmd_read : lsu2dtcm_icb_cmd_read;\n    assign selected_cmd_valid = arbiter_select ? ext2dtcm_icb_cmd_valid : lsu2dtcm_icb_cmd_valid;\n    assign selected_cmd_ready = arbiter_select ? ext2dtcm_icb_cmd_ready : lsu2dtcm_icb_cmd_ready;\n    assign selected_rsp_valid = arbiter_select ? ext2dtcm_icb_rsp_valid : lsu2dtcm_icb_rsp_valid;\n    assign selected_rsp_ready = arbiter_select ? ext2dtcm_icb_rsp_ready : lsu2dtcm_icb_rsp_ready;\n    assign selected_rsp_err = arbiter_select ? ext2dtcm_icb_rsp_err : lsu2dtcm_icb_rsp_err;\n    assign selected_rsp_rdata = arbiter_select ? ext2dtcm_icb_rsp_rdata : lsu2dtcm_icb_rsp_rdata;\n\n    // SRAM controller logic\n    assign dtcm_ram_cs = selected_cmd_valid && selected_cmd_ready;\n    assign dtcm_ram_we = !selected_read;\n    assign dtcm_ram_addr = selected_addr[E203_DTCM_RAM_AW-1:0];\n    assign dtcm_ram_wem = selected_wmask;\n    assign dtcm_ram_din = selected_wdata;\n    assign clk_dtcm_ram = clk;\n\n    // Response logic\n    assign lsu2dtcm_icb_rsp_valid = !arbiter_select && selected_rsp_valid;\n    assign lsu2dtcm_icb_rsp_err = !arbiter_select && selected_rsp_err;\n    assign lsu2dtcm_icb_rsp_rdata = !arbiter_select ? selected_rsp_rdata : 32'h0;\n\n    assign ext2dtcm_icb_rsp_valid = arbiter_select && selected_rsp_valid;\n    assign ext2dtcm_icb_rsp_err = arbiter_select && selected_rsp_err;\n    assign ext2dtcm_icb_rsp_rdata = arbiter_select ? selected_rsp_rdata : 32'h0;\n\n    // Clock gating and activity indicator\n    assign dtcm_active = selected_cmd_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 3, "code": "module e203_exu_regfile #(\n  parameter E203_RFIDX_WIDTH = 5, // Width of the register index\n  parameter E203_XLEN = 32        // Width of the register data\n)(\n  input  wire                     clk,\n  input  wire                     rst_n,\n  input  wire [E203_RFIDX_WIDTH-1:0] read_src1_idx,\n  input  wire [E203_RFIDX_WIDTH-1:0] read_src2_idx,\n  output wire [E203_XLEN-1:0]     read_src1_dat,\n  output wire [E203_XLEN-1:0]     read_src2_dat,\n  input  wire                     wbck_dest_wen,\n  input  wire [E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n  input  wire [E203_XLEN-1:0]     wbck_dest_dat,\n  output wire [E203_XLEN-1:0]     x1_r,\n  input  wire                     test_mode\n);\n\n  // Local parameters for register file size\n  `ifdef E203_CFG_REGNUM_IS_32\n    localparam NUM_REGS = 32;\n  `elsif E203_CFG_REGNUM_IS_16\n    localparam NUM_REGS = 16;\n  `else\n    localparam NUM_REGS = 32; // Default size\n  `endif\n\n  // Register array\n  reg [E203_XLEN-1:0] regs [0:NUM_REGS-1];\n\n  // Read logic\n  assign read_src1_dat = (read_src1_idx == 0) ? 0 : regs[read_src1_idx];\n  assign read_src2_dat = (read_src2_idx == 0) ? 0 : regs[read_src2_idx];\n\n  // Write logic\n  always @(posedge clk) begin\n    if (!rst_n) begin\n      // Asynchronous reset (if needed, though not specified to respond to reset)\n    end else begin\n      if (wbck_dest_wen && (wbck_dest_idx != 0)) begin\n        regs[wbck_dest_idx] <= wbck_dest_dat;\n      end\n    end\n  end\n\n  // Output for register x1\n  assign x1_r = regs[1];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 15, "code": "module e203_cpu_top(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire tcm_sd,\n    input wire tcm_ds,\n    input wire [E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input wire ext2itcm_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ext2itcm_icb_cmd_wdata,\n    input wire [E203_XLEN/8-1:0] ext2itcm_icb_cmd_wmask,\n    input wire ext2itcm_icb_cmd_valid,\n    input wire ext2itcm_icb_rsp_ready,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire dbg_irq_r,\n    output wire [E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_ready,\n    output wire [E203_XLEN-1:0] ext2itcm_icb_rsp_rdata,\n    output wire ext2itcm_icb_rsp_valid,\n    output wire ext2itcm_icb_rsp_err\n);\n\n    // Internal signals for connections between submodules\n    wire core_clk = clk;\n    wire core_rst_n = rst_n;\n\n    // Instantiate the e203_cpu core\n    e203_cpu u_e203_cpu(\n        .clk(core_clk),\n        .rst_n(core_rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ext_irq_a(ext_irq_a),\n        .sft_irq_a(sft_irq_a),\n        .tmr_irq_a(tmr_irq_a),\n        .inspect_pc(inspect_pc),\n        .inspect_dbg_irq(inspect_dbg_irq),\n        .inspect_mem_cmd_valid(inspect_mem_cmd_valid),\n        .inspect_mem_cmd_ready(inspect_mem_cmd_ready),\n        .inspect_mem_rsp_valid(inspect_mem_rsp_valid),\n        .inspect_mem_rsp_ready(inspect_mem_rsp_ready),\n        .inspect_core_clk(inspect_core_clk),\n        .core_csr_clk(core_csr_clk),\n        .core_wfi(core_wfi),\n        .tm_stop(tm_stop),\n        .dbg_irq_r(dbg_irq_r)\n    );\n\n    // Instantiate the e203_srams for ITCM and DTCM\n    e203_srams u_e203_srams(\n        .clk_itcm_ram(clk),\n        .rst_itcm(rst_n),\n        .itcm_ram_sd(tcm_sd),\n        .itcm_ram_ds(tcm_ds),\n        .itcm_ram_cs(ext2itcm_icb_cmd_valid & ext2itcm_icb_rsp_ready),\n        .itcm_ram_we(~ext2itcm_icb_cmd_read),\n        .itcm_ram_addr(ext2itcm_icb_cmd_addr),\n        .itcm_ram_wem(ext2itcm_icb_cmd_wmask),\n        .itcm_ram_din(ext2itcm_icb_cmd_wdata),\n        .itcm_ram_dout(ext2itcm_icb_rsp_rdata)\n    );\n\n    // ITCM interface response control\n    assign ext2itcm_icb_cmd_ready = ~ext2itcm_icb_rsp_valid | ext2itcm_icb_rsp_ready;\n    assign ext2itcm_icb_rsp_valid = ext2itcm_icb_cmd_valid & ~ext2itcm_icb_cmd_read;\n    assign ext2itcm_icb_rsp_err = 0; // No error handling in this example\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 15, "code": "// E203 Processor Configuration Document\n\n// 1. Introduction\n\n// This document describes the configuration system for the E203 processor. The E203 is a RISC-V architecture-based processor core that can be configured with various features and functional modules via macro definitions. This configuration file is licensed under the Apache 2.0 open-source license and is maintained by Nuclei System Technology.\n\n// 2. Basic Configuration Items\n\n// 2.1 Debug and Interrupt Configuration\n// **`E203_CFG_DEBUG_HAS_JTAG`**: Enables support for JTAG debug interface.\n// **`E203_CFG_IRQ_NEED_SYNC`**: Enables interrupt synchronization mechanism.\n\n// 2.2 Address Space Configuration\n// The system supports three address width configurations, and only one can be selected at a time:\n// - **`E203_CFG_ADDR_SIZE_IS_16`**: 16-bit address space.\n// - **`E203_CFG_ADDR_SIZE_IS_24`**: 24-bit address space.\n// - **`E203_CFG_ADDR_SIZE_IS_32`**: 32-bit address space (currently selected configuration).\n\n// The address size is unified through the **`E203_CFG_ADDR_SIZE`** macro, which is automatically set based on the chosen configuration.\n\n// 2.3 CPU Function Configuration\n// - **`E203_CFG_SUPPORT_MCYCLE_MINSTRET`**: Enables support for MCYCLE and MINSTRET counters.\n// - **`E203_CFG_REGNUM_IS_32`**: Configures the number of registers to 32.\n// - **`E203_CFG_HAS_ECC`**: Enables ECC (Error Correction Code) functionality.\n// - **`E203_CFG_HAS_NICE`**: Enables the NICE instruction extension.\n// - **`E203_CFG_SUPPORT_SHARE_MULDIV`**: Enables shared multiplication and division units.\n// - **`E203_CFG_SUPPORT_AMO`**: Enables support for atomic memory operations (AMO).\n\n// 2.4 Memory System Configuration\n\n// Instruction TCM (ITCM)\n// - **`E203_CFG_HAS_ITCM`**: Enables Instruction Tightly Coupled Memory (ITCM).\n// - **`E203_CFG_ITCM_ADDR_WIDTH`**: Configures the ITCM address width. The current setting is 16 bits.\n//   - Supports a 64KB configuration (16-bit address width, 8192 depth).\n//   - Optional 1024KB configuration (20-bit address width).\n//   - Optional 2048KB configuration (21-bit address width).\n\n// Data TCM (DTCM)\n// - **`E203_CFG_HAS_DTCM`**: Enables Data Tightly Coupled Memory (DTCM).\n// - **`E203_CFG_DTCM_ADDR_WIDTH`**: Configures the DTCM address width. The current setting is 16 bits.\n//   - Supports a 16KB configuration (14-bit address width, 4096 depth).\n//   - Supports a 256KB configuration (18-bit address width, 65536 depth).\n//   - Optional 1MB configuration (20-bit address width, 262144 depth).\n\n// 2.5 Memory Mapping Configuration\n\n// The system defines the base addresses for the following memory regions:\n\n// 1. **ITCM Region**:\n//    - Base address: `0x8000_0000`\n//    - Defined through **`E203_CFG_ITCM_ADDR_BASE`**.\n// 2. **DTCM Region**:\n//    - Base address: `0x9000_0000`\n//    - Defined through **`E203_CFG_DTCM_ADDR_BASE`**.\n// 3. **Peripheral Interface Regions**:\n//    - **PPI Region**: `0x1000_0000 - 0x1FFF_FFFF`\n//    - Defined through **`E203_CFG_PPI_ADDR_BASE`** and **`E203_CFG_PPI_BASE_REGION`**.\n// 4. **System Controller Regions**:\n//    - **CLINT Region**: `0x0200_0000 - 0x0200_FFFF`\n//    - Base Address of CLINT is defined through **`E203_CFG_CLINT_ADDR_BASE`**.(`E203_CFG_ADDR_SIZE'h0200_0000`)\n//    -  **`E203_CFG_CLINT_BASE_REGION`** macro defines the high address range used to determine whether an address belongs to CLINT REGION (`E203_CFG_ADDR_SIZE-1:E203_CFG_ADDR_SIZE-16`)\n//    - **PLIC Region**: `0x0C00_0000 - 0x0CFF_FFFF`\n//    - Base Address of PLIC is defined through **`E203_CFG_PLIC_ADDR_BASE`**.(`E203_CFG_ADDR_SIZE'h0C00_0000`)\n//    -  **`E203_CFG_PLIC_BASE_REGION`** macro defines the high address range used to determine whether an address belongs to PLIC REGION (`E203_CFG_ADDR_SIZE-1:E203_CFG_ADDR_SIZE-8`)\n// 5. **Fast IO Region**:\n//    - Base address: `0xF000_0000`\n//    - Defined through **`E203_CFG_FIO_ADDR_BASE`** and **`E203_CFG_FIO_BASE_REGION`**.\n\n// 3. Notes\n\n// 1. Only one address width configuration should be enabled at a time.\n// 2. TCM configurations should be selected based on available hardware resources.\n// 3. Memory mapping configurations must avoid address overlap.\n// 4. It is recommended to carefully evaluate the system's resource requirements and performance demands when modifying configurations.", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 2, "code": "module e203_exu_alu_csrctrl (\n    input wire csr_i_valid,\n    output reg csr_i_ready,\n    input wire [E203_XLEN-1:0] csr_i_rs1,\n    input wire [E203_DECINFO_CSR_WIDTH-1:0] csr_i_info,\n    input wire csr_i_rdwen,\n    output reg csr_ena,\n    output reg csr_wr_en,\n    output reg csr_rd_en,\n    output reg [11:0] csr_idx,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output reg [E203_XLEN-1:0] wbck_csr_dat,\n    output reg csr_o_valid,\n    input wire csr_o_ready,\n    output reg [E203_XLEN-1:0] csr_o_wbck_wdat,\n    output reg csr_o_wbck_err,\n    input wire clk,\n    input wire rst_n,\n\n    // Optional NICE interface signals\n    input wire nice_xs_off,\n    output reg csr_sel_nice,\n    output reg nice_csr_valid,\n    input wire nice_csr_ready,\n    output reg [31:0] nice_csr_addr,\n    output reg nice_csr_wr,\n    output reg [31:0] nice_csr_wdata,\n    input wire [31:0] nice_csr_rdata\n);\n\n    // Decode CSR instruction information\n    wire csrrw = csr_i_info[E203_DECINFO_CSR_CSRRW];\n    wire csrrs = csr_i_info[E203_DECINFO_CSR_CSRRS];\n    wire csrrc = csr_i_info[E203_DECINFO_CSR_CSRRC];\n    wire rs1imm = csr_i_info[E203_DECINFO_CSR_RS1IMM];\n    wire rs1is0 = csr_i_info[E203_DECINFO_CSR_RS1IS0];\n    wire [4:0] zimm = csr_i_info[E203_DECINFO_CSR_ZIMMM];\n    wire [11:0] csr_idx_field = csr_i_info[E203_DECINFO_CSR_CSRIDX];\n\n    // CSR index and data preparation\n    always @(*) begin\n        csr_idx = csr_idx_field;\n        wbck_csr_dat = (csrrw ? csr_i_rs1 : \n                        (csrrs ? (read_csr_dat | csr_i_rs1) : \n                        (csrrc ? (read_csr_dat & ~csr_i_rs1) : read_csr_dat)));\n    end\n\n    // Control signal logic\n    always @(*) begin\n        csr_rd_en = (csr_i_valid && (csrrw || csrrs || csrrc));\n        csr_wr_en = (csr_i_valid && ((csrrw) || (csrrs && !rs1is0) || (csrrc && !rs1is0)));\n        csr_ena = csr_i_valid && csr_o_ready && !nice_xs_off;\n        csr_i_ready = csr_o_ready;\n        csr_o_valid = csr_i_valid && csr_o_ready;\n        csr_o_wbck_wdat = read_csr_dat;\n        csr_o_wbck_err = csr_access_ilgl;\n\n        // NICE interface logic\n        csr_sel_nice = (csr_idx[11:8] == 4'hE) && !nice_xs_off;\n        nice_csr_valid = csr_i_valid && csr_o_ready && csr_sel_nice;\n        nice_csr_addr = {20'h0, csr_idx};\n        nice_csr_wr = csr_wr_en && csr_sel_nice;\n        nice_csr_wdata = wbck_csr_dat;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 3, "code": "module e203_dtcm_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n    output wire dtcm_active,\n\n    // LSU ICB Interface\n    input wire lsu2dtcm_icb_cmd_valid,\n    output wire lsu2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] lsu2dtcm_icb_cmd_addr,\n    input wire lsu2dtcm_icb_cmd_read,\n    input wire [31:0] lsu2dtcm_icb_cmd_wdata,\n    input wire [3:0] lsu2dtcm_icb_cmd_wmask,\n    output wire lsu2dtcm_icb_rsp_valid,\n    input wire lsu2dtcm_icb_rsp_ready,\n    output wire lsu2dtcm_icb_rsp_err,\n    output wire [31:0] lsu2dtcm_icb_rsp_rdata,\n\n    // External ICB Interface (Optional)\n    `ifdef E203_HAS_DTCM_EXTITF\n    input wire ext2dtcm_icb_cmd_valid,\n    output wire ext2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] ext2dtcm_icb_cmd_addr,\n    input wire ext2dtcm_icb_cmd_read,\n    input wire [31:0] ext2dtcm_icb_cmd_wdata,\n    input wire [3:0] ext2dtcm_icb_cmd_wmask,\n    output wire ext2dtcm_icb_rsp_valid,\n    input wire ext2dtcm_icb_rsp_ready,\n    output wire ext2dtcm_icb_rsp_err,\n    output wire [31:0] ext2dtcm_icb_rsp_rdata,\n    `endif\n\n    // DTCM RAM Interface\n    output wire dtcm_ram_cs,\n    output wire dtcm_ram_we,\n    output wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    output wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    output wire clk_dtcm_ram\n);\n\n    // Internal signals\n    wire icb_cmd_valid;\n    wire icb_cmd_ready;\n    wire [E203_DTCM_ADDR_WIDTH-1:0] icb_cmd_addr;\n    wire icb_cmd_read;\n    wire [31:0] icb_cmd_wdata;\n    wire [3:0] icb_cmd_wmask;\n    wire icb_rsp_valid;\n    wire icb_rsp_ready;\n    wire icb_rsp_err;\n    wire [31:0] icb_rsp_rdata;\n\n    // Arbitration logic (simplified example)\n    assign icb_cmd_valid = lsu2dtcm_icb_cmd_valid; // Priority to LSU\n    assign lsu2dtcm_icb_cmd_ready = icb_cmd_ready;\n    assign icb_cmd_addr = lsu2dtcm_icb_cmd_addr;\n    assign icb_cmd_read = lsu2dtcm_icb_cmd_read;\n    assign icb_cmd_wdata = lsu2dtcm_icb_cmd_wdata;\n    assign icb_cmd_wmask = lsu2dtcm_icb_cmd_wmask;\n\n    assign lsu2dtcm_icb_rsp_valid = icb_rsp_valid;\n    assign icb_rsp_ready = lsu2dtcm_icb_rsp_ready;\n    assign lsu2dtcm_icb_rsp_err = icb_rsp_err;\n    assign lsu2dtcm_icb_rsp_rdata = icb_rsp_rdata;\n\n    // SRAM controller logic\n    assign dtcm_ram_cs = icb_cmd_valid && icb_cmd_ready;\n    assign dtcm_ram_we = !icb_cmd_read;\n    assign dtcm_ram_addr = icb_cmd_addr[E203_DTCM_RAM_AW-1:0];\n    assign dtcm_ram_wem = icb_cmd_read ? 4'b0000 : icb_cmd_wmask;\n    assign dtcm_ram_din = icb_cmd_wdata;\n    assign clk_dtcm_ram = clk;\n\n    // Read data handling\n    assign icb_rsp_valid = dtcm_ram_cs && icb_cmd_read;\n    assign icb_rsp_rdata = dtcm_ram_dout;\n    assign icb_rsp_err = 1'b0; // Simplified error handling\n\n    // Activity indicator\n    assign dtcm_active = icb_cmd_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 3, "code": "module e203_exu_alu_lsuagu (\n    input wire agu_i_valid,\n    output wire agu_i_ready,\n    input wire [E203_XLEN-1:0] agu_i_rs1,\n    input wire [E203_XLEN-1:0] agu_i_rs2,\n    input wire [E203_XLEN-1:0] agu_i_imm,\n    input wire [E203_DECINFO_AGU_WIDTH-1:0] agu_i_info,\n    input wire [E203_ITAG_WIDTH-1:0] agu_i_itag,\n    output wire agu_i_longpipe,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire amo_wait,\n    input wire oitf_empty,\n    output wire agu_o_valid,\n    input wire agu_o_ready,\n    output wire [E203_XLEN-1:0] agu_o_wbck_wdat,\n    output wire agu_o_wbck_err,\n    output wire agu_o_cmt_misalgn,\n    output wire agu_o_cmt_ld,\n    output wire agu_o_cmt_stamo,\n    output wire agu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] agu_o_cmt_badaddr,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_cmd_usign,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire [E203_XLEN-1:0] agu_req_alu_op1,\n    output wire [E203_XLEN-1:0] agu_req_alu_op2,\n    output wire agu_req_alu_swap,\n    output wire agu_req_alu_add,\n    output wire agu_req_alu_and,\n    output wire agu_req_alu_or,\n    output wire agu_req_alu_xor,\n    output wire agu_req_alu_max,\n    output wire agu_req_alu_min,\n    output wire agu_req_alu_maxu,\n    output wire agu_req_alu_minu,\n    input wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire agu_sbf_0_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_0_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_0_r,\n    output wire agu_sbf_1_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_1_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_1_r,\n    input wire clk,\n    input wire rst_n\n);\n    // Implementation of AGU logic goes here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 1, "code": "module e203_exu_oitf #(\n  parameter E203_ITAG_WIDTH = 4, // Width of the instruction tag\n  parameter E203_RFIDX_WIDTH = 5, // Width of the register file index\n  parameter E203_PC_SIZE = 32, // Size of the program counter\n  parameter E203_OITF_DEPTH = 8 // Depth of the OITF\n)(\n  input clk,\n  input rst_n,\n\n  // Dispatch interface\n  input dis_ena,\n  input [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n  input disp_i_rdwen,\n  input disp_i_rdfpu,\n  input [E203_PC_SIZE-1:0] disp_i_pc,\n\n  // Retirement interface\n  input ret_ena,\n  output reg [E203_RFIDX_WIDTH-1:0] ret_rdidx,\n  output reg ret_rdwen,\n  output reg ret_rdfpu,\n  output reg [E203_PC_SIZE-1:0] ret_pc,\n\n  // Status signals\n  output dis_ready,\n  output oitf_empty,\n  output reg [E203_ITAG_WIDTH-1:0] dis_ptr,\n  output reg [E203_ITAG_WIDTH-1:0] ret_ptr\n);\n\n  // Internal OITF storage\n  reg [E203_RFIDX_WIDTH-1:0] rdidx [0:E203_OITF_DEPTH-1];\n  reg [E203_PC_SIZE-1:0] pc [0:E203_OITF_DEPTH-1];\n  reg rdwen [0:E203_OITF_DEPTH-1];\n  reg rdfpu [0:E203_OITF_DEPTH-1];\n  reg [E203_ITAG_WIDTH-1:0] next_dis_ptr, next_ret_ptr;\n  wire full, empty;\n\n  // Calculate full and empty conditions\n  assign full = (dis_ptr == ret_ptr) && (dis_ena && !ret_ena);\n  assign empty = (dis_ptr == ret_ptr) && (!dis_ena && ret_ena);\n  assign dis_ready = !full;\n  assign oitf_empty = empty;\n\n  // Dispatch logic\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      dis_ptr <= 0;\n      ret_ptr <= 0;\n    end else begin\n      if (dis_ena && dis_ready) begin\n        rdidx[dis_ptr] <= disp_i_rdidx;\n        pc[dis_ptr] <= disp_i_pc;\n        rdwen[dis_ptr] <= disp_i_rdwen;\n        rdfpu[dis_ptr] <= disp_i_rdfpu;\n        dis_ptr <= next_dis_ptr;\n      end\n      if (ret_ena && !oitf_empty) begin\n        ret_rdidx <= rdidx[ret_ptr];\n        ret_pc <= pc[ret_ptr];\n        ret_rdwen <= rdwen[ret_ptr];\n        ret_rdfpu <= rdfpu[ret_ptr];\n        ret_ptr <= next_ret_ptr;\n      end\n    end\n  end\n\n  // Pointer update logic\n  always @(*) begin\n    next_dis_ptr = (dis_ptr + 1) % E203_OITF_DEPTH;\n    next_ret_ptr = (ret_ptr + 1) % E203_OITF_DEPTH;\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 1, "code": "module e203_ifu_ifetch(\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_valid,\n    input wire ifu_req_ready,\n    output wire [E203_PC_SIZE-1:0] ifu_req_pc,\n    output wire ifu_req_seq,\n    output wire ifu_req_seq_rv32,\n    output wire [E203_PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_valid,\n    output wire ifu_rsp_ready,\n    input wire ifu_rsp_err,\n    input wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr,\n    input wire pipe_flush_req,\n    output wire pipe_flush_ack,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    `ifdef E203_TIMING_BOOST\n    input wire [E203_PC_SIZE-1:0] pipe_flush_pc,\n    `endif\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    input wire ifu_halt_req,\n    output wire ifu_halt_ack,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu\n);\n    // Fetch unit logic here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 2, "code": "module e203_irq_sync (\n    input wire clk,\n    input wire rst_n,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire dbg_irq_a,\n    output wire ext_irq_r,\n    output wire sft_irq_r,\n    output wire tmr_irq_r,\n    output wire dbg_irq_r\n);\n\n    // Synchronization instances for each interrupt type\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) ext_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(ext_irq_a),\n        .dout(ext_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) sft_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(sft_irq_a),\n        .dout(sft_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) tmr_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(tmr_irq_a),\n        .dout(tmr_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) dbg_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(dbg_irq_a),\n        .dout(dbg_irq_r)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 2, "code": "module e203_exu_commit(\n    output commit_mret,\n    output commit_trap,\n    output core_wfi,\n    output nonflush_cmt_ena,\n    output excp_active,\n    input amo_wait,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input alu_cmt_i_valid,\n    output alu_cmt_i_ready,\n    input [E203_PC_SIZE-1:0] alu_cmt_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_cmt_i_instr,\n    input alu_cmt_i_pc_vld,\n    input [E203_XLEN-1:0] alu_cmt_i_imm,\n    input alu_cmt_i_rv32,\n    input alu_cmt_i_bjp,\n    input alu_cmt_i_wfi,\n    input alu_cmt_i_fencei,\n    input alu_cmt_i_mret,\n    input alu_cmt_i_dret,\n    input alu_cmt_i_ecall,\n    input alu_cmt_i_ebreak,\n    input alu_cmt_i_ifu_misalgn,\n    input alu_cmt_i_ifu_buserr,\n    input alu_cmt_i_ifu_ilegl,\n    input alu_cmt_i_bjp_prdt,\n    input alu_cmt_i_bjp_rslv,\n    input alu_cmt_i_misalgn,\n    input alu_cmt_i_ld,\n    input alu_cmt_i_stamo,\n    input alu_cmt_i_buserr,\n    input [E203_ADDR_SIZE-1:0] alu_cmt_i_badaddr,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output cmt_badaddr_ena,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output cmt_epc_ena,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_cause_ena,\n    output cmt_instret_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output cmt_mret_ena,\n    input [E203_PC_SIZE-1:0] csr_epc_r,\n    input [E203_PC_SIZE-1:0] csr_dpc_r,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output longp_excp_i_ready,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input longp_excp_i_insterr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input clk,\n    input rst_n\n);\n    // Module implementation\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 4, "code": "module e203_reset_ctrl #(\n    parameter MASTER = 1,\n    parameter RST_SYNC_LEVEL = `E203_ASYNC_FF_LEVELS\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    output wire rst_core,\n    output wire rst_itcm,\n    output wire rst_dtcm,\n    output wire rst_aon\n);\n\nreg [RST_SYNC_LEVEL-1:0] rst_sync_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        rst_sync_reg <= {RST_SYNC_LEVEL{1'b1}};\n    end else begin\n        if (test_mode) begin\n            rst_sync_reg <= {RST_SYNC_LEVEL{rst_n}};\n        end else begin\n            rst_sync_reg <= {rst_sync_reg[RST_SYNC_LEVEL-2:0], 1'b1};\n        end\n    end\nend\n\nassign rst_core = (MASTER == 1) ? rst_sync_reg[RST_SYNC_LEVEL-1] : rst_n;\nassign rst_itcm = (MASTER == 1) ? rst_sync_reg[RST_SYNC_LEVEL-1] : rst_n;\nassign rst_dtcm = (MASTER == 1) ? rst_sync_reg[RST_SYNC_LEVEL-1] : rst_n;\nassign rst_aon = (MASTER == 1) ? rst_sync_reg[RST_SYNC_LEVEL-1] : rst_n;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 19, "code": "module e203_core (\n  input  wire        clk,\n  input  wire        rst_n,\n  input  wire [31:0] pc_rtvec,\n  input  wire [31:0] core_mhartid,\n  input  wire        dbg_irq_r,\n  input  wire [15:0] lcl_irq_r,\n  input  wire [3:0]  evt_r,\n  input  wire        ext_irq_r,\n  input  wire        sft_irq_r,\n  input  wire        tmr_irq_r,\n  input  wire [31:0] dcsr_r,\n  input  wire [31:0] dpc_r,\n  input  wire [31:0] dscratch_r,\n  input  wire        dbg_mode,\n  input  wire        dbg_halt_r,\n  input  wire        dbg_step_r,\n  input  wire        dbg_ebreakm_r,\n  input  wire        dbg_stopcycle,\n  output wire [31:0] inspect_pc,\n  output wire        core_wfi,\n  output wire        tm_stop,\n  output wire        core_cgstop,\n  output wire        tcm_cgstop,\n  output wire        wr_dcsr_ena,\n  output wire        wr_dpc_ena,\n  output wire        wr_dscratch_ena,\n  output wire [31:0] wr_csr_nxt,\n  output wire [31:0] cmt_dpc,\n  output wire        cmt_dpc_ena,\n  output wire [2:0]  cmt_dcause,\n  output wire        cmt_dcause_ena\n);\n\n  // Internal signals\n  wire [31:0] next_pc;\n  wire        fetch_valid;\n  wire        decode_valid;\n  wire        execute_valid;\n  wire        load_store_valid;\n  wire [31:0] executed_value;\n  wire [31:0] load_value;\n  wire        exception_flag;\n  wire        interrupt_flag;\n  wire [31:0] exception_pc;\n\n  // Instruction Fetch Unit (IFU)\n  e203_ifu u_ifu (\n    .clk(clk),\n    .rst_n(rst_n),\n    .pc_rtvec(pc_rtvec),\n    .fetch_valid(fetch_valid),\n    .next_pc(next_pc),\n    .inspect_pc(inspect_pc)\n  );\n\n  // Execution Unit (EXU)\n  e203_exu u_exu (\n    .clk(clk),\n    .rst_n(rst_n),\n    .execute_valid(execute_valid),\n    .executed_value(executed_value),\n    .exception_flag(exception_flag),\n    .interrupt_flag(interrupt_flag),\n    .exception_pc(exception_pc)\n  );\n\n  // Load Store Unit (LSU)\n  e203_lsu u_lsu (\n    .clk(clk),\n    .rst_n(rst_n),\n    .load_store_valid(load_store_valid),\n    .load_value(load_value)\n  );\n\n  // Exception and Interrupt Handling\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      cmt_dpc <= 32'b0;\n      cmt_dcause <= 3'b0;\n    end else if (exception_flag || interrupt_flag) begin\n      cmt_dpc <= exception_pc;\n      cmt_dcause <= (interrupt_flag) ? 3'b101 : 3'b100; // Example cause codes\n    end\n  end\n\n  // Core Control Signals\n  assign core_wfi = ~fetch_valid & ~decode_valid & ~execute_valid & ~load_store_valid;\n  assign tm_stop = dbg_stopcycle;\n  assign core_cgstop = ~clk; // Example gating control\n  assign tcm_cgstop = ~clk; // Example gating control\n\n  // Debug and CSR Handling\n  assign wr_dcsr_ena = dbg_mode & dbg_step_r;\n  assign wr_dpc_ena = dbg_mode & dbg_halt_r;\n  assign wr_dscratch_ena = dbg_mode & dbg_ebreakm_r;\n  assign wr_csr_nxt = dscratch_r; // Example CSR write data\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 16, "code": "module e203_cpu_top(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire tcm_sd,\n    input wire tcm_ds,\n    input wire [E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input wire ext2itcm_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ext2itcm_icb_cmd_wdata,\n    input wire [E203_XLEN/8-1:0] ext2itcm_icb_cmd_wmask,\n    input wire ext2itcm_icb_cmd_valid,\n    input wire ext2itcm_icb_rsp_ready,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire dbg_irq_r,\n    output wire ext2itcm_icb_cmd_ready,\n    output wire [E203_XLEN-1:0] ext2itcm_icb_rsp_rdata,\n    output wire ext2itcm_icb_rsp_valid,\n    output wire ext2itcm_icb_rsp_err\n);\n\n    // Core instantiation\n    e203_cpu core_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ext_irq_a(ext_irq_a),\n        .sft_irq_a(sft_irq_a),\n        .tmr_irq_a(tmr_irq_a),\n        .inspect_pc(inspect_pc),\n        .inspect_dbg_irq(inspect_dbg_irq),\n        .inspect_mem_cmd_valid(inspect_mem_cmd_valid),\n        .inspect_mem_cmd_ready(inspect_mem_cmd_ready),\n        .inspect_mem_rsp_valid(inspect_mem_rsp_valid),\n        .inspect_mem_rsp_ready(inspect_mem_rsp_ready),\n        .inspect_core_clk(inspect_core_clk),\n        .core_csr_clk(core_csr_clk),\n        .core_wfi(core_wfi),\n        .tm_stop(tm_stop),\n        .dbg_irq_r(dbg_irq_r)\n    );\n\n    // SRAM controller instantiation\n    e203_srams sram_ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .tcm_sd(tcm_sd),\n        .tcm_ds(tcm_ds),\n        .ext2itcm_icb_cmd_addr(ext2itcm_icb_cmd_addr),\n        .ext2itcm_icb_cmd_read(ext2itcm_icb_cmd_read),\n        .ext2itcm_icb_cmd_wdata(ext2itcm_icb_cmd_wdata),\n        .ext2itcm_icb_cmd_wmask(ext2itcm_icb_cmd_wmask),\n        .ext2itcm_icb_cmd_valid(ext2itcm_icb_cmd_valid),\n        .ext2itcm_icb_rsp_ready(ext2itcm_icb_rsp_ready),\n        .ext2itcm_icb_cmd_ready(ext2itcm_icb_cmd_ready),\n        .ext2itcm_icb_rsp_rdata(ext2itcm_icb_rsp_rdata),\n        .ext2itcm_icb_rsp_valid(ext2itcm_icb_rsp_valid),\n        .ext2itcm_icb_rsp_err(ext2itcm_icb_rsp_err)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 16, "code": "module e203_cpu(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC-1:0] pc_rtvec,\n    input wire [E203_HARD_ID_W-1:0] core_mhartid,\n    input wire dbg_irq_a,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    output wire [E203_PC-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire dbg_irq_r,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    output wire [31:0] wr_csr_nxt,\n    input wire [31:0] dcsr_r,\n    input wire [E203_PC-1:0] dpc_r,\n    input wire [31:0] dscratch_r,\n    input wire dbg_mode,\n    input wire dbg_halt_r,\n    input wire dbg_step_r,\n    input wire dbg_ebreakm_r,\n    input wire dbg_stopcycle\n    `ifdef E203_HAS_ITCM\n    ,output wire itcm_ls,\n    output wire itcm_ram_cs,\n    output wire itcm_ram_we,\n    output wire [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n    output wire [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n    output wire [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n    input wire [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n    output wire clk_itcm_ram\n    `endif\n    `ifdef E203_HAS_DTCM\n    ,output wire rst_dtcm,\n    output wire dtcm_ls,\n    output wire dtcm_ram_cs,\n    output wire dtcm_ram_we,\n    output wire [E203_ITCM_RAM_AW-1:0] dtcm_ram_addr,\n    output wire [E203_ITCM_RAM_MW-1:0] dtcm_ram_wem,\n    output wire [E203_ITCM_RAM_DW-1:0] dtcm_ram_din,\n    input wire [E203_ITCM_RAM_DW-1:0] dtcm_ram_dout\n    `endif\n);\n\n// Core logic and submodules instantiation here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 6, "code": "module e203_biu(\n    input wire clk,\n    input wire rst_n,\n    output wire biu_active,\n    // ICB Interface for LSU\n    input wire lsu_icb_cmd_valid,\n    output wire lsu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] lsu_icb_cmd_addr,\n    input wire lsu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] lsu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] lsu_icb_cmd_wmask,\n    input wire [1:0] lsu_icb_cmd_burst,\n    input wire [1:0] lsu_icb_cmd_beat,\n    input wire lsu_icb_cmd_lock,\n    input wire lsu_icb_cmd_excl,\n    input wire [1:0] lsu_icb_cmd_size,\n    output wire lsu_icb_rsp_valid,\n    input wire lsu_icb_rsp_ready,\n    output wire lsu_icb_rsp_err,\n    output wire lsu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] lsu_icb_rsp_rdata,\n    // ICB Interface for IFU\n    input wire ifu_icb_cmd_valid,\n    output wire ifu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] ifu_icb_cmd_addr,\n    input wire ifu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ifu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] ifu_icb_cmd_wmask,\n    input wire [1:0] ifu_icb_cmd_burst,\n    input wire [1:0] ifu_icb_cmd_beat,\n    input wire ifu_icb_cmd_lock,\n    input wire ifu_icb_cmd_excl,\n    input wire [1:0] ifu_icb_cmd_size,\n    output wire ifu_icb_rsp_valid,\n    input wire ifu_icb_rsp_ready,\n    output wire ifu_icb_rsp_err,\n    output wire ifu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] ifu_icb_rsp_rdata,\n    // Additional signals for peripherals\n    input wire [E203_ADDR_SIZE-1:0] ppi_region_indic,\n    input wire ppi_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] clint_region_indic,\n    input wire clint_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] plic_region_indic,\n    input wire plic_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] fio_region_indic,\n    input wire fio_icb_enable,\n    input wire mem_icb_enable\n);\n\n    // Internal signals for arbitration and buffering\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_valid;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_ready;\n    wire [BIU_ARBT_I_NUM*E203_ADDR_SIZE-1:0] arbt_icb_cmd_addr;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_read;\n    wire [BIU_ARBT_I_NUM*E203_XLEN-1:0] arbt_icb_cmd_wdata;\n    wire [BIU_ARBT_I_NUM*(E203_XLEN/8)-1:0] arbt_icb_cmd_wmask;\n    wire [BIU_ARBT_I_NUM*2-1:0] arbt_icb_cmd_burst;\n    wire [BIU_ARBT_I_NUM*2-1:0] arbt_icb_cmd_beat;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_lock;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_excl;\n    wire [BIU_ARBT_I_NUM*2-1:0] arbt_icb_cmd_size;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_valid;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_ready;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_err;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_excl_ok;\n    wire [BIU_ARBT_I_NUM*E203_XLEN-1:0] arbt_icb_rsp_rdata;\n\n    // Instantiate the ICB Arbiter\n    sirv_gnrl_icb_arbt #(\n        .AW(E203_ADDR_SIZE),\n        .DW(E203_XLEN),\n        .ARBT_NUM(BIU_ARBT_I_NUM),\n        .ARBT_PTR_W(BIU_ARBT_I_PTR_W),\n        .USR_W(1),\n        .ARBT_SCHEME(0),\n        .ALLOW_0CYCL_RSP(0),\n        .FIFO_OUTS_NUM(E203_BIU_OUTS_NUM),\n        .FIFO_CUT_READY(E203_BIU_CMD_CUT_READY)\n    ) u_icb_arbt (\n        .clk(clk),\n        .rst_n(rst_n),\n        .i_bus_icb_cmd_valid({ifu_icb_cmd_valid, lsu_icb_cmd_valid}),\n        .i_bus_icb_cmd_ready({ifu_icb_cmd_ready, lsu_icb_cmd_ready}),\n        .i_bus_icb_cmd_addr({ifu_icb_cmd_addr, lsu_icb_cmd_addr}),\n        .i_bus_icb_cmd_read({ifu_icb_cmd_read, lsu_icb_cmd_read}),\n        .i_bus_icb_cmd_wdata({ifu_icb_cmd_wdata, lsu_icb_cmd_wdata}),\n        .i_bus_icb_cmd_wmask({ifu_icb_cmd_wmask, lsu_icb_cmd_wmask}),\n        .i_bus_icb_cmd_burst({ifu_icb_cmd_burst, lsu_icb_cmd_burst}),\n        .i_bus_icb_cmd_beat({ifu_icb_cmd_beat, lsu_icb_cmd_beat}),\n        .i_bus_icb_cmd_lock({ifu_icb_cmd_lock, lsu_icb_cmd_lock}),\n        .i_bus_icb_cmd_excl({ifu_icb_cmd_excl, lsu_icb_cmd_excl}),\n        .i_bus_icb_cmd_size({ifu_icb_cmd_size, lsu_icb_cmd_size}),\n        .o_icb_cmd_valid(arbt_icb_cmd_valid),\n        .o_icb_cmd_ready(arbt_icb_cmd_ready),\n        .o_icb_cmd_addr(arbt_icb_cmd_addr),\n        .o_icb_cmd_read(arbt_icb_cmd_read),\n        .o_icb_cmd_wdata(arbt_icb_cmd_wdata),\n        .o_icb_cmd_wmask(arbt_icb_cmd_wmask),\n        .o_icb_rsp_valid(arbt_icb_rsp_valid),\n        .o_icb_rsp_ready(arbt_icb_rsp_ready),\n        .o_icb_rsp_err(arbt_icb_rsp_err),\n        .o_icb_rsp_excl_ok(arbt_icb_rsp_excl_ok),\n        .o_icb_rsp_rdata(arbt_icb_rsp_rdata)\n    );\n\n    // Additional logic for response handling and peripheral interfacing would be here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 2, "code": "module e203_exu_oitf #(\n  parameter E203_ITAG_WIDTH = 4,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_PC_SIZE = 32,\n  parameter E203_OITF_DEPTH = 16\n)(\n  input clk,\n  input rst_n,\n\n  // Dispatch interface\n  input dis_ena,\n  output reg dis_ready,\n  input [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n  input disp_i_rdwen,\n  input disp_i_rdfpu,\n  input [E203_PC_SIZE-1:0] disp_i_pc,\n\n  // Retirement interface\n  input ret_ena,\n  output reg [E203_RFIDX_WIDTH-1:0] ret_rdidx,\n  output reg ret_rdwen,\n  output reg ret_rdfpu,\n  output reg [E203_PC_SIZE-1:0] ret_pc,\n\n  // Status outputs\n  output reg oitf_empty,\n  output reg oitf_full\n);\n\n  // Internal registers for OITF\n  reg [E203_RFIDX_WIDTH-1:0] rdidx[E203_OITF_DEPTH-1:0];\n  reg [E203_PC_SIZE-1:0] pc[E203_OITF_DEPTH-1:0];\n  reg [E203_OITF_DEPTH-1:0] rdwen;\n  reg [E203_OITF_DEPTH-1:0] rdfpu;\n  reg [E203_ITAG_WIDTH-1:0] dis_ptr, ret_ptr;\n  reg dis_ptr_wrap, ret_ptr_wrap;\n\n  // Calculate full and empty conditions\n  wire ptr_equal = (dis_ptr == ret_ptr);\n  wire ptr_wrap_diff = (dis_ptr_wrap != ret_ptr_wrap);\n  assign oitf_full = ptr_equal & ptr_wrap_diff;\n  assign oitf_empty = ptr_equal & ~ptr_wrap_diff;\n\n  // Dispatch logic\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      dis_ptr <= 0;\n      dis_ptr_wrap <= 0;\n      dis_ready <= 1;\n    end else if (dis_ena && dis_ready) begin\n      rdidx[dis_ptr] <= disp_i_rdidx;\n      pc[dis_ptr] <= disp_i_pc;\n      rdwen[dis_ptr] <= disp_i_rdwen;\n      rdfpu[dis_ptr] <= disp_i_rdfpu;\n      dis_ptr <= dis_ptr + 1;\n      if (dis_ptr == E203_OITF_DEPTH-1) begin\n        dis_ptr_wrap <= ~dis_ptr_wrap;\n        dis_ptr <= 0;\n      end\n      dis_ready <= ~oitf_full;\n    end\n  end\n\n  // Retirement logic\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      ret_ptr <= 0;\n      ret_ptr_wrap <= 0;\n    end else if (ret_ena && !oitf_empty) begin\n      ret_rdidx <= rdidx[ret_ptr];\n      ret_pc <= pc[ret_ptr];\n      ret_rdwen <= rdwen[ret_ptr];\n      ret_rdfpu <= rdfpu[ret_ptr];\n      ret_ptr <= ret_ptr + 1;\n      if (ret_ptr == E203_OITF_DEPTH-1) begin\n        ret_ptr_wrap <= ~ret_ptr_wrap;\n        ret_ptr <= 0;\n      end\n    end\n  end\n\n  // Update status outputs\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      oitf_empty <= 1;\n      oitf_full <= 0;\n    end else begin\n      oitf_empty <= oitf_empty;\n      oitf_full <= oitf_full;\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 3, "code": "module e203_exu_wbck (\n    input wire alu_wbck_i_valid,\n    output wire alu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] alu_wbck_i_wdat,\n    input wire [E203_RFIDX_WIDTH-1:0] alu_wbck_i_rdidx,\n    input wire longp_wbck_i_valid,\n    output wire longp_wbck_i_ready,\n    input wire [E203_FLEN-1:0] longp_wbck_i_wdat,\n    input wire [4:0] longp_wbck_i_flags,\n    input wire [E203_RFIDX_WIDTH-1:0] longp_wbck_i_rdidx,\n    input wire longp_wbck_i_rdfpu,\n    output wire rf_wbck_o_ena,\n    output wire [E203_XLEN-1:0] rf_wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] rf_wbck_o_rdidx,\n    input wire clk,\n    input wire rst_n\n);\n\n// Arbitration logic\nassign longp_wbck_i_ready = longp_wbck_i_valid;\nassign alu_wbck_i_ready = alu_wbck_i_valid & ~longp_wbck_i_valid;\n\n// Write-back data selection\nwire [E203_XLEN-1:0] selected_wdat = longp_wbck_i_valid ? longp_wbck_i_wdat : alu_wbck_i_wdat;\nwire [E203_RFIDX_WIDTH-1:0] selected_rdidx = longp_wbck_i_valid ? longp_wbck_i_rdidx : alu_wbck_i_rdidx;\nwire selected_rdfpu = longp_wbck_i_valid ? longp_wbck_i_rdfpu : 1'b0;\n\n// Write-back enable\nassign rf_wbck_o_ena = (alu_wbck_i_valid | longp_wbck_i_valid) & ~selected_rdfpu;\n\n// Output assignment\nassign rf_wbck_o_wdat = selected_wdat;\nassign rf_wbck_o_rdidx = selected_rdidx;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 1, "code": "module e203_exu_alu_rglr (\n    input wire alu_i_valid,\n    output reg alu_i_ready,\n    input wire [E203_XLEN-1:0] alu_i_rs1,\n    input wire [E203_XLEN-1:0] alu_i_rs2,\n    input wire [E203_XLEN-1:0] alu_i_imm,\n    input wire [E203_PC_SIZE-1:0] alu_i_pc,\n    input wire [E203_DECINFO_ALU_WIDTH-1:0] alu_i_info,\n    output reg alu_o_valid,\n    input wire alu_o_ready,\n    output reg [E203_XLEN-1:0] alu_o_wbck_wdat,\n    output reg alu_o_wbck_err,\n    output reg alu_o_cmt_ecall,\n    output reg alu_o_cmt_ebreak,\n    output reg alu_o_cmt_wfi,\n    output reg alu_req_alu_add,\n    output reg alu_req_alu_sub,\n    output reg alu_req_alu_xor,\n    output reg alu_req_alu_sll,\n    output reg alu_req_alu_srl,\n    output reg alu_req_alu_sra,\n    output reg alu_req_alu_or,\n    output reg alu_req_alu_and,\n    output reg alu_req_alu_slt,\n    output reg alu_req_alu_sltu,\n    output reg alu_req_alu_lui,\n    output reg [E203_XLEN-1:0] alu_req_alu_op1,\n    output reg [E203_XLEN-1:0] alu_req_alu_op2,\n    output reg [E203_XLEN-1:0] alu_req_alu_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Handshake signals\n    always @(*) begin\n        alu_i_ready = alu_o_ready;\n        alu_o_valid = alu_i_valid;\n    end\n\n    // Operation decoding\n    always @(*) begin\n        alu_req_alu_add = alu_i_info[E203_DECINFO_ALU_ADD];\n        alu_req_alu_sub = alu_i_info[E203_DECINFO_ALU_SUB];\n        alu_req_alu_xor = alu_i_info[E203_DECINFO_ALU_XOR];\n        alu_req_alu_sll = alu_i_info[E203_DECINFO_ALU_SLL];\n        alu_req_alu_srl = alu_i_info[E203_DECINFO_ALU_SRL];\n        alu_req_alu_sra = alu_i_info[E203_DECINFO_ALU_SRA];\n        alu_req_alu_or = alu_i_info[E203_DECINFO_ALU_OR];\n        alu_req_alu_and = alu_i_info[E203_DECINFO_ALU_AND];\n        alu_req_alu_slt = alu_i_info[E203_DECINFO_ALU_SLT];\n        alu_req_alu_sltu = alu_i_info[E203_DECINFO_ALU_SLTU];\n        alu_req_alu_lui = alu_i_info[E203_DECINFO_ALU_LUI];\n    end\n\n    // Operand selection\n    always @(*) begin\n        alu_req_alu_op1 = alu_i_info[E203_DECINFO_ALU_OP1PC] ? alu_i_pc : alu_i_rs1;\n        alu_req_alu_op2 = alu_i_info[E203_DECINFO_ALU_OP2IMM] ? alu_i_imm : alu_i_rs2;\n    end\n\n    // Result and error handling\n    always @(*) begin\n        alu_o_wbck_wdat = alu_req_alu_res;\n        alu_o_wbck_err = alu_i_info[E203_DECINFO_ALU_ECAL] | alu_i_info[E203_DECINFO_ALU_EBRK] | alu_i_info[E203_DECINFO_ALU_WFI];\n        alu_o_cmt_ecall = alu_i_info[E203_DECINFO_ALU_ECAL];\n        alu_o_cmt_ebreak = alu_i_info[E203_DECINFO_ALU_EBRK];\n        alu_o_cmt_wfi = alu_i_info[E203_DECINFO_ALU_WFI];\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 4, "code": "module e203_exu_nice (\n    input wire nice_i_xs_off,\n    input wire nice_i_valid,\n    output wire nice_i_ready,\n    input wire [E203_XLEN-1:0] nice_i_instr,\n    input wire [E203_XLEN-1:0] nice_i_rs1,\n    input wire [E203_XLEN-1:0] nice_i_rs2,\n    input wire [E203_ITAG_WIDTH-1:0] nice_i_itag,\n    output wire nice_o_longpipe,\n    output wire nice_o_valid,\n    input wire nice_o_ready,\n    output wire nice_o_itag_valid,\n    input wire nice_o_itag_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire clk,\n    input wire rst_n\n);\n\n// Internal signals\nwire fifo_push, fifo_pop;\nwire [E203_ITAG_WIDTH-1:0] fifo_data_in, fifo_data_out;\nwire fifo_full, fifo_empty, fifo_valid;\n\n// Instantiate the general-purpose FIFO\nsirv_gnrl_fifo #(\n    .CUT_READY(1),\n    .MSKO(0),\n    .DP(4),\n    .DW(E203_ITAG_WIDTH)\n) itag_fifo (\n    .i_vld(fifo_push),\n    .i_rdy(!fifo_full),\n    .i_dat(fifo_data_in),\n    .o_vld(fifo_valid),\n    .o_rdy(fifo_pop),\n    .o_dat(fifo_data_out),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// Control logic for pushing to FIFO\nassign fifo_push = nice_i_valid && nice_i_ready && !nice_i_xs_off;\nassign fifo_data_in = nice_i_itag;\n\n// Control logic for popping from FIFO\nassign fifo_pop = nice_rsp_multicyc_valid && nice_o_itag_ready && !fifo_empty;\nassign nice_rsp_multicyc_ready = !fifo_empty && nice_o_itag_ready;\n\n// Output assignments\nassign nice_i_ready = !fifo_full && nice_o_ready && !nice_i_xs_off;\nassign nice_o_longpipe = !nice_i_xs_off;\nassign nice_o_valid = nice_i_valid && nice_i_ready;\nassign nice_o_itag_valid = fifo_valid && nice_rsp_multicyc_valid;\nassign nice_o_itag = fifo_data_out;\n\n// Request to custom accelerator\nassign nice_req_valid = nice_i_valid && nice_i_ready && !nice_i_xs_off;\nassign nice_req_instr = nice_i_instr;\nassign nice_req_rs1 = nice_i_rs1;\nassign nice_req_rs2 = nice_i_rs2;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 4, "code": "module e203_dtcm_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n    output wire dtcm_active,\n\n    // LSU ICB Interface\n    input wire lsu2dtcm_icb_cmd_valid,\n    output wire lsu2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] lsu2dtcm_icb_cmd_addr,\n    input wire lsu2dtcm_icb_cmd_read,\n    input wire [31:0] lsu2dtcm_icb_cmd_wdata,\n    input wire [3:0] lsu2dtcm_icb_cmd_wmask,\n    output wire lsu2dtcm_icb_rsp_valid,\n    input wire lsu2dtcm_icb_rsp_ready,\n    output wire lsu2dtcm_icb_rsp_err,\n    output wire [31:0] lsu2dtcm_icb_rsp_rdata,\n\n    // External ICB Interface (Optional)\n    `ifdef E203_HAS_DTCM_EXTITF\n    input wire ext2dtcm_icb_cmd_valid,\n    output wire ext2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] ext2dtcm_icb_cmd_addr,\n    input wire ext2dtcm_icb_cmd_read,\n    input wire [31:0] ext2dtcm_icb_cmd_wdata,\n    input wire [3:0] ext2dtcm_icb_cmd_wmask,\n    output wire ext2dtcm_icb_rsp_valid,\n    input wire ext2dtcm_icb_rsp_ready,\n    output wire ext2dtcm_icb_rsp_err,\n    output wire [31:0] ext2dtcm_icb_rsp_rdata,\n    `endif\n\n    // DTCM RAM Interface\n    output wire dtcm_ram_cs,\n    output wire dtcm_ram_we,\n    output wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    output wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    output wire clk_dtcm_ram\n);\n\n    // Internal signals\n    wire arbiter_cmd_valid;\n    wire arbiter_cmd_ready;\n    wire arbiter_cmd_read;\n    wire [E203_DTCM_ADDR_WIDTH-1:0] arbiter_cmd_addr;\n    wire [31:0] arbiter_cmd_wdata;\n    wire [3:0] arbiter_cmd_wmask;\n    wire arbiter_rsp_valid;\n    wire arbiter_rsp_ready;\n    wire arbiter_rsp_err;\n    wire [31:0] arbiter_rsp_rdata;\n\n    // Instantiate the bus arbiter\n    sirv_gnrl_icb_arbt #(\n        .ARBT_SCHEME(0),\n        .ALLOW_0CYCL_RSP(0),\n        .FIFO_OUTS_NUM(E203_DTCM_OUTS_NUM),\n        .FIFO_CUT_READY(0),\n        .USR_W(1),\n        .ARBT_NUM(DTCM_ARBT_I_NUM),\n        .AW(E203_DTCM_ADDR_WIDTH),\n        .DW(32),\n        .ARBT_PTR_W(DTCM_ARBT_I_PTR_W)\n    ) u_arbiter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .i_icb_cmd_valid(arbiter_cmd_valid),\n        .i_icb_cmd_ready(arbiter_cmd_ready),\n        .i_icb_cmd_read(arbiter_cmd_read),\n        .i_icb_cmd_addr(arbiter_cmd_addr),\n        .i_icb_cmd_wdata(arbiter_cmd_wdata),\n        .i_icb_cmd_wmask(arbiter_cmd_wmask),\n        .i_icb_rsp_valid(arbiter_rsp_valid),\n        .i_icb_rsp_ready(arbiter_rsp_ready),\n        .i_icb_rsp_err(arbiter_rsp_err),\n        .i_icb_rsp_rdata(arbiter_rsp_rdata)\n    );\n\n    // Instantiate the SRAM controller\n    sirv_sram_icb_ctrl #(\n        .DW(E203_DTCM_DATA_WIDTH),\n        .AW(E203_DTCM_ADDR_WIDTH),\n        .MW(E203_DTCM_WMSK_WIDTH),\n        .AW_LSB(2),\n        .USR_W(1)\n    ) u_sram_ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .tcm_cgstop(tcm_cgstop),\n        .i_icb_cmd_valid(arbiter_cmd_valid),\n        .i_icb_cmd_ready(arbiter_cmd_ready),\n        .i_icb_cmd_read(arbiter_cmd_read),\n        .i_icb_cmd_addr(arbiter_cmd_addr),\n        .i_icb_cmd_wdata(arbiter_cmd_wdata),\n        .i_icb_cmd_wmask(arbiter_cmd_wmask),\n        .i_icb_rsp_valid(arbiter_rsp_valid),\n        .i_icb_rsp_ready(arbiter_rsp_ready),\n        .i_icb_rsp_err(arbiter_rsp_err),\n        .i_icb_rsp_rdata(arbiter_rsp_rdata),\n        .ram_cs(dtcm_ram_cs),\n        .ram_we(dtcm_ram_we),\n        .ram_addr(dtcm_ram_addr),\n        .ram_wem(dtcm_ram_wem),\n        .ram_din(dtcm_ram_din),\n        .ram_dout(dtcm_ram_dout),\n        .clk_ram(clk_dtcm_ram),\n        .test_mode(test_mode)\n    );\n\n    // Control logic for dtcm_active signal\n    assign dtcm_active = arbiter_cmd_valid || arbiter_rsp_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 1, "code": "module e203_exu_excp(\n    output commit_trap,\n    output core_wfi,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input amo_wait,\n    input alu_excp_i_valid,\n    input alu_excp_i_ld,\n    input alu_excp_i_stamo,\n    input alu_excp_i_misalgn,\n    input alu_excp_i_buserr,\n    input alu_excp_i_ecall,\n    input alu_excp_i_ebreak,\n    input alu_excp_i_wfi,\n    input alu_excp_i_ifu_misalgn,\n    input alu_excp_i_ifu_buserr,\n    input alu_excp_i_ifu_ilegl,\n    input [E203_PC_SIZE-1:0] alu_excp_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_excp_i_instr,\n    input alu_excp_i_pc_vld,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input longp_excp_i_insterr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input excpirq_flush_ack,\n    output excpirq_flush_req,\n    output nonalu_excpirq_flush_req_raw,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op1,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op2,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input cmt_dret_ena,\n    input cmt_ena,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_badaddr_ena,\n    output cmt_epc_ena,\n    output cmt_cause_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output excp_active,\n    input clk,\n    input rst_n\n);\n    // Implementation of exception handling logic\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 5, "code": "module e203_reset_ctrl #(\n    parameter MASTER = 1,\n    parameter integer RST_SYNC_LEVEL = `E203_ASYNC_FF_LEVELS\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    output wire rst_core,\n    output wire rst_itcm,\n    output wire rst_dtcm,\n    output wire rst_aon\n);\n\n    // Synchronized reset signal\n    reg [RST_SYNC_LEVEL-1:0] sync_rst_n;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            sync_rst_n <= {RST_SYNC_LEVEL{1'b0}};\n        end else begin\n            sync_rst_n <= {sync_rst_n[RST_SYNC_LEVEL-2:0], 1'b1};\n        end\n    end\n\n    // Generate reset outputs\n    assign rst_core = (test_mode) ? rst_n : sync_rst_n[RST_SYNC_LEVEL-1];\n    assign rst_itcm = (test_mode) ? rst_n : sync_rst_n[RST_SYNC_LEVEL-1];\n    assign rst_dtcm = (test_mode) ? rst_n : sync_rst_n[RST_SYNC_LEVEL-1];\n    assign rst_aon  = (test_mode) ? rst_n : sync_rst_n[RST_SYNC_LEVEL-1];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 4, "code": "module e203_exu_alu_muldiv(\n    input mdv_nob2b,\n    input muldiv_i_valid,\n    output muldiv_i_ready,\n    input [E203_XLEN-1:0] muldiv_i_rs1,\n    input [E203_XLEN-1:0] muldiv_i_rs2,\n    input [E203_XLEN-1:0] muldiv_i_imm,\n    input [E203_DECINFO_MULDIV_WIDTH-1:0] muldiv_i_info,\n    input [E203_ITAG_WIDTH-1:0] muldiv_i_itag,\n    output muldiv_i_longpipe,\n    input flush_pulse,\n    output muldiv_o_valid,\n    input muldiv_o_ready,\n    output [E203_XLEN-1:0] muldiv_o_wbck_wdat,\n    output muldiv_o_wbck_err,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    output muldiv_req_alu_add,\n    output muldiv_req_alu_sub,\n    input [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output muldiv_sbf_0_ena,\n    output [32:0] muldiv_sbf_0_nxt,\n    input [32:0] muldiv_sbf_0_r,\n    output muldiv_sbf_1_ena,\n    output [32:0] muldiv_sbf_1_nxt,\n    input [32:0] muldiv_sbf_1_r,\n    input clk,\n    input rst_n\n);\n\n// Internal signals and registers\nreg [4:0] state;\nreg [4:0] next_state;\nreg [E203_XLEN-1:0] operand1, operand2;\nreg [E203_XLEN-1:0] result;\nreg valid, ready;\nwire operation_complete;\n\n// State definitions\nlocalparam MULDIV_STATE_0TH = 5'd0;\nlocalparam MULDIV_STATE_EXEC = 5'd1;\nlocalparam MULDIV_STATE_REMD_CHCK = 5'd2;\nlocalparam MULDIV_STATE_QUOT_CORR = 5'd3;\nlocalparam MULDIV_STATE_REMD_CORR = 5'd4;\n\n// FSM for handling multiplier and divider operations\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        state <= MULDIV_STATE_0TH;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (state)\n        MULDIV_STATE_0TH: begin\n            if (muldiv_i_valid && !flush_pulse)\n                next_state = MULDIV_STATE_EXEC;\n            else\n                next_state = MULDIV_STATE_0TH;\n        end\n        MULDIV_STATE_EXEC: begin\n            if (operation_complete)\n                next_state = MULDIV_STATE_REMD_CHCK;\n            else\n                next_state = MULDIV_STATE_EXEC;\n        end\n        MULDIV_STATE_REMD_CHCK: begin\n            if (need_correction)\n                next_state = MULDIV_STATE_QUOT_CORR;\n            else\n                next_state = MULDIV_STATE_0TH;\n        end\n        MULDIV_STATE_QUOT_CORR: begin\n            next_state = MULDIV_STATE_REMD_CORR;\n        end\n        MULDIV_STATE_REMD_CORR: begin\n            next_state = MULDIV_STATE_0TH;\n        end\n        default: begin\n            next_state = MULDIV_STATE_0TH;\n        end\n    endcase\nend\n\n// Output logic\nassign muldiv_i_ready = (state == MULDIV_STATE_0TH);\nassign muldiv_o_valid = (state == MULDIV_STATE_REMD_CORR) && operation_complete;\nassign muldiv_o_wbck_wdat = result;\nassign muldiv_o_wbck_err = 0;\n\n// Operation logic (simplified)\nalways @(posedge clk) begin\n    if (state == MULDIV_STATE_EXEC) begin\n        // Example operation logic\n        result <= operand1 * operand2; // Simplified multiplication\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 2, "code": "module e203_exu(\n    // Basic Interface\n    output commit_mret,\n    output commit_trap,\n    output exu_active,\n    output excp_active,\n    output core_wfi,\n    output tm_stop,\n    output itcm_nohold,\n    output core_cgstop,\n    output tcm_cgstop,\n    input [E203_HART_ID_W-1:0] core_mhartid,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    output wfi_halt_ifu_req,\n    input wfi_halt_ifu_ack,\n    output oitf_empty,\n    output [E203_XLEN-1:0] rf2ifu_x1,\n    output [E203_XLEN-1:0] rf2ifu_rs1,\n    output dec2ifu_rden,\n    output dec2ifu_rs1en,\n    output [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    output dec2ifu_mulhsu,\n    output dec2ifu_div,\n    output dec2ifu_rem,\n    output dec2ifu_divu,\n    output dec2ifu_remu,\n    input test_mode,\n    input clk_aon,\n    input clk,\n    input rst_n,\n\n    // From/To debug ctrl module\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output wr_dcsr_ena,\n    output wr_dpc_ena,\n    output wr_dscratch_ena,\n    output [E203_XLEN-1:0] wr_csr_nxt,\n    input [E203_XLEN-1:0] dcsr_r,\n    input [E203_PC_SIZE-1:0] dpc_r,\n    input [E203_XLEN-1:0] dscratch_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input dbg_stopcycle,\n\n    // IFU IR stage to EXU interface\n    input i_valid,\n    output i_ready,\n    input [E203_INSTR_SIZE-1:0] i_ir,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_pc_vld,\n    input i_misalgn,\n    input i_buserr,\n    input i_prdt_taken,\n    input i_muldiv_b2b,\n    input [E203_RFIDX_WIDTH-1:0] i_rs1idx,\n    input [E203_RFIDX_WIDTH-1:0] i_rs2idx,\n\n    // Flush interface to IFU\n    input pipe_flush_ack,\n    output pipe_flush_req,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    `ifdef E203_TIMING_BOOST\n    output [E203_PC_SIZE-1:0] pipe_flush_pc,\n    `endif\n\n    // LSU Write-Back Interface\n    input lsu_o_valid,\n    output lsu_o_ready,\n    input [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    input [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    input lsu_o_wbck_err,\n    input lsu_o_cmt_ld,\n    input lsu_o_cmt_st,\n    input [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    input lsu_o_cmt_buserr,\n\n    // AGU ICB Interface to LSU-ctrl\n    output agu_icb_cmd_valid,\n    input agu_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output agu_icb_cmd_read,\n    output [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output agu_icb_cmd_lock,\n    output agu_icb_cmd_excl,\n    output [1:0] agu_icb_cmd_size,\n    output agu_icb_cmd_back2agu,\n    output agu_icb_cmd_usign,\n    output [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input agu_icb_rsp_valid,\n    output agu_icb_rsp_ready,\n    input agu_icb_rsp_err,\n    input agu_icb_rsp_excl_ok,\n    input [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    // CSR_NICE Interface(optional)\n    `ifdef E203_HAS_CSR_NICE\n    output nice_csr_valid,\n    input nice_csr_ready,\n    output [31:0] nice_csr_addr,\n    output nice_csr_wr,\n    output [31:0] nice_csr_wdata,\n    input [31:0] nice_csr_rdata,\n    `endif\n\n    // NICE Interface(optional)\n    `ifdef E203_HAS_NICE\n    output nice_req_valid,\n    input nice_req_ready,\n    output [E203_XLEN-1:0] nice_req_inst,\n    output [E203_XLEN-1:0] nice_req_rs1,\n    output [E203_XLEN-1:0] nice_req_rs2,\n    input nice_rsp_multicyc_valid,\n    output nice_rsp_multicyc_ready,\n    input [E203_XLEN-1:0] nice_rsp_multicyc_dat,\n    input nice_rsp_multicyc_err\n    `endif\n);\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 5, "code": "module e203_dtcm_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n\n    // LSU ICB Interface\n    input wire lsu2dtcm_icb_cmd_valid,\n    output wire lsu2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] lsu2dtcm_icb_cmd_addr,\n    input wire lsu2dtcm_icb_cmd_read,\n    input wire [31:0] lsu2dtcm_icb_cmd_wdata,\n    input wire [3:0] lsu2dtcm_icb_cmd_wmask,\n    output wire lsu2dtcm_icb_rsp_valid,\n    input wire lsu2dtcm_icb_rsp_ready,\n    output wire lsu2dtcm_icb_rsp_err,\n    output wire [31:0] lsu2dtcm_icb_rsp_rdata,\n\n    // External ICB Interface (Optional)\n    `ifdef E203_HAS_DTCM_EXTITF\n    input wire ext2dtcm_icb_cmd_valid,\n    output wire ext2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] ext2dtcm_icb_cmd_addr,\n    input wire ext2dtcm_icb_cmd_read,\n    input wire [31:0] ext2dtcm_icb_cmd_wdata,\n    input wire [3:0] ext2dtcm_icb_cmd_wmask,\n    output wire ext2dtcm_icb_rsp_valid,\n    input wire ext2dtcm_icb_rsp_ready,\n    output wire ext2dtcm_icb_rsp_err,\n    output wire [31:0] ext2dtcm_icb_rsp_rdata,\n    `endif\n\n    // DTCM RAM Interface\n    output wire dtcm_ram_cs,\n    output wire dtcm_ram_we,\n    output wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    output wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    output wire clk_dtcm_ram,\n    output wire dtcm_active\n);\n\n    // Internal signals\n    wire icb_cmd_valid;\n    wire icb_cmd_ready;\n    wire [E203_DTCM_ADDR_WIDTH-1:0] icb_cmd_addr;\n    wire icb_cmd_read;\n    wire [31:0] icb_cmd_wdata;\n    wire [3:0] icb_cmd_wmask;\n    wire icb_rsp_valid;\n    wire icb_rsp_ready;\n    wire icb_rsp_err;\n    wire [31:0] icb_rsp_rdata;\n\n    // Arbitration logic (if external interface is enabled)\n    `ifdef E203_HAS_DTCM_EXTITF\n    sirv_gnrl_icb_arbt #(\n        .ARBT_SCHEME(0),\n        .ALLOW_0CYCL_RSP(0),\n        .FIFO_OUTS_NUM(E203_DTCM_OUTS_NUM),\n        .FIFO_CUT_READY(0),\n        .USR_W(1),\n        .ARBT_NUM(DTCM_ARBT_I_NUM),\n        .AW(E203_DTCM_ADDR_WIDTH),\n        .DW(32),\n        .ARBT_PTR_W(DTCM_ARBT_I_PTR_W)\n    ) u_arbiter (\n        .i_bus_icb_cmd_valid({ext2dtcm_icb_cmd_valid, lsu2dtcm_icb_cmd_valid}),\n        .i_bus_icb_cmd_ready({ext2dtcm_icb_cmd_ready, lsu2dtcm_icb_cmd_ready}),\n        .i_bus_icb_cmd_addr({ext2dtcm_icb_cmd_addr, lsu2dtcm_icb_cmd_addr}),\n        .i_bus_icb_cmd_read({ext2dtcm_icb_cmd_read, lsu2dtcm_icb_cmd_read}),\n        .i_bus_icb_cmd_wdata({ext2dtcm_icb_cmd_wdata, lsu2dtcm_icb_cmd_wdata}),\n        .i_bus_icb_cmd_wmask({ext2dtcm_icb_cmd_wmask, lsu2dtcm_icb_cmd_wmask}),\n        .i_bus_icb_rsp_valid({ext2dtcm_icb_rsp_valid, lsu2dtcm_icb_rsp_valid}),\n        .i_bus_icb_rsp_ready({ext2dtcm_icb_rsp_ready, lsu2dtcm_icb_rsp_ready}),\n        .i_bus_icb_rsp_err({ext2dtcm_icb_rsp_err, lsu2dtcm_icb_rsp_err}),\n        .i_bus_icb_rsp_rdata({ext2dtcm_icb_rsp_rdata, lsu2dtcm_icb_rsp_rdata}),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n    `else\n    assign icb_cmd_valid = lsu2dtcm_icb_cmd_valid;\n    assign lsu2dtcm_icb_cmd_ready = icb_cmd_ready;\n    assign icb_cmd_addr = lsu2dtcm_icb_cmd_addr;\n    assign icb_cmd_read = lsu2dtcm_icb_cmd_read;\n    assign icb_cmd_wdata = lsu2dtcm_icb_cmd_wdata;\n    assign icb_cmd_wmask = lsu2dtcm_icb_cmd_wmask;\n    assign lsu2dtcm_icb_rsp_valid = icb_rsp_valid;\n    assign icb_rsp_ready = lsu2dtcm_icb_rsp_ready;\n    assign lsu2dtcm_icb_rsp_err = icb_rsp_err;\n    assign lsu2dtcm_icb_rsp_rdata = icb_rsp_rdata;\n    `endif\n\n    // SRAM controller\n    sirv_sram_icb_ctrl #(\n        .DW(E203_DTCM_DATA_WIDTH),\n        .AW(E203_DTCM_ADDR_WIDTH),\n        .MW(E203_DTCM_WMSK_WIDTH),\n        .AW_LSB(2),\n        .USR_W(1)\n    ) u_sram_ctrl (\n        .sram_ctrl_active(dtcm_active),\n        .tcm_cgstop(tcm_cgstop),\n        .i_icb_cmd_valid(icb_cmd_valid),\n        .i_icb_cmd_ready(icb_cmd_ready),\n        .i_icb_cmd_read(icb_cmd_read),\n        .i_icb_cmd_addr(icb_cmd_addr),\n        .i_icb_cmd_wdata(icb_cmd_wdata),\n        .i_icb_cmd_wmask(icb_cmd_wmask),\n        .i_icb_cmd_usr(1'b0),\n        .i_icb_rsp_valid(icb_rsp_valid),\n        .i_icb_rsp_ready(icb_rsp_ready),\n        .i_icb_rsp_rdata(icb_rsp_rdata),\n        .i_icb_rsp_usr(),\n        .ram_cs(dtcm_ram_cs),\n        .ram_we(dtcm_ram_we),\n        .ram_addr(dtcm_ram_addr),\n        .ram_wem(dtcm_ram_wem),\n        .ram_din(dtcm_ram_din),\n        .ram_dout(dtcm_ram_dout),\n        .clk_ram(clk_dtcm_ram),\n        .test_mode(test_mode),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 17, "code": "module e203_cpu_top(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire tcm_sd,\n    input wire tcm_ds,\n    input wire [E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input wire ext2itcm_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ext2itcm_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] ext2itcm_icb_cmd_wmask,\n    input wire ext2itcm_icb_cmd_valid,\n    input wire ext2itcm_icb_rsp_ready,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire dbg_irq_r,\n    output wire ext2itcm_icb_cmd_ready,\n    output wire ext2itcm_icb_rsp_valid,\n    output wire ext2itcm_icb_rsp_err,\n    output wire [E203_XLEN-1:0] ext2itcm_icb_rsp_rdata\n);\n\n    // Internal signals\n    wire core_clk = clk;\n    wire core_rst_n = rst_n;\n    wire [E203_PC_SIZE-1:0] core_pc;\n    wire core_dbg_irq;\n    wire core_mem_cmd_valid;\n    wire core_mem_cmd_ready;\n    wire core_mem_rsp_valid;\n    wire core_mem_rsp_ready;\n    wire core_csr_clk_internal;\n    wire core_wfi_internal;\n    wire tm_stop_internal;\n    wire [E203_PC_SIZE-1:0] dbg_pc;\n    wire dbg_irq_sync;\n    wire [E203_XLEN-1:0] itcm_data_out;\n\n    // Core instantiation\n    e203_cpu core_inst (\n        .clk(core_clk),\n        .rst_n(core_rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ext_irq_a(ext_irq_a),\n        .sft_irq_a(sft_irq_a),\n        .tmr_irq_a(tmr_irq_a),\n        .tcm_sd(tcm_sd),\n        .tcm_ds(tcm_ds),\n        .ext2itcm_icb_cmd_addr(ext2itcm_icb_cmd_addr),\n        .ext2itcm_icb_cmd_read(ext2itcm_icb_cmd_read),\n        .ext2itcm_icb_cmd_wdata(ext2itcm_icb_cmd_wdata),\n        .ext2itcm_icb_cmd_wmask(ext2itcm_icb_cmd_wmask),\n        .ext2itcm_icb_cmd_valid(ext2itcm_icb_cmd_valid),\n        .ext2itcm_icb_rsp_ready(ext2itcm_icb_rsp_ready),\n        .inspect_pc(core_pc),\n        .inspect_dbg_irq(core_dbg_irq),\n        .inspect_mem_cmd_valid(core_mem_cmd_valid),\n        .inspect_mem_cmd_ready(core_mem_cmd_ready),\n        .inspect_mem_rsp_valid(core_mem_rsp_valid),\n        .inspect_mem_rsp_ready(core_mem_rsp_ready),\n        .inspect_core_clk(core_clk),\n        .core_csr_clk(core_csr_clk_internal),\n        .core_wfi(core_wfi_internal),\n        .tm_stop(tm_stop_internal),\n        .dbg_irq_r(dbg_irq_sync),\n        .ext2itcm_icb_cmd_ready(ext2itcm_icb_cmd_ready),\n        .ext2itcm_icb_rsp_valid(ext2itcm_icb_rsp_valid),\n        .ext2itcm_icb_rsp_err(ext2itcm_icb_rsp_err),\n        .ext2itcm_icb_rsp_rdata(itcm_data_out)\n    );\n\n    // Output assignments\n    assign inspect_pc = core_pc;\n    assign inspect_dbg_irq = core_dbg_irq;\n    assign inspect_mem_cmd_valid = core_mem_cmd_valid;\n    assign inspect_mem_cmd_ready = core_mem_cmd_ready;\n    assign inspect_mem_rsp_valid = core_mem_rsp_valid;\n    assign inspect_mem_rsp_ready = core_mem_rsp_ready;\n    assign inspect_core_clk = core_clk;\n    assign core_csr_clk = core_csr_clk_internal;\n    assign core_wfi = core_wfi_internal;\n    assign tm_stop = tm_stop_internal;\n    assign dbg_irq_r = dbg_irq_sync;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 3, "code": "module e203_exu_alu_csrctrl (\n    input wire csr_i_valid,\n    output reg csr_i_ready,\n    input wire [E203_XLEN-1:0] csr_i_rs1,\n    input wire [E203_DECINFO_CSR_WIDTH-1:0] csr_i_info,\n    input wire csr_i_rdwen,\n    output reg csr_ena,\n    output reg csr_wr_en,\n    output reg csr_rd_en,\n    output reg [11:0] csr_idx,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output reg [E203_XLEN-1:0] wbck_csr_dat,\n    output reg csr_o_valid,\n    input wire csr_o_ready,\n    output reg [E203_XLEN-1:0] csr_o_wbck_wdat,\n    output reg csr_o_wbck_err,\n    input wire clk,\n    input wire rst_n,\n    input wire nice_xs_off,\n    output reg csr_sel_nice,\n    output reg nice_csr_valid,\n    input wire nice_csr_ready,\n    output reg [31:0] nice_csr_addr,\n    output reg nice_csr_wr,\n    output reg [31:0] nice_csr_wdata,\n    input wire [31:0] nice_csr_rdata\n);\n\n    always @(*) begin\n        csr_i_ready = csr_o_ready;\n        csr_o_valid = csr_i_valid && csr_o_ready;\n        csr_ena = csr_i_valid && csr_o_ready && !csr_access_ilgl;\n        csr_idx = csr_i_info[E203_DECINFO_CSR_CSRIDX +: 12];\n\n        // Determine CSR operation type\n        csr_rd_en = csr_i_valid && ((csr_i_info[E203_DECINFO_CSR_CSRRW] && csr_i_rdwen) ||\n                                    csr_i_info[E203_DECINFO_CSR_CSRRS] ||\n                                    csr_i_info[E203_DECINFO_CSR_CSRRC]);\n\n        csr_wr_en = csr_i_valid && (csr_i_info[E203_DECINFO_CSR_CSRRW] ||\n                                    (csr_i_info[E203_DECINFO_CSR_CSRRS] && !csr_i_info[E203_DECINFO_CSR_RS1IS0]) ||\n                                    (csr_i_info[E203_DECINFO_CSR_CSRRC] && !csr_i_info[E203_DECINFO_CSR_RS1IS0]));\n\n        // Prepare data for CSR write operations\n        if (csr_i_info[E203_DECINFO_CSR_CSRRW]) begin\n            wbck_csr_dat = csr_i_rs1;\n        end else if (csr_i_info[E203_DECINFO_CSR_CSRRS]) begin\n            wbck_csr_dat = csr_i_rs1 | read_csr_dat;\n        end else if (csr_i_info[E203_DECINFO_CSR_CSRRC]) begin\n            wbck_csr_dat = (~csr_i_rs1) & read_csr_dat;\n        end\n\n        // Handle NICE interface selection\n        csr_sel_nice = (csr_idx[11:8] == 4'hE) && !nice_xs_off;\n        if (csr_sel_nice) begin\n            nice_csr_valid = csr_i_valid && csr_o_ready;\n            nice_csr_addr = {20'h0, csr_idx};\n            nice_csr_wr = csr_wr_en;\n            nice_csr_wdata = wbck_csr_dat;\n            csr_o_wbck_wdat = nice_csr_rdata;\n        end else begin\n            nice_csr_valid = 1'b0;\n            nice_csr_addr = 32'h0;\n            nice_csr_wr = 1'b0;\n            nice_csr_wdata = 32'h0;\n            csr_o_wbck_wdat = read_csr_dat;\n        end\n\n        // Error handling\n        csr_o_wbck_err = csr_access_ilgl;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 6, "code": "module e203_reset_ctrl #(\n    parameter MASTER = 1,\n    parameter integer RST_SYNC_LEVEL = `E203_ASYNC_FF_LEVELS\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    output wire rst_core,\n    output wire rst_itcm,\n    output wire rst_dtcm,\n    output wire rst_aon\n);\n\n    // Synchronized reset generation\n    reg [RST_SYNC_LEVEL-1:0] rst_sync_reg = {RST_SYNC_LEVEL{1'b1}};\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            rst_sync_reg <= {RST_SYNC_LEVEL{1'b1}};\n        end else if (test_mode) begin\n            rst_sync_reg <= {RST_SYNC_LEVEL{rst_n}};\n        end else begin\n            rst_sync_reg <= {rst_sync_reg[RST_SYNC_LEVEL-2:0], 1'b0};\n        end\n    end\n\n    // Output reset signals\n    assign rst_core = MASTER ? rst_sync_reg[RST_SYNC_LEVEL-1] : rst_n;\n    assign rst_aon = rst_sync_reg[RST_SYNC_LEVEL-1];\n\n    // Conditional compilation for ITCM and DTCM resets\n    `ifdef E203_HAS_ITCM\n    assign rst_itcm = rst_sync_reg[RST_SYNC_LEVEL-1];\n    `else\n    assign rst_itcm = 1'b0;\n    `endif\n\n    `ifdef E203_HAS_DTCM\n    assign rst_dtcm = rst_sync_reg[RST_SYNC_LEVEL-1];\n    `else\n    assign rst_dtcm = 1'b0;\n    `endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 17, "code": "// E203 Processor Configuration Document\n\n// 1. Introduction\n\n// This document describes the configuration system for the E203 processor. The E203 is a RISC-V architecture-based processor core that can be configured with various features and functional modules via macro definitions. This configuration file is licensed under the Apache 2.0 open-source license and is maintained by Nuclei System Technology.\n\n// 2. Basic Configuration Items\n\n// 2.1 Debug and Interrupt Configuration\n// **`E203_CFG_DEBUG_HAS_JTAG`**: Enables support for JTAG debug interface.\n// **`E203_CFG_IRQ_NEED_SYNC`**: Enables interrupt synchronization mechanism.\n\n// 2.2 Address Space Configuration\n// The system supports three address width configurations, and only one can be selected at a time:\n// **`E203_CFG_ADDR_SIZE_IS_16`**: 16-bit address space.\n// **`E203_CFG_ADDR_SIZE_IS_24`**: 24-bit address space.\n// **`E203_CFG_ADDR_SIZE_IS_32`**: 32-bit address space (currently selected configuration).\n\n// The address size is unified through the **`E203_CFG_ADDR_SIZE`** macro, which is automatically set based on the chosen configuration.\n\n// 2.3 CPU Function Configuration\n// **`E203_CFG_SUPPORT_MCYCLE_MINSTRET`**: Enables support for MCYCLE and MINSTRET counters.\n// **`E203_CFG_REGNUM_IS_32`**: Configures the number of registers to 32.\n// **`E203_CFG_HAS_ECC`**: Enables ECC (Error Correction Code) functionality.\n// **`E203_CFG_HAS_NICE`**: Enables the NICE instruction extension.\n// **`E203_CFG_SUPPORT_SHARE_MULDIV`**: Enables shared multiplication and division units.\n// **`E203_CFG_SUPPORT_AMO`**: Enables support for atomic memory operations (AMO).\n\n// 2.4 Memory System Configuration\n\n// Instruction TCM (ITCM)\n// **`E203_CFG_HAS_ITCM`**: Enables Instruction Tightly Coupled Memory (ITCM).\n// **`E203_CFG_ITCM_ADDR_WIDTH`**: Configures the ITCM address width. The current setting is 16 bits.\n//   - Supports a 64KB configuration (16-bit address width, 8192 depth).\n//   - Optional 1024KB configuration (20-bit address width).\n//   - Optional 2048KB configuration (21-bit address width).\n\n// Data TCM (DTCM)\n// **`E203_CFG_HAS_DTCM`**: Enables Data Tightly Coupled Memory (DTCM).\n// **`E203_CFG_DTCM_ADDR_WIDTH`**: Configures the DTCM address width. The current setting is 16 bits.\n//   - Supports a 16KB configuration (14-bit address width, 4096 depth).\n//   - Supports a 256KB configuration (18-bit address width, 65536 depth).\n//   - Optional 1MB configuration (20-bit address width, 262144 depth).\n\n// 2.5 Memory Mapping Configuration\n\n// The system defines the base addresses for the following memory regions:\n\n// 1. **ITCM Region**:\n//    - Base address: `0x8000_0000`\n//    - Defined through **`E203_CFG_ITCM_ADDR_BASE`**.\n// 2. **DTCM Region**:\n//    - Base address: `0x9000_0000`\n//    - Defined through **`E203_CFG_DTCM_ADDR_BASE`**.\n// 3. **Peripheral Interface Regions**:\n//    - **PPI Region**: `0x1000_0000 - 0x1FFF_FFFF`\n//    - Defined through **`E203_CFG_PPI_ADDR_BASE`** and **`E203_CFG_PPI_BASE_REGION`**.\n// 4. **System Controller Regions**:\n//    - **CLINT Region**: `0x0200_0000 - 0x0200_FFFF`\n//    - Base Address of CLINT is defined through **`E203_CFG_CLINT_ADDR_BASE`**.(`E203_CFG_ADDR_SIZE'h0200_0000`)\n//    -  **`E203_CFG_CLINT_BASE_REGION`** macro defines the high address range used to determine whether an address belongs to CLINT REGION (`E203_CFG_ADDR_SIZE-1:E203_CFG_ADDR_SIZE-16`)\n//    - **PLIC Region**: `0x0C00_0000 - 0x0CFF_FFFF`\n//    - Base Address of PLIC is defined through **`E203_CFG_PLIC_ADDR_BASE`**.(`E203_CFG_ADDR_SIZE'h0C00_0000`)\n//    -  **`E203_CFG_PLIC_BASE_REGION`** macro defines the high address range used to determine whether an address belongs to PLIC REGION (`E203_CFG_ADDR_SIZE-1:E203_CFG_ADDR_SIZE-8`)\n// 5. **Fast IO Region**:\n//    - Base address: `0xF000_0000`\n//    - Defined through **`E203_CFG_FIO_ADDR_BASE`** and **`E203_CFG_FIO_BASE_REGION`**.\n\n// 3. Notes\n\n// 1. Only one address width configuration should be enabled at a time.\n// 2. TCM configurations should be selected based on available hardware resources.\n// 3. Memory mapping configurations must avoid address overlap.\n// 4. It is recommended to carefully evaluate the system's resource requirements and performance demands when modifying configurations.", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 5, "code": "module e203_exu_branchslv(\n    input wire cmt_i_valid,\n    output wire cmt_i_ready,\n    input wire cmt_i_rv32,\n    input wire cmt_i_dret,\n    input wire cmt_i_mret,\n    input wire cmt_i_fencei,\n    input wire cmt_i_bjp,\n    input wire cmt_i_bjp_prdt,\n    input wire cmt_i_bjp_rslv,\n    input wire [E203_PC_SIZE-1:0] cmt_i_pc,\n    input wire [E203_XLEN-1:0] cmt_i_imm,\n    input wire [E203_PC_SIZE-1:0] csr_epc_r,\n    input wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    input wire nonalu_excpirq_flush_req_raw,\n    input wire brchmis_flush_ack,\n    output wire brchmis_flush_req,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op1,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op2,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_pc,\n    output wire cmt_mret_ena,\n    output wire cmt_dret_ena,\n    output wire cmt_fencei_ena,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Flush need generation\n    wire flush_need = (cmt_i_bjp & (cmt_i_bjp_prdt ^ cmt_i_bjp_rslv)) | cmt_i_fencei | cmt_i_mret | cmt_i_dret;\n\n    // Flush target calculation\n    wire [E203_PC_SIZE-1:0] flush_target;\n    assign flush_target = cmt_i_dret ? csr_dpc_r :\n                          cmt_i_mret ? csr_epc_r :\n                          (cmt_i_bjp & ~cmt_i_bjp_prdt & cmt_i_bjp_rslv) ? (cmt_i_pc + cmt_i_imm) :\n                          (cmt_i_bjp & cmt_i_bjp_prdt & ~cmt_i_bjp_rslv) ? (cmt_i_pc + (cmt_i_rv32 ? 4 : 2)) :\n                          csr_epc_r;\n\n    // Pipeline flush control\n    assign brchmis_flush_req = flush_need & cmt_i_valid & ~nonalu_excpirq_flush_req_raw;\n    assign brchmis_flush_add_op1 = cmt_i_pc;\n    assign brchmis_flush_add_op2 = cmt_i_imm;\n\n    // Special signal commit\n    assign cmt_mret_ena = cmt_i_mret & flush_need;\n    assign cmt_dret_ena = cmt_i_dret & flush_need;\n    assign cmt_fencei_ena = cmt_i_fencei & flush_need;\n\n    // Controls the ready signal for the instruction\n    assign cmt_i_ready = ~flush_need & ~nonalu_excpirq_flush_req_raw & brchmis_flush_ack;\n\n    // Timing boost option\n    `ifdef E203_TIMING_BOOST\n    assign brchmis_flush_pc = flush_target;\n    `else\n    assign brchmis_flush_pc = 0; // Default to zero when timing boost is not enabled\n    `endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 6, "code": "module e203_dtcm_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n    output wire dtcm_active,\n\n    // LSU ICB Interface\n    input wire lsu2dtcm_icb_cmd_valid,\n    output wire lsu2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] lsu2dtcm_icb_cmd_addr,\n    input wire lsu2dtcm_icb_cmd_read,\n    input wire [31:0] lsu2dtcm_icb_cmd_wdata,\n    input wire [3:0] lsu2dtcm_icb_cmd_wmask,\n    output wire lsu2dtcm_icb_rsp_valid,\n    input wire lsu2dtcm_icb_rsp_ready,\n    output wire lsu2dtcm_icb_rsp_err,\n    output wire [31:0] lsu2dtcm_icb_rsp_rdata,\n\n    // External ICB Interface\n    `ifdef E203_HAS_DTCM_EXTITF\n    input wire ext2dtcm_icb_cmd_valid,\n    output wire ext2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] ext2dtcm_icb_cmd_addr,\n    input wire ext2dtcm_icb_cmd_read,\n    input wire [31:0] ext2dtcm_icb_cmd_wdata,\n    input wire [3:0] ext2dtcm_icb_cmd_wmask,\n    output wire ext2dtcm_icb_rsp_valid,\n    input wire ext2dtcm_icb_rsp_ready,\n    output wire ext2dtcm_icb_rsp_err,\n    output wire [31:0] ext2dtcm_icb_rsp_rdata,\n    `endif\n\n    // DTCM RAM Interface\n    output wire dtcm_ram_cs,\n    output wire dtcm_ram_we,\n    output wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    output wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    output wire clk_dtcm_ram\n);\n\n    // Internal signals\n    wire icb_cmd_valid;\n    wire icb_cmd_ready;\n    wire [E203_DTCM_ADDR_WIDTH-1:0] icb_cmd_addr;\n    wire icb_cmd_read;\n    wire [31:0] icb_cmd_wdata;\n    wire [3:0] icb_cmd_wmask;\n    wire icb_rsp_valid;\n    wire icb_rsp_ready;\n    wire icb_rsp_err;\n    wire [31:0] icb_rsp_rdata;\n\n    // Arbitration logic (if external interface is present)\n    `ifdef E203_HAS_DTCM_EXTITF\n    assign icb_cmd_valid = lsu2dtcm_icb_cmd_valid || ext2dtcm_icb_cmd_valid;\n    assign icb_cmd_addr = lsu2dtcm_icb_cmd_valid ? lsu2dtcm_icb_cmd_addr : ext2dtcm_icb_cmd_addr;\n    assign icb_cmd_read = lsu2dtcm_icb_cmd_valid ? lsu2dtcm_icb_cmd_read : ext2dtcm_icb_cmd_read;\n    assign icb_cmd_wdata = lsu2dtcm_icb_cmd_valid ? lsu2dtcm_icb_cmd_wdata : ext2dtcm_icb_cmd_wdata;\n    assign icb_cmd_wmask = lsu2dtcm_icb_cmd_valid ? lsu2dtcm_icb_cmd_wmask : ext2dtcm_icb_cmd_wmask;\n    `else\n    assign icb_cmd_valid = lsu2dtcm_icb_cmd_valid;\n    assign icb_cmd_addr = lsu2dtcm_icb_cmd_addr;\n    assign icb_cmd_read = lsu2dtcm_icb_cmd_read;\n    assign icb_cmd_wdata = lsu2dtcm_icb_cmd_wdata;\n    assign icb_cmd_wmask = lsu2dtcm_icb_cmd_wmask;\n    `endif\n\n    // SRAM controller logic\n    assign dtcm_ram_cs = icb_cmd_valid && icb_cmd_ready;\n    assign dtcm_ram_we = !icb_cmd_read;\n    assign dtcm_ram_addr = icb_cmd_addr[E203_DTCM_RAM_AW-1:0];\n    assign dtcm_ram_wem = icb_cmd_read ? 4'b0000 : icb_cmd_wmask;\n    assign dtcm_ram_din = icb_cmd_wdata;\n    assign clk_dtcm_ram = clk;\n\n    // Response logic\n    assign icb_rsp_valid = dtcm_ram_cs && !icb_cmd_read;\n    assign icb_rsp_rdata = dtcm_ram_dout;\n    assign icb_rsp_err = 1'b0;  // No error handling in this example\n\n    // Connect to LSU and external interface\n    assign lsu2dtcm_icb_cmd_ready = icb_cmd_ready;\n    assign lsu2dtcm_icb_rsp_valid = icb_rsp_valid;\n    assign lsu2dtcm_icb_rsp_rdata = icb_rsp_rdata;\n    assign lsu2dtcm_icb_rsp_err = icb_rsp_err;\n\n    `ifdef E203_HAS_DTCM_EXTITF\n    assign ext2dtcm_icb_cmd_ready = icb_cmd_ready;\n    assign ext2dtcm_icb_rsp_valid = icb_rsp_valid;\n    assign ext2dtcm_icb_rsp_rdata = icb_rsp_rdata;\n    assign ext2dtcm_icb_rsp_err = icb_rsp_err;\n    `endif\n\n    // Clock gating and activity indicator\n    assign dtcm_active = icb_cmd_valid || icb_rsp_valid;\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 7, "code": "module e203_dtcm_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n    output wire dtcm_active,\n\n    // LSU ICB Interface\n    input wire lsu2dtcm_icb_cmd_valid,\n    output wire lsu2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] lsu2dtcm_icb_cmd_addr,\n    input wire lsu2dtcm_icb_cmd_read,\n    input wire [31:0] lsu2dtcm_icb_cmd_wdata,\n    input wire [3:0] lsu2dtcm_icb_cmd_wmask,\n    output wire lsu2dtcm_icb_rsp_valid,\n    input wire lsu2dtcm_icb_rsp_ready,\n    output wire lsu2dtcm_icb_rsp_err,\n    output wire [31:0] lsu2dtcm_icb_rsp_rdata,\n\n    // External ICB Interface (Optional)\n    `ifdef E203_HAS_DTCM_EXTITF\n    input wire ext2dtcm_icb_cmd_valid,\n    output wire ext2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] ext2dtcm_icb_cmd_addr,\n    input wire ext2dtcm_icb_cmd_read,\n    input wire [31:0] ext2dtcm_icb_cmd_wdata,\n    input wire [3:0] ext2dtcm_icb_cmd_wmask,\n    output wire ext2dtcm_icb_rsp_valid,\n    input wire ext2dtcm_icb_rsp_ready,\n    output wire ext2dtcm_icb_rsp_err,\n    output wire [31:0] ext2dtcm_icb_rsp_rdata,\n    `endif\n\n    // DTCM RAM Interface\n    output wire dtcm_ram_cs,\n    output wire dtcm_ram_we,\n    output wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    output wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    output wire clk_dtcm_ram\n);\n\n    // Internal signals for arbitration and control\n    wire arb_cmd_valid;\n    wire arb_cmd_ready;\n    wire [E203_DTCM_ADDR_WIDTH-1:0] arb_cmd_addr;\n    wire arb_cmd_read;\n    wire [31:0] arb_cmd_wdata;\n    wire [3:0] arb_cmd_wmask;\n    wire arb_rsp_valid;\n    wire arb_rsp_ready;\n    wire arb_rsp_err;\n    wire [31:0] arb_rsp_rdata;\n\n    // Instantiate the bus arbiter\n    sirv_gnrl_icb_arbt #(\n        .ARBT_SCHEME(0),\n        .ALLOW_0CYCL_RSP(0),\n        .FIFO_OUTS_NUM(E203_DTCM_OUTS_NUM),\n        .FIFO_CUT_READY(0),\n        .USR_W(1),\n        .ARBT_NUM(DTCM_ARBT_I_NUM),\n        .AW(E203_DTCM_ADDR_WIDTH),\n        .DW(32),\n        .ARBT_PTR_W(DTCM_ARBT_I_PTR_W)\n    ) u_dtcm_arbiter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .i_icb_cmd_valid({ext2dtcm_icb_cmd_valid, lsu2dtcm_icb_cmd_valid}),\n        .i_icb_cmd_ready({ext2dtcm_icb_cmd_ready, lsu2dtcm_icb_cmd_ready}),\n        .i_icb_cmd_addr({ext2dtcm_icb_cmd_addr, lsu2dtcm_icb_cmd_addr}),\n        .i_icb_cmd_read({ext2dtcm_icb_cmd_read, lsu2dtcm_icb_cmd_read}),\n        .i_icb_cmd_wdata({ext2dtcm_icb_cmd_wdata, lsu2dtcm_icb_cmd_wdata}),\n        .i_icb_cmd_wmask({ext2dtcm_icb_cmd_wmask, lsu2dtcm_icb_cmd_wmask}),\n        .i_icb_rsp_valid({ext2dtcm_icb_rsp_valid, lsu2dtcm_icb_rsp_valid}),\n        .i_icb_rsp_ready({ext2dtcm_icb_rsp_ready, lsu2dtcm_icb_rsp_ready}),\n        .i_icb_rsp_err({ext2dtcm_icb_rsp_err, lsu2dtcm_icb_rsp_err}),\n        .i_icb_rsp_rdata({ext2dtcm_icb_rsp_rdata, lsu2dtcm_icb_rsp_rdata}),\n        .o_icb_cmd_valid(arb_cmd_valid),\n        .o_icb_cmd_ready(arb_cmd_ready),\n        .o_icb_cmd_addr(arb_cmd_addr),\n        .o_icb_cmd_read(arb_cmd_read),\n        .o_icb_cmd_wdata(arb_cmd_wdata),\n        .o_icb_cmd_wmask(arb_cmd_wmask),\n        .o_icb_rsp_valid(arb_rsp_valid),\n        .o_icb_rsp_ready(arb_rsp_ready),\n        .o_icb_rsp_err(arb_rsp_err),\n        .o_icb_rsp_rdata(arb_rsp_rdata)\n    );\n\n    // SRAM controller logic\n    assign dtcm_ram_cs = arb_cmd_valid && arb_cmd_ready;\n    assign dtcm_ram_we = !arb_cmd_read;\n    assign dtcm_ram_addr = arb_cmd_addr[E203_DTCM_RAM_AW-1:0];\n    assign dtcm_ram_wem = arb_cmd_wmask;\n    assign dtcm_ram_din = arb_cmd_wdata;\n    assign clk_dtcm_ram = clk;\n\n    // Response logic\n    assign arb_rsp_valid = dtcm_ram_cs && !arb_cmd_read;\n    assign arb_rsp_rdata = dtcm_ram_dout;\n    assign arb_rsp_err = 0; // No error handling in this example\n\n    // Activity indicator\n    assign dtcm_active = arb_cmd_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 2, "code": "module e203_ifu_minidec #(\n  parameter E203_INSTR_SIZE = 32,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_XLEN = 32\n)(\n  input [E203_INSTR_SIZE-1:0] instr,\n  output dec_rs1en,\n  output dec_rs2en,\n  output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n  output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n  output dec_mulhsu,\n  output dec_mul,\n  output dec_div,\n  output dec_rem,\n  output dec_divu,\n  output dec_remu,\n  output dec_rv32,\n  output dec_bjp,\n  output dec_jal,\n  output dec_jalr,\n  output dec_bxx,\n  output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  output [E203_XLEN-1:0] dec_bjp_imm\n);\n\n  // Internal signals for decoding\n  wire [6:0] opcode = instr[6:0];\n  wire [2:0] funct3 = instr[14:12];\n  wire [6:0] funct7 = instr[31:25];\n\n  // Decode logic for register indices\n  assign dec_rs1idx = instr[19:15];\n  assign dec_rs2idx = instr[24:20];\n  assign dec_jalr_rs1idx = instr[19:15];\n\n  // Decode logic for register enable signals\n  assign dec_rs1en = (opcode == 7'b1100111) || // JALR\n                     (opcode == 7'b1100011) || // BXX\n                     (opcode == 7'b0000011) || // LOAD\n                     (opcode == 7'b0100011) || // STORE\n                     (opcode == 7'b0010011) || // IMM\n                     (opcode == 7'b0110011);   // REG\n\n  assign dec_rs2en = (opcode == 7'b0100011) || // STORE\n                     (opcode == 7'b0110011);   // REG\n\n  // Decode logic for operations\n  assign dec_mul = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b000);\n  assign dec_mulhsu = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b010);\n  assign dec_div = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b100);\n  assign dec_divu = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b101);\n  assign dec_rem = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b110);\n  assign dec_remu = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b111);\n\n  // Decode logic for branches and jumps\n  assign dec_bjp = (opcode == 7'b1100011) || // BXX\n                   (opcode == 7'b1101111) || // JAL\n                   (opcode == 7'b1100111);   // JALR\n\n  assign dec_jal = (opcode == 7'b1101111);\n  assign dec_jalr = (opcode == 7'b1100111);\n  assign dec_bxx = (opcode == 7'b1100011);\n\n  // Immediate for branches and jumps\n  assign dec_bjp_imm = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};\n\n  // RV32 flag (assuming all instructions are RV32 in this simplified example)\n  assign dec_rv32 = 1'b1;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 20, "code": "module e203_core(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_ADDR_SIZE-1:0] pc_rtvec,\n    input wire [E203_HART_ID_W-1:0] core_mhartid,\n    input wire dbg_irq_r,\n    input wire [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input wire [E203_EVT_NUM-1:0] evt_r,\n    input wire ext_irq_r,\n    input wire sft_irq_r,\n    input wire tmr_irq_r,\n    input wire dbg_mode,\n    input wire dbg_halt_r,\n    input wire dbg_step_r,\n    input wire dbg_ebreakm_r,\n    input wire dbg_stopcycle,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire core_cgstop,\n    output wire tcm_cgstop,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    output wire [31:0] wr_csr_nxt,\n    output wire [E203_PC_SIZE-1:0] cmt_dpc,\n    output wire cmt_dpc_ena,\n    output wire [2:0] cmt_dcause,\n    output wire cmt_dcause_ena,\n    input wire [31:0] dcsr_r,\n    input wire [E203_PC_SIZE-1:0] dpc_r,\n    input wire [31:0] dscratch_r\n);\n\n    // Core internal signals\n    wire ifu_active;\n    wire [E203_PC_SIZE-1:0] current_pc;\n    wire [E203_INSTR_SIZE-1:0] instruction;\n    wire ifu_valid;\n    wire ifu_ready;\n\n    // Instantiate IFU\n    e203_ifu u_ifu (\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ifu_active(ifu_active),\n        .current_pc(current_pc),\n        .instruction(instruction),\n        .ifu_valid(ifu_valid),\n        .ifu_ready(ifu_ready)\n    );\n\n    // Instantiate EXU\n    e203_exu u_exu (\n        .clk(clk),\n        .rst_n(rst_n),\n        .instruction(instruction),\n        .exu_active(exu_active),\n        .core_mhartid(core_mhartid),\n        .dbg_irq_r(dbg_irq_r),\n        .lcl_irq_r(lcl_irq_r),\n        .evt_r(evt_r),\n        .ext_irq_r(ext_irq_r),\n        .sft_irq_r(sft_irq_r),\n        .tmr_irq_r(tmr_irq_r),\n        .dbg_mode(dbg_mode),\n        .dbg_halt_r(dbg_halt_r),\n        .dbg_step_r(dbg_step_r),\n        .dbg_ebreakm_r(dbg_ebreakm_r),\n        .dbg_stopcycle(dbg_stopcycle),\n        .core_wfi(core_wfi),\n        .tm_stop(tm_stop),\n        .core_cgstop(core_cgstop),\n        .tcm_cgstop(tcm_cgstop),\n        .wr_dcsr_ena(wr_dcsr_ena),\n        .wr_dpc_ena(wr_dpc_ena),\n        .wr_dscratch_ena(wr_dscratch_ena),\n        .wr_csr_nxt(wr_csr_nxt),\n        .cmt_dpc(cmt_dpc),\n        .cmt_dpc_ena(cmt_dpc_ena),\n        .cmt_dcause(cmt_dcause),\n        .cmt_dcause_ena(cmt_dcause_ena),\n        .dcsr_r(dcsr_r),\n        .dpc_r(dpc_r),\n        .dscratch_r(dscratch_r)\n    );\n\n    // Instantiate LSU\n    e203_lsu u_lsu (\n        .clk(clk),\n        .rst_n(rst_n),\n        .lsu_active(lsu_active)\n    );\n\n    // Instantiate BIU\n    e203_biu u_biu (\n        .clk(clk),\n        .rst_n(rst_n),\n        .biu_active(biu_active)\n    );\n\n    // Connect IFU to EXU\n    assign ifu_ready = exu_ready;\n    assign exu_instruction = instruction;\n    assign exu_pc = current_pc;\n    assign exu_valid = ifu_valid;\n\n    // Connect EXU to LSU\n    assign lsu_exu_data = exu_data;\n    assign lsu_exu_addr = exu_addr;\n    assign lsu_exu_cmd = exu_cmd;\n\n    // Connect LSU to BIU\n    assign biu_lsu_data = lsu_data;\n    assign biu_lsu_addr = lsu_addr;\n    assign biu_lsu_cmd = lsu_cmd;\n\n    // Output current PC for inspection\n    assign inspect_pc = current_pc;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 5, "code": "module e203_exu_alu_muldiv(\n    input mdv_nob2b,\n    input muldiv_i_valid,\n    output muldiv_i_ready,\n    input [E203_XLEN-1:0] muldiv_i_rs1,\n    input [E203_XLEN-1:0] muldiv_i_rs2,\n    input [E203_XLEN-1:0] muldiv_i_imm,\n    input [E203_DECINFO_MULDIV_WIDTH-1:0] muldiv_i_info,\n    input [E203_ITAG_WIDTH-1:0] muldiv_i_itag,\n    output muldiv_i_longpipe,\n    input flush_pulse,\n    output muldiv_o_valid,\n    input muldiv_o_ready,\n    output [E203_XLEN-1:0] muldiv_o_wbck_wdat,\n    output muldiv_o_wbck_err,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    output muldiv_req_alu_add,\n    output muldiv_req_alu_sub,\n    input [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output muldiv_sbf_0_ena,\n    output [32:0] muldiv_sbf_0_nxt,\n    input [32:0] muldiv_sbf_0_r,\n    output muldiv_sbf_1_ena,\n    output [32:0] muldiv_sbf_1_nxt,\n    input [32:0] muldiv_sbf_1_r,\n    input clk,\n    input rst_n\n);\n    // Internal signals and registers\n    reg [4:0] state;\n    reg [4:0] next_state;\n\n    // State definitions\n    localparam MULDIV_STATE_0TH = 5'd0;\n    localparam MULDIV_STATE_EXEC = 5'd1;\n    localparam MULDIV_STATE_REMD_CHCK = 5'd2;\n    localparam MULDIV_STATE_QUOT_CORR = 5'd3;\n    localparam MULDIV_STATE_REMD_CORR = 5'd4;\n\n    // FSM for managing multiplier and divider operations\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= MULDIV_STATE_0TH;\n        else if (flush_pulse)\n            state <= MULDIV_STATE_0TH;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            MULDIV_STATE_0TH: begin\n                if (muldiv_i_valid)\n                    next_state = MULDIV_STATE_EXEC;\n                else\n                    next_state = MULDIV_STATE_0TH;\n            end\n            MULDIV_STATE_EXEC: begin\n                if (muldiv_i_info[0]) // Assuming LSB indicates completion\n                    next_state = MULDIV_STATE_REMD_CHCK;\n                else\n                    next_state = MULDIV_STATE_EXEC;\n            end\n            MULDIV_STATE_REMD_CHCK: begin\n                if (some_condition) // Placeholder for actual condition\n                    next_state = MULDIV_STATE_QUOT_CORR;\n                else\n                    next_state = MULDIV_STATE_0TH;\n            end\n            MULDIV_STATE_QUOT_CORR: begin\n                next_state = MULDIV_STATE_REMD_CORR;\n            end\n            MULDIV_STATE_REMD_CORR: begin\n                next_state = MULDIV_STATE_0TH;\n            end\n            default: next_state = MULDIV_STATE_0TH;\n        endcase\n    end\n\n    // Output logic\n    assign muldiv_i_ready = (state == MULDIV_STATE_0TH);\n    assign muldiv_o_valid = (state == MULDIV_STATE_REMD_CORR);\n    assign muldiv_o_wbck_wdat = muldiv_req_alu_res; // Placeholder\n    assign muldiv_o_wbck_err = 0;\n\n    // Example combinational logic for Booth encoding\n    always @(*) begin\n        // Booth encoding logic here\n    end\n\n    // Example shared buffer control\n    always @(*) begin\n        muldiv_sbf_0_ena = (state == MULDIV_STATE_EXEC);\n        muldiv_sbf_0_nxt = muldiv_sbf_0_r + 33'd1; // Placeholder operation\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 6, "code": "module e203_exu_alu_muldiv(\n    input mdv_nob2b,\n    input muldiv_i_valid,\n    output muldiv_i_ready,\n    input [E203_XLEN-1:0] muldiv_i_rs1,\n    input [E203_XLEN-1:0] muldiv_i_rs2,\n    input [E203_XLEN-1:0] muldiv_i_imm,\n    input [E203_DECINFO_MULDIV_WIDTH-1:0] muldiv_i_info,\n    input [E203_ITAG_WIDTH-1:0] muldiv_i_itag,\n    output muldiv_i_longpipe,\n    input flush_pulse,\n    output muldiv_o_valid,\n    input muldiv_o_ready,\n    output [E203_XLEN-1:0] muldiv_o_wbck_wdat,\n    output muldiv_o_wbck_err,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    output muldiv_req_alu_add,\n    output muldiv_req_alu_sub,\n    input [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output muldiv_sbf_0_ena,\n    output [32:0] muldiv_sbf_0_nxt,\n    input [32:0] muldiv_sbf_0_r,\n    output muldiv_sbf_1_ena,\n    output [32:0] muldiv_sbf_1_nxt,\n    input [32:0] muldiv_sbf_1_r,\n    input clk,\n    input rst_n\n);\n    // Internal signals and registers\n    reg [4:0] state;\n    wire [E203_XLEN-1:0] op1, op2;\n    wire start_mul, start_div;\n    wire mul_ready, div_ready;\n    wire [E203_XLEN-1:0] mul_result, div_result;\n    wire mul_done, div_done;\n\n    // State machine for controlling MUL/DIV operations\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= MULDIV_STATE_0TH;\n        end else begin\n            case (state)\n                MULDIV_STATE_0TH: begin\n                    if (muldiv_i_valid && !flush_pulse) begin\n                        if (start_mul)\n                            state <= MULDIV_STATE_EXEC;\n                        else if (start_div)\n                            state <= MULDIV_STATE_EXEC;\n                    end\n                end\n                MULDIV_STATE_EXEC: begin\n                    if (mul_done || div_done) begin\n                        state <= MULDIV_STATE_0TH;\n                    end\n                end\n                default: state <= MULDIV_STATE_0TH;\n            endcase\n        end\n    end\n\n    // Logic for starting multiplication or division\n    assign start_mul = muldiv_i_valid && (muldiv_i_info == `MULDIV_START_MUL);\n    assign start_div = muldiv_i_valid && (muldiv_i_info == `MULDIV_START_DIV);\n\n    // Multiplication and division units\n    mul_unit mul_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start_mul),\n        .op1(muldiv_i_rs1),\n        .op2(muldiv_i_rs2),\n        .result(mul_result),\n        .done(mul_done)\n    );\n\n    div_unit div_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start_div),\n        .op1(muldiv_i_rs1),\n        .op2(muldiv_i_rs2),\n        .result(div_result),\n        .done(div_done)\n    );\n\n    // Output assignment\n    assign muldiv_o_valid = (state == MULDIV_STATE_EXEC) && (mul_done || div_done);\n    assign muldiv_o_wbck_wdat = mul_done ? mul_result : div_result;\n    assign muldiv_o_wbck_err = 0; // Assuming no errors in this simplified example\n\n    // Handshake signals\n    assign muldiv_i_ready = (state == MULDIV_STATE_0TH);\n    assign muldiv_i_longpipe = 1'b1; // Long pipeline operation due to multiple cycles required\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 2, "code": "module e203_exu_alu_rglr (\n    input wire alu_i_valid,\n    output wire alu_i_ready,\n    input wire [E203_XLEN-1:0] alu_i_rs1,\n    input wire [E203_XLEN-1:0] alu_i_rs2,\n    input wire [E203_XLEN-1:0] alu_i_imm,\n    input wire [E203_PC_SIZE-1:0] alu_i_pc,\n    input wire [E203_DECINFO_ALU_WIDTH-1:0] alu_i_info,\n    output wire alu_o_valid,\n    input wire alu_o_ready,\n    output wire [E203_XLEN-1:0] alu_o_wbck_wdat,\n    output wire alu_o_wbck_err,\n    output wire alu_o_cmt_ecall,\n    output wire alu_o_cmt_ebreak,\n    output wire alu_o_cmt_wfi,\n    output wire alu_req_alu_add,\n    output wire alu_req_alu_sub,\n    output wire alu_req_alu_xor,\n    output wire alu_req_alu_sll,\n    output wire alu_req_alu_srl,\n    output wire alu_req_alu_sra,\n    output wire alu_req_alu_or,\n    output wire alu_req_alu_and,\n    output wire alu_req_alu_slt,\n    output wire alu_req_alu_sltu,\n    output wire alu_req_alu_lui,\n    output wire [E203_XLEN-1:0] alu_req_alu_op1,\n    output wire [E203_XLEN-1:0] alu_req_alu_op2,\n    output wire [E203_XLEN-1:0] alu_req_alu_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Handshake signals\n    assign alu_i_ready = alu_o_ready;\n    assign alu_o_valid = alu_i_valid;\n\n    // Operation type decoding\n    assign alu_req_alu_add = alu_i_info[E203_DECINFO_ALU_ADD] & ~alu_i_info[E203_DECINFO_ALU_NOP];\n    assign alu_req_alu_sub = alu_i_info[E203_DECINFO_ALU_SUB];\n    assign alu_req_alu_xor = alu_i_info[E203_DECINFO_ALU_XOR];\n    assign alu_req_alu_sll = alu_i_info[E203_DECINFO_ALU_SLL];\n    assign alu_req_alu_srl = alu_i_info[E203_DECINFO_ALU_SRL];\n    assign alu_req_alu_sra = alu_i_info[E203_DECINFO_ALU_SRA];\n    assign alu_req_alu_or  = alu_i_info[E203_DECINFO_ALU_OR];\n    assign alu_req_alu_and = alu_i_info[E203_DECINFO_ALU_AND];\n    assign alu_req_alu_slt = alu_i_info[E203_DECINFO_ALU_SLT];\n    assign alu_req_alu_sltu = alu_i_info[E203_DECINFO_ALU_SLTU];\n    assign alu_req_alu_lui = alu_i_info[E203_DECINFO_ALU_LUI];\n\n    // Operand selection\n    assign alu_req_alu_op1 = alu_i_info[E203_DECINFO_ALU_OP1PC] ? alu_i_pc : alu_i_rs1;\n    assign alu_req_alu_op2 = alu_i_info[E203_DECINFO_ALU_OP2IMM] ? alu_i_imm : alu_i_rs2;\n\n    // Result forwarding\n    assign alu_o_wbck_wdat = alu_req_alu_res;\n\n    // Special instructions handling\n    assign alu_o_cmt_ecall = alu_i_info[E203_DECINFO_ALU_ECAL];\n    assign alu_o_cmt_ebreak = alu_i_info[E203_DECINFO_ALU_EBRK];\n    assign alu_o_cmt_wfi = alu_i_info[E203_DECINFO_ALU_WFI];\n\n    // Error handling\n    assign alu_o_wbck_err = alu_o_cmt_ecall | alu_o_cmt_ebreak | alu_o_cmt_wfi;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 18, "code": "// E203 Processor Configuration Document\n\n// 1. Introduction\n\n// This document describes the configuration system for the E203 processor. The E203 is a RISC-V architecture-based processor core that can be configured with various features and functional modules via macro definitions. This configuration file is licensed under the Apache 2.0 open-source license and is maintained by Nuclei System Technology.\n\n// 2. Basic Configuration Items\n\n// 2.1 Debug and Interrupt Configuration\n// **`E203_CFG_DEBUG_HAS_JTAG`**: Enables support for JTAG debug interface.\n// **`E203_CFG_IRQ_NEED_SYNC`**: Enables interrupt synchronization mechanism.\n\n// 2.2 Address Space Configuration\n// The system supports three address width configurations, and only one can be selected at a time:\n// - **`E203_CFG_ADDR_SIZE_IS_16`**: 16-bit address space.\n// - **`E203_CFG_ADDR_SIZE_IS_24`**: 24-bit address space.\n// - **`E203_CFG_ADDR_SIZE_IS_32`**: 32-bit address space (currently selected configuration).\n\n// The address size is unified through the **`E203_CFG_ADDR_SIZE`** macro, which is automatically set based on the chosen configuration.\n\n// 2.3 CPU Function Configuration\n// - **`E203_CFG_SUPPORT_MCYCLE_MINSTRET`**: Enables support for MCYCLE and MINSTRET counters.\n// - **`E203_CFG_REGNUM_IS_32`**: Configures the number of registers to 32.\n// - **`E203_CFG_HAS_ECC`**: Enables ECC (Error Correction Code) functionality.\n// - **`E203_CFG_HAS_NICE`**: Enables the NICE instruction extension.\n// - **`E203_CFG_SUPPORT_SHARE_MULDIV`**: Enables shared multiplication and division units.\n// - **`E203_CFG_SUPPORT_AMO`**: Enables support for atomic memory operations (AMO).\n\n// 2.4 Memory System Configuration\n\n// Instruction TCM (ITCM)\n// - **`E203_CFG_HAS_ITCM`**: Enables Instruction Tightly Coupled Memory (ITCM).\n// - **`E203_CFG_ITCM_ADDR_WIDTH`**: Configures the ITCM address width. The current setting is 16 bits.\n//   - Supports a 64KB configuration (16-bit address width, 8192 depth).\n//   - Optional 1024KB configuration (20-bit address width).\n//   - Optional 2048KB configuration (21-bit address width).\n\n// Data TCM (DTCM)\n// - **`E203_CFG_HAS_DTCM`**: Enables Data Tightly Coupled Memory (DTCM).\n// - **`E203_CFG_DTCM_ADDR_WIDTH`**: Configures the DTCM address width. The current setting is 16 bits.\n//   - Supports a 16KB configuration (14-bit address width, 4096 depth).\n//   - Supports a 256KB configuration (18-bit address width, 65536 depth).\n//   - Optional 1MB configuration (20-bit address width, 262144 depth).\n\n// 2.5 Memory Mapping Configuration\n\n// The system defines the base addresses for the following memory regions:\n\n// 1. **ITCM Region**:\n//    - Base address: `0x8000_0000`\n//    - Defined through **`E203_CFG_ITCM_ADDR_BASE`**.\n// 2. **DTCM Region**:\n//    - Base address: `0x9000_0000`\n//    - Defined through **`E203_CFG_DTCM_ADDR_BASE`**.\n// 3. **Peripheral Interface Regions**:\n//    - **PPI Region**: `0x1000_0000 - 0x1FFF_FFFF`\n//    - Defined through **`E203_CFG_PPI_ADDR_BASE`** and **`E203_CFG_PPI_BASE_REGION`**.\n// 4. **System Controller Regions**:\n//    - **CLINT Region**: `0x0200_0000 - 0x0200_FFFF`\n//    - Base Address of CLINT is defined through **`E203_CFG_CLINT_ADDR_BASE`**.(`E203_CFG_ADDR_SIZE'h0200_0000`)\n//    -  **`E203_CFG_CLINT_BASE_REGION`** macro defines the high address range used to determine whether an address belongs to CLINT REGION (`E203_CFG_ADDR_SIZE-1:E203_CFG_ADDR_SIZE-16`)\n//    - **PLIC Region**: `0x0C00_0000 - 0x0CFF_FFFF`\n//    - Base Address of PLIC is defined through **`E203_CFG_PLIC_ADDR_BASE`**.(`E203_CFG_ADDR_SIZE'h0C00_0000`)\n//    -  **`E203_CFG_PLIC_BASE_REGION`** macro defines the high address range used to determine whether an address belongs to PLIC REGION (`E203_CFG_ADDR_SIZE-1:E203_CFG_ADDR_SIZE-8`)\n// 5. **Fast IO Region**:\n//    - Base address: `0xF000_0000`\n//    - Defined through **`E203_CFG_FIO_ADDR_BASE`** and **`E203_CFG_FIO_BASE_REGION`**.\n\n// 3. Notes\n\n// 1. Only one address width configuration should be enabled at a time.\n// 2. TCM configurations should be selected based on available hardware resources.\n// 3. Memory mapping configurations must avoid address overlap.\n// 4. It is recommended to carefully evaluate the system's resource requirements and performance demands when modifying configurations.", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 1, "code": "module e203_exu_alu_dpath(\n    input wire alu_req_alu,\n    input wire alu_req_alu_add,\n    input wire alu_req_alu_sub,\n    input wire alu_req_alu_xor,\n    input wire alu_req_alu_sll,\n    input wire alu_req_alu_srl,\n    input wire alu_req_alu_sra,\n    input wire alu_req_alu_or,\n    input wire alu_req_alu_and,\n    input wire [E203_XLEN-1:0] alu_req_alu_op1,\n    input wire [E203_XLEN-1:0] alu_req_alu_op2,\n    input wire bjp_req_alu,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    input wire agu_req_alu,\n    input wire [E203_XLEN-1:0] agu_req_alu_op1,\n    input wire [E203_XLEN-1:0] agu_req_alu_op2,\n    input wire muldiv_req_alu,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    input wire muldiv_req_alu_add,\n    input wire muldiv_req_alu_sub,\n    input wire muldiv_sbf_0_ena,\n    input wire [32:0] muldiv_sbf_0_nxt,\n    input wire muldiv_sbf_1_ena,\n    input wire [32:0] muldiv_sbf_1_nxt,\n    input wire clk,\n    input wire rst_n,\n    output wire [E203_XLEN-1:0] alu_req_alu_res,\n    output wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    output wire bjp_req_alu_cmp_res,\n    output wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output wire [32:0] muldiv_sbf_0_r,\n    output wire [32:0] muldiv_sbf_1_r\n);\n\n    // Internal signals for ALU operations\n    wire [E203_XLEN-1:0] add_result;\n    wire [E203_XLEN-1:0] sub_result;\n    wire [E203_XLEN-1:0] and_result;\n    wire [E203_XLEN-1:0] or_result;\n    wire [E203_XLEN-1:0] xor_result;\n    wire [E203_XLEN-1:0] sll_result;\n    wire [E203_XLEN-1:0] srl_result;\n    wire [E203_XLEN-1:0] sra_result;\n\n    // ALU operation implementations\n    assign add_result = alu_req_alu_op1 + alu_req_alu_op2;\n    assign sub_result = alu_req_alu_op1 - alu_req_alu_op2;\n    assign and_result = alu_req_alu_op1 & alu_req_alu_op2;\n    assign or_result = alu_req_alu_op1 | alu_req_alu_op2;\n    assign xor_result = alu_req_alu_op1 ^ alu_req_alu_op2;\n    assign sll_result = alu_req_alu_op1 << alu_req_alu_op2;\n    assign srl_result = alu_req_alu_op1 >> alu_req_alu_op2;\n    assign sra_result = ($signed(alu_req_alu_op1)) >>> alu_req_alu_op2;\n\n    // Result multiplexing based on operation type\n    assign alu_req_alu_res = ({E203_XLEN{alu_req_alu_add}} & add_result) |\n                             ({E203_XLEN{alu_req_alu_sub}} & sub_result) |\n                             ({E203_XLEN{alu_req_alu_and}} & and_result) |\n                             ({E203_XLEN{alu_req_alu_or}} & or_result) |\n                             ({E203_XLEN{alu_req_alu_xor}} & xor_result) |\n                             ({E203_XLEN{alu_req_alu_sll}} & sll_result) |\n                             ({E203_XLEN{alu_req_alu_srl}} & srl_result) |\n                             ({E203_XLEN{alu_req_alu_sra}} & sra_result);\n\n    // BJP and AGU operation results\n    assign bjp_req_alu_add_res = bjp_req_alu_op1 + bjp_req_alu_op2;\n    assign bjp_req_alu_cmp_res = (bjp_req_alu_op1 == bjp_req_alu_op2);\n    assign agu_req_alu_res = (agu_req_alu_op1 + agu_req_alu_op2);\n\n    // MULDIV operation results\n    assign muldiv_req_alu_res = (muldiv_req_alu_add) ? (muldiv_req_alu_op1 + muldiv_req_alu_op2) :\n                               (muldiv_req_alu_sub) ? (muldiv_req_alu_op1 - muldiv_req_alu_op2) : {E203_ALU_ADDER_WIDTH{1'b0}};\n\n    // Shared buffer management\n    sirv_gnrl_dffl #(33) sbf_0_dffl (\n        .lden(muldiv_sbf_0_ena),\n        .dnxt(muldiv_sbf_0_nxt),\n        .qout(muldiv_sbf_0_r),\n        .clk(clk)\n    );\n\n    sirv_gnrl_dffl #(33) sbf_1_dffl (\n        .lden(muldiv_sbf_1_ena),\n        .dnxt(muldiv_sbf_1_nxt),\n        .qout(muldiv_sbf_1_r),\n        .clk(clk)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 1, "code": "module e203_lsu(\n    input wire commit_mret,\n    input wire commit_trap,\n    input wire excp_active,\n    output wire lsu_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n    output wire [ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_buserr,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [XLEN/8-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [XLEN-1:0] agu_icb_rsp_rdata\n);\n    // LSU logic implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 1, "code": "module e203_ifu_ift2icb (\n    input wire itcm_nohold,\n    input wire ifu_req_valid,\n    input wire [PC_SIZE-1:0] ifu_req_pc,\n    input wire ifu_req_seq,\n    input wire ifu_req_seq_rv32,\n    input wire [PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_ready,\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_ready,\n    output wire ifu_rsp_valid,\n    output wire ifu_rsp_err,\n    output wire [31:0] ifu_rsp_instr,\n    output wire ifu2itcm_icb_cmd_valid,\n    input wire ifu2itcm_icb_cmd_ready,\n    output wire [ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_rsp_valid,\n    output wire ifu2itcm_icb_rsp_ready,\n    input wire ifu2itcm_icb_rsp_err,\n    input wire [ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    output wire ifu2biu_icb_cmd_valid,\n    input wire ifu2biu_icb_cmd_ready,\n    output wire [ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input wire ifu2biu_icb_rsp_valid,\n    output wire ifu2biu_icb_rsp_ready,\n    input wire ifu2biu_icb_rsp_err,\n    input wire [SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata\n);\n\n    // State definitions\n    localparam ICB_STATE_IDLE = 2'b00;\n    localparam ICB_STATE_1ST = 2'b01;\n    localparam ICB_STATE_WAIT2ND = 2'b10;\n    localparam ICB_STATE_2ND = 2'b11;\n\n    // State registers\n    reg [1:0] icb_state;\n    reg [1:0] icb_state_nxt;\n\n    // State transition and output logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            icb_state <= ICB_STATE_IDLE;\n        end else begin\n            icb_state <= icb_state_nxt;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (icb_state)\n            ICB_STATE_IDLE: begin\n                if (ifu_req_valid && ifu_req_ready)\n                    icb_state_nxt = ICB_STATE_1ST;\n                else\n                    icb_state_nxt = ICB_STATE_IDLE;\n            end\n            ICB_STATE_1ST: begin\n                if (ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid)\n                    icb_state_nxt = ifu_req_valid ? ICB_STATE_1ST : ICB_STATE_IDLE;\n                else\n                    icb_state_nxt = ICB_STATE_WAIT2ND;\n            end\n            ICB_STATE_WAIT2ND: begin\n                if (ifu2itcm_icb_cmd_ready || ifu2biu_icb_cmd_ready)\n                    icb_state_nxt = ICB_STATE_2ND;\n                else\n                    icb_state_nxt = ICB_STATE_WAIT2ND;\n            end\n            ICB_STATE_2ND: begin\n                if (ifu_rsp_ready)\n                    icb_state_nxt = ifu_req_valid ? ICB_STATE_1ST : ICB_STATE_IDLE;\n                else\n                    icb_state_nxt = ICB_STATE_2ND;\n            end\n            default: icb_state_nxt = ICB_STATE_IDLE;\n        endcase\n    end\n\n    // Output logic\n    assign ifu_req_ready = (icb_state == ICB_STATE_IDLE);\n    assign ifu_rsp_valid = (icb_state == ICB_STATE_2ND) && (ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid);\n    assign ifu_rsp_err = (icb_state == ICB_STATE_2ND) && (ifu2itcm_icb_rsp_err || ifu2biu_icb_rsp_err);\n    assign ifu_rsp_instr = (icb_state == ICB_STATE_2ND) ? (ifu2itcm_icb_rsp_valid ? ifu2itcm_icb_rsp_rdata : ifu2biu_icb_rsp_rdata) : 32'h0;\n\n    // ICB command logic\n    assign ifu2itcm_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && (ifu_req_pc < `ITCM_ADDR_BASE + `ITCM_SIZE);\n    assign ifu2itcm_icb_cmd_addr = ifu_req_pc;\n    assign ifu2itcm_icb_rsp_ready = (icb_state == ICB_STATE_1ST) || (icb_state == ICB_STATE_2ND);\n\n    assign ifu2biu_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && (ifu_req_pc >= `SYSMEM_ADDR_BASE);\n    assign ifu2biu_icb_cmd_addr = ifu_req_pc;\n    assign ifu2biu_icb_rsp_ready = (icb_state == ICB_STATE_1ST) || (icb_state == ICB_STATE_2ND);\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 4, "code": "module e203_exu_alu_csrctrl (\n    input wire csr_i_valid,\n    output reg csr_i_ready,\n    input wire [E203_XLEN-1:0] csr_i_rs1,\n    input wire [E203_DECINFO_CSR_WIDTH-1:0] csr_i_info,\n    input wire csr_i_rdwen,\n    output reg csr_ena,\n    output reg csr_wr_en,\n    output reg csr_rd_en,\n    output reg [11:0] csr_idx,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output reg [E203_XLEN-1:0] wbck_csr_dat,\n    output reg csr_o_valid,\n    input wire csr_o_ready,\n    output reg [E203_XLEN-1:0] csr_o_wbck_wdat,\n    output reg csr_o_wbck_err,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Decode CSR instruction information\n    wire csrrw = csr_i_info[E203_DECINFO_CSR_CSRRW];\n    wire csrrs = csr_i_info[E203_DECINFO_CSR_CSRRS];\n    wire csrrc = csr_i_info[E203_DECINFO_CSR_CSRRC];\n    wire rs1imm = csr_i_info[E203_DECINFO_CSR_RS1IMM];\n    wire rs1is0 = csr_i_info[E203_DECINFO_CSR_RS1IS0];\n    wire [4:0] zimm = csr_i_info[E203_DECINFO_CSR_ZIMMM];\n    wire [11:0] csr_index = csr_i_info[E203_DECINFO_CSR_CSRIDX];\n\n    // Operand 1 selection\n    wire [E203_XLEN-1:0] csr_op1 = rs1imm ? { { (E203_XLEN-5){1'b0} }, zimm } : csr_i_rs1;\n\n    // CSR enable and index logic\n    always @(*) begin\n        csr_ena = csr_i_valid && csr_o_ready;\n        csr_idx = csr_index;\n        csr_i_ready = csr_o_ready;\n        csr_o_valid = csr_i_valid && csr_o_ready;\n    end\n\n    // CSR read and write enable logic\n    always @(*) begin\n        csr_rd_en = csr_i_valid && (csrrw || csrrs || csrrc);\n        csr_wr_en = csr_i_valid && ((csrrw && csr_i_rdwen) || (csrrs && !rs1is0) || (csrrc && !rs1is0));\n    end\n\n    // Data preparation for CSR write operations\n    always @(*) begin\n        case ({csrrw, csrrs, csrrc})\n            3'b100: wbck_csr_dat = csr_op1; // CSRRW\n            3'b010: wbck_csr_dat = csr_op1 | read_csr_dat; // CSRRS\n            3'b001: wbck_csr_dat = ~csr_op1 & read_csr_dat; // CSRRC\n            default: wbck_csr_dat = {E203_XLEN{1'b0}};\n        endcase\n    end\n\n    // Error handling\n    always @(*) begin\n        csr_o_wbck_wdat = read_csr_dat;\n        csr_o_wbck_err = csr_access_ilgl;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 5, "code": "module e203_exu_csr (\n    input wire nonflush_cmt_ena,\n    input wire csr_ena,\n    input wire csr_wr_en,\n    input wire csr_rd_en,\n    input wire [11:0] csr_idx,\n    output wire csr_access_ilgl,\n    output wire tm_stop,\n    output wire core_cgstop,\n    output wire tcm_cgstop,\n    output wire itcm_nohold,\n    output wire mdv_nob2b,\n    output wire [E203_XLEN-1:0] read_csr_dat,\n    input wire [E203_XLEN-1:0] wbck_csr_dat,\n    input wire [E203_HART_ID_W-1:0] core_mhartid,\n    input wire ext_irq_r,\n    input wire sft_irq_r,\n    input wire tmr_irq_r,\n    output wire status_mie_r,\n    output wire mtie_r,\n    output wire msie_r,\n    output wire meie_r,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    input wire [E203_XLEN-1:0] dcsr_r,\n    input wire [E203_PC_SIZE-1:0] dpc_r,\n    input wire [E203_XLEN-1:0] dscratch_r,\n    output wire u_mode,\n    output wire s_mode,\n    output wire h_mode,\n    output wire m_mode,\n    input wire [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    input wire cmt_badaddr_ena,\n    input wire [E203_PC_SIZE-1:0] cmt_epc,\n    input wire cmt_epc_ena,\n    input wire [E203_XLEN-1:0] cmt_cause,\n    input wire cmt_cause_ena,\n    input wire cmt_status_ena,\n    input wire cmt_instret_ena,\n    input wire cmt_mret_ena,\n    output wire [E203_PC_SIZE-1:0] csr_epc_r,\n    output wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    output wire [E203_XLEN-1:0] csr_mtvec_r,\n    input wire clk_aon,\n    input wire clk,\n    input wire rst_n\n);\n\n// Implementation of the CSR module logic\n// Note: The actual implementation details such as register definitions,\n//       CSR handling logic, interrupt handling, etc., are not included\n//       in this example for brevity.\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 1, "code": "module e203_exu_decode (\n    input [E203_INSTR_SIZE-1:0] i_instr,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_prdt_taken,\n    input i_misalgn,\n    input i_buserr,\n    input i_muldiv_b2b,\n    input dbg_mode,\n    output dec_rs1x0,\n    output dec_rs2x0,\n    output dec_rs1en,\n    output dec_rs2en,\n    output dec_rdwen,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rdidx,\n    output [E203_DECINFO_WIDTH-1:0] dec_info,\n    output [E203_XLEN-1:0] dec_imm,\n    output [E203_PC_SIZE-1:0] dec_pc,\n    output dec_misalgn,\n    output dec_buserr,\n    output dec_ilegl,\n    output dec_mulhsu,\n    output dec_mul,\n    output dec_div,\n    output dec_rem,\n    output dec_divu,\n    output dec_remu,\n    output dec_rv32,\n    output dec_bjp,\n    output dec_jal,\n    output dec_jalr,\n    output dec_bxx,\n    output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    output [E203_XLEN-1:0] dec_bjp_imm,\n    output dec_nice,\n    output nice_cmt_off_ilgl_o\n);\n\n    // Internal signals for decoding logic\n    wire [6:0] opcode = i_instr[6:0];\n    wire [2:0] funct3 = i_instr[14:12];\n    wire [6:0] funct7 = i_instr[31:25];\n    wire [4:0] rs1 = i_instr[19:15];\n    wire [4:0] rs2 = i_instr[24:20];\n    wire [4:0] rd = i_instr[11:7];\n    wire [11:0] imm12 = i_instr[31:20];\n    wire [11:0] imm12_I = {{20{i_instr[31]}}, i_instr[31:20]};\n    wire [11:0] imm12_S = {{20{i_instr[31]}}, i_instr[31:25], i_instr[11:7]};\n    wire [12:0] imm13 = {{19{i_instr[31]}}, i_instr[31], i_instr[7], i_instr[30:25], i_instr[11:8], 1'b0};\n    wire [20:0] imm21 = {{11{i_instr[31]}}, i_instr[31], i_instr[19:12], i_instr[20], i_instr[30:21], 1'b0};\n\n    // Decode logic for different instruction types\n    always @(*) begin\n        case (opcode)\n            7'b0110011: begin // R-Type\n                dec_rs1en = 1'b1;\n                dec_rs2en = 1'b1;\n                dec_rdwen = 1'b1;\n                dec_rs1idx = rs1;\n                dec_rs2idx = rs2;\n                dec_rdidx = rd;\n                // Additional decoding based on funct3 and funct7\n            end\n            7'b0010011: begin // I-Type\n                dec_rs1en = 1'b1;\n                dec_rs2en = 1'b0;\n                dec_rdwen = 1'b1;\n                dec_rs1idx = rs1;\n                dec_rdidx = rd;\n                dec_imm = imm12_I;\n                // Additional decoding based on funct3\n            end\n            7'b0000011: begin // Load\n                dec_rs1en = 1'b1;\n                dec_rs2en = 1'b0;\n                dec_rdwen = 1'b1;\n                dec_rs1idx = rs1;\n                dec_rdidx = rd;\n                dec_imm = imm12_I;\n                // Set load-specific flags\n            end\n            7'b1100011: begin // B-Type\n                dec_rs1en = 1'b1;\n                dec_rs2en = 1'b1;\n                dec_rdwen = 1'b0;\n                dec_rs1idx = rs1;\n                dec_rs2idx = rs2;\n                dec_imm = imm13;\n                // Set branch-specific flags\n            end\n            7'b1101111: begin // JAL\n                dec_rs1en = 1'b0;\n                dec_rs2en = 1'b0;\n                dec_rdwen = 1'b1;\n                dec_rdidx = rd;\n                dec_imm = imm21;\n                // Set JAL-specific flags\n            end\n            default: begin\n                // Handle illegal or unrecognized instructions\n                dec_ilegl = 1'b1;\n            end\n        endcase\n    end\n\n    // Output fixed signals\n    assign dec_pc = i_pc;\n    assign dec_misalgn = i_misalgn;\n    assign dec_buserr = i_buserr;\n\n    // Optional NICE interface\n    `ifdef E203_HAS_NICE\n    assign dec_nice = (nice_xs_off && nice_cmt_off_ilgl_o);\n    `endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 5, "code": "module e203_exu_alu_csrctrl (\n    input wire csr_i_valid,\n    output reg csr_i_ready,\n    input wire [E203_XLEN-1:0] csr_i_rs1,\n    input wire [E203_DECINFO_CSR_WIDTH-1:0] csr_i_info,\n    input wire csr_i_rdwen,\n    output reg csr_ena,\n    output reg csr_wr_en,\n    output reg csr_rd_en,\n    output reg [11:0] csr_idx,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output reg [E203_XLEN-1:0] wbck_csr_dat,\n    output reg csr_o_valid,\n    input wire csr_o_ready,\n    output reg [E203_XLEN-1:0] csr_o_wbck_wdat,\n    output reg csr_o_wbck_err,\n    input wire clk,\n    input wire rst_n,\n    // NICE interface signals\n    input wire nice_xs_off,\n    output reg csr_sel_nice,\n    output reg nice_csr_valid,\n    input wire nice_csr_ready,\n    output reg [31:0] nice_csr_addr,\n    output reg nice_csr_wr,\n    output reg [31:0] nice_csr_wdata,\n    input wire [31:0] nice_csr_rdata\n);\n\n    // Decode CSR instruction information\n    wire csrrw = csr_i_info[E203_DECINFO_CSR_CSRRW];\n    wire csrrs = csr_i_info[E203_DECINFO_CSR_CSRRS];\n    wire csrrc = csr_i_info[E203_DECINFO_CSR_CSRRC];\n    wire rs1imm = csr_i_info[E203_DECINFO_CSR_RS1IMM];\n    wire rs1is0 = csr_i_info[E203_DECINFO_CSR_RS1IS0];\n    wire [4:0] zimm = csr_i_info[E203_DECINFO_CSR_ZIMMM];\n    wire [11:0] csr_idx_info = csr_i_info[E203_DECINFO_CSR_CSRIDX];\n\n    // Prepare operand 1\n    wire [E203_XLEN-1:0] csr_op1 = rs1imm ? {E203_XLEN-5{1'b0}, zimm} : csr_i_rs1;\n\n    // CSR enable and index logic\n    always @(*) begin\n        csr_ena = csr_i_valid && csr_o_ready && !csr_access_ilgl;\n        csr_idx = csr_idx_info;\n        csr_i_ready = csr_o_ready;\n        csr_o_valid = csr_i_valid && csr_o_ready;\n    end\n\n    // CSR read and write enable logic\n    always @(*) begin\n        csr_rd_en = (csrrw && csr_i_rdwen) || csrrs || csrrc;\n        csr_wr_en = (csrrw || (csrrs && !rs1is0) || (csrrc && !rs1is0)) && csr_i_valid;\n    end\n\n    // Data for CSR write operations\n    always @(*) begin\n        case ({csrrw, csrrs, csrrc})\n            3'b100: wbck_csr_dat = csr_op1; // CSRRW\n            3'b010: wbck_csr_dat = csr_op1 | read_csr_dat; // CSRRS\n            3'b001: wbck_csr_dat = ~csr_op1 & read_csr_dat; // CSRRC\n            default: wbck_csr_dat = {E203_XLEN{1'b0}};\n        endcase\n    end\n\n    // Error handling\n    always @(*) begin\n        csr_o_wbck_wdat = read_csr_dat;\n        csr_o_wbck_err = csr_access_ilgl;\n    end\n\n    // NICE interface logic\n    always @(*) begin\n        csr_sel_nice = (csr_idx[11:8] == 4'hE) && !nice_xs_off;\n        nice_csr_valid = csr_i_valid && csr_o_ready && csr_sel_nice;\n        nice_csr_addr = {20'h0, csr_idx};\n        nice_csr_wr = csr_wr_en && csr_sel_nice;\n        nice_csr_wdata = wbck_csr_dat;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 3, "code": "module e203_exu_oitf #(\n  parameter E203_ITAG_WIDTH = 4, // Width of the instruction tag\n  parameter E203_RFIDX_WIDTH = 5, // Width of the register file index\n  parameter E203_PC_SIZE = 32, // Size of the program counter\n  parameter E203_OITF_DEPTH = 8 // Depth of the OITF\n)(\n  input clk,\n  input rst_n,\n  \n  // Dispatch interface\n  input dis_ena,\n  output reg dis_ready,\n  input [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n  input disp_i_rdwen,\n  input disp_i_rdfpu,\n  input [E203_PC_SIZE-1:0] disp_i_pc,\n\n  // Retirement interface\n  input ret_ena,\n  output reg [E203_RFIDX_WIDTH-1:0] ret_rdidx,\n  output reg ret_rdwen,\n  output reg ret_rdfpu,\n  output reg [E203_PC_SIZE-1:0] ret_pc,\n\n  // Dependency checking outputs\n  output reg oitfrd_match_disprs1,\n  output reg oitfrd_match_disprs2,\n  output reg oitfrd_match_disprs3,\n  output reg oitfrd_match_disprd,\n  output reg oitf_empty\n);\n\n  // Internal registers for OITF\n  reg [E203_RFIDX_WIDTH-1:0] rdidx[E203_OITF_DEPTH-1:0];\n  reg [E203_PC_SIZE-1:0] pc[E203_OITF_DEPTH-1:0];\n  reg [E203_OITF_DEPTH-1:0] rdwen;\n  reg [E203_OITF_DEPTH-1:0] rdfpu;\n  reg [E203_ITAG_WIDTH-1:0] dis_ptr, ret_ptr;\n  reg dis_ptr_wrap, ret_ptr_wrap;\n\n  // Initialize all entries\n  integer i;\n  initial begin\n    for (i = 0; i < E203_OITF_DEPTH; i = i + 1) begin\n      rdidx[i] = 0;\n      pc[i] = 0;\n      rdwen[i] = 0;\n      rdfpu[i] = 0;\n    end\n    dis_ptr = 0;\n    ret_ptr = 0;\n    dis_ptr_wrap = 0;\n    ret_ptr_wrap = 0;\n  end\n\n  // Check if OITF is full or empty\n  wire oitf_full = (dis_ptr == ret_ptr) && (dis_ptr_wrap != ret_ptr_wrap);\n  assign oitf_empty = (dis_ptr == ret_ptr) && (dis_ptr_wrap == ret_ptr_wrap);\n\n  // Dispatch logic\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      dis_ptr <= 0;\n      dis_ptr_wrap <= 0;\n      dis_ready <= 1'b1;\n    end else if (dis_ena && dis_ready) begin\n      rdidx[dis_ptr] <= disp_i_rdidx;\n      pc[dis_ptr] <= disp_i_pc;\n      rdwen[dis_ptr] <= disp_i_rdwen;\n      rdfpu[dis_ptr] <= disp_i_rdfpu;\n      dis_ptr <= dis_ptr + 1;\n      if (dis_ptr == E203_OITF_DEPTH-1) begin\n        dis_ptr_wrap <= ~dis_ptr_wrap;\n        dis_ptr <= 0;\n      end\n      dis_ready <= !oitf_full;\n    end\n  end\n\n  // Retirement logic\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      ret_ptr <= 0;\n      ret_ptr_wrap <= 0;\n    end else if (ret_ena) begin\n      ret_rdidx <= rdidx[ret_ptr];\n      ret_pc <= pc[ret_ptr];\n      ret_rdwen <= rdwen[ret_ptr];\n      ret_rdfpu <= rdfpu[ret_ptr];\n      ret_ptr <= ret_ptr + 1;\n      if (ret_ptr == E203_OITF_DEPTH-1) begin\n        ret_ptr_wrap <= ~ret_ptr_wrap;\n        ret_ptr <= 0;\n      end\n    end\n  end\n\n  // Dependency checking logic\n  always @(*) begin\n    oitfrd_match_disprs1 = 0;\n    oitfrd_match_disprs2 = 0;\n    oitfrd_match_disprs3 = 0;\n    oitfrd_match_disprd = 0;\n    for (i = 0; i < E203_OITF_DEPTH; i = i + 1) begin\n      if (rdwen[i]) begin\n        if (rdidx[i] == disp_i_rdidx) oitfrd_match_disprd = 1;\n      end\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 18, "code": "module e203_cpu_top(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire tcm_sd,\n    input wire tcm_ds,\n    input wire [E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input wire ext2itcm_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ext2itcm_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] ext2itcm_icb_cmd_wmask,\n    input wire ext2itcm_icb_rsp_ready,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire dbg_irq_r,\n    output wire ext2itcm_icb_cmd_valid,\n    output wire ext2itcm_icb_cmd_ready,\n    output wire ext2itcm_icb_rsp_valid,\n    output wire ext2itcm_icb_rsp_err,\n    output wire [E203_XLEN-1:0] ext2itcm_icb_rsp_rdata\n);\n\n    // Instantiate the e203_cpu core\n    e203_cpu u_e203_cpu(\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ext_irq_a(ext_irq_a),\n        .sft_irq_a(sft_irq_a),\n        .tmr_irq_a(tmr_irq_a),\n        .inspect_pc(inspect_pc),\n        .inspect_dbg_irq(inspect_dbg_irq),\n        .inspect_mem_cmd_valid(inspect_mem_cmd_valid),\n        .inspect_mem_cmd_ready(inspect_mem_cmd_ready),\n        .inspect_mem_rsp_valid(inspect_mem_rsp_valid),\n        .inspect_mem_rsp_ready(inspect_mem_rsp_ready),\n        .inspect_core_clk(inspect_core_clk),\n        .core_csr_clk(core_csr_clk),\n        .core_wfi(core_wfi),\n        .tm_stop(tm_stop),\n        .dbg_irq_r(dbg_irq_r)\n    );\n\n    // Instantiate the e203_srams for ITCM and DTCM management\n    e203_srams u_e203_srams(\n        .clk(clk),\n        .rst_n(rst_n),\n        .tcm_sd(tcm_sd),\n        .tcm_ds(tcm_ds),\n        .ext2itcm_icb_cmd_valid(ext2itcm_icb_cmd_valid),\n        .ext2itcm_icb_cmd_ready(ext2itcm_icb_cmd_ready),\n        .ext2itcm_icb_cmd_addr(ext2itcm_icb_cmd_addr),\n        .ext2itcm_icb_cmd_read(ext2itcm_icb_cmd_read),\n        .ext2itcm_icb_cmd_wdata(ext2itcm_icb_cmd_wdata),\n        .ext2itcm_icb_cmd_wmask(ext2itcm_icb_cmd_wmask),\n        .ext2itcm_icb_rsp_valid(ext2itcm_icb_rsp_valid),\n        .ext2itcm_icb_rsp_ready(ext2itcm_icb_rsp_ready),\n        .ext2itcm_icb_rsp_err(ext2itcm_icb_rsp_err),\n        .ext2itcm_icb_rsp_rdata(ext2itcm_icb_rsp_rdata)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 19, "code": "// E203 Processor Configuration Document\n\n// 1. Introduction\n\n// This document describes the configuration system for the E203 processor. The E203 is a RISC-V architecture-based processor core that can be configured with various features and functional modules via macro definitions. This configuration file is licensed under the Apache 2.0 open-source license and is maintained by Nuclei System Technology.\n\n// 2. Basic Configuration Items\n\n// 2.1 Debug and Interrupt Configuration\n// **`E203_CFG_DEBUG_HAS_JTAG`**: Enables support for JTAG debug interface.\n// **`E203_CFG_IRQ_NEED_SYNC`**: Enables interrupt synchronization mechanism.\n\n// 2.2 Address Space Configuration\n// The system supports three address width configurations, and only one can be selected at a time:\n// **`E203_CFG_ADDR_SIZE_IS_16`**: 16-bit address space.\n// **`E203_CFG_ADDR_SIZE_IS_24`**: 24-bit address space.\n// **`E203_CFG_ADDR_SIZE_IS_32`**: 32-bit address space (currently selected configuration).\n\n// The address size is unified through the **`E203_CFG_ADDR_SIZE`** macro, which is automatically set based on the chosen configuration.\n\n// 2.3 CPU Function Configuration\n// **`E203_CFG_SUPPORT_MCYCLE_MINSTRET`**: Enables support for MCYCLE and MINSTRET counters.\n// **`E203_CFG_REGNUM_IS_32`**: Configures the number of registers to 32.\n// **`E203_CFG_HAS_ECC`**: Enables ECC (Error Correction Code) functionality.\n// **`E203_CFG_HAS_NICE`**: Enables the NICE instruction extension.\n// **`E203_CFG_SUPPORT_SHARE_MULDIV`**: Enables shared multiplication and division units.\n// **`E203_CFG_SUPPORT_AMO`**: Enables support for atomic memory operations (AMO).\n\n// 2.4 Memory System Configuration\n\n// Instruction TCM (ITCM)\n// **`E203_CFG_HAS_ITCM`**: Enables Instruction Tightly Coupled Memory (ITCM).\n// **`E203_CFG_ITCM_ADDR_WIDTH`**: Configures the ITCM address width. The current setting is 16 bits.\n//   - Supports a 64KB configuration (16-bit address width, 8192 depth).\n//   - Optional 1024KB configuration (20-bit address width).\n//   - Optional 2048KB configuration (21-bit address width).\n\n// Data TCM (DTCM)\n// **`E203_CFG_HAS_DTCM`**: Enables Data Tightly Coupled Memory (DTCM).\n// **`E203_CFG_DTCM_ADDR_WIDTH`**: Configures the DTCM address width. The current setting is 16 bits.\n//   - Supports a 16KB configuration (14-bit address width, 4096 depth).\n//   - Supports a 256KB configuration (18-bit address width, 65536 depth).\n//   - Optional 1MB configuration (20-bit address width, 262144 depth).\n\n// 2.5 Memory Mapping Configuration\n\n// The system defines the base addresses for the following memory regions:\n\n// 1. **ITCM Region**:\n//    - Base address: `0x8000_0000`\n//    - Defined through **`E203_CFG_ITCM_ADDR_BASE`**.\n// 2. **DTCM Region**:\n//    - Base address: `0x9000_0000`\n//    - Defined through **`E203_CFG_DTCM_ADDR_BASE`**.\n// 3. **Peripheral Interface Regions**:\n//    - **PPI Region**: `0x1000_0000 - 0x1FFF_FFFF`\n//    - Defined through **`E203_CFG_PPI_ADDR_BASE`** and **`E203_CFG_PPI_BASE_REGION`**.\n// 4. **System Controller Regions**:\n//    - **CLINT Region**: `0x0200_0000 - 0x0200_FFFF`\n//    - Base Address of CLINT is defined through **`E203_CFG_CLINT_ADDR_BASE`**.(`E203_CFG_ADDR_SIZE'h0200_0000`)\n//    -  **`E203_CFG_CLINT_BASE_REGION`** macro defines the high address range used to determine whether an address belongs to CLINT REGION (`E203_CFG_ADDR_SIZE-1:E203_CFG_ADDR_SIZE-16`)\n//    - **PLIC Region**: `0x0C00_0000 - 0x0CFF_FFFF`\n//    - Base Address of PLIC is defined through **`E203_CFG_PLIC_ADDR_BASE`**.(`E203_CFG_ADDR_SIZE'h0C00_0000`)\n//    -  **`E203_CFG_PLIC_BASE_REGION`** macro defines the high address range used to determine whether an address belongs to PLIC REGION (`E203_CFG_ADDR_SIZE-1:E203_CFG_ADDR_SIZE-8`)\n// 5. **Fast IO Region**:\n//    - Base address: `0xF000_0000`\n//    - Defined through **`E203_CFG_FIO_ADDR_BASE`** and **`E203_CFG_FIO_BASE_REGION`**.\n\n// 3. Notes\n\n// 1. Only one address width configuration should be enabled at a time.\n// 2. TCM configurations should be selected based on available hardware resources.\n// 3. Memory mapping configurations must avoid address overlap.\n// 4. It is recommended to carefully evaluate the system's resource requirements and performance demands when modifying configurations.", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 7, "code": "module e203_biu(\n    input wire clk,\n    input wire rst_n,\n    output wire biu_active,\n    // ICB Interface - LSU\n    input wire lsu_icb_cmd_valid,\n    output wire lsu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] lsu_icb_cmd_addr,\n    input wire lsu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] lsu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] lsu_icb_cmd_wmask,\n    input wire [1:0] lsu_icb_cmd_burst,\n    input wire [1:0] lsu_icb_cmd_beat,\n    input wire lsu_icb_cmd_lock,\n    input wire lsu_icb_cmd_excl,\n    input wire [1:0] lsu_icb_cmd_size,\n    output wire lsu_icb_rsp_valid,\n    input wire lsu_icb_rsp_ready,\n    output wire lsu_icb_rsp_err,\n    output wire lsu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] lsu_icb_rsp_rdata,\n    // ICB Interface - IFU\n    input wire ifu_icb_cmd_valid,\n    output wire ifu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] ifu_icb_cmd_addr,\n    input wire ifu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ifu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] ifu_icb_cmd_wmask,\n    input wire [1:0] ifu_icb_cmd_burst,\n    input wire [1:0] ifu_icb_cmd_beat,\n    input wire ifu_icb_cmd_lock,\n    input wire ifu_icb_cmd_excl,\n    input wire [1:0] ifu_icb_cmd_size,\n    output wire ifu_icb_rsp_valid,\n    input wire ifu_icb_rsp_ready,\n    output wire ifu_icb_rsp_err,\n    output wire ifu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] ifu_icb_rsp_rdata,\n    // Additional signals for PPI, CLINT, PLIC, FIO\n    input wire [E203_ADDR_SIZE-1:0] ppi_region_indic,\n    input wire ppi_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] clint_region_indic,\n    input wire clint_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] plic_region_indic,\n    input wire plic_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] fio_region_indic,\n    input wire fio_icb_enable\n);\n\n    // Internal signals\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_valid;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_ready;\n    wire [BIU_ARBT_I_NUM*E203_ADDR_SIZE-1:0] arbt_icb_cmd_addr;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_read;\n    wire [BIU_ARBT_I_NUM*E203_XLEN-1:0] arbt_icb_cmd_wdata;\n    wire [BIU_ARBT_I_NUM*(E203_XLEN/8)-1:0] arbt_icb_cmd_wmask;\n    wire [BIU_ARBT_I_NUM*2-1:0] arbt_icb_cmd_burst;\n    wire [BIU_ARBT_I_NUM*2-1:0] arbt_icb_cmd_beat;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_lock;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_excl;\n    wire [BIU_ARBT_I_NUM*2-1:0] arbt_icb_cmd_size;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_valid;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_ready;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_err;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_excl_ok;\n    wire [BIU_ARBT_I_NUM*E203_XLEN-1:0] arbt_icb_rsp_rdata;\n\n    // Instantiate ICB Arbiter\n    sirv_gnrl_icb_arbt #(\n        .AW(E203_ADDR_SIZE),\n        .DW(E203_XLEN),\n        .ARBT_NUM(BIU_ARBT_I_NUM),\n        .ARBT_PTR_W(BIU_ARBT_I_PTR_W),\n        .USR_W(1),\n        .ARBT_SCHEME(0),\n        .ALLOW_0CYCL_RSP(0),\n        .FIFO_OUTS_NUM(E203_BIU_OUTS_NUM),\n        .FIFO_CUT_READY(E203_BIU_CMD_CUT_READY)\n    ) u_icb_arbt (\n        .clk(clk),\n        .rst_n(rst_n),\n        .i_bus_icb_cmd_valid(arbt_icb_cmd_valid),\n        .i_bus_icb_cmd_ready(arbt_icb_cmd_ready),\n        .i_bus_icb_cmd_addr(arbt_icb_cmd_addr),\n        .i_bus_icb_cmd_read(arbt_icb_cmd_read),\n        .i_bus_icb_cmd_wdata(arbt_icb_cmd_wdata),\n        .i_bus_icb_cmd_wmask(arbt_icb_cmd_wmask),\n        .i_bus_icb_cmd_burst(arbt_icb_cmd_burst),\n        .i_bus_icb_cmd_beat(arbt_icb_cmd_beat),\n        .i_bus_icb_cmd_lock(arbt_icb_cmd_lock),\n        .i_bus_icb_cmd_excl(arbt_icb_cmd_excl),\n        .i_bus_icb_cmd_size(arbt_icb_cmd_size),\n        .i_bus_icb_rsp_valid(arbt_icb_rsp_valid),\n        .i_bus_icb_rsp_ready(arbt_icb_rsp_ready),\n        .i_bus_icb_rsp_err(arbt_icb_rsp_err),\n        .i_bus_icb_rsp_excl_ok(arbt_icb_rsp_excl_ok),\n        .i_bus_icb_rsp_rdata(arbt_icb_rsp_rdata),\n        .o_icb_cmd_valid(),\n        .o_icb_cmd_ready(),\n        .o_icb_cmd_read(),\n        .o_icb_cmd_addr(),\n        .o_icb_cmd_wdata(),\n        .o_icb_cmd_wmask(),\n        .o_icb_rsp_valid(),\n        .o_icb_rsp_ready(),\n        .o_icb_rsp_err(),\n        .o_icb_rsp_excl_ok(),\n        .o_icb_rsp_rdata()\n    );\n\n    // Additional logic and modules would be instantiated here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 6, "code": "module e203_exu_alu_bjp (\n    input wire bjp_i_valid,\n    output wire bjp_i_ready,\n    input wire [E203_XLEN-1:0] bjp_i_rs1,\n    input wire [E203_XLEN-1:0] bjp_i_rs2,\n    input wire [E203_XLEN-1:0] bjp_i_imm,\n    input wire [E203_PC_SIZE-1:0] bjp_i_pc,\n    input wire [E203_DECINFO_BJP_WIDTH-1:0] bjp_i_info,\n    output wire bjp_o_valid,\n    input wire bjp_o_ready,\n    output wire [E203_XLEN-1:0] bjp_o_wbck_wdat,\n    output wire bjp_o_wbck_err,\n    output wire bjp_o_cmt_bjp,\n    output wire bjp_o_cmt_mret,\n    output wire bjp_o_cmt_dret,\n    output wire bjp_o_cmt_fencei,\n    output wire bjp_o_cmt_prdt,\n    output wire bjp_o_cmt_rslv,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    output wire bjp_req_alu_cmp_eq,\n    output wire bjp_req_alu_cmp_ne,\n    output wire bjp_req_alu_cmp_lt,\n    output wire bjp_req_alu_cmp_gt,\n    output wire bjp_req_alu_cmp_ltu,\n    output wire bjp_req_alu_cmp_gtu,\n    output wire bjp_req_alu_add,\n    input wire bjp_req_alu_cmp_res,\n    input wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Handshake signals\n    assign bjp_i_ready = bjp_o_ready;\n    assign bjp_o_valid = bjp_i_valid;\n\n    // Default assignments\n    assign bjp_o_wbck_err = 1'b0;\n    assign bjp_o_wbck_wdat = bjp_req_alu_add_res;\n\n    // Control signals\n    wire is_jump = bjp_i_info[E203_DECINFO_BJP_JUMP];\n    wire is_beq = bjp_i_info[E203_DECINFO_BJP_BEQ];\n    wire is_bne = bjp_i_info[E203_DECINFO_BJP_BNE];\n    wire is_blt = bjp_i_info[E203_DECINFO_BJP_BLT];\n    wire is_bgt = bjp_i_info[E203_DECINFO_BJP_BGT];\n    wire is_bltu = bjp_i_info[E203_DECINFO_BJP_BLTU];\n    wire is_bgtu = bjp_i_info[E203_DECINFO_BJP_BGTU];\n    wire is_mret = bjp_i_info[E203_DECINFO_BJP_MRET];\n    wire is_dret = bjp_i_info[E203_DECINFO_BJP_DRET];\n    wire is_fencei = bjp_i_info[E203_DECINFO_BJP_FENCEI];\n\n    // ALU operation requests\n    assign bjp_req_alu_cmp_eq = is_beq;\n    assign bjp_req_alu_cmp_ne = is_bne;\n    assign bjp_req_alu_cmp_lt = is_blt;\n    assign bjp_req_alu_cmp_gt = is_bgt;\n    assign bjp_req_alu_cmp_ltu = is_bltu;\n    assign bjp_req_alu_cmp_gtu = is_bgtu;\n    assign bjp_req_alu_add = is_jump;\n\n    // Operand selection\n    assign bjp_req_alu_op1 = is_jump ? bjp_i_pc : bjp_i_rs1;\n    assign bjp_req_alu_op2 = is_jump ? bjp_i_imm : bjp_i_rs2;\n\n    // Commit signals\n    assign bjp_o_cmt_bjp = bjp_i_valid & (is_jump | is_beq | is_bne | is_blt | is_bgt | is_bltu | is_bgtu);\n    assign bjp_o_cmt_mret = is_mret;\n    assign bjp_o_cmt_dret = is_dret;\n    assign bjp_o_cmt_fencei = is_fencei;\n    assign bjp_o_cmt_prdt = bjp_i_info[E203_DECINFO_BJP_BPRDT];\n    assign bjp_o_cmt_rslv = is_jump ? 1'b1 : bjp_req_alu_cmp_res;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 3, "code": "module e203_ifu_minidec #(\n  parameter E203_INSTR_SIZE = 32,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_XLEN = 32\n)(\n  input [E203_INSTR_SIZE-1:0] instr,\n  output reg dec_rs1en,\n  output reg dec_rs2en,\n  output reg [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n  output reg [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n  output reg dec_mulhsu,\n  output reg dec_mul,\n  output reg dec_div,\n  output reg dec_rem,\n  output reg dec_divu,\n  output reg dec_remu,\n  output reg dec_rv32,\n  output reg dec_bjp,\n  output reg dec_jal,\n  output reg dec_jalr,\n  output reg dec_bxx,\n  output reg [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  output reg [E203_XLEN-1:0] dec_bjp_imm\n);\n\n  // Internal signals for decoding\n  wire [6:0] opcode = instr[6:0];\n  wire [2:0] funct3 = instr[14:12];\n  wire [6:0] funct7 = instr[31:25];\n\n  always @(*) begin\n    // Default assignments\n    dec_rs1en = 1'b0;\n    dec_rs2en = 1'b0;\n    dec_rs1idx = instr[19:15];\n    dec_rs2idx = instr[24:20];\n    dec_mulhsu = 1'b0;\n    dec_mul = 1'b0;\n    dec_div = 1'b0;\n    dec_rem = 1'b0;\n    dec_divu = 1'b0;\n    dec_remu = 1'b0;\n    dec_rv32 = 1'b1; // Assuming RV32\n    dec_bjp = 1'b0;\n    dec_jal = 1'b0;\n    dec_jalr = 1'b0;\n    dec_bxx = 1'b0;\n    dec_jalr_rs1idx = instr[19:15];\n    dec_bjp_imm = {E203_XLEN{1'b0}};\n\n    // Decode logic\n    case (opcode)\n      7'b0110011: begin // R-type\n        dec_rs1en = 1'b1;\n        dec_rs2en = 1'b1;\n        case (funct3)\n          3'b000: begin\n            if (funct7 == 7'b0000001) begin\n              dec_mul = 1'b1;\n            end\n          end\n          3'b001: begin\n            if (funct7 == 7'b0000001) begin\n              dec_mulhsu = 1'b1;\n            end\n          end\n        endcase\n      end\n      7'b1101111: begin // JAL\n        dec_jal = 1'b1;\n        dec_bjp = 1'b1;\n        dec_bjp_imm = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0};\n      end\n      7'b1100111: begin // JALR\n        dec_jalr = 1'b1;\n        dec_bjp = 1'b1;\n        dec_bjp_imm = {{20{instr[31]}}, instr[31:20]};\n      end\n      7'b1100011: begin // B-type\n        dec_bxx = 1'b1;\n        dec_bjp = 1'b1;\n        dec_bjp_imm = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};\n      end\n    endcase\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 8, "code": "module e203_dtcm_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n    output wire dtcm_active,\n\n    // LSU ICB Interface\n    input wire lsu2dtcm_icb_cmd_valid,\n    output wire lsu2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] lsu2dtcm_icb_cmd_addr,\n    input wire lsu2dtcm_icb_cmd_read,\n    input wire [31:0] lsu2dtcm_icb_cmd_wdata,\n    input wire [3:0] lsu2dtcm_icb_cmd_wmask,\n    output wire lsu2dtcm_icb_rsp_valid,\n    input wire lsu2dtcm_icb_rsp_ready,\n    output wire lsu2dtcm_icb_rsp_err,\n    output wire [31:0] lsu2dtcm_icb_rsp_rdata,\n\n    // External ICB Interface (optional)\n    `ifdef E203_HAS_DTCM_EXTITF\n    input wire ext2dtcm_icb_cmd_valid,\n    output wire ext2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] ext2dtcm_icb_cmd_addr,\n    input wire ext2dtcm_icb_cmd_read,\n    input wire [31:0] ext2dtcm_icb_cmd_wdata,\n    input wire [3:0] ext2dtcm_icb_cmd_wmask,\n    output wire ext2dtcm_icb_rsp_valid,\n    input wire ext2dtcm_icb_rsp_ready,\n    output wire ext2dtcm_icb_rsp_err,\n    output wire [31:0] ext2dtcm_icb_rsp_rdata,\n    `endif\n\n    // DTCM RAM Interface\n    output wire dtcm_ram_cs,\n    output wire dtcm_ram_we,\n    output wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    output wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    output wire clk_dtcm_ram\n);\n\n    // Internal signals\n    wire icb_cmd_valid;\n    wire icb_cmd_ready;\n    wire [E203_DTCM_ADDR_WIDTH-1:0] icb_cmd_addr;\n    wire icb_cmd_read;\n    wire [31:0] icb_cmd_wdata;\n    wire [3:0] icb_cmd_wmask;\n    wire icb_rsp_valid;\n    wire icb_rsp_ready;\n    wire icb_rsp_err;\n    wire [31:0] icb_rsp_rdata;\n\n    // Arbitration logic (if external interface is used)\n    `ifdef E203_HAS_DTCM_EXTITF\n    // Instantiate the bus arbiter\n    sirv_gnrl_icb_arbt #(\n        .ARBT_SCHEME(0),\n        .ALLOW_0CYCL_RSP(0),\n        .FIFO_OUTS_NUM(E203_DTCM_OUTS_NUM),\n        .FIFO_CUT_READY(0),\n        .USR_W(1),\n        .ARBT_NUM(DTCM_ARBT_I_NUM),\n        .AW(E203_DTCM_ADDR_WIDTH),\n        .DW(32),\n        .ARBT_PTR_W(DTCM_ARBT_I_PTR_W)\n    ) u_dtcm_arbiter (\n        .o_icb_cmd_valid(icb_cmd_valid),\n        .o_icb_cmd_ready(icb_cmd_ready),\n        .o_icb_cmd_addr(icb_cmd_addr),\n        .o_icb_cmd_read(icb_cmd_read),\n        .o_icb_cmd_wdata(icb_cmd_wdata),\n        .o_icb_cmd_wmask(icb_cmd_wmask),\n        .i_icb_rsp_valid(icb_rsp_valid),\n        .i_icb_rsp_ready(icb_rsp_ready),\n        .i_icb_rsp_err(icb_rsp_err),\n        .i_icb_rsp_rdata(icb_rsp_rdata),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n    `else\n    // Connect LSU directly to the DTCM controller\n    assign icb_cmd_valid = lsu2dtcm_icb_cmd_valid;\n    assign icb_cmd_ready = lsu2dtcm_icb_cmd_ready;\n    assign icb_cmd_addr = lsu2dtcm_icb_cmd_addr;\n    assign icb_cmd_read = lsu2dtcm_icb_cmd_read;\n    assign icb_cmd_wdata = lsu2dtcm_icb_cmd_wdata;\n    assign icb_cmd_wmask = lsu2dtcm_icb_cmd_wmask;\n    assign icb_rsp_valid = lsu2dtcm_icb_rsp_valid;\n    assign icb_rsp_ready = lsu2dtcm_icb_rsp_ready;\n    assign icb_rsp_err = lsu2dtcm_icb_rsp_err;\n    assign icb_rsp_rdata = lsu2dtcm_icb_rsp_rdata;\n    `endif\n\n    // SRAM controller\n    sirv_sram_icb_ctrl #(\n        .DW(E203_DTCM_DATA_WIDTH),\n        .AW(E203_DTCM_ADDR_WIDTH),\n        .MW(E203_DTCM_WMSK_WIDTH),\n        .AW_LSB(2),\n        .USR_W(1)\n    ) u_dtcm_sram_ctrl (\n        .sram_ctrl_active(dtcm_active),\n        .tcm_cgstop(tcm_cgstop),\n        .i_icb_cmd_valid(icb_cmd_valid),\n        .i_icb_cmd_ready(icb_cmd_ready),\n        .i_icb_cmd_read(icb_cmd_read),\n        .i_icb_cmd_addr(icb_cmd_addr),\n        .i_icb_cmd_wdata(icb_cmd_wdata),\n        .i_icb_cmd_wmask(icb_cmd_wmask),\n        .i_icb_rsp_valid(icb_rsp_valid),\n        .i_icb_rsp_ready(icb_rsp_ready),\n        .i_icb_rsp_rdata(icb_rsp_rdata),\n        .ram_cs(dtcm_ram_cs),\n        .ram_we(dtcm_ram_we),\n        .ram_addr(dtcm_ram_addr),\n        .ram_wem(dtcm_ram_wem),\n        .ram_din(icb_cmd_wdata),\n        .ram_dout(dtcm_ram_dout),\n        .clk_ram(clk_dtcm_ram),\n        .test_mode(test_mode),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 2, "code": "module e203_exu_alu_dpath(\n    input wire alu_req_alu,\n    input wire alu_req_alu_add,\n    input wire alu_req_alu_sub,\n    input wire alu_req_alu_xor,\n    input wire alu_req_alu_sll,\n    input wire alu_req_alu_srl,\n    input wire alu_req_alu_sra,\n    input wire alu_req_alu_or,\n    input wire alu_req_alu_and,\n    input wire [E203_XLEN-1:0] alu_req_alu_op1,\n    input wire [E203_XLEN-1:0] alu_req_alu_op2,\n    input wire bjp_req_alu,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    input wire agu_req_alu,\n    input wire [E203_XLEN-1:0] agu_req_alu_op1,\n    input wire [E203_XLEN-1:0] agu_req_alu_op2,\n    input wire muldiv_req_alu,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    input wire muldiv_req_alu_add,\n    input wire muldiv_req_alu_sub,\n    input wire muldiv_sbf_0_ena,\n    input wire [32:0] muldiv_sbf_0_nxt,\n    input wire muldiv_sbf_1_ena,\n    input wire [32:0] muldiv_sbf_1_nxt,\n    input wire clk,\n    input wire rst_n,\n    output wire [E203_XLEN-1:0] alu_req_alu_res,\n    output wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    output wire bjp_req_alu_cmp_res,\n    output wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output wire [32:0] muldiv_sbf_0_r,\n    output wire [32:0] muldiv_sbf_1_r\n);\n\n// Internal signals for ALU operations\nwire [E203_XLEN-1:0] add_result;\nwire [E203_XLEN-1:0] sub_result;\nwire [E203_XLEN-1:0] and_result;\nwire [E203_XLEN-1:0] or_result;\nwire [E203_XLEN-1:0] xor_result;\nwire [E203_XLEN-1:0] sll_result;\nwire [E203_XLEN-1:0] srl_result;\nwire [E203_XLEN-1:0] sra_result;\n\n// ALU operation implementations\nassign add_result = alu_req_alu_op1 + alu_req_alu_op2;\nassign sub_result = alu_req_alu_op1 - alu_req_alu_op2;\nassign and_result = alu_req_alu_op1 & alu_req_alu_op2;\nassign or_result = alu_req_alu_op1 | alu_req_alu_op2;\nassign xor_result = alu_req_alu_op1 ^ alu_req_alu_op2;\nassign sll_result = alu_req_alu_op1 << alu_req_alu_op2[E203_XLEN-1:0];\nassign srl_result = alu_req_alu_op1 >> alu_req_alu_op2[E203_XLEN-1:0];\nassign sra_result = $signed(alu_req_alu_op1) >>> alu_req_alu_op2[E203_XLEN-1:0];\n\n// Result multiplexing based on operation type\nassign alu_req_alu_res = ({E203_XLEN{alu_req_alu_add}} & add_result) |\n                         ({E203_XLEN{alu_req_alu_sub}} & sub_result) |\n                         ({E203_XLEN{alu_req_alu_and}} & and_result) |\n                         ({E203_XLEN{alu_req_alu_or}} & or_result) |\n                         ({E203_XLEN{alu_req_alu_xor}} & xor_result) |\n                         ({E203_XLEN{alu_req_alu_sll}} & sll_result) |\n                         ({E203_XLEN{alu_req_alu_srl}} & srl_result) |\n                         ({E203_XLEN{alu_req_alu_sra}} & sra_result);\n\n// BJP, AGU, and MULDIV results handling\nassign bjp_req_alu_add_res = bjp_req_alu_op1 + bjp_req_alu_op2;\nassign bjp_req_alu_cmp_res = (bjp_req_alu_op1 == bjp_req_alu_op2);\nassign agu_req_alu_res = agu_req_alu_op1 + agu_req_alu_op2; // Example for AGU add operation\nassign muldiv_req_alu_res = (muldiv_req_alu_add ? muldiv_req_alu_op1 + muldiv_req_alu_op2 :\n                            muldiv_req_alu_sub ? muldiv_req_alu_op1 - muldiv_req_alu_op2 : {E203_ALU_ADDER_WIDTH{1'b0}});\n\n// Shared buffer handling using D flip-flops\nsirv_gnrl_dffl #(.DW(33)) sbf_0_dffl (\n    .lden(muldiv_sbf_0_ena),\n    .dnxt(muldiv_sbf_0_nxt),\n    .qout(muldiv_sbf_0_r),\n    .clk(clk)\n);\n\nsirv_gnrl_dffl #(.DW(33)) sbf_1_dffl (\n    .lden(muldiv_sbf_1_ena),\n    .dnxt(muldiv_sbf_1_nxt),\n    .qout(muldiv_sbf_1_r),\n    .clk(clk)\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 1, "code": "module e203_exu_longpwbck (\n    input wire lsu_wbck_i_valid,\n    output wire lsu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] lsu_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] lsu_wbck_i_itag,\n    input wire lsu_wbck_i_err,\n    input wire lsu_cmt_i_buserr,\n    input wire [E203_ADDR_SIZE-1:0] lsu_cmt_i_badaddr,\n    input wire lsu_cmt_i_ld,\n    input wire lsu_cmt_i_st,\n    output wire longp_wbck_o_valid,\n    input wire longp_wbck_o_ready,\n    output wire [E203_FLEN-1:0] longp_wbck_o_wdat,\n    output wire [4:0] longp_wbck_o_flags,\n    output wire [E203_RFIDX_WIDTH-1:0] longp_wbck_o_rdidx,\n    output wire longp_wbck_o_rdfpu,\n    output wire longp_excp_o_valid,\n    input wire longp_excp_o_ready,\n    output wire longp_excp_o_insterr,\n    output wire longp_excp_o_ld,\n    output wire longp_excp_o_st,\n    output wire longp_excp_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] longp_excp_o_badaddr,\n    output wire [E203_PC_SIZE-1:0] longp_excp_o_pc,\n    input wire oitf_empty,\n    input wire [E203_ITAG_WIDTH-1:0] oitf_ret_ptr,\n    input wire [E203_RFIDX_WIDTH-1:0] oitf_ret_rdidx,\n    input wire [E203_PC_SIZE-1:0] oitf_ret_pc,\n    input wire oitf_ret_rdwen,\n    input wire oitf_ret_rdfpu,\n    output wire oitf_ret_ena,\n    input wire clk,\n    input wire rst_n\n`ifdef E203_HAS_NICE\n    , input wire nice_longp_wbck_i_valid,\n    output wire nice_longp_wbck_i_ready,\n    input wire [E203_XLEN-1:0] nice_longp_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] nice_longp_wbck_i_itag,\n    input wire nice_longp_wbck_i_err\n`endif\n);\n\n    // Internal signals\n    wire wbck_i_valid;\n    wire wbck_i_ready;\n    wire [E203_XLEN-1:0] wbck_i_wdat;\n    wire [E203_ITAG_WIDTH-1:0] wbck_i_itag;\n    wire wbck_i_err;\n\n    // Arbitration logic\n    assign wbck_i_valid = lsu_wbck_i_valid;\n    assign wbck_i_wdat = lsu_wbck_i_wdat;\n    assign wbck_i_itag = lsu_wbck_i_itag;\n    assign wbck_i_err = lsu_wbck_i_err;\n\n    assign lsu_wbck_i_ready = wbck_i_ready;\n\n    // Write-back and exception control logic\n    assign longp_wbck_o_valid = wbck_i_valid && longp_wbck_o_ready && !wbck_i_err;\n    assign longp_wbck_o_wdat = wbck_i_wdat;\n    assign longp_wbck_o_rdidx = oitf_ret_rdidx;\n    assign longp_wbck_o_rdfpu = oitf_ret_rdfpu;\n\n    assign longp_excp_o_valid = wbck_i_err && longp_excp_o_ready;\n    assign longp_excp_o_insterr = wbck_i_err;\n    assign longp_excp_o_ld = lsu_cmt_i_ld;\n    assign longp_excp_o_st = lsu_cmt_i_st;\n    assign longp_excp_o_buserr = lsu_cmt_i_buserr;\n    assign longp_excp_o_badaddr = lsu_cmt_i_badaddr;\n    assign longp_excp_o_pc = oitf_ret_pc;\n\n    // OITF control\n    assign oitf_ret_ena = wbck_i_valid && wbck_i_ready;\n\n    // Clock and reset\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            // Reset logic\n        end else begin\n            // Operational logic\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 7, "code": "module e203_reset_ctrl #(\n    parameter MASTER = 1,\n    parameter RST_SYNC_LEVEL = `E203_ASYNC_FF_LEVELS\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    output reg rst_core,\n    output reg rst_itcm,\n    output reg rst_dtcm,\n    output reg rst_aon\n);\n\nreg [RST_SYNC_LEVEL-1:0] rst_sync;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        rst_sync <= {RST_SYNC_LEVEL{1'b1}};\n    end else if (test_mode) begin\n        rst_sync <= {RST_SYNC_LEVEL{rst_n}};\n    end else begin\n        rst_sync <= {rst_sync[RST_SYNC_LEVEL-2:0], 1'b1};\n    end\nend\n\nalways @(*) begin\n    if (test_mode) begin\n        rst_core = rst_n;\n        rst_itcm = rst_n;\n        rst_dtcm = rst_n;\n        rst_aon = rst_n;\n    end else if (MASTER == 1) begin\n        rst_core = rst_sync[RST_SYNC_LEVEL-1];\n        rst_itcm = rst_sync[RST_SYNC_LEVEL-1];\n        rst_dtcm = rst_sync[RST_SYNC_LEVEL-1];\n        rst_aon = rst_sync[RST_SYNC_LEVEL-1];\n    end else begin\n        rst_core = rst_n;\n        rst_itcm = rst_n;\n        rst_dtcm = rst_n;\n        rst_aon = rst_n;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 8, "code": "module e203_biu(\n    input wire clk,\n    input wire rst_n,\n    output wire biu_active,\n    // ICB interface for LSU\n    input wire lsu_icb_cmd_valid,\n    output wire lsu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] lsu_icb_cmd_addr,\n    input wire lsu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] lsu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] lsu_icb_cmd_wmask,\n    input wire [1:0] lsu_icb_cmd_burst,\n    input wire [1:0] lsu_icb_cmd_beat,\n    input wire lsu_icb_cmd_lock,\n    input wire lsu_icb_cmd_excl,\n    input wire [1:0] lsu_icb_cmd_size,\n    output wire lsu_icb_rsp_valid,\n    input wire lsu_icb_rsp_ready,\n    output wire lsu_icb_rsp_err,\n    output wire lsu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] lsu_icb_rsp_rdata,\n    // ICB interface for IFU\n    input wire ifu_icb_cmd_valid,\n    output wire ifu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] ifu_icb_cmd_addr,\n    input wire ifu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ifu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] ifu_icb_cmd_wmask,\n    input wire [1:0] ifu_icb_cmd_burst,\n    input wire [1:0] ifu_icb_cmd_beat,\n    input wire ifu_icb_cmd_lock,\n    input wire ifu_icb_cmd_excl,\n    input wire [1:0] ifu_icb_cmd_size,\n    output wire ifu_icb_rsp_valid,\n    input wire ifu_icb_rsp_ready,\n    output wire ifu_icb_rsp_err,\n    output wire ifu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] ifu_icb_rsp_rdata,\n    // Additional signals for peripherals\n    input wire [E203_ADDR_SIZE-1:0] ppi_region_indic,\n    input wire ppi_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] clint_region_indic,\n    input wire clint_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] plic_region_indic,\n    input wire plic_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] fio_region_indic,\n    input wire fio_icb_enable,\n    input wire mem_icb_enable\n);\n\n// Internal signals\nwire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_valid;\nwire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_ready;\nwire [BIU_ARBT_I_NUM*E203_ADDR_SIZE-1:0] arbt_icb_cmd_addr;\nwire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_read;\nwire [BIU_ARBT_I_NUM*E203_XLEN-1:0] arbt_icb_cmd_wdata;\nwire [BIU_ARBT_I_NUM*(E203_XLEN/8)-1:0] arbt_icb_cmd_wmask;\nwire [BIU_ARBT_I_NUM*2-1:0] arbt_icb_cmd_burst;\nwire [BIU_ARBT_I_NUM*2-1:0] arbt_icb_cmd_beat;\nwire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_lock;\nwire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_excl;\nwire [BIU_ARBT_I_NUM*2-1:0] arbt_icb_cmd_size;\nwire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_valid;\nwire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_ready;\nwire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_err;\nwire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_excl_ok;\nwire [BIU_ARBT_I_NUM*E203_XLEN-1:0] arbt_icb_rsp_rdata;\n\n// Instantiate the ICB Arbiter\nsirv_gnrl_icb_arbt #(\n    .AW(E203_ADDR_SIZE),\n    .DW(E203_XLEN),\n    .ARBT_NUM(BIU_ARBT_I_NUM),\n    .ARBT_PTR_W(BIU_ARBT_I_PTR_W),\n    .USR_W(1),\n    .ARBT_SCHEME(0),\n    .ALLOW_0CYCL_RSP(0),\n    .FIFO_OUTS_NUM(E203_BIU_OUTS_NUM),\n    .FIFO_CUT_READY(E203_BIU_CMD_CUT_READY)\n) u_icb_arbt (\n    .clk(clk),\n    .rst_n(rst_n),\n    .i_bus_icb_cmd_valid({ifu_icb_cmd_valid, lsu_icb_cmd_valid}),\n    .i_bus_icb_cmd_ready({ifu_icb_cmd_ready, lsu_icb_cmd_ready}),\n    .i_bus_icb_cmd_addr({ifu_icb_cmd_addr, lsu_icb_cmd_addr}),\n    .i_bus_icb_cmd_read({ifu_icb_cmd_read, lsu_icb_cmd_read}),\n    .i_bus_icb_cmd_wdata({ifu_icb_cmd_wdata, lsu_icb_cmd_wdata}),\n    .i_bus_icb_cmd_wmask({ifu_icb_cmd_wmask, lsu_icb_cmd_wmask}),\n    .i_bus_icb_cmd_burst({ifu_icb_cmd_burst, lsu_icb_cmd_burst}),\n    .i_bus_icb_cmd_beat({ifu_icb_cmd_beat, lsu_icb_cmd_beat}),\n    .i_bus_icb_cmd_lock({ifu_icb_cmd_lock, lsu_icb_cmd_lock}),\n    .i_bus_icb_cmd_excl({ifu_icb_cmd_excl, lsu_icb_cmd_excl}),\n    .i_bus_icb_cmd_size({ifu_icb_cmd_size, lsu_icb_cmd_size}),\n    .o_bus_icb_rsp_valid({ifu_icb_rsp_valid, lsu_icb_rsp_valid}),\n    .o_bus_icb_rsp_ready({ifu_icb_rsp_ready, lsu_icb_rsp_ready}),\n    .o_bus_icb_rsp_err({ifu_icb_rsp_err, lsu_icb_rsp_err}),\n    .o_bus_icb_rsp_excl_ok({ifu_icb_rsp_excl_ok, lsu_icb_rsp_excl_ok}),\n    .o_bus_icb_rsp_rdata({ifu_icb_rsp_rdata, lsu_icb_rsp_rdata})\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 9, "code": "module e203_biu(\n    input wire clk,\n    input wire rst_n,\n    output wire biu_active,\n\n    // ICB Interface for LSU\n    input wire lsu_icb_cmd_valid,\n    output wire lsu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] lsu_icb_cmd_addr,\n    input wire lsu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] lsu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] lsu_icb_cmd_wmask,\n    input wire [1:0] lsu_icb_cmd_burst,\n    input wire [1:0] lsu_icb_cmd_beat,\n    input wire lsu_icb_cmd_lock,\n    input wire lsu_icb_cmd_excl,\n    input wire [1:0] lsu_icb_cmd_size,\n    output wire lsu_icb_rsp_valid,\n    input wire lsu_icb_rsp_ready,\n    output wire lsu_icb_rsp_err,\n    output wire lsu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] lsu_icb_rsp_rdata,\n\n    // ICB Interface for IFU\n    input wire ifu_icb_cmd_valid,\n    output wire ifu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] ifu_icb_cmd_addr,\n    input wire ifu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ifu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] ifu_icb_cmd_wmask,\n    input wire [1:0] ifu_icb_cmd_burst,\n    input wire [1:0] ifu_icb_cmd_beat,\n    input wire ifu_icb_cmd_lock,\n    input wire ifu_icb_cmd_excl,\n    input wire [1:0] ifu_icb_cmd_size,\n    output wire ifu_icb_rsp_valid,\n    input wire ifu_icb_rsp_ready,\n    output wire ifu_icb_rsp_err,\n    output wire ifu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] ifu_icb_rsp_rdata,\n\n    // Additional signals for peripherals\n    input wire [E203_ADDR_SIZE-1:0] ppi_region_indic,\n    input wire ppi_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] clint_region_indic,\n    input wire clint_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] plic_region_indic,\n    input wire plic_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] fio_region_indic,\n    input wire fio_icb_enable,\n    input wire mem_icb_enable\n);\n\n    // Internal signals\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_valid;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_ready;\n    wire [BIU_ARBT_I_NUM*E203_ADDR_SIZE-1:0] arbt_icb_cmd_addr;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_read;\n    wire [BIU_ARBT_I_NUM*E203_XLEN-1:0] arbt_icb_cmd_wdata;\n    wire [BIU_ARBT_I_NUM*(E203_XLEN/8)-1:0] arbt_icb_cmd_wmask;\n    wire [BIU_ARBT_I_NUM*2-1:0] arbt_icb_cmd_burst;\n    wire [BIU_ARBT_I_NUM*2-1:0] arbt_icb_cmd_beat;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_lock;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_excl;\n    wire [BIU_ARBT_I_NUM*2-1:0] arbt_icb_cmd_size;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_valid;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_ready;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_err;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_excl_ok;\n    wire [BIU_ARBT_I_NUM*E203_XLEN-1:0] arbt_icb_rsp_rdata;\n\n    // Instantiate the ICB Arbiter\n    sirv_gnrl_icb_arbt #(\n        .AW(E203_ADDR_SIZE),\n        .DW(E203_XLEN),\n        .ARBT_NUM(BIU_ARBT_I_NUM),\n        .ARBT_PTR_W(BIU_ARBT_I_PTR_W),\n        .USR_W(1),\n        .ARBT_SCHEME(0),\n        .ALLOW_0CYCL_RSP(0),\n        .FIFO_OUTS_NUM(E203_BIU_OUTS_NUM),\n        .FIFO_CUT_READY(E203_BIU_CMD_CUT_READY)\n    ) u_icb_arbt (\n        .clk(clk),\n        .rst_n(rst_n),\n        .i_bus_icb_cmd_valid({ifu_icb_cmd_valid, lsu_icb_cmd_valid}),\n        .i_bus_icb_cmd_ready({ifu_icb_cmd_ready, lsu_icb_cmd_ready}),\n        .i_bus_icb_cmd_addr({ifu_icb_cmd_addr, lsu_icb_cmd_addr}),\n        .i_bus_icb_cmd_read({ifu_icb_cmd_read, lsu_icb_cmd_read}),\n        .i_bus_icb_cmd_wdata({ifu_icb_cmd_wdata, lsu_icb_cmd_wdata}),\n        .i_bus_icb_cmd_wmask({ifu_icb_cmd_wmask, lsu_icb_cmd_wmask}),\n        .i_bus_icb_cmd_burst({ifu_icb_cmd_burst, lsu_icb_cmd_burst}),\n        .i_bus_icb_cmd_beat({ifu_icb_cmd_beat, lsu_icb_cmd_beat}),\n        .i_bus_icb_cmd_lock({ifu_icb_cmd_lock, lsu_icb_cmd_lock}),\n        .i_bus_icb_cmd_excl({ifu_icb_cmd_excl, lsu_icb_cmd_excl}),\n        .i_bus_icb_cmd_size({ifu_icb_cmd_size, lsu_icb_cmd_size}),\n        .o_icb_cmd_valid(arbt_icb_cmd_valid),\n        .o_icb_cmd_ready(arbt_icb_cmd_ready),\n        .o_icb_cmd_addr(arbt_icb_cmd_addr),\n        .o_icb_cmd_read(arbt_icb_cmd_read),\n        .o_icb_cmd_wdata(arbt_icb_cmd_wdata),\n        .o_icb_cmd_wmask(arbt_icb_cmd_wmask),\n        .o_icb_rsp_valid(arbt_icb_rsp_valid),\n        .o_icb_rsp_ready(arbt_icb_rsp_ready),\n        .o_icb_rsp_err(arbt_icb_rsp_err),\n        .o_icb_rsp_excl_ok(arbt_icb_rsp_excl_ok),\n        .o_icb_rsp_rdata(arbt_icb_rsp_rdata)\n    );\n\n    // Additional logic for peripheral handling and response routing would be here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 2, "code": "module e203_exu_decode (\n    input [E203_INSTR_SIZE-1:0] i_instr,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_prdt_taken,\n    input i_misalgn,\n    input i_buserr,\n    input i_muldiv_b2b,\n    input dbg_mode,\n    output dec_rs1x0,\n    output dec_rs2x0,\n    output dec_rs1en,\n    output dec_rs2en,\n    output dec_rdwen,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rdidx,\n    output [E203_DECINFO_WIDTH-1:0] dec_info,\n    output [E203_XLEN-1:0] dec_imm,\n    output [E203_PC_SIZE-1:0] dec_pc,\n    output dec_misalgn,\n    output dec_buserr,\n    output dec_ilegl,\n    output dec_mulhsu,\n    output dec_mul,\n    output dec_div,\n    output dec_rem,\n    output dec_divu,\n    output dec_remu,\n    output dec_rv32,\n    output dec_bjp,\n    output dec_jal,\n    output dec_jalr,\n    output dec_bxx,\n    output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    output [E203_XLEN-1:0] dec_bjp_imm,\n    input nice_xs_off,\n    output dec_nice,\n    output nice_cmt_off_ilgl_o\n);\n\n    // Internal signal declarations\n    wire [6:0] opcode = i_instr[6:0];\n    wire [2:0] funct3 = i_instr[14:12];\n    wire [6:0] funct7 = i_instr[31:25];\n    wire [4:0] rs1 = i_instr[19:15];\n    wire [4:0] rs2 = i_instr[24:20];\n    wire [4:0] rd = i_instr[11:7];\n    wire [11:0] imm12 = i_instr[31:20];\n    wire [11:0] imm12_I = {{20{i_instr[31]}}, i_instr[31:20]};\n    wire [11:0] imm12_S = {{20{i_instr[31]}}, i_instr[31:25], i_instr[11:7]};\n    wire [12:0] imm13 = {{19{i_instr[31]}}, i_instr[31], i_instr[7], i_instr[30:25], i_instr[11:8], 1'b0};\n\n    // Decode logic\n    assign dec_rs1x0 = (rs1 == 5'b00000);\n    assign dec_rs2x0 = (rs2 == 5'b00000);\n    assign dec_rs1en = (opcode == 7'b1100111) || (opcode == 7'b0000011) || (opcode == 7'b0100011) || (opcode == 7'b1100011);\n    assign dec_rs2en = (opcode == 7'b0100011) || (opcode == 7'b1100011);\n    assign dec_rdwen = (opcode == 7'b0110011) || (opcode == 7'b0010011) || (opcode == 7'b0000011) || (opcode == 7'b1100111) || (opcode == 7'b1101111);\n    assign dec_rs1idx = rs1;\n    assign dec_rs2idx = rs2;\n    assign dec_rdidx = rd;\n    assign dec_info = {E203_DECINFO_WIDTH{1'b0}}; // Placeholder for actual decode information\n    assign dec_imm = imm12_I;\n    assign dec_pc = i_pc;\n    assign dec_misalgn = i_misalgn;\n    assign dec_buserr = i_buserr;\n    assign dec_ilegl = 1'b0; // Placeholder for illegal instruction detection\n    assign dec_mulhsu = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b010);\n    assign dec_mul = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b000);\n    assign dec_div = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b100);\n    assign dec_rem = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b110);\n    assign dec_divu = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b101);\n    assign dec_remu = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b111);\n    assign dec_rv32 = (i_instr[1:0] == 2'b11);\n    assign dec_bjp = (opcode == 7'b1101111) || (opcode == 7'b1100111) || (opcode == 7'b1100011);\n    assign dec_jal = (opcode == 7'b1101111);\n    assign dec_jalr = (opcode == 7'b1100111);\n    assign dec_bxx = (opcode == 7'b1100011);\n    assign dec_jalr_rs1idx = rs1;\n    assign dec_bjp_imm = imm13;\n    assign dec_nice = 1'b0; // Placeholder for NICE instruction detection\n    assign nice_cmt_off_ilgl_o = nice_xs_off && dec_nice;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 3, "code": "module e203_itcm_ram #(\n  parameter FORCE_X2ZERO = 0,\n  parameter DP = `E203_ITCM_RAM_DP,\n  parameter DW = `E203_ITCM_RAM_DW,\n  parameter MW = `E203_ITCM_RAM_MW,\n  parameter AW = `E203_ITCM_RAM_AW\n)(\n  input wire sd,\n  input wire ds,\n  input wire ls,\n  input wire cs,\n  input wire we,\n  input wire [AW-1:0] addr,\n  input wire [MW-1:0] wem,\n  input wire [DW-1:0] din,\n  input wire rst_n,\n  input wire clk,\n  output wire [DW-1:0] dout\n);\n\n  // Instantiate the generic RAM module\n  sirv_gnrl_ram #(\n    .FORCE_X2ZERO(FORCE_X2ZERO),\n    .DP(DP),\n    .DW(DW),\n    .MW(MW),\n    .AW(AW)\n  ) ram_inst (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 1, "code": "module e203_ifu_litebpu #(\n  parameter E203_PC_SIZE = 32,\n  parameter E203_XLEN = 32,\n  parameter E203_RFIDX_WIDTH = 5\n)(\n  input clk,\n  input rst_n,\n  input [E203_PC_SIZE-1:0] pc,\n  input dec_jal,\n  input dec_jalr,\n  input dec_bxx,\n  input [E203_XLEN-1:0] dec_bjp_imm,\n  input [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  input oitf_empty,\n  input ir_empty,\n  input ir_rs1en,\n  input jalr_rs1idx_cam_irrdidx,\n  input dec_i_valid,\n  input ir_valid_clr,\n  input [E203_XLEN-1:0] rf2bpu_x1,\n  input [E203_XLEN-1:0] rf2bpu_rs1,\n  output reg prdt_taken,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op1,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op2,\n  output reg bpu_wait,\n  output reg bpu2rf_rs1_ena\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      prdt_taken <= 1'b0;\n      prdt_pc_add_op1 <= {E203_PC_SIZE{1'b0}};\n      prdt_pc_add_op2 <= {E203_PC_SIZE{1'b0}};\n      bpu_wait <= 1'b0;\n      bpu2rf_rs1_ena <= 1'b0;\n    end else begin\n      // Default outputs\n      prdt_taken <= 1'b0;\n      prdt_pc_add_op1 <= pc;\n      prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n      bpu_wait <= 1'b0;\n      bpu2rf_rs1_ena <= 1'b0;\n\n      // Prediction logic\n      if (dec_i_valid) begin\n        if (dec_jal) begin\n          prdt_taken <= 1'b1;\n        end else if (dec_jalr) begin\n          prdt_taken <= 1'b1;\n          if (dec_jalr_rs1idx == 0) begin\n            prdt_pc_add_op1 <= {E203_PC_SIZE{1'b0}};\n          end else if (dec_jalr_rs1idx == 1) begin\n            prdt_pc_add_op1 <= rf2bpu_x1;\n            if (!oitf_empty || jalr_rs1idx_cam_irrdidx) begin\n              bpu_wait <= 1'b1;\n            end\n          end else begin\n            prdt_pc_add_op1 <= rf2bpu_rs1;\n            if (!oitf_empty || (ir_rs1en && !ir_empty)) begin\n              bpu_wait <= 1'b1;\n            end\n          end\n        end else if (dec_bxx) begin\n          if (dec_bjp_imm[E203_XLEN-1]) begin // Negative offset\n            prdt_taken <= 1'b1;\n          end\n        end\n      end\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 7, "code": "module e203_exu_alu_bjp (\n    input wire bjp_i_valid,\n    output wire bjp_i_ready,\n    input wire [E203_XLEN-1:0] bjp_i_rs1,\n    input wire [E203_XLEN-1:0] bjp_i_rs2,\n    input wire [E203_XLEN-1:0] bjp_i_imm,\n    input wire [E203_PC_SIZE-1:0] bjp_i_pc,\n    input wire [E203_DECINFO_BJP_WIDTH-1:0] bjp_i_info,\n    output wire bjp_o_valid,\n    input wire bjp_o_ready,\n    output wire [E203_XLEN-1:0] bjp_o_wbck_wdat,\n    output wire bjp_o_wbck_err,\n    output wire bjp_o_cmt_bjp,\n    output wire bjp_o_cmt_mret,\n    output wire bjp_o_cmt_dret,\n    output wire bjp_o_cmt_fencei,\n    output wire bjp_o_cmt_prdt,\n    output wire bjp_o_cmt_rslv,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    output wire bjp_req_alu_cmp_eq,\n    output wire bjp_req_alu_cmp_ne,\n    output wire bjp_req_alu_cmp_lt,\n    output wire bjp_req_alu_cmp_gt,\n    output wire bjp_req_alu_cmp_ltu,\n    output wire bjp_req_alu_cmp_gtu,\n    output wire bjp_req_alu_add,\n    input wire bjp_req_alu_cmp_res,\n    input wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Handshake signals\n    assign bjp_i_ready = bjp_o_ready;\n    assign bjp_o_valid = bjp_i_valid;\n\n    // Default assignments\n    assign bjp_o_wbck_err = 1'b0;\n\n    // ALU operation requests\n    wire is_jump = bjp_i_info[E203_DECINFO_BJP_JUMP];\n    wire is_beq = bjp_i_info[E203_DECINFO_BJP_BEQ];\n    wire is_bne = bjp_i_info[E203_DECINFO_BJP_BNE];\n    wire is_blt = bjp_i_info[E203_DECINFO_BJP_BLT];\n    wire is_bgt = bjp_i_info[E203_DECINFO_BJP_BGT];\n    wire is_bltu = bjp_i_info[E203_DECINFO_BJP_BLTU];\n    wire is_bgtu = bjp_i_info[E203_DECINFO_BJP_BGTU];\n\n    assign bjp_req_alu_cmp_eq = is_beq;\n    assign bjp_req_alu_cmp_ne = is_bne;\n    assign bjp_req_alu_cmp_lt = is_blt;\n    assign bjp_req_alu_cmp_gt = is_bgt;\n    assign bjp_req_alu_cmp_ltu = is_bltu;\n    assign bjp_req_alu_cmp_gtu = is_bgtu;\n\n    // Operand selection\n    assign bjp_req_alu_op1 = is_jump ? bjp_i_pc : bjp_i_rs1;\n    assign bjp_req_alu_op2 = is_jump ? bjp_i_imm : bjp_i_rs2;\n\n    // ALU add request for jumps\n    assign bjp_req_alu_add = is_jump;\n\n    // Commit signals\n    assign bjp_o_cmt_bjp = bjp_i_valid && (is_jump || is_beq || is_bne || is_blt || is_bgt || is_bltu || is_bgtu);\n    assign bjp_o_cmt_mret = bjp_i_info[E203_DECINFO_BJP_MRET];\n    assign bjp_o_cmt_dret = bjp_i_info[E203_DECINFO_BJP_DRET];\n    assign bjp_o_cmt_fencei = bjp_i_info[E203_DECINFO_BJP_FENCEI];\n\n    // Predicted and resolved results\n    assign bjp_o_cmt_prdt = bjp_i_info[E203_DECINFO_BJP_BPRDT];\n    assign bjp_o_cmt_rslv = is_jump ? 1'b1 : bjp_req_alu_cmp_res;\n\n    // Write back data\n    assign bjp_o_wbck_wdat = bjp_req_alu_add_res;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 8, "code": "module e203_exu_alu_bjp (\n    input wire bjp_i_valid,\n    output wire bjp_i_ready,\n    input wire [E203_XLEN-1:0] bjp_i_rs1,\n    input wire [E203_XLEN-1:0] bjp_i_rs2,\n    input wire [E203_XLEN-1:0] bjp_i_imm,\n    input wire [E203_PC_SIZE-1:0] bjp_i_pc,\n    input wire [E203_DECINFO_BJP_WIDTH-1:0] bjp_i_info,\n    output wire bjp_o_valid,\n    input wire bjp_o_ready,\n    output wire [E203_XLEN-1:0] bjp_o_wbck_wdat,\n    output wire bjp_o_wbck_err,\n    output wire bjp_o_cmt_bjp,\n    output wire bjp_o_cmt_mret,\n    output wire bjp_o_cmt_dret,\n    output wire bjp_o_cmt_fencei,\n    output wire bjp_o_cmt_prdt,\n    output wire bjp_o_cmt_rslv,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    output wire bjp_req_alu_cmp_eq,\n    output wire bjp_req_alu_cmp_ne,\n    output wire bjp_req_alu_cmp_lt,\n    output wire bjp_req_alu_cmp_gt,\n    output wire bjp_req_alu_cmp_ltu,\n    output wire bjp_req_alu_cmp_gtu,\n    output wire bjp_req_alu_add,\n    input wire bjp_req_alu_cmp_res,\n    input wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Handshake mechanism\n    assign bjp_i_ready = bjp_o_ready;\n    assign bjp_o_valid = bjp_i_valid;\n\n    // Default assignments\n    assign bjp_o_wbck_err = 1'b0;\n    assign bjp_o_cmt_mret = bjp_i_info[E203_DECINFO_BJP_MRET];\n    assign bjp_o_cmt_dret = bjp_i_info[E203_DECINFO_BJP_DRET];\n    assign bjp_o_cmt_fencei = bjp_i_info[E203_DECINFO_BJP_FENCEI];\n    assign bjp_o_cmt_bjp = bjp_i_info[E203_DECINFO_BJP_BXX] | bjp_i_info[E203_DECINFO_BJP_JUMP];\n\n    // Operand selection\n    assign bjp_req_alu_op1 = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? bjp_i_pc : bjp_i_rs1;\n    assign bjp_req_alu_op2 = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? bjp_i_imm : bjp_i_rs2;\n\n    // ALU operation requests\n    assign bjp_req_alu_cmp_eq = bjp_i_info[E203_DECINFO_BJP_BEQ];\n    assign bjp_req_alu_cmp_ne = bjp_i_info[E203_DECINFO_BJP_BNE];\n    assign bjp_req_alu_cmp_lt = bjp_i_info[E203_DECINFO_BJP_BLT];\n    assign bjp_req_alu_cmp_gt = bjp_i_info[E203_DECINFO_BJP_BGT];\n    assign bjp_req_alu_cmp_ltu = bjp_i_info[E203_DECINFO_BJP_BLTU];\n    assign bjp_req_alu_cmp_gtu = bjp_i_info[E203_DECINFO_BJP_BGTU];\n    assign bjp_req_alu_add = bjp_i_info[E203_DECINFO_BJP_JUMP];\n\n    // Result handling\n    assign bjp_o_wbck_wdat = bjp_req_alu_add_res;\n    assign bjp_o_cmt_prdt = bjp_i_info[E203_DECINFO_BJP_BPRDT];\n    assign bjp_o_cmt_rslv = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? 1'b1 : bjp_req_alu_cmp_res;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 9, "code": "module e203_dtcm_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n    output wire dtcm_active,\n\n    // LSU ICB Interface\n    input wire lsu2dtcm_icb_cmd_valid,\n    output wire lsu2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] lsu2dtcm_icb_cmd_addr,\n    input wire lsu2dtcm_icb_cmd_read,\n    input wire [31:0] lsu2dtcm_icb_cmd_wdata,\n    input wire [3:0] lsu2dtcm_icb_cmd_wmask,\n    output wire lsu2dtcm_icb_rsp_valid,\n    input wire lsu2dtcm_icb_rsp_ready,\n    output wire lsu2dtcm_icb_rsp_err,\n    output wire [31:0] lsu2dtcm_icb_rsp_rdata,\n\n    // External ICB Interface (Optional)\n    `ifdef E203_HAS_DTCM_EXTITF\n    input wire ext2dtcm_icb_cmd_valid,\n    output wire ext2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] ext2dtcm_icb_cmd_addr,\n    input wire ext2dtcm_icb_cmd_read,\n    input wire [31:0] ext2dtcm_icb_cmd_wdata,\n    input wire [3:0] ext2dtcm_icb_cmd_wmask,\n    output wire ext2dtcm_icb_rsp_valid,\n    input wire ext2dtcm_icb_rsp_ready,\n    output wire ext2dtcm_icb_rsp_err,\n    output wire [31:0] ext2dtcm_icb_rsp_rdata,\n    `endif\n\n    // DTCM RAM Interface\n    output wire dtcm_ram_cs,\n    output wire dtcm_ram_we,\n    output wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    output wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    output wire clk_dtcm_ram\n);\n\n    // Implementation of the DTCM controller logic\n    // Including arbitration, SRAM control, and response generation\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 3, "code": "module e203_irq_sync (\n    input wire clk,\n    input wire rst_n,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire dbg_irq_a,\n    output wire ext_irq_r,\n    output wire sft_irq_r,\n    output wire tmr_irq_r,\n    output wire dbg_irq_r\n);\n\n  // Synchronization instances for each interrupt type\n  sirv_gnrl_sync #(\n    .DP(2),\n    .DW(1)\n  ) u_ext_irq_sync (\n    .clk(clk),\n    .rst_n(rst_n),\n    .din_a(ext_irq_a),\n    .dout(ext_irq_r)\n  );\n\n  sirv_gnrl_sync #(\n    .DP(2),\n    .DW(1)\n  ) u_sft_irq_sync (\n    .clk(clk),\n    .rst_n(rst_n),\n    .din_a(sft_irq_a),\n    .dout(sft_irq_r)\n  );\n\n  sirv_gnrl_sync #(\n    .DP(2),\n    .DW(1)\n  ) u_tmr_irq_sync (\n    .clk(clk),\n    .rst_n(rst_n),\n    .din_a(tmr_irq_a),\n    .dout(tmr_irq_r)\n  );\n\n  sirv_gnrl_sync #(\n    .DP(2),\n    .DW(1)\n  ) u_dbg_irq_sync (\n    .clk(clk),\n    .rst_n(rst_n),\n    .din_a(dbg_irq_a),\n    .dout(dbg_irq_r)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 20, "code": "// E203 Processor Configuration Document\n\n// 1. Introduction\n\n// This document describes the configuration system for the E203 processor. The E203 is a RISC-V architecture-based processor core that can be configured with various features and functional modules via macro definitions. This configuration file is licensed under the Apache 2.0 open-source license and is maintained by Nuclei System Technology.\n\n// 2. Basic Configuration Items\n\n// 2.1 Debug and Interrupt Configuration\n// **`E203_CFG_DEBUG_HAS_JTAG`**: Enables support for JTAG debug interface.\n// **`E203_CFG_IRQ_NEED_SYNC`**: Enables interrupt synchronization mechanism.\n\n// 2.2 Address Space Configuration\n// The system supports three address width configurations, and only one can be selected at a time:\n// **`E203_CFG_ADDR_SIZE_IS_16`**: 16-bit address space.\n// **`E203_CFG_ADDR_SIZE_IS_24`**: 24-bit address space.\n// **`E203_CFG_ADDR_SIZE_IS_32`**: 32-bit address space (currently selected configuration).\n\n// The address size is unified through the **`E203_CFG_ADDR_SIZE`** macro, which is automatically set based on the chosen configuration.\n\n// 2.3 CPU Function Configuration\n// **`E203_CFG_SUPPORT_MCYCLE_MINSTRET`**: Enables support for MCYCLE and MINSTRET counters.\n// **`E203_CFG_REGNUM_IS_32`**: Configures the number of registers to 32.\n// **`E203_CFG_HAS_ECC`**: Enables ECC (Error Correction Code) functionality.\n// **`E203_CFG_HAS_NICE`**: Enables the NICE instruction extension.\n// **`E203_CFG_SUPPORT_SHARE_MULDIV`**: Enables shared multiplication and division units.\n// **`E203_CFG_SUPPORT_AMO`**: Enables support for atomic memory operations (AMO).\n\n// 2.4 Memory System Configuration\n\n// Instruction TCM (ITCM)\n// **`E203_CFG_HAS_ITCM`**: Enables Instruction Tightly Coupled Memory (ITCM).\n// **`E203_CFG_ITCM_ADDR_WIDTH`**: Configures the ITCM address width. The current setting is 16 bits.\n//   - Supports a 64KB configuration (16-bit address width, 8192 depth).\n//   - Optional 1024KB configuration (20-bit address width).\n//   - Optional 2048KB configuration (21-bit address width).\n\n// Data TCM (DTCM)\n// **`E203_CFG_HAS_DTCM`**: Enables Data Tightly Coupled Memory (DTCM).\n// **`E203_CFG_DTCM_ADDR_WIDTH`**: Configures the DTCM address width. The current setting is 16 bits.\n//   - Supports a 16KB configuration (14-bit address width, 4096 depth).\n//   - Supports a 256KB configuration (18-bit address width, 65536 depth).\n//   - Optional 1MB configuration (20-bit address width, 262144 depth).\n\n// 2.5 Memory Mapping Configuration\n\n// The system defines the base addresses for the following memory regions:\n\n// 1. **ITCM Region**:\n//    - Base address: `0x8000_0000`\n//    - Defined through **`E203_CFG_ITCM_ADDR_BASE`**.\n// 2. **DTCM Region**:\n//    - Base address: `0x9000_0000`\n//    - Defined through **`E203_CFG_DTCM_ADDR_BASE`**.\n// 3. **Peripheral Interface Regions**:\n//    - **PPI Region**: `0x1000_0000 - 0x1FFF_FFFF`\n//    - Defined through **`E203_CFG_PPI_ADDR_BASE`** and **`E203_CFG_PPI_BASE_REGION`**.\n// 4. **System Controller Regions**:\n//    - **CLINT Region**: `0x0200_0000 - 0x0200_FFFF`\n//    - Base Address of CLINT is defined through **`E203_CFG_CLINT_ADDR_BASE`**.(`E203_CFG_ADDR_SIZE'h0200_0000`)\n//    -  **`E203_CFG_CLINT_BASE_REGION`** macro defines the high address range used to determine whether an address belongs to CLINT REGION (`E203_CFG_ADDR_SIZE-1:E203_CFG_ADDR_SIZE-16`)\n//    - **PLIC Region**: `0x0C00_0000 - 0x0CFF_FFFF`\n//    - Base Address of PLIC is defined through **`E203_CFG_PLIC_ADDR_BASE`**.(`E203_CFG_ADDR_SIZE'h0C00_0000`)\n//    -  **`E203_CFG_PLIC_BASE_REGION`** macro defines the high address range used to determine whether an address belongs to PLIC REGION (`E203_CFG_ADDR_SIZE-1:E203_CFG_ADDR_SIZE-8`)\n// 5. **Fast IO Region**:\n//    - Base address: `0xF000_0000`\n//    - Defined through **`E203_CFG_FIO_ADDR_BASE`** and **`E203_CFG_FIO_BASE_REGION`**.\n\n// 3. Notes\n\n// 1. Only one address width configuration should be enabled at a time.\n// 2. TCM configurations should be selected based on available hardware resources.\n// 3. Memory mapping configurations must avoid address overlap.\n// 4. It is recommended to carefully evaluate the system's resource requirements and performance demands when modifying configurations.", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 7, "code": "module e203_srams (\n  input wire itcm_ram_sd,\n  input wire itcm_ram_ds,\n  input wire itcm_ram_ls,\n  input wire itcm_ram_cs,\n  input wire itcm_ram_we,\n  input wire [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n  input wire [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n  input wire [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n  output wire [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n  input wire clk_itcm_ram,\n  input wire rst_itcm,\n\n  input wire dtcm_ram_sd,\n  input wire dtcm_ram_ds,\n  input wire dtcm_ram_ls,\n  input wire dtcm_ram_cs,\n  input wire dtcm_ram_we,\n  input wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n  input wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n  input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n  output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n  input wire clk_dtcm_ram,\n  input wire rst_dtcm\n);\n\n`ifdef E203_HAS_ITCM\n  e203_itcm_ram #(\n    .AW(E203_ITCM_RAM_AW),\n    .MW(E203_ITCM_RAM_MW),\n    .DW(E203_ITCM_RAM_DW)\n  ) u_itcm_ram (\n    .clk(clk_itcm_ram),\n    .rst_n(~rst_itcm),\n    .cs(itcm_ram_cs),\n    .we(itcm_ram_we),\n    .addr(itcm_ram_addr),\n    .wem(itcm_ram_wem),\n    .din(itcm_ram_din),\n    .dout(itcm_ram_dout),\n    .sd(itcm_ram_sd),\n    .ds(itcm_ram_ds),\n    .ls(itcm_ram_ls)\n  );\n`endif\n\n`ifdef E203_HAS_DTCM\n  e203_dtcm_ram #(\n    .AW(E203_DTCM_RAM_AW),\n    .MW(E203_DTCM_RAM_MW),\n    .DW(E203_DTCM_RAM_DW)\n  ) u_dtcm_ram (\n    .clk(clk_dtcm_ram),\n    .rst_n(~rst_dtcm),\n    .cs(dtcm_ram_cs),\n    .we(dtcm_ram_we),\n    .addr(dtcm_ram_addr),\n    .wem(dtcm_ram_wem),\n    .din(dtcm_ram_din),\n    .dout(dtcm_ram_dout),\n    .sd(dtcm_ram_sd),\n    .ds(dtcm_ram_ds),\n    .ls(dtcm_ram_ls)\n  );\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 8, "code": "module e203_reset_ctrl #(\n    parameter MASTER = 1,\n    parameter integer RST_SYNC_LEVEL = `E203_ASYNC_FF_LEVELS\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    output wire rst_core,\n    output wire rst_itcm,\n    output wire rst_dtcm,\n    output wire rst_aon\n);\n\n    // Synchronized reset signal\n    reg [RST_SYNC_LEVEL-1:0] rst_sync_reg = {RST_SYNC_LEVEL{1'b1}};\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            rst_sync_reg <= {RST_SYNC_LEVEL{1'b1}};\n        end else if (test_mode) begin\n            rst_sync_reg <= {RST_SYNC_LEVEL{rst_n}};\n        end else begin\n            rst_sync_reg <= {rst_sync_reg[RST_SYNC_LEVEL-2:0], 1'b0};\n        end\n    end\n\n    // Output reset signals\n    assign rst_core = (MASTER == 1) ? rst_sync_reg[RST_SYNC_LEVEL-1] : rst_n;\n    assign rst_itcm = (MASTER == 1) ? rst_sync_reg[RST_SYNC_LEVEL-1] : rst_n;\n    assign rst_dtcm = (MASTER == 1) ? rst_sync_reg[RST_SYNC_LEVEL-1] : rst_n;\n    assign rst_aon = (MASTER == 1) ? rst_sync_reg[RST_SYNC_LEVEL-1] : rst_n;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 4, "code": "module e203_itcm_ram #(\n  parameter FORCE_X2ZERO = 0,\n  parameter DP = `E203_ITCM_RAM_DP,\n  parameter DW = `E203_ITCM_RAM_DW,\n  parameter MW = `E203_ITCM_RAM_MW,\n  parameter AW = `E203_ITCM_RAM_AW\n)(\n  input wire sd,\n  input wire ds,\n  input wire ls,\n  input wire cs,\n  input wire we,\n  input wire [AW-1:0] addr,\n  input wire [MW-1:0] wem,\n  input wire [DW-1:0] din,\n  input wire rst_n,\n  input wire clk,\n  output wire [DW-1:0] dout\n);\n\n  sirv_gnrl_ram #(\n    .FORCE_X2ZERO(FORCE_X2ZERO),\n    .DP(DP),\n    .DW(DW),\n    .MW(MW),\n    .AW(AW)\n  ) u_sirv_gnrl_ram (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 10, "code": "module e203_dtcm_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n\n    // LSU ICB Interface\n    input wire lsu2dtcm_icb_cmd_valid,\n    output wire lsu2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] lsu2dtcm_icb_cmd_addr,\n    input wire lsu2dtcm_icb_cmd_read,\n    input wire [31:0] lsu2dtcm_icb_cmd_wdata,\n    input wire [3:0] lsu2dtcm_icb_cmd_wmask,\n    output wire lsu2dtcm_icb_rsp_valid,\n    input wire lsu2dtcm_icb_rsp_ready,\n    output wire lsu2dtcm_icb_rsp_err,\n    output wire [31:0] lsu2dtcm_icb_rsp_rdata,\n\n    // External ICB Interface (Optional)\n    `ifdef E203_HAS_DTCM_EXTITF\n    input wire ext2dtcm_icb_cmd_valid,\n    output wire ext2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] ext2dtcm_icb_cmd_addr,\n    input wire ext2dtcm_icb_cmd_read,\n    input wire [31:0] ext2dtcm_icb_cmd_wdata,\n    input wire [3:0] ext2dtcm_icb_cmd_wmask,\n    output wire ext2dtcm_icb_rsp_valid,\n    input wire ext2dtcm_icb_rsp_ready,\n    output wire ext2dtcm_icb_rsp_err,\n    output wire [31:0] ext2dtcm_icb_rsp_rdata,\n    `endif\n\n    // DTCM RAM Interface\n    output wire dtcm_ram_cs,\n    output wire dtcm_ram_we,\n    output wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    output wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    output wire clk_dtcm_ram,\n\n    output wire dtcm_active\n);\n\n    // Internal signals\n    wire icb_cmd_valid;\n    wire icb_cmd_ready;\n    wire [E203_DTCM_ADDR_WIDTH-1:0] icb_cmd_addr;\n    wire icb_cmd_read;\n    wire [31:0] icb_cmd_wdata;\n    wire [3:0] icb_cmd_wmask;\n    wire icb_rsp_valid;\n    wire icb_rsp_ready;\n    wire icb_rsp_err;\n    wire [31:0] icb_rsp_rdata;\n\n    // Arbitration logic (if external interface is enabled)\n    `ifdef E203_HAS_DTCM_EXTITF\n    // Instantiate the bus arbiter\n    sirv_gnrl_icb_arbt #(\n        .ARBT_SCHEME(0),\n        .ALLOW_0CYCL_RSP(0),\n        .FIFO_OUTS_NUM(E203_DTCM_OUTS_NUM),\n        .FIFO_CUT_READY(0),\n        .USR_W(1),\n        .ARBT_NUM(DTCM_ARBT_I_NUM),\n        .AW(E203_DTCM_ADDR_WIDTH),\n        .DW(32),\n        .ARBT_PTR_W(DTCM_ARBT_I_PTR_W)\n    ) u_dtcm_arbiter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .i_icb_cmd_valid({ext2dtcm_icb_cmd_valid, lsu2dtcm_icb_cmd_valid}),\n        .i_icb_cmd_ready({ext2dtcm_icb_cmd_ready, lsu2dtcm_icb_cmd_ready}),\n        .i_icb_cmd_addr({ext2dtcm_icb_cmd_addr, lsu2dtcm_icb_cmd_addr}),\n        .i_icb_cmd_read({ext2dtcm_icb_cmd_read, lsu2dtcm_icb_cmd_read}),\n        .i_icb_cmd_wdata({ext2dtcm_icb_cmd_wdata, lsu2dtcm_icb_cmd_wdata}),\n        .i_icb_cmd_wmask({ext2dtcm_icb_cmd_wmask, lsu2dtcm_icb_cmd_wmask}),\n        .i_icb_rsp_valid({ext2dtcm_icb_rsp_valid, lsu2dtcm_icb_rsp_valid}),\n        .i_icb_rsp_ready({ext2dtcm_icb_rsp_ready, lsu2dtcm_icb_rsp_ready}),\n        .i_icb_rsp_err({ext2dtcm_icb_rsp_err, lsu2dtcm_icb_rsp_err}),\n        .i_icb_rsp_rdata({ext2dtcm_icb_rsp_rdata, lsu2dtcm_icb_rsp_rdata}),\n        .o_icb_cmd_valid(icb_cmd_valid),\n        .o_icb_cmd_ready(icb_cmd_ready),\n        .o_icb_cmd_addr(icb_cmd_addr),\n        .o_icb_cmd_read(icb_cmd_read),\n        .o_icb_cmd_wdata(icb_cmd_wdata),\n        .o_icb_cmd_wmask(icb_cmd_wmask),\n        .o_icb_rsp_valid(icb_rsp_valid),\n        .o_icb_rsp_ready(icb_rsp_ready),\n        .o_icb_rsp_err(icb_rsp_err),\n        .o_icb_rsp_rdata(icb_rsp_rdata)\n    );\n    `else\n    // Connect LSU directly to internal signals if no external interface\n    assign icb_cmd_valid = lsu2dtcm_icb_cmd_valid;\n    assign icb_cmd_ready = lsu2dtcm_icb_cmd_ready;\n    assign icb_cmd_addr = lsu2dtcm_icb_cmd_addr;\n    assign icb_cmd_read = lsu2dtcm_icb_cmd_read;\n    assign icb_cmd_wdata = lsu2dtcm_icb_cmd_wdata;\n    assign icb_cmd_wmask = lsu2dtcm_icb_cmd_wmask;\n    assign icb_rsp_valid = lsu2dtcm_icb_rsp_valid;\n    assign icb_rsp_ready = lsu2dtcm_icb_rsp_ready;\n    assign icb_rsp_err = lsu2dtcm_icb_rsp_err;\n    assign icb_rsp_rdata = lsu2dtcm_icb_rsp_rdata;\n    `endif\n\n    // SRAM controller logic\n    sirv_sram_icb_ctrl #(\n        .DW(E203_DTCM_DATA_WIDTH),\n        .AW(E203_DTCM_ADDR_WIDTH),\n        .MW(E203_DTCM_WMSK_WIDTH),\n        .AW_LSB(2),\n        .USR_W(1)\n    ) u_dtcm_sram_ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .tcm_cgstop(tcm_cgstop),\n        .test_mode(test_mode),\n        .i_icb_cmd_valid(icb_cmd_valid),\n        .i_icb_cmd_ready(icb_cmd_ready),\n        .i_icb_cmd_read(icb_cmd_read),\n        .i_icb_cmd_addr(icb_cmd_addr),\n        .i_icb_cmd_wdata(icb_cmd_wdata),\n        .i_icb_cmd_wmask(icb_cmd_wmask),\n        .i_icb_rsp_valid(icb_rsp_valid),\n        .i_icb_rsp_ready(icb_rsp_ready),\n        .i_icb_rsp_err(icb_rsp_err),\n        .i_icb_rsp_rdata(icb_rsp_rdata),\n        .ram_cs(dtcm_ram_cs),\n        .ram_we(dtcm_ram_we),\n        .ram_addr(dtcm_ram_addr),\n        .ram_wem(dtcm_ram_wem),\n        .ram_din(dtcm_ram_din),\n        .ram_dout(dtcm_ram_dout),\n        .clk_ram(clk_dtcm_ram),\n        .sram_ctrl_active(dtcm_active)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 2, "code": "module e203_ifu_ifetch(\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_valid,\n    input wire ifu_req_ready,\n    output wire [E203_PC_SIZE-1:0] ifu_req_pc,\n    output wire ifu_req_seq,\n    output wire ifu_req_seq_rv32,\n    output wire [E203_PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_valid,\n    output wire ifu_rsp_ready,\n    input wire ifu_rsp_err,\n    input wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr,\n    input wire pipe_flush_req,\n    output wire pipe_flush_ack,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    `ifdef E203_TIMING_BOOST\n    input wire [E203_PC_SIZE-1:0] pipe_flush_pc,\n    `endif\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    input wire ifu_halt_req,\n    output wire ifu_halt_ack,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu\n);\n    // Internal signal declarations\n    reg [E203_PC_SIZE-1:0] pc_reg, pc_next;\n    reg [E203_INSTR_SIZE-1:0] ir_reg, ir_next;\n    reg valid_reg, valid_next;\n    reg [E203_RFIDX_WIDTH-1:0] rs1idx_reg, rs1idx_next;\n    reg [E203_RFIDX_WIDTH-1:0] rs2idx_reg, rs2idx_next;\n    reg prdt_taken_reg, prdt_taken_next;\n    reg misalgn_reg, misalgn_next;\n    reg buserr_reg, buserr_next;\n    reg muldiv_b2b_reg, muldiv_b2b_next;\n    reg halt_ack_reg, halt_ack_next;\n\n    // Fetch logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            pc_reg <= 0;\n            ir_reg <= 0;\n            valid_reg <= 0;\n            rs1idx_reg <= 0;\n            rs2idx_reg <= 0;\n            prdt_taken_reg <= 0;\n            misalgn_reg <= 0;\n            buserr_reg <= 0;\n            muldiv_b2b_reg <= 0;\n            halt_ack_reg <= 0;\n        end else begin\n            pc_reg <= pc_next;\n            ir_reg <= ir_next;\n            valid_reg <= valid_next;\n            rs1idx_reg <= rs1idx_next;\n            rs2idx_reg <= rs2idx_next;\n            prdt_taken_reg <= prdt_taken_next;\n            misalgn_reg <= misalgn_next;\n            buserr_reg <= buserr_next;\n            muldiv_b2b_reg <= muldiv_b2b_next;\n            halt_ack_reg <= halt_ack_next;\n        end\n    end\n\n    // Next state logic for fetch unit\n    always @* begin\n        pc_next = pc_reg;\n        ir_next = ir_reg;\n        valid_next = valid_reg;\n        rs1idx_next = rs1idx_reg;\n        rs2idx_next = rs2idx_reg;\n        prdt_taken_next = prdt_taken_reg;\n        misalgn_next = misalgn_reg;\n        buserr_next = buserr_reg;\n        muldiv_b2b_next = muldiv_b2b_reg;\n        halt_ack_next = halt_ack_reg;\n\n        if (ifu_req_ready && ifu_req_valid) begin\n            pc_next = ifu_req_pc; // Update PC on successful fetch request\n        end\n        if (ifu_rsp_valid && ifu_rsp_ready) begin\n            ir_next = ifu_rsp_instr; // Load new instruction\n            valid_next = 1'b1; // Set valid flag\n        end\n        if (pipe_flush_req) begin\n            valid_next = 1'b0; // Clear valid flag on flush\n        end\n        if (ifu_halt_req) begin\n            halt_ack_next = 1'b1; // Acknowledge halt request\n        end else begin\n            halt_ack_next = 1'b0; // Clear halt acknowledge\n        end\n    end\n\n    // Output assignments\n    assign ifu_o_ir = ir_reg;\n    assign ifu_o_pc = pc_reg;\n    assign ifu_o_pc_vld = valid_reg;\n    assign ifu_o_rs1idx = rs1idx_reg;\n    assign ifu_o_rs2idx = rs2idx_reg;\n    assign ifu_o_prdt_taken = prdt_taken_reg;\n    assign ifu_o_misalgn = misalgn_reg;\n    assign ifu_o_buserr = buserr_reg;\n    assign ifu_o_muldiv_b2b = muldiv_b2b_reg;\n    assign ifu_o_valid = valid_reg;\n    assign ifu_halt_ack = halt_ack_reg;\n    assign ifu_rsp_ready = !valid_reg; // Ready to accept response if not valid\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 2, "code": "module e203_exu_alu(\n    input         clk,\n    input         rst_n,\n    input         i_valid,\n    output        i_ready,\n    input  [31:0] i_rs1,\n    input  [31:0] i_rs2,\n    input  [31:0] i_imm,\n    input  [31:0] i_info,\n    input  [31:0] i_pc,\n    input  [31:0] i_instr,\n    output        o_valid,\n    input         o_ready,\n    output [31:0] o_result\n);\n\n    // Internal signals for ALU operations\n    reg [31:0] result;\n    wire [3:0] alu_op;\n    wire [31:0] op_a, op_b;\n\n    // Decode ALU operation from instruction info\n    assign alu_op = i_info[3:0]; // Simplified decoding\n\n    // Select operands\n    assign op_a = i_rs1;\n    assign op_b = (i_info[4]) ? i_imm : i_rs2; // Immediate or register operand\n\n    // ALU Operations\n    always @(*) begin\n        case (alu_op)\n            4'b0000: result = op_a + op_b; // ADD\n            4'b0001: result = op_a - op_b; // SUB\n            4'b0010: result = op_a & op_b; // AND\n            4'b0011: result = op_a | op_b; // OR\n            4'b0100: result = op_a ^ op_b; // XOR\n            4'b0101: result = (op_a < op_b) ? 32'd1 : 32'd0; // SLT\n            4'b0110: result = ($unsigned(op_a) < $unsigned(op_b)) ? 32'd1 : 32'd0; // SLTU\n            4'b0111: result = op_a << op_b[4:0]; // SLL\n            4'b1000: result = op_a >> op_b[4:0]; // SRL\n            4'b1001: result = $signed(op_a) >>> op_b[4:0]; // SRA\n            default: result = 32'd0;\n        endcase\n    end\n\n    // Handshaking signals\n    assign i_ready = o_ready;\n    assign o_valid = i_valid;\n\n    // Output result\n    assign o_result = result;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 4, "code": "module e203_exu_regfile #(\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_XLEN = 32\n)(\n  input [E203_RFIDX_WIDTH-1:0] read_src1_idx,\n  input [E203_RFIDX_WIDTH-1:0] read_src2_idx,\n  output [E203_XLEN-1:0] read_src1_dat,\n  output [E203_XLEN-1:0] read_src2_dat,\n  input wbck_dest_wen,\n  input [E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n  input [E203_XLEN-1:0] wbck_dest_dat,\n  output [E203_XLEN-1:0] x1_r,\n  input test_mode,\n  input clk,\n  input rst_n\n);\n\n  // Register file storage\n  reg [E203_XLEN-1:0] regfile [0:(1<<E203_RFIDX_WIDTH)-1];\n\n  // Read logic\n  assign read_src1_dat = (read_src1_idx == 0) ? 0 : regfile[read_src1_idx];\n  assign read_src2_dat = (read_src2_idx == 0) ? 0 : regfile[read_src2_idx];\n\n  // Write logic\n  always @(posedge clk) begin\n    if (wbck_dest_wen && wbck_dest_idx != 0) begin\n      regfile[wbck_dest_idx] <= wbck_dest_dat;\n    end\n  end\n\n  // Special register x1 output\n  assign x1_r = regfile[1];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 3, "code": "module e203_exu_alu_rglr(\n    input wire alu_i_valid,\n    output wire alu_i_ready,\n    input wire [E203_XLEN-1:0] alu_i_rs1,\n    input wire [E203_XLEN-1:0] alu_i_rs2,\n    input wire [E203_XLEN-1:0] alu_i_imm,\n    input wire [E203_PC_SIZE-1:0] alu_i_pc,\n    input wire [E203_DECINFO_ALU_WIDTH-1:0] alu_i_info,\n    output wire alu_o_valid,\n    input wire alu_o_ready,\n    output wire [E203_XLEN-1:0] alu_o_wbck_wdat,\n    output wire alu_o_wbck_err,\n    output wire alu_o_cmt_ecall,\n    output wire alu_o_cmt_ebreak,\n    output wire alu_o_cmt_wfi,\n    output wire alu_req_alu_add,\n    output wire alu_req_alu_sub,\n    output wire alu_req_alu_xor,\n    output wire alu_req_alu_sll,\n    output wire alu_req_alu_srl,\n    output wire alu_req_alu_sra,\n    output wire alu_req_alu_or,\n    output wire alu_req_alu_and,\n    output wire alu_req_alu_slt,\n    output wire alu_req_alu_sltu,\n    output wire alu_req_alu_lui,\n    output wire [E203_XLEN-1:0] alu_req_alu_op1,\n    output wire [E203_XLEN-1:0] alu_req_alu_op2,\n    output wire [E203_XLEN-1:0] alu_req_alu_res,\n    input wire clk,\n    input wire rst_n\n);\n\n// Handshake signals\nassign alu_i_ready = alu_o_ready;\nassign alu_o_valid = alu_i_valid;\n\n// Operation type decoding\nassign alu_req_alu_add  = alu_i_info[E203_DECINFO_ALU_ADD] & ~alu_i_info[E203_DECINFO_ALU_NOP];\nassign alu_req_alu_sub  = alu_i_info[E203_DECINFO_ALU_SUB];\nassign alu_req_alu_xor  = alu_i_info[E203_DECINFO_ALU_XOR];\nassign alu_req_alu_sll  = alu_i_info[E203_DECINFO_ALU_SLL];\nassign alu_req_alu_srl  = alu_i_info[E203_DECINFO_ALU_SRL];\nassign alu_req_alu_sra  = alu_i_info[E203_DECINFO_ALU_SRA];\nassign alu_req_alu_or   = alu_i_info[E203_DECINFO_ALU_OR];\nassign alu_req_alu_and  = alu_i_info[E203_DECINFO_ALU_AND];\nassign alu_req_alu_slt  = alu_i_info[E203_DECINFO_ALU_SLT];\nassign alu_req_alu_sltu = alu_i_info[E203_DECINFO_ALU_SLTU];\nassign alu_req_alu_lui  = alu_i_info[E203_DECINFO_ALU_LUI];\n\n// Operand selection\nassign alu_req_alu_op1 = alu_i_info[E203_DECINFO_ALU_OP1PC] ? alu_i_pc : alu_i_rs1;\nassign alu_req_alu_op2 = alu_i_info[E203_DECINFO_ALU_OP2IMM] ? alu_i_imm : alu_i_rs2;\n\n// Special instructions\nassign alu_o_cmt_ecall  = alu_i_info[E203_DECINFO_ALU_ECAL];\nassign alu_o_cmt_ebreak = alu_i_info[E203_DECINFO_ALU_EBRK];\nassign alu_o_cmt_wfi    = alu_i_info[E203_DECINFO_ALU_WFI];\n\n// Error handling for special instructions\nassign alu_o_wbck_err = alu_o_cmt_ecall | alu_o_cmt_ebreak | alu_o_cmt_wfi;\n\n// Result handling\nassign alu_o_wbck_wdat = alu_req_alu_res;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 4, "code": "module e203_exu_oitf #(\n  parameter E203_ITAG_WIDTH = 4,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_PC_SIZE = 32,\n  parameter E203_OITF_DEPTH = 16\n)(\n  input clk,\n  input rst_n,\n\n  // Dispatch interface\n  input dis_ena,\n  output reg dis_ready,\n  input [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n  input disp_i_rdwen,\n  input disp_i_rdfpu,\n  input [E203_PC_SIZE-1:0] disp_i_pc,\n\n  // Retirement interface\n  input ret_ena,\n  output reg [E203_RFIDX_WIDTH-1:0] ret_rdidx,\n  output reg ret_rdwen,\n  output reg ret_rdfpu,\n  output reg [E203_PC_SIZE-1:0] ret_pc,\n\n  // Dependency checking outputs\n  output reg oitfrd_match_disprs1,\n  output reg oitfrd_match_disprs2,\n  output reg oitfrd_match_disprs3,\n  output reg oitfrd_match_disprd,\n  output reg oitf_empty\n);\n\n  // Internal registers for tracking outstanding instructions\n  reg [E203_RFIDX_WIDTH-1:0] rdidx [0:E203_OITF_DEPTH-1];\n  reg [E203_PC_SIZE-1:0] pc [0:E203_OITF_DEPTH-1];\n  reg rdwen [0:E203_OITF_DEPTH-1];\n  reg rdfpu [0:E203_OITF_DEPTH-1];\n  reg [E203_ITAG_WIDTH-1:0] dis_ptr, ret_ptr;\n  reg full, empty;\n\n  // Initialize pointers and status flags\n  initial begin\n    dis_ptr = 0;\n    ret_ptr = 0;\n    full = 0;\n    empty = 1;\n    dis_ready = 1;\n  end\n\n  // Dispatch logic\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      dis_ptr <= 0;\n      full <= 0;\n      empty <= 1;\n      dis_ready <= 1;\n    end else if (dis_ena && dis_ready) begin\n      rdidx[dis_ptr] <= disp_i_rdidx;\n      pc[dis_ptr] <= disp_i_pc;\n      rdwen[dis_ptr] <= disp_i_rdwen;\n      rdfpu[dis_ptr] <= disp_i_rdfpu;\n      dis_ptr <= (dis_ptr + 1) % E203_OITF_DEPTH;\n      full <= (dis_ptr + 1) % E203_OITF_DEPTH == ret_ptr;\n      empty <= 0;\n    end\n  end\n\n  // Retirement logic\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      ret_ptr <= 0;\n      empty <= 1;\n    end else if (ret_ena && !empty) begin\n      ret_rdidx <= rdidx[ret_ptr];\n      ret_rdwen <= rdwen[ret_ptr];\n      ret_rdfpu <= rdfpu[ret_ptr];\n      ret_pc <= pc[ret_ptr];\n      ret_ptr <= (ret_ptr + 1) % E203_OITF_DEPTH;\n      empty <= ret_ptr + 1 == dis_ptr;\n      full <= 0;\n    end\n  end\n\n  // Dependency checking logic\n  integer i;\n  always @(*) begin\n    oitfrd_match_disprs1 = 0;\n    oitfrd_match_disprs2 = 0;\n    oitfrd_match_disprs3 = 0;\n    oitfrd_match_disprd = 0;\n    for (i = 0; i < E203_OITF_DEPTH; i = i + 1) begin\n      if (rdwen[i]) begin\n        if (rdidx[i] == disp_i_rdidx) oitfrd_match_disprd = 1;\n      end\n    end\n  end\n\n  // Update dis_ready based on full status\n  always @(*) begin\n    dis_ready = !full;\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 5, "code": "module e203_exu_oitf #(\n  parameter E203_ITAG_WIDTH = 4,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_PC_SIZE = 32,\n  parameter E203_OITF_DEPTH = 16\n)(\n  input clk,\n  input rst_n,\n\n  // Dispatch interface\n  input dis_ena,\n  output reg dis_ready,\n  output [E203_ITAG_WIDTH-1:0] dis_ptr,\n\n  // Retirement interface\n  input ret_ena,\n  output reg [E203_ITAG_WIDTH-1:0] ret_ptr,\n  output [E203_RFIDX_WIDTH-1:0] ret_rdidx,\n  output ret_rdwen,\n  output ret_rdfpu,\n  output [E203_PC_SIZE-1:0] ret_pc,\n\n  // Dispatch instruction details\n  input [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n  input disp_i_rdwen,\n  input disp_i_rdfpu,\n  input [E203_PC_SIZE-1:0] disp_i_pc,\n\n  // Dependency checking outputs\n  output oitfrd_match_disprs1,\n  output oitfrd_match_disprs2,\n  output oitfrd_match_disprs3,\n  output oitfrd_match_disprd,\n  output oitf_empty\n);\n\n  reg [E203_RFIDX_WIDTH-1:0] rdidx [0:E203_OITF_DEPTH-1];\n  reg [E203_PC_SIZE-1:0] pc [0:E203_OITF_DEPTH-1];\n  reg rdwen [0:E203_OITF_DEPTH-1];\n  reg rdfpu [0:E203_OITF_DEPTH-1];\n  reg [E203_ITAG_WIDTH-1:0] head, tail;\n  reg full, empty;\n\n  wire wrap = (head == tail) && (full || empty);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      head <= 0;\n      tail <= 0;\n      full <= 0;\n      empty <= 1;\n    end else begin\n      if (dis_ena && dis_ready) begin\n        rdidx[tail] <= disp_i_rdidx;\n        pc[tail] <= disp_i_pc;\n        rdwen[tail] <= disp_i_rdwen;\n        rdfpu[tail] <= disp_i_rdfpu;\n        tail <= tail + 1;\n        empty <= 0;\n        if (wrap) full <= 1;\n      end\n      if (ret_ena && !empty) begin\n        head <= head + 1;\n        full <= 0;\n        if (wrap) empty <= 1;\n      end\n    end\n  end\n\n  assign dis_ready = !full;\n  assign dis_ptr = tail;\n  assign ret_ptr = head;\n  assign ret_rdidx = rdidx[head];\n  assign ret_rdwen = rdwen[head];\n  assign ret_rdfpu = rdfpu[head];\n  assign ret_pc = pc[head];\n\n  assign oitf_empty = empty;\n\n  // Dependency checking logic\n  integer i;\n  reg match_rs1, match_rs2, match_rs3, match_rd;\n  always @(*) begin\n    match_rs1 = 0;\n    match_rs2 = 0;\n    match_rs3 = 0;\n    match_rd = 0;\n    for (i = 0; i < E203_OITF_DEPTH; i++) begin\n      if (rdwen[i]) begin\n        if (rdidx[i] == disp_i_rdidx) match_rd = 1;\n      end\n    end\n  end\n\n  assign oitfrd_match_disprs1 = match_rs1;\n  assign oitfrd_match_disprs2 = match_rs2;\n  assign oitfrd_match_disprs3 = match_rs3;\n  assign oitfrd_match_disprd = match_rd;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 10, "code": "module e203_biu(\n    input wire clk,\n    input wire rst_n,\n    output wire biu_active,\n\n    // LSU Interface\n    input wire lsu_icb_cmd_valid,\n    output wire lsu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] lsu_icb_cmd_addr,\n    input wire lsu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] lsu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] lsu_icb_cmd_wmask,\n    input wire [1:0] lsu_icb_cmd_burst,\n    input wire [1:0] lsu_icb_cmd_beat,\n    input wire lsu_icb_cmd_lock,\n    input wire lsu_icb_cmd_excl,\n    input wire [1:0] lsu_icb_cmd_size,\n    output wire lsu_icb_rsp_valid,\n    input wire lsu_icb_rsp_ready,\n    output wire lsu_icb_rsp_err,\n    output wire lsu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] lsu_icb_rsp_rdata,\n\n    // IFU Interface\n    input wire ifu_icb_cmd_valid,\n    output wire ifu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] ifu_icb_cmd_addr,\n    input wire ifu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ifu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] ifu_icb_cmd_wmask,\n    input wire [1:0] ifu_icb_cmd_burst,\n    input wire [1:0] ifu_icb_cmd_beat,\n    input wire ifu_icb_cmd_lock,\n    input wire ifu_icb_cmd_excl,\n    input wire [1:0] ifu_icb_cmd_size,\n    output wire ifu_icb_rsp_valid,\n    input wire ifu_icb_rsp_ready,\n    output wire ifu_icb_rsp_err,\n    output wire ifu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] ifu_icb_rsp_rdata,\n\n    // PPI Interface\n    input wire ppi_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] ppi_region_indic,\n\n    // CLINT Interface\n    input wire clint_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] clint_region_indic,\n\n    // PLIC Interface\n    input wire plic_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] plic_region_indic,\n\n    // FIO Interface\n    input wire fio_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] fio_region_indic,\n\n    // MEM Interface\n    input wire mem_icb_enable\n);\n\n    // Internal signals for arbitration and buffering\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_valid;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_ready;\n    wire [E203_ADDR_SIZE*BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_addr;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_read;\n    wire [E203_XLEN*BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_wdata;\n    wire [(E203_XLEN/8)*BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_wmask;\n    wire [2*BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_burst;\n    wire [2*BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_beat;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_lock;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_excl;\n    wire [2*BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_size;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_valid;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_ready;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_err;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_excl_ok;\n    wire [E203_XLEN*BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_rdata;\n\n    // Instantiate the ICB Arbiter\n    sirv_gnrl_icb_arbt #(\n        .AW(E203_ADDR_SIZE),\n        .DW(E203_XLEN),\n        .ARBT_NUM(BIU_ARBT_I_NUM),\n        .ARBT_PTR_W(BIU_ARBT_I_PTR_W),\n        .USR_W(1),\n        .ARBT_SCHEME(0),\n        .ALLOW_0CYCL_RSP(0),\n        .FIFO_OUTS_NUM(E203_BIU_OUTS_NUM),\n        .FIFO_CUT_READY(E203_BIU_CMD_CUT_READY)\n    ) u_icb_arbt (\n        .clk(clk),\n        .rst_n(rst_n),\n        .i_icb_cmd_valid(arbt_icb_cmd_valid),\n        .i_icb_cmd_ready(arbt_icb_cmd_ready),\n        .i_icb_cmd_addr(arbt_icb_cmd_addr),\n        .i_icb_cmd_read(arbt_icb_cmd_read),\n        .i_icb_cmd_wdata(arbt_icb_cmd_wdata),\n        .i_icb_cmd_wmask(arbt_icb_cmd_wmask),\n        .i_icb_cmd_burst(arbt_icb_cmd_burst),\n        .i_icb_cmd_beat(arbt_icb_cmd_beat),\n        .i_icb_cmd_lock(arbt_icb_cmd_lock),\n        .i_icb_cmd_excl(arbt_icb_cmd_excl),\n        .i_icb_cmd_size(arbt_icb_cmd_size),\n        .i_icb_rsp_valid(arbt_icb_rsp_valid),\n        .i_icb_rsp_ready(arbt_icb_rsp_ready),\n        .i_icb_rsp_err(arbt_icb_rsp_err),\n        .i_icb_rsp_excl_ok(arbt_icb_rsp_excl_ok),\n        .i_icb_rsp_rdata(arbt_icb_rsp_rdata),\n        .o_icb_cmd_valid(lsu_icb_cmd_valid),\n        .o_icb_cmd_ready(lsu_icb_cmd_ready),\n        .o_icb_cmd_addr(lsu_icb_cmd_addr),\n        .o_icb_cmd_read(lsu_icb_cmd_read),\n        .o_icb_cmd_wdata(lsu_icb_cmd_wdata),\n        .o_icb_cmd_wmask(lsu_icb_cmd_wmask),\n        .o_icb_rsp_valid(lsu_icb_rsp_valid),\n        .o_icb_rsp_ready(lsu_icb_rsp_ready),\n        .o_icb_rsp_err(lsu_icb_rsp_err),\n        .o_icb_rsp_excl_ok(lsu_icb_rsp_excl_ok),\n        .o_icb_rsp_rdata(lsu_icb_rsp_rdata)\n    );\n\n    // Additional logic for IFU, PPI, CLINT, PLIC, FIO, and MEM interfaces can be added here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 2, "code": "module e203_exu_longpwbck (\n    input wire lsu_wbck_i_valid,\n    output wire lsu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] lsu_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] lsu_wbck_i_itag,\n    input wire lsu_wbck_i_err,\n    input wire lsu_cmt_i_buserr,\n    input wire [E203_ADDR_SIZE-1:0] lsu_cmt_i_badaddr,\n    input wire lsu_cmt_i_ld,\n    input wire lsu_cmt_i_st,\n    output wire longp_wbck_o_valid,\n    input wire longp_wbck_o_ready,\n    output wire [E203_FLEN-1:0] longp_wbck_o_wdat,\n    output wire [4:0] longp_wbck_o_flags,\n    output wire [E203_RFIDX_WIDTH-1:0] longp_wbck_o_rdidx,\n    output wire longp_wbck_o_rdfpu,\n    output wire longp_excp_o_valid,\n    input wire longp_excp_o_ready,\n    output wire longp_excp_o_insterr,\n    output wire longp_excp_o_ld,\n    output wire longp_excp_o_st,\n    output wire longp_excp_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] longp_excp_o_badaddr,\n    output wire [E203_PC_SIZE-1:0] longp_excp_o_pc,\n    input wire oitf_empty,\n    input wire [E203_ITAG_WIDTH-1:0] oitf_ret_ptr,\n    input wire [E203_RFIDX_WIDTH-1:0] oitf_ret_rdidx,\n    input wire [E203_PC_SIZE-1:0] oitf_ret_pc,\n    input wire oitf_ret_rdwen,\n    input wire oitf_ret_rdfpu,\n    output wire oitf_ret_ena,\n    input wire clk,\n    input wire rst_n\n    `ifdef E203_HAS_NICE\n    , input wire nice_longp_wbck_i_valid,\n    output wire nice_longp_wbck_i_ready,\n    input wire [E203_XLEN-1:0] nice_longp_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] nice_longp_wbck_i_itag,\n    input wire nice_longp_wbck_i_err\n    `endif\n);\n\n    // Internal signals for arbitration and control logic\n    wire wbck_need, excp_need;\n    wire lsu_match, nice_match;\n    wire lsu_wbck_ready, nice_wbck_ready;\n    wire lsu_excp_ready, nice_excp_ready;\n\n    // Determine if write-back is needed\n    assign wbck_need = (oitf_ret_rdwen && !lsu_wbck_i_err);\n    assign excp_need = (lsu_wbck_i_err);\n\n    // Check if the instruction tags match\n    assign lsu_match = (lsu_wbck_i_valid && (lsu_wbck_i_itag == oitf_ret_ptr));\n    `ifdef E203_HAS_NICE\n    assign nice_match = (nice_longp_wbck_i_valid && (nice_longp_wbck_i_itag == oitf_ret_ptr));\n    `else\n    assign nice_match = 1'b0;\n    `endif\n\n    // Ready signals for LSU and NICE\n    assign lsu_wbck_ready = lsu_match && longp_wbck_o_ready;\n    assign lsu_excp_ready = lsu_match && longp_excp_o_ready;\n    `ifdef E203_HAS_NICE\n    assign nice_wbck_ready = nice_match && longp_wbck_o_ready;\n    assign nice_excp_ready = nice_match && longp_excp_o_ready;\n    `endif\n\n    // Output valid signals\n    assign longp_wbck_o_valid = (lsu_match || nice_match) && wbck_need && longp_wbck_o_ready;\n    assign longp_excp_o_valid = (lsu_match || nice_match) && excp_need && longp_excp_o_ready;\n\n    // Data and flags for write-back\n    assign longp_wbck_o_wdat = lsu_match ? lsu_wbck_i_wdat : nice_longp_wbck_i_wdat;\n    assign longp_wbck_o_flags = {5{lsu_match || nice_match}};\n\n    // Exception outputs\n    assign longp_excp_o_insterr = lsu_wbck_i_err;\n    assign longp_excp_o_ld = lsu_cmt_i_ld;\n    assign longp_excp_o_st = lsu_cmt_i_st;\n    assign longp_excp_o_buserr = lsu_cmt_i_buserr;\n    assign longp_excp_o_badaddr = lsu_cmt_i_badaddr;\n    assign longp_excp_o_pc = oitf_ret_pc;\n\n    // Ready outputs\n    assign lsu_wbck_i_ready = lsu_wbck_ready || lsu_excp_ready;\n    `ifdef E203_HAS_NICE\n    assign nice_longp_wbck_i_ready = nice_wbck_ready || nice_excp_ready;\n    `endif\n\n    // OITF control\n    assign oitf_ret_ena = (lsu_match || nice_match) && (wbck_need || excp_need);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 9, "code": "module e203_reset_ctrl #(\n    parameter MASTER = 1,\n    parameter RST_SYNC_LEVEL = `E203_ASYNC_FF_LEVELS\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    output reg rst_core,\n    output reg rst_itcm,\n    output reg rst_dtcm,\n    output reg rst_aon\n);\n\nreg [RST_SYNC_LEVEL-1:0] rst_sync;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        rst_sync <= {RST_SYNC_LEVEL{1'b1}};\n    end else if (test_mode) begin\n        rst_sync <= {RST_SYNC_LEVEL{rst_n}};\n    end else begin\n        rst_sync <= {rst_sync[RST_SYNC_LEVEL-2:0], 1'b1};\n    end\nend\n\nalways @(*) begin\n    if (test_mode) begin\n        rst_core = rst_n;\n        rst_itcm = rst_n;\n        rst_dtcm = rst_n;\n        rst_aon = rst_n;\n    end else if (MASTER == 1) begin\n        rst_core = rst_sync[RST_SYNC_LEVEL-1];\n        rst_itcm = rst_sync[RST_SYNC_LEVEL-1];\n        rst_dtcm = rst_sync[RST_SYNC_LEVEL-1];\n        rst_aon = rst_sync[RST_SYNC_LEVEL-1];\n    end else begin\n        rst_core = rst_n;\n        rst_itcm = rst_n;\n        rst_dtcm = rst_n;\n        rst_aon = rst_n;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 6, "code": "module e203_exu_csr (\n    input wire nonflush_cmt_ena,\n    input wire csr_ena,\n    input wire csr_wr_en,\n    input wire csr_rd_en,\n    input wire [11:0] csr_idx,\n    output wire csr_access_ilgl,\n    output wire tm_stop,\n    output wire core_cgstop,\n    output wire tcm_cgstop,\n    output wire itcm_nohold,\n    output wire mdv_nob2b,\n    output wire [E203_XLEN-1:0] read_csr_dat,\n    input wire [E203_XLEN-1:0] wbck_csr_dat,\n    input wire [E203_HART_ID_W-1:0] core_mhartid,\n    input wire ext_irq_r,\n    input wire sft_irq_r,\n    input wire tmr_irq_r,\n    output wire status_mie_r,\n    output wire mtie_r,\n    output wire msie_r,\n    output wire meie_r,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    input wire [E203_XLEN-1:0] dcsr_r,\n    input wire [E203_PC_SIZE-1:0] dpc_r,\n    input wire [E203_XLEN-1:0] dscratch_r,\n    output wire u_mode,\n    output wire s_mode,\n    output wire h_mode,\n    output wire m_mode,\n    input wire [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    input wire cmt_badaddr_ena,\n    input wire [E203_PC_SIZE-1:0] cmt_epc,\n    input wire cmt_epc_ena,\n    input wire [E203_XLEN-1:0] cmt_cause,\n    input wire cmt_cause_ena,\n    input wire cmt_status_ena,\n    input wire cmt_instret_ena,\n    input wire cmt_mret_ena,\n    output wire [E203_PC_SIZE-1:0] csr_epc_r,\n    output wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    output wire [E203_XLEN-1:0] csr_mtvec_r,\n    input wire clk_aon,\n    input wire clk,\n    input wire rst_n\n);\n\n// Optional Interface\n`ifdef E203_HAS_NICE\n    output wire nice_xs_off;\n`endif\n\n// Internal signal declarations\nreg [E203_XLEN-1:0] mstatus;\nreg [E203_XLEN-1:0] mie;\nreg [E203_XLEN-1:0] mip;\nreg [E203_XLEN-1:0] mtvec;\nreg [E203_XLEN-1:0] mscratch;\nreg [E203_XLEN-1:0] mepc;\nreg [E203_XLEN-1:0] mcause;\nreg [E203_XLEN-1:0] mtval;\nreg [E203_XLEN-1:0] mcycle;\nreg [E203_XLEN-1:0] minstret;\nreg [E203_XLEN-1:0] mvendorid = 32'h536;\nreg [E203_XLEN-1:0] marchid = 32'hE203;\nreg [E203_XLEN-1:0] mimpid = 32'h1;\nreg [E203_XLEN-1:0] mhartid = core_mhartid;\n\n// CSR access logic\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        // Reset logic\n        mstatus <= 0;\n        mie <= 0;\n        mip <= 0;\n        mtvec <= 0;\n        mscratch <= 0;\n        mepc <= 0;\n        mcause <= 0;\n        mtval <= 0;\n        mcycle <= 0;\n        minstret <= 0;\n    end else if (csr_ena) begin\n        if (csr_wr_en) begin\n            case (csr_idx)\n                12'h300: mstatus <= wbck_csr_dat;\n                12'h304: mie <= wbck_csr_dat;\n                12'h305: mtvec <= wbck_csr_dat;\n                12'h340: mscratch <= wbck_csr_dat;\n                12'h341: mepc <= wbck_csr_dat;\n                12'h342: mcause <= wbck_csr_dat;\n                12'h343: mtval <= wbck_csr_dat;\n                12'hB00: mcycle <= wbck_csr_dat;\n                12'hB02: minstret <= wbck_csr_dat;\n                // Additional CSR registers\n                default: ;\n            endcase\n        end\n        if (csr_rd_en) begin\n            case (csr_idx)\n                12'h300: read_csr_dat <= mstatus;\n                12'h304: read_csr_dat <= mie;\n                12'h305: read_csr_dat <= mtvec;\n                12'h340: read_csr_dat <= mscratch;\n                12'h341: read_csr_dat <= mepc;\n                12'h342: read_csr_dat <= mcause;\n                12'h343: read_csr_dat <= mtval;\n                12'hB00: read_csr_dat <= mcycle;\n                12'hB02: read_csr_dat <= minstret;\n                // Additional CSR registers\n                default: read_csr_dat <= 32'h0;\n            endcase\n        end\n    end\nend\n\n// Output assignments\nassign csr_access_ilgl = 0; // No illegal access in this implementation\nassign tm_stop = 0;\nassign core_cgstop = 0;\nassign tcm_cgstop = 0;\nassign itcm_nohold = 0;\nassign mdv_nob2b = 0;\nassign u_mode = 0;\nassign s_mode = 0;\nassign h_mode = 0;\nassign m_mode = 1; // Only machine mode supported\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 11, "code": "module e203_dtcm_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n    output wire dtcm_active,\n\n    // LSU ICB Interface\n    input wire lsu2dtcm_icb_cmd_valid,\n    output wire lsu2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] lsu2dtcm_icb_cmd_addr,\n    input wire lsu2dtcm_icb_cmd_read,\n    input wire [31:0] lsu2dtcm_icb_cmd_wdata,\n    input wire [3:0] lsu2dtcm_icb_cmd_wmask,\n    output wire lsu2dtcm_icb_rsp_valid,\n    input wire lsu2dtcm_icb_rsp_ready,\n    output wire lsu2dtcm_icb_rsp_err,\n    output wire [31:0] lsu2dtcm_icb_rsp_rdata,\n\n    // External ICB Interface (Optional)\n    `ifdef E203_HAS_DTCM_EXTITF\n    input wire ext2dtcm_icb_cmd_valid,\n    output wire ext2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] ext2dtcm_icb_cmd_addr,\n    input wire ext2dtcm_icb_cmd_read,\n    input wire [31:0] ext2dtcm_icb_cmd_wdata,\n    input wire [3:0] ext2dtcm_icb_cmd_wmask,\n    output wire ext2dtcm_icb_rsp_valid,\n    input wire ext2dtcm_icb_rsp_ready,\n    output wire ext2dtcm_icb_rsp_err,\n    output wire [31:0] ext2dtcm_icb_rsp_rdata,\n    `endif\n\n    // DTCM RAM Interface\n    output wire dtcm_ram_cs,\n    output wire dtcm_ram_we,\n    output wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    output wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    output wire clk_dtcm_ram\n);\n\n    // Internal signals\n    wire arb_cmd_valid;\n    wire arb_cmd_ready;\n    wire [E203_DTCM_ADDR_WIDTH-1:0] arb_cmd_addr;\n    wire arb_cmd_read;\n    wire [31:0] arb_cmd_wdata;\n    wire [3:0] arb_cmd_wmask;\n    wire arb_rsp_valid;\n    wire arb_rsp_ready;\n    wire arb_rsp_err;\n    wire [31:0] arb_rsp_rdata;\n\n    // Instantiate the bus arbiter\n    sirv_gnrl_icb_arbt #(\n        .ARBT_SCHEME(0),\n        .ALLOW_0CYCL_RSP(0),\n        .FIFO_OUTS_NUM(E203_DTCM_OUTS_NUM),\n        .FIFO_CUT_READY(0),\n        .USR_W(1),\n        .ARBT_NUM(DTCM_ARBT_I_NUM),\n        .AW(E203_DTCM_ADDR_WIDTH),\n        .DW(32),\n        .ARBT_PTR_W(DTCM_ARBT_I_PTR_W)\n    ) u_dtcm_arbiter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .i_icb_cmd_valid(arb_cmd_valid),\n        .i_icb_cmd_ready(arb_cmd_ready),\n        .i_icb_cmd_addr(arb_cmd_addr),\n        .i_icb_cmd_read(arb_cmd_read),\n        .i_icb_cmd_wdata(arb_cmd_wdata),\n        .i_icb_cmd_wmask(arb_cmd_wmask),\n        .i_icb_rsp_valid(arb_rsp_valid),\n        .i_icb_rsp_ready(arb_rsp_ready),\n        .i_icb_rsp_err(arb_rsp_err),\n        .i_icb_rsp_rdata(arb_rsp_rdata)\n    );\n\n    // Instantiate the SRAM controller\n    sirv_sram_icb_ctrl #(\n        .DW(E203_DTCM_DATA_WIDTH),\n        .AW(E203_DTCM_ADDR_WIDTH),\n        .MW(E203_DTCM_WMSK_WIDTH),\n        .AW_LSB(2),\n        .USR_W(1)\n    ) u_dtcm_sram_ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .tcm_cgstop(tcm_cgstop),\n        .i_icb_cmd_valid(arb_cmd_valid),\n        .i_icb_cmd_ready(arb_cmd_ready),\n        .i_icb_cmd_read(arb_cmd_read),\n        .i_icb_cmd_addr(arb_cmd_addr),\n        .i_icb_cmd_wdata(arb_cmd_wdata),\n        .i_icb_cmd_wmask(arb_cmd_wmask),\n        .i_icb_rsp_valid(arb_rsp_valid),\n        .i_icb_rsp_ready(arb_rsp_ready),\n        .i_icb_rsp_err(arb_rsp_err),\n        .i_icb_rsp_rdata(arb_rsp_rdata),\n        .ram_cs(dtcm_ram_cs),\n        .ram_we(dtcm_ram_we),\n        .ram_addr(dtcm_ram_addr),\n        .ram_wem(dtcm_ram_wem),\n        .ram_din(dtcm_ram_din),\n        .ram_dout(dtcm_ram_dout),\n        .clk_ram(clk_dtcm_ram),\n        .sram_ctrl_active(dtcm_active),\n        .test_mode(test_mode)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 6, "code": "module e203_exu_branchslv (\n    input wire cmt_i_valid,\n    output wire cmt_i_ready,\n    input wire cmt_i_rv32,\n    input wire cmt_i_dret,\n    input wire cmt_i_mret,\n    input wire cmt_i_fencei,\n    input wire cmt_i_bjp,\n    input wire cmt_i_bjp_prdt,\n    input wire cmt_i_bjp_rslv,\n    input wire [E203_PC_SIZE-1:0] cmt_i_pc,\n    input wire [E203_XLEN-1:0] cmt_i_imm,\n    input wire [E203_PC_SIZE-1:0] csr_epc_r,\n    input wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    input wire nonalu_excpirq_flush_req_raw,\n    input wire brchmis_flush_ack,\n    output wire brchmis_flush_req,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op1,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op2,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_pc,\n    output wire cmt_mret_ena,\n    output wire cmt_dret_ena,\n    output wire cmt_fencei_ena,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Flush request generation\n    wire flush_need_bjp = cmt_i_bjp & (cmt_i_bjp_prdt ^ cmt_i_bjp_rslv);\n    wire flush_need_fencei = cmt_i_fencei;\n    wire flush_need_mret_dret = cmt_i_mret | cmt_i_dret;\n    wire flush_need = (flush_need_bjp | flush_need_fencei | flush_need_mret_dret) & cmt_i_valid;\n\n    // Flush request output\n    assign brchmis_flush_req = flush_need & ~nonalu_excpirq_flush_req_raw;\n\n    // Flush address calculation\n    wire [E203_PC_SIZE-1:0] next_pc = cmt_i_rv32 ? (cmt_i_pc + 32'd4) : (cmt_i_pc + 32'd2);\n    wire [E203_PC_SIZE-1:0] branch_target = cmt_i_pc + cmt_i_imm[E203_PC_SIZE-1:0];\n\n    assign brchmis_flush_add_op1 = cmt_i_pc;\n    assign brchmis_flush_add_op2 = cmt_i_imm;\n\n    // Selecting flush target PC\n    always @(*) begin\n        if (cmt_i_fencei | (cmt_i_bjp & cmt_i_bjp_prdt & ~cmt_i_bjp_rslv)) begin\n            brchmis_flush_pc = next_pc;\n        end else if (cmt_i_bjp & ~cmt_i_bjp_prdt & cmt_i_bjp_rslv) begin\n            brchmis_flush_pc = branch_target;\n        end else if (cmt_i_dret) begin\n            brchmis_flush_pc = csr_dpc_r;\n        end else begin\n            brchmis_flush_pc = csr_epc_r;\n        end\n    end\n\n    // Commit signals for special instructions\n    assign cmt_mret_ena = cmt_i_mret & flush_need & brchmis_flush_ack;\n    assign cmt_dret_ena = cmt_i_dret & flush_need & brchmis_flush_ack;\n    assign cmt_fencei_ena = cmt_i_fencei & flush_need & brchmis_flush_ack;\n\n    // Ready signal logic\n    assign cmt_i_ready = ~flush_need & ~nonalu_excpirq_flush_req_raw & brchmis_flush_ack;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 11, "code": "module e203_biu(\n    input wire clk,\n    input wire rst_n,\n    output wire biu_active,\n\n    // ICB interface to LSU\n    input wire lsu_icb_cmd_valid,\n    output wire lsu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] lsu_icb_cmd_addr,\n    input wire lsu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] lsu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] lsu_icb_cmd_wmask,\n    input wire [1:0] lsu_icb_cmd_burst,\n    input wire [1:0] lsu_icb_cmd_beat,\n    input wire lsu_icb_cmd_lock,\n    input wire lsu_icb_cmd_excl,\n    input wire [1:0] lsu_icb_cmd_size,\n    output wire lsu_icb_rsp_valid,\n    input wire lsu_icb_rsp_ready,\n    output wire lsu_icb_rsp_err,\n    output wire lsu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] lsu_icb_rsp_rdata,\n\n    // ICB interface to IFU\n    `ifdef E203_HAS_MEM_ITF\n    input wire ifu_icb_cmd_valid,\n    output wire ifu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] ifu_icb_cmd_addr,\n    input wire ifu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ifu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] ifu_icb_cmd_wmask,\n    input wire [1:0] ifu_icb_cmd_burst,\n    input wire [1:0] ifu_icb_cmd_beat,\n    input wire ifu_icb_cmd_lock,\n    input wire ifu_icb_cmd_excl,\n    input wire [1:0] ifu_icb_cmd_size,\n    output wire ifu_icb_rsp_valid,\n    input wire ifu_icb_rsp_ready,\n    output wire ifu_icb_rsp_err,\n    output wire ifu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] ifu_icb_rsp_rdata,\n    `endif\n\n    // ICB interface to PPI\n    input wire ppi_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] ppi_region_indic,\n\n    // ICB interface to CLINT\n    input wire clint_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] clint_region_indic,\n\n    // ICB interface to PLIC\n    input wire plic_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] plic_region_indic,\n\n    // ICB interface to FIO\n    `ifdef E203_HAS_FIO\n    input wire fio_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] fio_region_indic,\n    `endif\n\n    // ICB interface to MEM\n    `ifdef E203_HAS_MEM_ITF\n    input wire mem_icb_enable\n    `endif\n);\n\n    // Internal signals for arbitration and splitting\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_valid;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_ready;\n    wire [E203_ADDR_SIZE*BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_addr;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_read;\n    wire [E203_XLEN*BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_wdata;\n    wire [(E203_XLEN/8)*BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_wmask;\n    wire [2*BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_burst;\n    wire [2*BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_beat;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_lock;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_excl;\n    wire [2*BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_size;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_valid;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_ready;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_err;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_excl_ok;\n    wire [E203_XLEN*BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_rdata;\n\n    // Instantiate the ICB Arbiter\n    sirv_gnrl_icb_arbt #(\n        .AW(E203_ADDR_SIZE),\n        .DW(E203_XLEN),\n        .ARBT_NUM(BIU_ARBT_I_NUM),\n        .ARBT_PTR_W(BIU_ARBT_I_PTR_W),\n        .USR_W(1),\n        .ARBT_SCHEME(0),\n        .ALLOW_0CYCL_RSP(0),\n        .FIFO_OUTS_NUM(E203_BIU_OUTS_NUM),\n        .FIFO_CUT_READY(E203_BIU_CMD_CUT_READY)\n    ) u_icb_arbt (\n        .clk(clk),\n        .rst_n(rst_n),\n        .i_bus_icb_cmd_valid(arbt_icb_cmd_valid),\n        .i_bus_icb_cmd_ready(arbt_icb_cmd_ready),\n        .i_bus_icb_cmd_addr(arbt_icb_cmd_addr),\n        .i_bus_icb_cmd_read(arbt_icb_cmd_read),\n        .i_bus_icb_cmd_wdata(arbt_icb_cmd_wdata),\n        .i_bus_icb_cmd_wmask(arbt_icb_cmd_wmask),\n        .i_bus_icb_cmd_burst(arbt_icb_cmd_burst),\n        .i_bus_icb_cmd_beat(arbt_icb_cmd_beat),\n        .i_bus_icb_cmd_lock(arbt_icb_cmd_lock),\n        .i_bus_icb_cmd_excl(arbt_icb_cmd_excl),\n        .i_bus_icb_cmd_size(arbt_icb_cmd_size),\n        .i_bus_icb_rsp_valid(arbt_icb_rsp_valid),\n        .i_bus_icb_rsp_ready(arbt_icb_rsp_ready),\n        .i_bus_icb_rsp_err(arbt_icb_rsp_err),\n        .i_bus_icb_rsp_excl_ok(arbt_icb_rsp_excl_ok),\n        .i_bus_icb_rsp_rdata(arbt_icb_rsp_rdata),\n        .o_icb_cmd_valid(),\n        .o_icb_cmd_ready(),\n        .o_icb_cmd_read(),\n        .o_icb_cmd_addr(),\n        .o_icb_cmd_wdata(),\n        .o_icb_cmd_wmask(),\n        .o_icb_rsp_valid(),\n        .o_icb_rsp_ready(),\n        .o_icb_rsp_err(),\n        .o_icb_rsp_excl_ok(),\n        .o_icb_rsp_rdata()\n    );\n\n    // Additional logic for handling ICB interfaces, splitting, buffering, etc.\n    // would be implemented here.\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 2, "code": "module e203_ifu_ift2icb (\n    input wire itcm_nohold,\n    input wire ifu_req_valid,\n    input wire [PC_SIZE-1:0] ifu_req_pc,\n    input wire ifu_req_seq,\n    input wire ifu_req_seq_rv32,\n    input wire [PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_ready,\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_ready,\n    output wire ifu_rsp_valid,\n    output wire ifu_rsp_err,\n    output wire [31:0] ifu_rsp_instr,\n    output wire ifu2itcm_icb_cmd_valid,\n    input wire ifu2itcm_icb_cmd_ready,\n    output wire [ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_rsp_valid,\n    output wire ifu2itcm_icb_rsp_ready,\n    input wire ifu2itcm_icb_rsp_err,\n    input wire [ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    output wire ifu2biu_icb_cmd_valid,\n    input wire ifu2biu_icb_cmd_ready,\n    output wire [ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input wire ifu2biu_icb_rsp_valid,\n    output wire ifu2biu_icb_rsp_ready,\n    input wire ifu2biu_icb_rsp_err,\n    input wire [SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata\n);\n\n    // State machine states\n    localparam ICB_STATE_IDLE = 2'b00;\n    localparam ICB_STATE_1ST = 2'b01;\n    localparam ICB_STATE_WAIT2ND = 2'b10;\n    localparam ICB_STATE_2ND = 2'b11;\n\n    reg [1:0] icb_state, icb_state_nxt;\n    wire icb_state_ena;\n    wire state_idle_exit_ena;\n\n    // Handshake signals\n    wire ifu_req_hsked = ifu_req_valid && ifu_req_ready;\n    wire ifu_icb_cmd_hsked = ifu2itcm_icb_cmd_valid && ifu2itcm_icb_cmd_ready;\n    wire ifu_icb_rsp_hsked = ifu2itcm_icb_rsp_valid && ifu2itcm_icb_rsp_ready;\n\n    // State transition logic\n    always @(*) begin\n        icb_state_nxt = icb_state;\n        case (icb_state)\n            ICB_STATE_IDLE: begin\n                if (state_idle_exit_ena)\n                    icb_state_nxt = ICB_STATE_1ST;\n            end\n            ICB_STATE_1ST: begin\n                if (ifu_icb_rsp_hsked)\n                    icb_state_nxt = ICB_STATE_IDLE;\n            end\n            ICB_STATE_WAIT2ND: begin\n                if (ifu_icb_cmd_ready)\n                    icb_state_nxt = ICB_STATE_2ND;\n            end\n            ICB_STATE_2ND: begin\n                if (ifu_icb_rsp_hsked)\n                    icb_state_nxt = ICB_STATE_IDLE;\n            end\n        endcase\n    end\n\n    // State update control\n    assign icb_state_ena = (icb_state != icb_state_nxt);\n    sirv_gnrl_dfflr #(2) icb_state_reg (\n        .lden(icb_state_ena),\n        .dnxt(icb_state_nxt),\n        .qout(icb_state),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\n    // Output logic\n    assign ifu_req_ready = (icb_state == ICB_STATE_IDLE);\n    assign ifu_rsp_valid = ifu_icb_rsp_hsked;\n    assign ifu_rsp_err = ifu2itcm_icb_rsp_err;\n    assign ifu_rsp_instr = ifu2itcm_icb_rsp_rdata[31:0];\n\n    // ICB command logic\n    assign ifu2itcm_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && ifu_req_valid;\n    assign ifu2itcm_icb_cmd_addr = ifu_req_pc[ITCM_ADDR_WIDTH-1:0];\n    assign ifu2itcm_icb_rsp_ready = (icb_state == ICB_STATE_1ST);\n\n    // System memory interface logic\n    assign ifu2biu_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && ifu_req_valid;\n    assign ifu2biu_icb_cmd_addr = ifu_req_pc[ADDR_SIZE-1:0];\n    assign ifu2biu_icb_rsp_ready = (icb_state == ICB_STATE_1ST);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 2, "code": "module e203_lsu(\n    input wire commit_mret,\n    input wire commit_trap,\n    input wire excp_active,\n    output wire lsu_active,\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n    output wire [ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_buserr,\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [XLEN/8-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [XLEN-1:0] agu_icb_rsp_rdata\n);\n\n    // LSU internal logic here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 4, "code": "module e203_irq_sync (\n    input wire clk,\n    input wire rst_n,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire dbg_irq_a,\n    output wire ext_irq_r,\n    output wire sft_irq_r,\n    output wire tmr_irq_r,\n    output wire dbg_irq_r\n);\n\n    // Synchronization using sirv_gnrl_sync module\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) u_ext_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(ext_irq_a),\n        .dout(ext_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) u_sft_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(sft_irq_a),\n        .dout(sft_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) u_tmr_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(tmr_irq_a),\n        .dout(tmr_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) u_dbg_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(dbg_irq_a),\n        .dout(dbg_irq_r)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 1, "code": "module e203_exu_disp(\n    input wire wfi_halt_exu_req,\n    output wire wfi_halt_exu_ack,\n    input wire oitf_empty,\n    input wire amo_wait,\n    input wire disp_i_valid,\n    output wire disp_i_ready,\n    input wire disp_i_rs1x0,\n    input wire disp_i_rs2x0,\n    input wire disp_i_rs1en,\n    input wire disp_i_rs2en,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input wire [E203_XLEN-1:0] disp_i_rs1,\n    input wire [E203_XLEN-1:0] disp_i_rs2,\n    input wire disp_i_rdwen,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input wire [E203_DECINFO_WIDTH-1:0] disp_i_info,\n    input wire [E203_XLEN-1:0] disp_i_imm,\n    input wire [E203_PC_SIZE-1:0] disp_i_pc,\n    input wire disp_i_misalgn,\n    input wire disp_i_buserr,\n    input wire disp_i_ilegl,\n    output wire disp_o_alu_valid,\n    input wire disp_o_alu_ready,\n    input wire disp_o_alu_longpipe,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs1,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs2,\n    output wire disp_o_alu_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_o_alu_rdidx,\n    output wire [E203_DECINFO_WIDTH-1:0] disp_o_alu_info,\n    output wire [E203_XLEN-1:0] disp_o_alu_imm,\n    output wire [E203_PC_SIZE-1:0] disp_o_alu_pc,\n    output wire [E203_ITAG_WIDTH-1:0] disp_o_alu_itag,\n    output wire disp_o_alu_misalgn,\n    output wire disp_o_alu_buserr,\n    output wire disp_o_alu_ilegl,\n    input wire oitfrd_match_disprs1,\n    input wire oitfrd_match_disprs2,\n    input wire oitfrd_match_disprs3,\n    input wire oitfrd_match_disprd,\n    input wire [E203_ITAG_WIDTH-1:0] disp_oitf_ptr,\n    output wire disp_oitf_ena,\n    input wire disp_oitf_ready,\n    output wire disp_oitf_rs1fpu,\n    output wire disp_oitf_rs2fpu,\n    output wire disp_oitf_rs3fpu,\n    output wire disp_oitf_rdfpu,\n    output wire disp_oitf_rs1en,\n    output wire disp_oitf_rs2en,\n    output wire disp_oitf_rs3en,\n    output wire disp_oitf_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs2idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs3idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rdidx,\n    output wire [E203_PC_SIZE-1:0] disp_oitf_pc,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Implementation of dispatch logic, dependency checks, and WFI handling\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 10, "code": "module e203_reset_ctrl #(\n    parameter MASTER = 1,\n    parameter RST_SYNC_LEVEL = `E203_ASYNC_FF_LEVELS\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    output wire rst_core,\n    output wire rst_itcm,\n    output wire rst_dtcm,\n    output wire rst_aon\n);\n\nreg [RST_SYNC_LEVEL-1:0] rst_sync_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        rst_sync_reg <= {RST_SYNC_LEVEL{1'b1}};\n    end else begin\n        rst_sync_reg <= {rst_sync_reg[RST_SYNC_LEVEL-2:0], 1'b0};\n    end\nend\n\nwire rst_sync = rst_sync_reg[RST_SYNC_LEVEL-1];\n\nassign rst_core = test_mode ? rst_n : (MASTER ? rst_sync : rst_n);\nassign rst_itcm = test_mode ? rst_n : (MASTER ? rst_sync : rst_n);\nassign rst_dtcm = test_mode ? rst_n : (MASTER ? rst_sync : rst_n);\nassign rst_aon = test_mode ? rst_n : (MASTER ? rst_sync : rst_n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 3, "code": "module e203_exu_longpwbck (\n    input wire lsu_wbck_i_valid,\n    output wire lsu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] lsu_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] lsu_wbck_i_itag,\n    input wire lsu_wbck_i_err,\n    input wire lsu_cmt_i_buserr,\n    input wire [E203_ADDR_SIZE-1:0] lsu_cmt_i_badaddr,\n    input wire lsu_cmt_i_ld,\n    input wire lsu_cmt_i_st,\n    output wire longp_wbck_o_valid,\n    input wire longp_wbck_o_ready,\n    output wire [E203_FLEN-1:0] longp_wbck_o_wdat,\n    output wire [4:0] longp_wbck_o_flags,\n    output wire [E203_RFIDX_WIDTH-1:0] longp_wbck_o_rdidx,\n    output wire longp_wbck_o_rdfpu,\n    output wire longp_excp_o_valid,\n    input wire longp_excp_o_ready,\n    output wire longp_excp_o_insterr,\n    output wire longp_excp_o_ld,\n    output wire longp_excp_o_st,\n    output wire longp_excp_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] longp_excp_o_badaddr,\n    output wire [E203_PC_SIZE-1:0] longp_excp_o_pc,\n    input wire oitf_empty,\n    input wire [E203_ITAG_WIDTH-1:0] oitf_ret_ptr,\n    input wire [E203_RFIDX_WIDTH-1:0] oitf_ret_rdidx,\n    input wire [E203_PC_SIZE-1:0] oitf_ret_pc,\n    input wire oitf_ret_rdwen,\n    input wire oitf_ret_rdfpu,\n    output wire oitf_ret_ena,\n    input wire clk,\n    input wire rst_n\n`ifdef E203_HAS_NICE\n    , input wire nice_longp_wbck_i_valid,\n    output wire nice_longp_wbck_i_ready,\n    input wire [E203_XLEN-1:0] nice_longp_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] nice_longp_wbck_i_itag,\n    input wire nice_longp_wbck_i_err\n`endif\n);\n\n    // Write-back and exception arbitration logic\n    wire wbck_need = oitf_ret_rdwen && !lsu_wbck_i_err;\n    wire excp_need = lsu_wbck_i_err || lsu_cmt_i_buserr;\n\n    assign lsu_wbck_i_ready = (wbck_need && longp_wbck_o_ready) && (excp_need && longp_excp_o_ready);\n    assign longp_wbck_o_valid = wbck_need && lsu_wbck_i_valid && !excp_need;\n    assign longp_excp_o_valid = excp_need && lsu_wbck_i_valid && !wbck_need;\n\n    assign longp_wbck_o_wdat = lsu_wbck_i_wdat;\n    assign longp_wbck_o_rdidx = oitf_ret_rdidx;\n    assign longp_wbck_o_rdfpu = oitf_ret_rdfpu;\n    assign longp_wbck_o_flags = {lsu_cmt_i_ld, lsu_cmt_i_st, lsu_wbck_i_err, lsu_cmt_i_buserr, 1'b0};\n\n    assign longp_excp_o_insterr = lsu_wbck_i_err;\n    assign longp_excp_o_ld = lsu_cmt_i_ld;\n    assign longp_excp_o_st = lsu_cmt_i_st;\n    assign longp_excp_o_buserr = lsu_cmt_i_buserr;\n    assign longp_excp_o_badaddr = lsu_cmt_i_badaddr;\n    assign longp_excp_o_pc = oitf_ret_pc;\n\n    assign oitf_ret_ena = lsu_wbck_i_ready && lsu_wbck_i_valid;\n\n`ifdef E203_HAS_NICE\n    // NICE module write-back handling\n    assign nice_longp_wbck_i_ready = (wbck_need && longp_wbck_o_ready) && (excp_need && longp_excp_o_ready);\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 1, "code": "module e203_ifu(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire itcm_nohold,\n    input wire pipe_flush_req,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input wire ifu_halt_req,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rden,\n    input wire dec2ifu_rs1en,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire ifu_active,\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    output wire pipe_flush_ack,\n    output wire ifu_halt_ack\n);\n\n    // Internal signals\n    wire ifu_req_valid;\n    wire [E203_PC_SIZE-1:0] ifu_req_pc;\n    wire ifu_req_seq;\n    wire ifu_req_seq_rv32;\n    wire [E203_PC_SIZE-1:0] ifu_req_last_pc;\n    wire ifu_req_ready;\n    wire ifu_rsp_valid;\n    wire ifu_rsp_err;\n    wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr;\n\n    // Instantiate the IFU fetch module\n    e203_ifu_ifetch ifetch(\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ifu_o_ready(ifu_o_ready),\n        .pipe_flush_req(pipe_flush_req),\n        .pipe_flush_add_op1(pipe_flush_add_op1),\n        .pipe_flush_add_op2(pipe_flush_add_op2),\n        .ifu_halt_req(ifu_halt_req),\n        .oitf_empty(oitf_empty),\n        .rf2ifu_x1(rf2ifu_x1),\n        .rf2ifu_rs1(rf2ifu_rs1),\n        .dec2ifu_rden(dec2ifu_rden),\n        .dec2ifu_rs1en(dec2ifu_rs1en),\n        .dec2ifu_rdidx(dec2ifu_rdidx),\n        .dec2ifu_mulhsu(dec2ifu_mulhsu),\n        .dec2ifu_div(dec2ifu_div),\n        .dec2ifu_rem(dec2ifu_rem),\n        .dec2ifu_divu(dec2ifu_divu),\n        .dec2ifu_remu(dec2ifu_remu),\n        .inspect_pc(inspect_pc),\n        .ifu_req_valid(ifu_req_valid),\n        .ifu_req_pc(ifu_req_pc),\n        .ifu_req_seq(ifu_req_seq),\n        .ifu_req_seq_rv32(ifu_req_seq_rv32),\n        .ifu_req_last_pc(ifu_req_last_pc),\n        .pipe_flush_ack(pipe_flush_ack),\n        .ifu_halt_ack(ifu_halt_ack),\n        .ifu_o_ir(ifu_o_ir),\n        .ifu_o_pc(ifu_o_pc),\n        .ifu_o_pc_vld(ifu_o_pc_vld),\n        .ifu_o_misalgn(ifu_o_misalgn),\n        .ifu_o_buserr(ifu_o_buserr),\n        .ifu_o_rs1idx(ifu_o_rs1idx),\n        .ifu_o_rs2idx(ifu_o_rs2idx),\n        .ifu_o_prdt_taken(ifu_o_prdt_taken),\n        .ifu_o_muldiv_b2b(ifu_o_muldiv_b2b),\n        .ifu_o_valid(ifu_o_valid)\n    );\n\n    // Instantiate the IFU to ICB bridge module\n    e203_ifu_ift2icb ift2icb(\n        .clk(clk),\n        .rst_n(rst_n),\n        .ifu_req_valid(ifu_req_valid),\n        .ifu_req_pc(ifu_req_pc),\n        .ifu_req_seq(ifu_req_seq),\n        .ifu_req_seq_rv32(ifu_req_seq_rv32),\n        .ifu_req_last_pc(ifu_req_last_pc),\n        .ifu_rsp_ready(ifu_o_ready),\n        .itcm_nohold(itcm_nohold),\n        .ifu_req_ready(ifu_req_ready),\n        .ifu_rsp_valid(ifu_rsp_valid),\n        .ifu_rsp_err(ifu_rsp_err),\n        .ifu_rsp_instr(ifu_rsp_instr)\n    );\n\n    assign ifu_active = ifu_req_valid || ifu_rsp_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 6, "code": "module e203_exu_alu_csrctrl (\n    input wire csr_i_valid,\n    output reg csr_i_ready,\n    input wire [E203_XLEN-1:0] csr_i_rs1,\n    input wire [E203_DECINFO_CSR_WIDTH-1:0] csr_i_info,\n    input wire csr_i_rdwen,\n    output reg csr_ena,\n    output reg csr_wr_en,\n    output reg csr_rd_en,\n    output reg [11:0] csr_idx,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output reg [E203_XLEN-1:0] wbck_csr_dat,\n    output reg csr_o_valid,\n    input wire csr_o_ready,\n    output reg [E203_XLEN-1:0] csr_o_wbck_wdat,\n    output reg csr_o_wbck_err,\n    input wire clk,\n    input wire rst_n\n);\n\n    wire csrrw = csr_i_info[E203_DECINFO_CSR_CSRRW];\n    wire csrrs = csr_i_info[E203_DECINFO_CSR_CSRRS];\n    wire csrrc = csr_i_info[E203_DECINFO_CSR_CSRRC];\n    wire rs1imm = csr_i_info[E203_DECINFO_CSR_RS1IMM];\n    wire rs1is0 = csr_i_info[E203_DECINFO_CSR_RS1IS0];\n    wire [4:0] zimm = csr_i_info[E203_DECINFO_CSR_ZIMMM];\n    wire [11:0] csr_idx_info = csr_i_info[E203_DECINFO_CSR_CSRIDX];\n\n    wire [E203_XLEN-1:0] csr_op1 = rs1imm ? { {(E203_XLEN-5){1'b0}}, zimm } : csr_i_rs1;\n\n    always @* begin\n        csr_i_ready = csr_o_ready;\n        csr_o_valid = csr_i_valid && csr_o_ready;\n        csr_idx = csr_idx_info;\n        csr_ena = csr_i_valid && csr_o_ready && !csr_access_ilgl;\n\n        csr_rd_en = (csrrw && csr_i_rdwen) || csrrs || csrrc;\n        csr_wr_en = (csrrw || (csrrs && !rs1is0) || (csrrc && !rs1is0)) && csr_i_valid;\n\n        wbck_csr_dat = (csrrw ? csr_op1 : \n                        csrrs ? (csr_op1 | read_csr_dat) : \n                        csrrc ? (csr_op1 & ~read_csr_dat) : \n                        read_csr_dat);\n\n        csr_o_wbck_wdat = read_csr_dat;\n        csr_o_wbck_err = csr_access_ilgl;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 12, "code": "module e203_dtcm_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n    output wire dtcm_active,\n\n    // LSU ICB Interface\n    input wire lsu2dtcm_icb_cmd_valid,\n    output wire lsu2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] lsu2dtcm_icb_cmd_addr,\n    input wire lsu2dtcm_icb_cmd_read,\n    input wire [31:0] lsu2dtcm_icb_cmd_wdata,\n    input wire [3:0] lsu2dtcm_icb_cmd_wmask,\n    output wire lsu2dtcm_icb_rsp_valid,\n    input wire lsu2dtcm_icb_rsp_ready,\n    output wire lsu2dtcm_icb_rsp_err,\n    output wire [31:0] lsu2dtcm_icb_rsp_rdata,\n\n    // External ICB Interface (Optional)\n    `ifdef E203_HAS_DTCM_EXTITF\n    input wire ext2dtcm_icb_cmd_valid,\n    output wire ext2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] ext2dtcm_icb_cmd_addr,\n    input wire ext2dtcm_icb_cmd_read,\n    input wire [31:0] ext2dtcm_icb_cmd_wdata,\n    input wire [3:0] ext2dtcm_icb_cmd_wmask,\n    output wire ext2dtcm_icb_rsp_valid,\n    input wire ext2dtcm_icb_rsp_ready,\n    output wire ext2dtcm_icb_rsp_err,\n    output wire [31:0] ext2dtcm_icb_rsp_rdata,\n    `endif\n\n    // DTCM RAM Interface\n    output wire dtcm_ram_cs,\n    output wire dtcm_ram_we,\n    output wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    output wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    output wire clk_dtcm_ram\n);\n\n    // Internal signals\n    wire arb_cmd_valid;\n    wire arb_cmd_ready;\n    wire arb_cmd_read;\n    wire [E203_DTCM_ADDR_WIDTH-1:0] arb_cmd_addr;\n    wire [31:0] arb_cmd_wdata;\n    wire [3:0] arb_cmd_wmask;\n    wire arb_rsp_valid;\n    wire arb_rsp_ready;\n    wire arb_rsp_err;\n    wire [31:0] arb_rsp_rdata;\n\n    // Instantiate the bus arbiter\n    sirv_gnrl_icb_arbt #(\n        .ARBT_SCHEME(0),\n        .ALLOW_0CYCL_RSP(0),\n        .FIFO_OUTS_NUM(E203_DTCM_OUTS_NUM),\n        .FIFO_CUT_READY(0),\n        .USR_W(1),\n        .ARBT_NUM(DTCM_ARBT_I_NUM),\n        .AW(E203_DTCM_ADDR_WIDTH),\n        .DW(32),\n        .ARBT_PTR_W(DTCM_ARBT_I_PTR_W)\n    ) u_dtcm_arbiter (\n        .o_icb_cmd_valid(arb_cmd_valid),\n        .o_icb_cmd_ready(arb_cmd_ready),\n        .o_icb_cmd_read(arb_cmd_read),\n        .o_icb_cmd_addr(arb_cmd_addr),\n        .o_icb_cmd_wdata(arb_cmd_wdata),\n        .o_icb_cmd_wmask(arb_cmd_wmask),\n        .o_icb_rsp_valid(arb_rsp_valid),\n        .o_icb_rsp_ready(arb_rsp_ready),\n        .o_icb_rsp_err(arb_rsp_err),\n        .o_icb_rsp_rdata(arb_rsp_rdata),\n        .i_bus_icb_cmd_ready({lsu2dtcm_icb_cmd_ready, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_cmd_ready `endif}),\n        .i_bus_icb_cmd_valid({lsu2dtcm_icb_cmd_valid, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_cmd_valid `endif}),\n        .i_bus_icb_cmd_read({lsu2dtcm_icb_cmd_read, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_cmd_read `endif}),\n        .i_bus_icb_cmd_addr({lsu2dtcm_icb_cmd_addr, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_cmd_addr `endif}),\n        .i_bus_icb_cmd_wdata({lsu2dtcm_icb_cmd_wdata, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_cmd_wdata `endif}),\n        .i_bus_icb_cmd_wmask({lsu2dtcm_icb_cmd_wmask, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_cmd_wmask `endif}),\n        .i_bus_icb_rsp_valid({lsu2dtcm_icb_rsp_valid, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_rsp_valid `endif}),\n        .i_bus_icb_rsp_ready({lsu2dtcm_icb_rsp_ready, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_rsp_ready `endif}),\n        .i_bus_icb_rsp_err({lsu2dtcm_icb_rsp_err, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_rsp_err `endif}),\n        .i_bus_icb_rsp_rdata({lsu2dtcm_icb_rsp_rdata, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_rsp_rdata `endif}),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\n    // SRAM controller\n    sirv_sram_icb_ctrl #(\n        .DW(E203_DTCM_DATA_WIDTH),\n        .AW(E203_DTCM_ADDR_WIDTH),\n        .MW(E203_DTCM_WMSK_WIDTH),\n        .AW_LSB(2),\n        .USR_W(1)\n    ) u_dtcm_sram_ctrl (\n        .sram_ctrl_active(dtcm_active),\n        .tcm_cgstop(tcm_cgstop),\n        .i_icb_cmd_valid(arb_cmd_valid),\n        .i_icb_cmd_ready(arb_cmd_ready),\n        .i_icb_cmd_read(arb_cmd_read),\n        .i_icb_cmd_addr(arb_cmd_addr),\n        .i_icb_cmd_wdata(arb_cmd_wdata),\n        .i_icb_cmd_wmask(arb_cmd_wmask),\n        .i_icb_rsp_valid(arb_rsp_valid),\n        .i_icb_rsp_ready(arb_rsp_ready),\n        .i_icb_rsp_rdata(arb_rsp_rdata),\n        .ram_cs(dtcm_ram_cs),\n        .ram_we(dtcm_ram_we),\n        .ram_addr(dtcm_ram_addr),\n        .ram_wem(dtcm_ram_wem),\n        .ram_din(dtcm_ram_din),\n        .ram_dout(dtcm_ram_dout),\n        .clk_ram(clk_dtcm_ram),\n        .test_mode(test_mode),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 12, "code": "module e203_biu(\n    input wire clk,\n    input wire rst_n,\n    output wire biu_active,\n\n    // ICB Interface to LSU\n    input wire lsu_icb_cmd_valid,\n    output wire lsu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] lsu_icb_cmd_addr,\n    input wire lsu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] lsu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] lsu_icb_cmd_wmask,\n    input wire [1:0] lsu_icb_cmd_burst,\n    input wire [1:0] lsu_icb_cmd_beat,\n    input wire lsu_icb_cmd_lock,\n    input wire lsu_icb_cmd_excl,\n    input wire [1:0] lsu_icb_cmd_size,\n    output wire lsu_icb_rsp_valid,\n    input wire lsu_icb_rsp_ready,\n    output wire lsu_icb_rsp_err,\n    output wire lsu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] lsu_icb_rsp_rdata,\n\n    // ICB Interface to IFU\n    input wire ifu_icb_cmd_valid,\n    output wire ifu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] ifu_icb_cmd_addr,\n    input wire ifu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ifu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] ifu_icb_cmd_wmask,\n    input wire [1:0] ifu_icb_cmd_burst,\n    input wire [1:0] ifu_icb_cmd_beat,\n    input wire ifu_icb_cmd_lock,\n    input wire ifu_icb_cmd_excl,\n    input wire [1:0] ifu_icb_cmd_size,\n    output wire ifu_icb_rsp_valid,\n    input wire ifu_icb_rsp_ready,\n    output wire ifu_icb_rsp_err,\n    output wire ifu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] ifu_icb_rsp_rdata,\n\n    // ICB Interface to PPI\n    input wire ppi_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] ppi_region_indic,\n\n    // ICB Interface to CLINT\n    input wire clint_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] clint_region_indic,\n\n    // ICB Interface to PLIC\n    input wire plic_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] plic_region_indic,\n\n    // ICB Interface to FIO\n    input wire fio_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] fio_region_indic,\n\n    // ICB Interface to MEM\n    input wire mem_icb_enable\n);\n\n    // Internal signals for arbitration, buffering, and splitting\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_valid;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_ready;\n    wire [BIU_ARBT_I_NUM*E203_ADDR_SIZE-1:0] arbt_icb_cmd_addr;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_read;\n    wire [BIU_ARBT_I_NUM*E203_XLEN-1:0] arbt_icb_cmd_wdata;\n    wire [BIU_ARBT_I_NUM*(E203_XLEN/8)-1:0] arbt_icb_cmd_wmask;\n    wire [BIU_ARBT_I_NUM*2-1:0] arbt_icb_cmd_burst;\n    wire [BIU_ARBT_I_NUM*2-1:0] arbt_icb_cmd_beat;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_lock;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_excl;\n    wire [BIU_ARBT_I_NUM*2-1:0] arbt_icb_cmd_size;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_valid;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_ready;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_err;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_excl_ok;\n    wire [BIU_ARBT_I_NUM*E203_XLEN-1:0] arbt_icb_rsp_rdata;\n\n    // Instantiate the ICB Arbiter\n    sirv_gnrl_icb_arbt #(\n        .AW(E203_ADDR_SIZE),\n        .DW(E203_XLEN),\n        .ARBT_NUM(BIU_ARBT_I_NUM),\n        .ARBT_PTR_W(BIU_ARBT_I_PTR_W),\n        .USR_W(1),\n        .ARBT_SCHEME(0),\n        .ALLOW_0CYCL_RSP(0),\n        .FIFO_OUTS_NUM(E203_BIU_OUTS_NUM),\n        .FIFO_CUT_READY(E203_BIU_CMD_CUT_READY)\n    ) u_icb_arbt (\n        .clk(clk),\n        .rst_n(rst_n),\n        .i_bus_icb_cmd_valid({ifu_icb_cmd_valid, lsu_icb_cmd_valid}),\n        .i_bus_icb_cmd_ready({ifu_icb_cmd_ready, lsu_icb_cmd_ready}),\n        .i_bus_icb_cmd_addr({ifu_icb_cmd_addr, lsu_icb_cmd_addr}),\n        .i_bus_icb_cmd_read({ifu_icb_cmd_read, lsu_icb_cmd_read}),\n        .i_bus_icb_cmd_wdata({ifu_icb_cmd_wdata, lsu_icb_cmd_wdata}),\n        .i_bus_icb_cmd_wmask({ifu_icb_cmd_wmask, lsu_icb_cmd_wmask}),\n        .i_bus_icb_cmd_burst({ifu_icb_cmd_burst, lsu_icb_cmd_burst}),\n        .i_bus_icb_cmd_beat({ifu_icb_cmd_beat, lsu_icb_cmd_beat}),\n        .i_bus_icb_cmd_lock({ifu_icb_cmd_lock, lsu_icb_cmd_lock}),\n        .i_bus_icb_cmd_excl({ifu_icb_cmd_excl, lsu_icb_cmd_excl}),\n        .i_bus_icb_cmd_size({ifu_icb_cmd_size, lsu_icb_cmd_size}),\n        .o_bus_icb_rsp_valid({ifu_icb_rsp_valid, lsu_icb_rsp_valid}),\n        .o_bus_icb_rsp_ready({ifu_icb_rsp_ready, lsu_icb_rsp_ready}),\n        .o_bus_icb_rsp_err({ifu_icb_rsp_err, lsu_icb_rsp_err}),\n        .o_bus_icb_rsp_excl_ok({ifu_icb_rsp_excl_ok, lsu_icb_rsp_excl_ok}),\n        .o_bus_icb_rsp_rdata({ifu_icb_rsp_rdata, lsu_icb_rsp_rdata})\n    );\n\n    // Additional logic for response handling, buffering, and splitting would be here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 4, "code": "module e203_exu_alu_lsuagu (\n    input wire agu_i_valid,\n    output wire agu_i_ready,\n    input wire [E203_XLEN-1:0] agu_i_rs1,\n    input wire [E203_XLEN-1:0] agu_i_rs2,\n    input wire [E203_XLEN-1:0] agu_i_imm,\n    input wire [E203_DECINFO_AGU_WIDTH-1:0] agu_i_info,\n    input wire [E203_ITAG_WIDTH-1:0] agu_i_itag,\n    output wire agu_i_longpipe,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire amo_wait,\n    input wire oitf_empty,\n    output wire agu_o_valid,\n    input wire agu_o_ready,\n    output wire [E203_XLEN-1:0] agu_o_wbck_wdat,\n    output wire agu_o_wbck_err,\n    output wire agu_o_cmt_misalgn,\n    output wire agu_o_cmt_ld,\n    output wire agu_o_cmt_stamo,\n    output wire agu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] agu_o_cmt_badaddr,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_cmd_usign,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire [E203_XLEN-1:0] agu_req_alu_op1,\n    output wire [E203_XLEN-1:0] agu_req_alu_op2,\n    output wire agu_req_alu_swap,\n    output wire agu_req_alu_add,\n    output wire agu_req_alu_and,\n    output wire agu_req_alu_or,\n    output wire agu_req_alu_xor,\n    output wire agu_req_alu_max,\n    output wire agu_req_alu_min,\n    output wire agu_req_alu_maxu,\n    output wire agu_req_alu_minu,\n    input wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire agu_sbf_0_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_0_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_0_r,\n    output wire agu_sbf_1_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_1_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_1_r,\n    input wire clk,\n    input wire rst_n\n);\n    // Implementation of the AGU logic\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 5, "code": "module e203_irq_sync (\n    input wire clk,\n    input wire rst_n,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire dbg_irq_a,\n    output wire ext_irq_r,\n    output wire sft_irq_r,\n    output wire tmr_irq_r,\n    output wire dbg_irq_r\n);\n\n    // Synchronization instances for each interrupt type\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) u_ext_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(ext_irq_a),\n        .dout(ext_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) u_sft_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(sft_irq_a),\n        .dout(sft_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) u_tmr_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(tmr_irq_a),\n        .dout(tmr_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) u_dbg_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(dbg_irq_a),\n        .dout(dbg_irq_r)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 5, "code": "module e203_exu_alu_lsuagu (\n    input wire agu_i_valid,\n    output wire agu_i_ready,\n    input wire [E203_XLEN-1:0] agu_i_rs1,\n    input wire [E203_XLEN-1:0] agu_i_rs2,\n    input wire [E203_XLEN-1:0] agu_i_imm,\n    input wire [E203_DECINFO_AGU_WIDTH-1:0] agu_i_info,\n    input wire [E203_ITAG_WIDTH-1:0] agu_i_itag,\n    output wire agu_i_longpipe,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire amo_wait,\n    input wire oitf_empty,\n    output wire agu_o_valid,\n    input wire agu_o_ready,\n    output wire [E203_XLEN-1:0] agu_o_wbck_wdat,\n    output wire agu_o_wbck_err,\n    output wire agu_o_cmt_misalgn,\n    output wire agu_o_cmt_ld,\n    output wire agu_o_cmt_stamo,\n    output wire agu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] agu_o_cmt_badaddr,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_cmd_usign,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire [E203_XLEN-1:0] agu_req_alu_op1,\n    output wire [E203_XLEN-1:0] agu_req_alu_op2,\n    output wire agu_req_alu_swap,\n    output wire agu_req_alu_add,\n    output wire agu_req_alu_and,\n    output wire agu_req_alu_or,\n    output wire agu_req_alu_xor,\n    output wire agu_req_alu_max,\n    output wire agu_req_alu_min,\n    output wire agu_req_alu_maxu,\n    output wire agu_req_alu_minu,\n    input wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire agu_sbf_0_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_0_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_0_r,\n    output wire agu_sbf_1_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_1_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_1_r,\n    input wire clk,\n    input wire rst_n\n);\n    // Implementation of AGU logic goes here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 11, "code": "module e203_reset_ctrl #(\n    parameter MASTER = 1,\n    parameter integer RST_SYNC_LEVEL = `E203_ASYNC_FF_LEVELS\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    output wire rst_core,\n    output wire rst_itcm,\n    output wire rst_dtcm,\n    output wire rst_aon\n);\n\nreg [RST_SYNC_LEVEL-1:0] rst_sync;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        rst_sync <= {RST_SYNC_LEVEL{1'b1}};\n    end else if (test_mode) begin\n        rst_sync <= {RST_SYNC_LEVEL{rst_n}};\n    end else begin\n        rst_sync <= {rst_sync[RST_SYNC_LEVEL-2:0], 1'b1};\n    end\nend\n\nassign rst_core = rst_sync[RST_SYNC_LEVEL-1];\nassign rst_itcm = rst_sync[RST_SYNC_LEVEL-1];\nassign rst_dtcm = rst_sync[RST_SYNC_LEVEL-1];\nassign rst_aon = rst_sync[RST_SYNC_LEVEL-1];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 3, "code": "module e203_exu(\n    // Basic Interface\n    output commit_mret,\n    output commit_trap,\n    output exu_active,\n    output excp_active,\n    output core_wfi,\n    output tm_stop,\n    output itcm_nohold,\n    output core_cgstop,\n    output tcm_cgstop,\n    input [E203_HART_ID_W-1:0] core_mhartid,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    output wfi_halt_ifu_req,\n    input wfi_halt_ifu_ack,\n    output oitf_empty,\n    output [E203_XLEN-1:0] rf2ifu_x1,\n    output [E203_XLEN-1:0] rf2ifu_rs1,\n    output dec2ifu_rden,\n    output dec2ifu_rs1en,\n    output [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    output dec2ifu_mulhsu,\n    output dec2ifu_div,\n    output dec2ifu_rem,\n    output dec2ifu_divu,\n    output dec2ifu_remu,\n    input test_mode,\n    input clk_aon,\n    input clk,\n    input rst_n,\n\n    // From/To debug ctrl module\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output wr_dcsr_ena,\n    output wr_dpc_ena,\n    output wr_dscratch_ena,\n    output [E203_XLEN-1:0] wr_csr_nxt,\n    input [E203_XLEN-1:0] dcsr_r,\n    input [E203_PC_SIZE-1:0] dpc_r,\n    input [E203_XLEN-1:0] dscratch_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input dbg_stopcycle,\n\n    // IFU IR stage to EXU interface\n    input i_valid,\n    output i_ready,\n    input [E203_INSTR_SIZE-1:0] i_ir,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_pc_vld,\n    input i_misalgn,\n    input i_buserr,\n    input i_prdt_taken,\n    input i_muldiv_b2b,\n    input [E203_RFIDX_WIDTH-1:0] i_rs1idx,\n    input [E203_RFIDX_WIDTH-1:0] i_rs2idx,\n\n    // Flush interface to IFU\n    input pipe_flush_ack,\n    output pipe_flush_req,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    `ifdef E203_TIMING_BOOST\n    output [E203_PC_SIZE-1:0] pipe_flush_pc,\n    `endif\n\n    // LSU Write-Back Interface\n    input lsu_o_valid,\n    output lsu_o_ready,\n    input [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    input [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    input lsu_o_wbck_err,\n    input lsu_o_cmt_ld,\n    input lsu_o_cmt_st,\n    input [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    input lsu_o_cmt_buserr,\n\n    // AGU ICB Interface to LSU-ctrl\n    output agu_icb_cmd_valid,\n    input agu_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output agu_icb_cmd_read,\n    output [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output agu_icb_cmd_lock,\n    output agu_icb_cmd_excl,\n    output [1:0] agu_icb_cmd_size,\n    output agu_icb_cmd_back2agu,\n    output agu_icb_cmd_usign,\n    output [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input agu_icb_rsp_valid,\n    output agu_icb_rsp_ready,\n    input agu_icb_rsp_err,\n    input agu_icb_rsp_excl_ok,\n    input [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    // CSR_NICE Interface(optional)\n    `ifdef E203_HAS_CSR_NICE\n    output nice_csr_valid,\n    input nice_csr_ready,\n    output [31:0] nice_csr_addr,\n    output nice_csr_wr,\n    output [31:0] nice_csr_wdata,\n    input [31:0] nice_csr_rdata,\n    `endif\n\n    // NICE Interface(optional)\n    `ifdef E203_HAS_NICE\n    output nice_req_valid,\n    input nice_req_ready,\n    output [E203_XLEN-1:0] nice_req_inst,\n    output [E203_XLEN-1:0] nice_req_rs1,\n    output [E203_XLEN-1:0] nice_req_rs2,\n    input nice_rsp_multicyc_valid,\n    output nice_rsp_multicyc_ready,\n    input [E203_XLEN-1:0] nice_rsp_multicyc_dat,\n    input nice_rsp_multicyc_err\n    `endif\n);\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 7, "code": "module e203_exu_alu_csrctrl (\n    input wire csr_i_valid,\n    output reg csr_i_ready,\n    input wire [E203_XLEN-1:0] csr_i_rs1,\n    input wire [E203_DECINFO_CSR_WIDTH-1:0] csr_i_info,\n    input wire csr_i_rdwen,\n    output reg csr_ena,\n    output reg csr_wr_en,\n    output reg csr_rd_en,\n    output reg [11:0] csr_idx,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output reg [E203_XLEN-1:0] wbck_csr_dat,\n    output reg csr_o_valid,\n    input wire csr_o_ready,\n    output reg [E203_XLEN-1:0] csr_o_wbck_wdat,\n    output reg csr_o_wbck_err,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Decode CSR instruction information\n    wire csrrw = csr_i_info[E203_DECINFO_CSR_CSRRW];\n    wire csrrs = csr_i_info[E203_DECINFO_CSR_CSRRS];\n    wire csrrc = csr_i_info[E203_DECINFO_CSR_CSRRC];\n    wire rs1imm = csr_i_info[E203_DECINFO_CSR_RS1IMM];\n    wire rs1is0 = csr_i_info[E203_DECINFO_CSR_RS1IS0];\n    wire [4:0] zimm = csr_i_info[E203_DECINFO_CSR_ZIMMM];\n    wire [11:0] csr_idx_info = csr_i_info[E203_DECINFO_CSR_CSRIDX];\n\n    // Prepare operand 1\n    wire [E203_XLEN-1:0] csr_op1 = rs1imm ? { {(E203_XLEN-5){1'b0}}, zimm } : csr_i_rs1;\n\n    // CSR read and write enable logic\n    always @(*) begin\n        csr_rd_en = csr_i_valid && ((csrrw && csr_i_rdwen) || csrrs || csrrc);\n        csr_wr_en = csr_i_valid && (csrrw || (csrrs && !rs1is0) || (csrrc && !rs1is0));\n        csr_idx = csr_idx_info;\n        csr_ena = csr_o_valid && csr_o_ready;\n        csr_i_ready = csr_o_ready;\n        csr_o_valid = csr_i_valid && csr_o_ready;\n        csr_o_wbck_wdat = read_csr_dat;\n        csr_o_wbck_err = csr_access_ilgl;\n    end\n\n    // Prepare data for CSR write operations\n    always @(*) begin\n        case ({csrrw, csrrs, csrrc})\n            3'b100: wbck_csr_dat = csr_op1; // CSRRW\n            3'b010: wbck_csr_dat = csr_op1 | read_csr_dat; // CSRRS\n            3'b001: wbck_csr_dat = ~csr_op1 & read_csr_dat; // CSRRC\n            default: wbck_csr_dat = {E203_XLEN{1'b0}};\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 2, "code": "module e203_exu_disp (\n    input wire wfi_halt_exu_req,\n    output wire wfi_halt_exu_ack,\n    input wire oitf_empty,\n    input wire amo_wait,\n    input wire disp_i_valid,\n    output wire disp_i_ready,\n    input wire disp_i_rs1x0,\n    input wire disp_i_rs2x0,\n    input wire disp_i_rs1en,\n    input wire disp_i_rs2en,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input wire [E203_XLEN-1:0] disp_i_rs1,\n    input wire [E203_XLEN-1:0] disp_i_rs2,\n    input wire disp_i_rdwen,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input wire [E203_DECINFO_WIDTH-1:0] disp_i_info,\n    input wire [E203_XLEN-1:0] disp_i_imm,\n    input wire [E203_PC_SIZE-1:0] disp_i_pc,\n    input wire disp_i_misalgn,\n    input wire disp_i_buserr,\n    input wire disp_i_ilegl,\n    output wire disp_o_alu_valid,\n    input wire disp_o_alu_ready,\n    input wire disp_o_alu_longpipe,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs1,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs2,\n    output wire disp_o_alu_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_o_alu_rdidx,\n    output wire [E203_DECINFO_WIDTH-1:0] disp_o_alu_info,\n    output wire [E203_XLEN-1:0] disp_o_alu_imm,\n    output wire [E203_PC_SIZE-1:0] disp_o_alu_pc,\n    output wire [E203_ITAG_WIDTH-1:0] disp_o_alu_itag,\n    output wire disp_o_alu_misalgn,\n    output wire disp_o_alu_buserr,\n    output wire disp_o_alu_ilegl,\n    input wire oitfrd_match_disprs1,\n    input wire oitfrd_match_disprs2,\n    input wire oitfrd_match_disprs3,\n    input wire oitfrd_match_disprd,\n    input wire [E203_ITAG_WIDTH-1:0] disp_oitf_ptr,\n    output wire disp_oitf_ena,\n    input wire disp_oitf_ready,\n    output wire disp_oitf_rs1fpu,\n    output wire disp_oitf_rs2fpu,\n    output wire disp_oitf_rs3fpu,\n    output wire disp_oitf_rdfpu,\n    output wire disp_oitf_rs1en,\n    output wire disp_oitf_rs2en,\n    output wire disp_oitf_rs3en,\n    output wire disp_oitf_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs2idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs3idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rdidx,\n    output wire [E203_PC_SIZE-1:0] disp_oitf_pc,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Implementation of the dispatch logic\n    // This is a simplified example and needs to be expanded based on actual requirements\n\n    assign disp_i_ready = !amo_wait && oitf_empty && !wfi_halt_exu_req;\n    assign wfi_halt_exu_ack = wfi_halt_exu_req && oitf_empty;\n\n    assign disp_o_alu_valid = disp_i_valid && disp_i_ready;\n    assign disp_o_alu_rs1 = disp_i_rs1;\n    assign disp_o_alu_rs2 = disp_i_rs2;\n    assign disp_o_alu_rdwen = disp_i_rdwen;\n    assign disp_o_alu_rdidx = disp_i_rdidx;\n    assign disp_o_alu_info = disp_i_info;\n    assign disp_o_alu_imm = disp_i_imm;\n    assign disp_o_alu_pc = disp_i_pc;\n    assign disp_o_alu_itag = disp_oitf_ptr;\n    assign disp_o_alu_misalgn = disp_i_misalgn;\n    assign disp_o_alu_buserr = disp_i_buserr;\n    assign disp_o_alu_ilegl = disp_i_ilegl;\n\n    assign disp_oitf_ena = disp_o_alu_valid && disp_o_alu_ready && disp_o_alu_longpipe;\n    assign disp_oitf_rs1fpu = 0; // Assuming no FPU in this example\n    assign disp_oitf_rs2fpu = 0;\n    assign disp_oitf_rs3fpu = 0;\n    assign disp_oitf_rdfpu = 0;\n    assign disp_oitf_rs1en = disp_i_rs1en;\n    assign disp_oitf_rs2en = disp_i_rs2en;\n    assign disp_oitf_rs3en = 0; // Assuming no third operand\n    assign disp_oitf_rdwen = disp_i_rdwen;\n    assign disp_oitf_rs1idx = disp_i_rs1idx;\n    assign disp_oitf_rs2idx = disp_i_rs2idx;\n    assign disp_oitf_rs3idx = 0; // Assuming no third operand\n    assign disp_oitf_rdidx = disp_i_rdidx;\n    assign disp_oitf_pc = disp_i_pc;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 17, "code": "`ifdef E203_HAS_CSR_NICE\nmodule e203_extend_csr (\n    input wire clk,\n    input wire rst_n,\n    input wire nice_csr_valid,\n    output wire nice_csr_ready,\n    input wire [31:0] nice_csr_addr,\n    input wire nice_csr_wr,\n    input wire [31:0] nice_csr_wdata,\n    output wire [31:0] nice_csr_rdata\n);\n\n  // CSR access ready signal, always 1\n  assign nice_csr_ready = 1'b1;\n\n  // CSR read data, always 0\n  assign nice_csr_rdata = 32'b0;\n\nendmodule\n`endif", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 4, "code": "module e203_exu_alu_rglr (\n    input wire alu_i_valid,\n    output wire alu_i_ready,\n    input wire [E203_XLEN-1:0] alu_i_rs1,\n    input wire [E203_XLEN-1:0] alu_i_rs2,\n    input wire [E203_XLEN-1:0] alu_i_imm,\n    input wire [E203_PC_SIZE-1:0] alu_i_pc,\n    input wire [E203_DECINFO_ALU_WIDTH-1:0] alu_i_info,\n    output wire alu_o_valid,\n    input wire alu_o_ready,\n    output wire [E203_XLEN-1:0] alu_o_wbck_wdat,\n    output wire alu_o_wbck_err,\n    output wire alu_o_cmt_ecall,\n    output wire alu_o_cmt_ebreak,\n    output wire alu_o_cmt_wfi,\n    output wire alu_req_alu_add,\n    output wire alu_req_alu_sub,\n    output wire alu_req_alu_xor,\n    output wire alu_req_alu_sll,\n    output wire alu_req_alu_srl,\n    output wire alu_req_alu_sra,\n    output wire alu_req_alu_or,\n    output wire alu_req_alu_and,\n    output wire alu_req_alu_slt,\n    output wire alu_req_alu_sltu,\n    output wire alu_req_alu_lui,\n    output wire [E203_XLEN-1:0] alu_req_alu_op1,\n    output wire [E203_XLEN-1:0] alu_req_alu_op2,\n    output wire [E203_XLEN-1:0] alu_req_alu_res,\n    input wire clk,\n    input wire rst_n\n);\n\n// Handshake mechanism\nassign alu_i_ready = alu_o_ready;\nassign alu_o_valid = alu_i_valid;\n\n// Decode the ALU operation from the instruction info\nassign alu_req_alu_add = alu_i_info[E203_DECINFO_ALU_ADD] & ~alu_i_info[E203_DECINFO_ALU_NOP];\nassign alu_req_alu_sub = alu_i_info[E203_DECINFO_ALU_SUB];\nassign alu_req_alu_xor = alu_i_info[E203_DECINFO_ALU_XOR];\nassign alu_req_alu_sll = alu_i_info[E203_DECINFO_ALU_SLL];\nassign alu_req_alu_srl = alu_i_info[E203_DECINFO_ALU_SRL];\nassign alu_req_alu_sra = alu_i_info[E203_DECINFO_ALU_SRA];\nassign alu_req_alu_or  = alu_i_info[E203_DECINFO_ALU_OR];\nassign alu_req_alu_and = alu_i_info[E203_DECINFO_ALU_AND];\nassign alu_req_alu_slt = alu_i_info[E203_DECINFO_ALU_SLT];\nassign alu_req_alu_sltu = alu_i_info[E203_DECINFO_ALU_SLTU];\nassign alu_req_alu_lui = alu_i_info[E203_DECINFO_ALU_LUI];\n\n// Select the correct operands based on the instruction info\nassign alu_req_alu_op1 = alu_i_info[E203_DECINFO_ALU_OP1PC] ? alu_i_pc : alu_i_rs1;\nassign alu_req_alu_op2 = alu_i_info[E203_DECINFO_ALU_OP2IMM] ? alu_i_imm : alu_i_rs2;\n\n// Compute the result based on the operation\n// This is a simplified example assuming an adder for demonstration\nassign alu_req_alu_res = alu_req_alu_add ? (alu_req_alu_op1 + alu_req_alu_op2) :\n                        alu_req_alu_sub ? (alu_req_alu_op1 - alu_req_alu_op2) :\n                        alu_req_alu_xor ? (alu_req_alu_op1 ^ alu_req_alu_op2) :\n                        alu_req_alu_or  ? (alu_req_alu_op1 | alu_req_alu_op2) :\n                        alu_req_alu_and ? (alu_req_alu_op1 & alu_req_alu_op2) :\n                        alu_req_alu_slt ? ($signed(alu_req_alu_op1) < $signed(alu_req_alu_op2)) :\n                        alu_req_alu_sltu ? (alu_req_alu_op1 < alu_req_alu_op2) :\n                        alu_req_alu_lui ? alu_i_imm : 32'h0;\n\n// Pass the result back\nassign alu_o_wbck_wdat = alu_req_alu_res;\n\n// Handle special instructions\nassign alu_o_cmt_ecall = alu_i_info[E203_DECINFO_ALU_ECAL];\nassign alu_o_cmt_ebreak = alu_i_info[E203_DECINFO_ALU_EBRK];\nassign alu_o_cmt_wfi = alu_i_info[E203_DECINFO_ALU_WFI];\n\n// Error handling for special instructions\nassign alu_o_wbck_err = alu_o_cmt_ecall | alu_o_cmt_ebreak | alu_o_cmt_wfi;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 6, "code": "module e203_irq_sync (\n    input wire clk,\n    input wire rst_n,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire dbg_irq_a,\n    output wire ext_irq_r,\n    output wire sft_irq_r,\n    output wire tmr_irq_r,\n    output wire dbg_irq_r\n);\n\n  sirv_gnrl_sync #(\n    .DP(2),\n    .DW(1)\n  ) u_ext_irq_sync (\n    .clk(clk),\n    .rst_n(rst_n),\n    .din_a(ext_irq_a),\n    .dout(ext_irq_r)\n  );\n\n  sirv_gnrl_sync #(\n    .DP(2),\n    .DW(1)\n  ) u_sft_irq_sync (\n    .clk(clk),\n    .rst_n(rst_n),\n    .din_a(sft_irq_a),\n    .dout(sft_irq_r)\n  );\n\n  sirv_gnrl_sync #(\n    .DP(2),\n    .DW(1)\n  ) u_tmr_irq_sync (\n    .clk(clk),\n    .rst_n(rst_n),\n    .din_a(tmr_irq_a),\n    .dout(tmr_irq_r)\n  );\n\n  sirv_gnrl_sync #(\n    .DP(2),\n    .DW(1)\n  ) u_dbg_irq_sync (\n    .clk(clk),\n    .rst_n(rst_n),\n    .din_a(dbg_irq_a),\n    .dout(dbg_irq_r)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 7, "code": "module e203_exu_alu_muldiv(\n    input mdv_nob2b,\n    input muldiv_i_valid,\n    output muldiv_i_ready,\n    input [E203_XLEN-1:0] muldiv_i_rs1,\n    input [E203_XLEN-1:0] muldiv_i_rs2,\n    input [E203_XLEN-1:0] muldiv_i_imm,\n    input [E203_DECINFO_MULDIV_WIDTH-1:0] muldiv_i_info,\n    input [E203_ITAG_WIDTH-1:0] muldiv_i_itag,\n    output muldiv_i_longpipe,\n    input flush_pulse,\n    output muldiv_o_valid,\n    input muldiv_o_ready,\n    output [E203_XLEN-1:0] muldiv_o_wbck_wdat,\n    output muldiv_o_wbck_err,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    output muldiv_req_alu_add,\n    output muldiv_req_alu_sub,\n    input [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output muldiv_sbf_0_ena,\n    output [32:0] muldiv_sbf_0_nxt,\n    input [32:0] muldiv_sbf_0_r,\n    output muldiv_sbf_1_ena,\n    output [32:0] muldiv_sbf_1_nxt,\n    input [32:0] muldiv_sbf_1_r,\n    input clk,\n    input rst_n\n);\n\n    // Internal signals and registers\n    reg [4:0] state;\n    wire [E203_XLEN-1:0] op1, op2;\n    wire start_mul, start_div;\n    wire mul_ready, div_ready;\n    wire [E203_XLEN-1:0] result;\n    wire result_valid;\n    wire error_flag;\n\n    // State definitions\n    localparam MULDIV_STATE_IDLE = 5'd0,\n               MULDIV_STATE_MUL = 5'd1,\n               MULDIV_STATE_DIV = 5'd2,\n               MULDIV_STATE_FINISH = 5'd3,\n               MULDIV_STATE_WAIT = 5'd4;\n\n    // Control FSM for multiplication and division operations\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= MULDIV_STATE_IDLE;\n        end else begin\n            case (state)\n                MULDIV_STATE_IDLE: begin\n                    if (muldiv_i_valid) begin\n                        if (start_mul) state <= MULDIV_STATE_MUL;\n                        else if (start_div) state <= MULDIV_STATE_DIV;\n                    end\n                end\n                MULDIV_STATE_MUL: begin\n                    if (mul_ready) state <= MULDIV_STATE_FINISH;\n                end\n                MULDIV_STATE_DIV: begin\n                    if (div_ready) state <= MULDIV_STATE_FINISH;\n                end\n                MULDIV_STATE_FINISH: begin\n                    if (muldiv_o_ready) state <= MULDIV_STATE_WAIT;\n                end\n                MULDIV_STATE_WAIT: begin\n                    if (!muldiv_i_valid) state <= MULDIV_STATE_IDLE;\n                end\n                default: state <= MULDIV_STATE_IDLE;\n            endcase\n        end\n    end\n\n    // Output assignments\n    assign muldiv_i_ready = (state == MULDIV_STATE_IDLE);\n    assign muldiv_o_valid = (state == MULDIV_STATE_FINISH);\n    assign muldiv_o_wbck_wdat = result;\n    assign muldiv_o_wbck_err = error_flag;\n\n    // Example operation logic (simplified)\n    assign start_mul = muldiv_i_info[0];\n    assign start_div = muldiv_i_info[1];\n    assign op1 = muldiv_i_rs1;\n    assign op2 = muldiv_i_rs2;\n    assign mul_ready = 1'b1; // Placeholder for actual ready signal from multiplier\n    assign div_ready = 1'b1; // Placeholder for actual ready signal from divider\n    assign result = op1 + op2; // Placeholder for actual result\n    assign result_valid = 1'b1; // Placeholder for actual result valid signal\n    assign error_flag = 1'b0; // Placeholder for error condition\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 4, "code": "// E203 Execution Unit (EXU) Top Module\nmodule e203_exu(\n    // Basic Interface\n    output commit_mret,\n    output commit_trap,\n    output exu_active,\n    output excp_active,\n    output core_wfi,\n    output tm_stop,\n    output itcm_nohold,\n    output core_cgstop,\n    output tcm_cgstop,\n    input [E203_HART_ID_W-1:0] core_mhartid,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    output wfi_halt_ifu_req,\n    input wfi_halt_ifu_ack,\n    output oitf_empty,\n    output [E203_XLEN-1:0] rf2ifu_x1,\n    output [E203_XLEN-1:0] rf2ifu_rs1,\n    output dec2ifu_rden,\n    output dec2ifu_rs1en,\n    output [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    output dec2ifu_mulhsu,\n    output dec2ifu_div,\n    output dec2ifu_rem,\n    output dec2ifu_divu,\n    output dec2ifu_remu,\n    input test_mode,\n    input clk_aon,\n    input clk,\n    input rst_n,\n\n    // From/To debug ctrl module\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output wr_dcsr_ena,\n    output wr_dpc_ena,\n    output wr_dscratch_ena,\n    output [E203_XLEN-1:0] wr_csr_nxt,\n    input [E203_XLEN-1:0] dcsr_r,\n    input [E203_PC_SIZE-1:0] dpc_r,\n    input [E203_XLEN-1:0] dscratch_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input dbg_stopcycle,\n\n    // IFU IR stage to EXU interface\n    input i_valid,\n    output i_ready,\n    input [E203_INSTR_SIZE-1:0] i_ir,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_pc_vld,\n    input i_misalgn,\n    input i_buserr,\n    input i_prdt_taken,\n    input i_muldiv_b2b,\n    input [E203_RFIDX_WIDTH-1:0] i_rs1idx,\n    input [E203_RFIDX_WIDTH-1:0] i_rs2idx,\n\n    // Flush interface to IFU\n    input pipe_flush_ack,\n    output pipe_flush_req,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    `ifdef E203_TIMING_BOOST\n    output [E203_PC_SIZE-1:0] pipe_flush_pc,\n    `endif\n\n    // LSU Write-Back Interface\n    input lsu_o_valid,\n    output lsu_o_ready,\n    input [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    input [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    input lsu_o_wbck_err,\n    input lsu_o_cmt_ld,\n    input lsu_o_cmt_st,\n    input [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    input lsu_o_cmt_buserr,\n\n    // AGU ICB Interface to LSU-ctrl\n    output agu_icb_cmd_valid,\n    input agu_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output agu_icb_cmd_read,\n    output [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output agu_icb_cmd_lock,\n    output agu_icb_cmd_excl,\n    output [1:0] agu_icb_cmd_size,\n    output agu_icb_cmd_back2agu,\n    output agu_icb_cmd_usign,\n    output [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input agu_icb_rsp_valid,\n    output agu_icb_rsp_ready,\n    input agu_icb_rsp_err,\n    input agu_icb_rsp_excl_ok,\n    input [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    // CSR_NICE Interface(optional)\n    `ifdef E203_HAS_CSR_NICE\n    output nice_csr_valid,\n    input nice_csr_ready,\n    output [31:0] nice_csr_addr,\n    output nice_csr_wr,\n    output [31:0] nice_csr_wdata,\n    input [31:0] nice_csr_rdata,\n    `endif\n\n    // NICE Interface(optional)\n    `ifdef E203_HAS_NICE\n    output nice_req_valid,\n    input nice_req_ready,\n    output [E203_XLEN-1:0] nice_req_inst,\n    output [E203_XLEN-1:0] nice_req_rs1,\n    output [E203_XLEN-1:0] nice_req_rs2,\n    input nice_rsp_multicyc_valid,\n    output nice_rsp_multicyc_ready,\n    input [E203_XLEN-1:0] nice_rsp_multicyc_dat,\n    input nice_rsp_multicyc_err\n    `endif\n);\n    // Internal signals and logic\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 12, "code": "module e203_reset_ctrl #(\n    parameter MASTER = 1,\n    parameter RST_SYNC_LEVEL = `E203_ASYNC_FF_LEVELS\n)(\n    input clk,\n    input rst_n,\n    input test_mode,\n    output rst_core,\n    output rst_itcm,\n    output rst_dtcm,\n    output rst_aon\n);\n\nreg [RST_SYNC_LEVEL-1:0] rst_sync_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        rst_sync_reg <= {RST_SYNC_LEVEL{1'b1}};\n    end else begin\n        if (test_mode) begin\n            rst_sync_reg <= {RST_SYNC_LEVEL{rst_n}};\n        end else begin\n            rst_sync_reg <= {rst_sync_reg[RST_SYNC_LEVEL-2:0], 1'b1};\n        end\n    end\nend\n\nassign rst_core = (MASTER == 1) ? rst_sync_reg[RST_SYNC_LEVEL-1] : rst_n;\nassign rst_itcm = (MASTER == 1) ? rst_sync_reg[RST_SYNC_LEVEL-1] : rst_n;\nassign rst_dtcm = (MASTER == 1) ? rst_sync_reg[RST_SYNC_LEVEL-1] : rst_n;\nassign rst_aon = (MASTER == 1) ? rst_sync_reg[RST_SYNC_LEVEL-1] : rst_n;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 5, "code": "module e203_exu_alu_rglr(\n    input wire alu_i_valid,\n    output wire alu_i_ready,\n    input wire [E203_XLEN-1:0] alu_i_rs1,\n    input wire [E203_XLEN-1:0] alu_i_rs2,\n    input wire [E203_XLEN-1:0] alu_i_imm,\n    input wire [E203_PC_SIZE-1:0] alu_i_pc,\n    input wire [E203_DECINFO_ALU_WIDTH-1:0] alu_i_info,\n    output wire alu_o_valid,\n    input wire alu_o_ready,\n    output wire [E203_XLEN-1:0] alu_o_wbck_wdat,\n    output wire alu_o_wbck_err,\n    output wire alu_o_cmt_ecall,\n    output wire alu_o_cmt_ebreak,\n    output wire alu_o_cmt_wfi,\n    output wire alu_req_alu_add,\n    output wire alu_req_alu_sub,\n    output wire alu_req_alu_xor,\n    output wire alu_req_alu_sll,\n    output wire alu_req_alu_srl,\n    output wire alu_req_alu_sra,\n    output wire alu_req_alu_or,\n    output wire alu_req_alu_and,\n    output wire alu_req_alu_slt,\n    output wire alu_req_alu_sltu,\n    output wire alu_req_alu_lui,\n    output wire [E203_XLEN-1:0] alu_req_alu_op1,\n    output wire [E203_XLEN-1:0] alu_req_alu_op2,\n    output wire [E203_XLEN-1:0] alu_req_alu_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Handshake signals\n    assign alu_i_ready = alu_o_ready;\n    assign alu_o_valid = alu_i_valid;\n\n    // Operation type decoding\n    assign alu_req_alu_add = alu_i_info[E203_DECINFO_ALU_ADD] & ~alu_i_info[E203_DECINFO_ALU_NOP];\n    assign alu_req_alu_sub = alu_i_info[E203_DECINFO_ALU_SUB];\n    assign alu_req_alu_xor = alu_i_info[E203_DECINFO_ALU_XOR];\n    assign alu_req_alu_sll = alu_i_info[E203_DECINFO_ALU_SLL];\n    assign alu_req_alu_srl = alu_i_info[E203_DECINFO_ALU_SRL];\n    assign alu_req_alu_sra = alu_i_info[E203_DECINFO_ALU_SRA];\n    assign alu_req_alu_or  = alu_i_info[E203_DECINFO_ALU_OR];\n    assign alu_req_alu_and = alu_i_info[E203_DECINFO_ALU_AND];\n    assign alu_req_alu_slt = alu_i_info[E203_DECINFO_ALU_SLT];\n    assign alu_req_alu_sltu = alu_i_info[E203_DECINFO_ALU_SLTU];\n    assign alu_req_alu_lui = alu_i_info[E203_DECINFO_ALU_LUI];\n\n    // Source operand selection\n    assign alu_req_alu_op1 = alu_i_info[E203_DECINFO_ALU_OP1PC] ? alu_i_pc : alu_i_rs1;\n    assign alu_req_alu_op2 = alu_i_info[E203_DECINFO_ALU_OP2IMM] ? alu_i_imm : alu_i_rs2;\n\n    // Result from shared data path\n    assign alu_o_wbck_wdat = alu_req_alu_res;\n\n    // Special instructions handling\n    assign alu_o_cmt_ecall = alu_i_info[E203_DECINFO_ALU_ECAL];\n    assign alu_o_cmt_ebreak = alu_i_info[E203_DECINFO_ALU_EBRK];\n    assign alu_o_cmt_wfi = alu_i_info[E203_DECINFO_ALU_WFI];\n\n    // Error handling for special instructions\n    assign alu_o_wbck_err = alu_o_cmt_ecall | alu_o_cmt_ebreak | alu_o_cmt_wfi;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 3, "code": "module e203_exu_disp(\n    input wfi_halt_exu_req,\n    output reg wfi_halt_exu_ack,\n    input oitf_empty,\n    input amo_wait,\n    input disp_i_valid,\n    output reg disp_i_ready,\n    input disp_i_rs1x0,\n    input disp_i_rs2x0,\n    input disp_i_rs1en,\n    input disp_i_rs2en,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input [E203_XLEN-1:0] disp_i_rs1,\n    input [E203_XLEN-1:0] disp_i_rs2,\n    input disp_i_rdwen,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input [E203_DECINFO_WIDTH-1:0] disp_i_info,\n    input [E203_XLEN-1:0] disp_i_imm,\n    input [E203_PC_SIZE-1:0] disp_i_pc,\n    input disp_i_misalgn,\n    input disp_i_buserr,\n    input disp_i_ilegl,\n    output reg disp_o_alu_valid,\n    input disp_o_alu_ready,\n    input disp_o_alu_longpipe,\n    output reg [E203_XLEN-1:0] disp_o_alu_rs1,\n    output reg [E203_XLEN-1:0] disp_o_alu_rs2,\n    output reg disp_o_alu_rdwen,\n    output reg [E203_RFIDX_WIDTH-1:0] disp_o_alu_rdidx,\n    output reg [E203_DECINFO_WIDTH-1:0] disp_o_alu_info,\n    output reg [E203_XLEN-1:0] disp_o_alu_imm,\n    output reg [E203_PC_SIZE-1:0] disp_o_alu_pc,\n    output reg [E203_ITAG_WIDTH-1:0] disp_o_alu_itag,\n    output reg disp_o_alu_misalgn,\n    output reg disp_o_alu_buserr,\n    output reg disp_o_alu_ilegl,\n    input oitfrd_match_disprs1,\n    input oitfrd_match_disprs2,\n    input oitfrd_match_disprs3,\n    input oitfrd_match_disprd,\n    input [E203_ITAG_WIDTH-1:0] disp_oitf_ptr,\n    output reg disp_oitf_ena,\n    input disp_oitf_ready,\n    output reg disp_oitf_rs1fpu,\n    output reg disp_oitf_rs2fpu,\n    output reg disp_oitf_rs3fpu,\n    output reg disp_oitf_rdfpu,\n    output reg disp_oitf_rs1en,\n    output reg disp_oitf_rs2en,\n    output reg disp_oitf_rs3en,\n    output reg disp_oitf_rdwen,\n    output reg [E203_RFIDX_WIDTH-1:0] disp_oitf_rs1idx,\n    output reg [E203_RFIDX_WIDTH-1:0] disp_oitf_rs2idx,\n    output reg [E203_RFIDX_WIDTH-1:0] disp_oitf_rs3idx,\n    output reg [E203_RFIDX_WIDTH-1:0] disp_oitf_rdidx,\n    output reg [E203_PC_SIZE-1:0] disp_oitf_pc,\n    input clk,\n    input rst_n\n);\n\n    // Implementation of dispatch logic\n    always @(*) begin\n        // Default assignments\n        disp_i_ready = 1'b0;\n        disp_o_alu_valid = 1'b0;\n        disp_oitf_ena = 1'b0;\n        wfi_halt_exu_ack = 1'b0;\n\n        // Handle WFI and AMO wait conditions\n        if (wfi_halt_exu_req && oitf_empty && !amo_wait) begin\n            wfi_halt_exu_ack = 1'b1;\n        end else if (disp_i_valid && disp_o_alu_ready && disp_oitf_ready) begin\n            disp_i_ready = 1'b1;\n            disp_o_alu_valid = 1'b1;\n            disp_oitf_ena = disp_o_alu_longpipe;\n\n            // Forward operands and control signals to ALU\n            disp_o_alu_rs1 = disp_i_rs1x0 ? 0 : disp_i_rs1;\n            disp_o_alu_rs2 = disp_i_rs2x0 ? 0 : disp_i_rs2;\n            disp_o_alu_rdwen = disp_i_rdwen;\n            disp_o_alu_rdidx = disp_i_rdidx;\n            disp_o_alu_info = disp_i_info;\n            disp_o_alu_imm = disp_i_imm;\n            disp_o_alu_pc = disp_i_pc;\n            disp_o_alu_itag = disp_oitf_ptr;\n            disp_o_alu_misalgn = disp_i_misalgn;\n            disp_o_alu_buserr = disp_i_buserr;\n            disp_o_alu_ilegl = disp_i_ilegl;\n\n            // Forward information to OITF\n            disp_oitf_rs1fpu = 1'b0; // Assuming no FPU in this example\n            disp_oitf_rs2fpu = 1'b0;\n            disp_oitf_rs3fpu = 1'b0;\n            disp_oitf_rdfpu = 1'b0;\n            disp_oitf_rs1en = disp_i_rs1en;\n            disp_oitf_rs2en = disp_i_rs2en;\n            disp_oitf_rs3en = 1'b0; // Assuming no third operand\n            disp_oitf_rdwen = disp_i_rdwen;\n            disp_oitf_rs1idx = disp_i_rs1idx;\n            disp_oitf_rs2idx = disp_i_rs2idx;\n            disp_oitf_rs3idx = 0; // No third operand\n            disp_oitf_rdidx = disp_i_rdidx;\n            disp_oitf_pc = disp_i_pc;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 8, "code": "module e203_srams (\n    input wire itcm_ram_sd,\n    input wire itcm_ram_ds,\n    input wire itcm_ram_ls,\n    input wire itcm_ram_cs,\n    input wire itcm_ram_we,\n    input wire [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n    input wire [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n    input wire [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n    output wire [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n    input wire clk_itcm_ram,\n    input wire rst_itcm,\n    \n    input wire dtcm_ram_sd,\n    input wire dtcm_ram_ds,\n    input wire dtcm_ram_ls,\n    input wire dtcm_ram_cs,\n    input wire dtcm_ram_we,\n    input wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    input wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    input wire clk_dtcm_ram,\n    input wire rst_dtcm\n);\n\n`ifdef E203_HAS_ITCM\n    e203_itcm_ram itcm_ram (\n        .sd(itcm_ram_sd),\n        .ds(itcm_ram_ds),\n        .ls(itcm_ram_ls),\n        .cs(itcm_ram_cs),\n        .we(itcm_ram_we),\n        .addr(itcm_ram_addr),\n        .wem(itcm_ram_wem),\n        .din(itcm_ram_din),\n        .dout(itcm_ram_dout),\n        .clk(clk_itcm_ram),\n        .rst_n(rst_itcm)\n    );\n`endif\n\n`ifdef E203_HAS_DTCM\n    e203_dtcm_ram dtcm_ram (\n        .sd(dtcm_ram_sd),\n        .ds(dtcm_ram_ds),\n        .ls(dtcm_ram_ls),\n        .cs(dtcm_ram_cs),\n        .we(dtcm_ram_we),\n        .addr(dtcm_ram_addr),\n        .wem(dtcm_ram_wem),\n        .din(dtcm_ram_din),\n        .dout(dtcm_ram_dout),\n        .clk(clk_dtcm_ram),\n        .rst_n(rst_dtcm)\n    );\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 6, "code": "module e203_exu_oitf #(\n  parameter E203_ITAG_WIDTH = 4,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_PC_SIZE = 32,\n  parameter E203_OITF_DEPTH = 16\n)(\n  input clk,\n  input rst_n,\n\n  // Dispatch interface\n  input dis_ena,\n  input [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n  input disp_i_rdwen,\n  input disp_i_rdfpu,\n  input [E203_PC_SIZE-1:0] disp_i_pc,\n  output dis_ready,\n  output [E203_ITAG_WIDTH-1:0] dis_ptr,\n\n  // Retirement interface\n  input ret_ena,\n  output [E203_RFIDX_WIDTH-1:0] ret_rdidx,\n  output ret_rdwen,\n  output ret_rdfpu,\n  output [E203_PC_SIZE-1:0] ret_pc,\n  output [E203_ITAG_WIDTH-1:0] ret_ptr,\n  output oitf_empty,\n\n  // Dependency checking outputs\n  output oitfrd_match_disprs1,\n  output oitfrd_match_disprs2,\n  output oitfrd_match_disprs3,\n  output oitfrd_match_disprd\n);\n\n  // Internal registers for tracking the OITF entries\n  reg [E203_RFIDX_WIDTH-1:0] rdidx[E203_OITF_DEPTH-1:0];\n  reg [E203_PC_SIZE-1:0] pc[E203_OITF_DEPTH-1:0];\n  reg rdwen[E203_OITF_DEPTH-1:0];\n  reg rdfpu[E203_OITF_DEPTH-1:0];\n  reg [E203_ITAG_WIDTH-1:0] head, tail;\n  reg full, empty;\n\n  // Initialize pointers and status flags\n  integer i;\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      head <= 0;\n      tail <= 0;\n      full <= 0;\n      empty <= 1;\n      for (i = 0; i < E203_OITF_DEPTH; i = i + 1) begin\n        rdidx[i] <= 0;\n        pc[i] <= 0;\n        rdwen[i] <= 0;\n        rdfpu[i] <= 0;\n      end\n    end else begin\n      // Dispatch logic\n      if (dis_ena && !full) begin\n        rdidx[tail] <= disp_i_rdidx;\n        pc[tail] <= disp_i_pc;\n        rdwen[tail] <= disp_i_rdwen;\n        rdfpu[tail] <= disp_i_rdfpu;\n        tail <= (tail + 1) % E203_OITF_DEPTH;\n        empty <= 0;\n        full <= (tail + 1) % E203_OITF_DEPTH == head;\n      end\n\n      // Retirement logic\n      if (ret_ena && !empty) begin\n        head <= (head + 1) % E203_OITF_DEPTH;\n        full <= 0;\n        empty <= (head + 1) % E203_OITF_DEPTH == tail;\n      end\n    end\n  end\n\n  // Outputs\n  assign dis_ready = !full;\n  assign dis_ptr = tail;\n  assign ret_ptr = head;\n  assign ret_rdidx = rdidx[head];\n  assign ret_rdwen = rdwen[head];\n  assign ret_rdfpu = rdfpu[head];\n  assign ret_pc = pc[head];\n  assign oitf_empty = empty;\n\n  // Dependency checking logic\n  assign oitfrd_match_disprs1 = |({E203_OITF_DEPTH{disp_i_rs1en}} & rdwen & (rdidx == disp_i_rs1idx));\n  assign oitfrd_match_disprs2 = |({E203_OITF_DEPTH{disp_i_rs2en}} & rdwen & (rdidx == disp_i_rs2idx));\n  assign oitfrd_match_disprs3 = |({E203_OITF_DEPTH{disp_i_rs3en}} & rdwen & (rdidx == disp_i_rs3idx));\n  assign oitfrd_match_disprd = |(rdwen & (rdidx == disp_i_rdidx));\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 9, "code": "module e203_exu_alu_bjp (\n    input wire bjp_i_valid,\n    output wire bjp_i_ready,\n    input wire [E203_XLEN-1:0] bjp_i_rs1,\n    input wire [E203_XLEN-1:0] bjp_i_rs2,\n    input wire [E203_XLEN-1:0] bjp_i_imm,\n    input wire [E203_PC_SIZE-1:0] bjp_i_pc,\n    input wire [E203_DECINFO_BJP_WIDTH-1:0] bjp_i_info,\n    output wire bjp_o_valid,\n    input wire bjp_o_ready,\n    output wire [E203_XLEN-1:0] bjp_o_wbck_wdat,\n    output wire bjp_o_wbck_err,\n    output wire bjp_o_cmt_bjp,\n    output wire bjp_o_cmt_mret,\n    output wire bjp_o_cmt_dret,\n    output wire bjp_o_cmt_fencei,\n    output wire bjp_o_cmt_prdt,\n    output wire bjp_o_cmt_rslv,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    output wire bjp_req_alu_cmp_eq,\n    output wire bjp_req_alu_cmp_ne,\n    output wire bjp_req_alu_cmp_lt,\n    output wire bjp_req_alu_cmp_gt,\n    output wire bjp_req_alu_cmp_ltu,\n    output wire bjp_req_alu_cmp_gtu,\n    output wire bjp_req_alu_add,\n    input wire bjp_req_alu_cmp_res,\n    input wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Handshake mechanism\n    assign bjp_i_ready = bjp_o_ready;\n    assign bjp_o_valid = bjp_i_valid;\n\n    // Operand selection\n    assign bjp_req_alu_op1 = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? bjp_i_pc : bjp_i_rs1;\n    assign bjp_req_alu_op2 = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? (E203_XLEN == 32 ? 32'd4 : 32'd2) : bjp_i_rs2;\n\n    // ALU operation request generation\n    assign bjp_req_alu_cmp_eq = bjp_i_info[E203_DECINFO_BJP_BEQ];\n    assign bjp_req_alu_cmp_ne = bjp_i_info[E203_DECINFO_BJP_BNE];\n    assign bjp_req_alu_cmp_lt = bjp_i_info[E203_DECINFO_BJP_BLT];\n    assign bjp_req_alu_cmp_gt = bjp_i_info[E203_DECINFO_BJP_BGT];\n    assign bjp_req_alu_cmp_ltu = bjp_i_info[E203_DECINFO_BJP_BLTU];\n    assign bjp_req_alu_cmp_gtu = bjp_i_info[E203_DECINFO_BJP_BGTU];\n    assign bjp_req_alu_add = bjp_i_info[E203_DECINFO_BJP_JUMP];\n\n    // Commit signals\n    assign bjp_o_cmt_bjp = bjp_i_valid && (bjp_i_info[E203_DECINFO_BJP_BXX] || bjp_i_info[E203_DECINFO_BJP_JUMP]);\n    assign bjp_o_cmt_mret = bjp_i_info[E203_DECINFO_BJP_MRET];\n    assign bjp_o_cmt_dret = bjp_i_info[E203_DECINFO_BJP_DRET];\n    assign bjp_o_cmt_fencei = bjp_i_info[E203_DECINFO_BJP_FENCEI];\n\n    // Resolved and predicted results\n    assign bjp_o_cmt_prdt = bjp_i_info[E203_DECINFO_BJP_BPRDT];\n    assign bjp_o_cmt_rslv = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? 1'b1 : bjp_req_alu_cmp_res;\n\n    // Write back data and error generation\n    assign bjp_o_wbck_wdat = bjp_req_alu_add_res;\n    assign bjp_o_wbck_err = 1'b0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 3, "code": "module e203_exu_alu_dpath(\n    input wire alu_req_alu,\n    input wire alu_req_alu_add,\n    input wire alu_req_alu_sub,\n    input wire alu_req_alu_xor,\n    input wire alu_req_alu_sll,\n    input wire alu_req_alu_srl,\n    input wire alu_req_alu_sra,\n    input wire alu_req_alu_or,\n    input wire alu_req_alu_and,\n    input wire [E203_XLEN-1:0] alu_req_alu_op1,\n    input wire [E203_XLEN-1:0] alu_req_alu_op2,\n    input wire bjp_req_alu,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    input wire agu_req_alu,\n    input wire [E203_XLEN-1:0] agu_req_alu_op1,\n    input wire [E203_XLEN-1:0] agu_req_alu_op2,\n    input wire muldiv_req_alu,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    input wire muldiv_req_alu_add,\n    input wire muldiv_req_alu_sub,\n    input wire muldiv_sbf_0_ena,\n    input wire [32:0] muldiv_sbf_0_nxt,\n    input wire muldiv_sbf_1_ena,\n    input wire [32:0] muldiv_sbf_1_nxt,\n    input wire clk,\n    input wire rst_n,\n    output wire [E203_XLEN-1:0] alu_req_alu_res,\n    output wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    output wire bjp_req_alu_cmp_res,\n    output wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output wire [32:0] muldiv_sbf_0_r,\n    output wire [32:0] muldiv_sbf_1_r\n);\n\n    // Internal signals for ALU operations\n    wire [E203_XLEN-1:0] add_res;\n    wire [E203_XLEN-1:0] sub_res;\n    wire [E203_XLEN-1:0] xor_res;\n    wire [E203_XLEN-1:0] sll_res;\n    wire [E203_XLEN-1:0] srl_res;\n    wire [E203_XLEN-1:0] sra_res;\n    wire [E203_XLEN-1:0] or_res;\n    wire [E203_XLEN-1:0] and_res;\n\n    // ALU operation implementations\n    assign add_res = alu_req_alu_op1 + alu_req_alu_op2;\n    assign sub_res = alu_req_alu_op1 - alu_req_alu_op2;\n    assign xor_res = alu_req_alu_op1 ^ alu_req_alu_op2;\n    assign sll_res = alu_req_alu_op1 << alu_req_alu_op2;\n    assign srl_res = alu_req_alu_op1 >> alu_req_alu_op2;\n    assign sra_res = $signed(alu_req_alu_op1) >>> alu_req_alu_op2;\n    assign or_res = alu_req_alu_op1 | alu_req_alu_op2;\n    assign and_res = alu_req_alu_op1 & alu_req_alu_op2;\n\n    // Result multiplexing based on operation request\n    assign alu_req_alu_res = ({E203_XLEN{alu_req_alu_add}} & add_res) |\n                             ({E203_XLEN{alu_req_alu_sub}} & sub_res) |\n                             ({E203_XLEN{alu_req_alu_xor}} & xor_res) |\n                             ({E203_XLEN{alu_req_alu_sll}} & sll_res) |\n                             ({E203_XLEN{alu_req_alu_srl}} & srl_res) |\n                             ({E203_XLEN{alu_req_alu_sra}} & sra_res) |\n                             ({E203_XLEN{alu_req_alu_or}} & or_res) |\n                             ({E203_XLEN{alu_req_alu_and}} & and_res);\n\n    // BJP and AGU operation results\n    assign bjp_req_alu_add_res = bjp_req_alu_op1 + bjp_req_alu_op2;\n    assign bjp_req_alu_cmp_res = (bjp_req_alu_op1 == bjp_req_alu_op2);\n    assign agu_req_alu_res = agu_req_alu_op1 + agu_req_alu_op2;\n\n    // MULDIV operation results\n    wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_add_res = muldiv_req_alu_op1 + muldiv_req_alu_op2;\n    wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_sub_res = muldiv_req_alu_op1 - muldiv_req_alu_op2;\n    assign muldiv_req_alu_res = ({E203_ALU_ADDER_WIDTH{muldiv_req_alu_add}} & muldiv_add_res) |\n                                ({E203_ALU_ADDER_WIDTH{muldiv_req_alu_sub}} & muldiv_sub_res);\n\n    // Shared buffer handling\n    sirv_gnrl_dffl #(.DW(33)) sbf_0_dffl (\n        .lden(muldiv_sbf_0_ena),\n        .dnxt(muldiv_sbf_0_nxt),\n        .qout(muldiv_sbf_0_r),\n        .clk(clk)\n    );\n\n    sirv_gnrl_dffl #(.DW(33)) sbf_1_dffl (\n        .lden(muldiv_sbf_1_ena),\n        .dnxt(muldiv_sbf_1_nxt),\n        .qout(muldiv_sbf_1_r),\n        .clk(clk)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 9, "code": "module e203_srams #(\n  parameter E203_ITCM_RAM_AW = 12, // Address width for ITCM\n  parameter E203_ITCM_RAM_MW = 4,  // Write mask width for ITCM\n  parameter E203_ITCM_RAM_DW = 32, // Data width for ITCM\n  parameter E203_DTCM_RAM_AW = 12, // Address width for DTCM\n  parameter E203_DTCM_RAM_MW = 4,  // Write mask width for DTCM\n  parameter E203_DTCM_RAM_DW = 32  // Data width for DTCM\n)(\n  input  wire                     clk,\n  input  wire                     rst_n,\n\n  // ITCM Interface\n  input  wire                     itcm_ram_cs,\n  input  wire                     itcm_ram_we,\n  input  wire [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n  input  wire [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n  input  wire [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n  output wire [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n\n  // DTCM Interface\n  input  wire                     dtcm_ram_cs,\n  input  wire                     dtcm_ram_we,\n  input  wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n  input  wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n  input  wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n  output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout\n);\n\n`ifdef E203_HAS_ITCM\n  // ITCM Memory Array\n  reg [E203_ITCM_RAM_DW-1:0] itcm_ram [(2**E203_ITCM_RAM_AW)-1:0];\n\n  always @(posedge clk) begin\n    if (itcm_ram_cs && itcm_ram_we) begin\n      for (int i = 0; i < E203_ITCM_RAM_MW; i++) begin\n        if (itcm_ram_wem[i])\n          itcm_ram[itcm_ram_addr][8*i+:8] <= itcm_ram_din[8*i+:8];\n      end\n    end\n  end\n\n  assign itcm_ram_dout = itcm_ram[itcm_ram_addr];\n`endif\n\n`ifdef E203_HAS_DTCM\n  // DTCM Memory Array\n  reg [E203_DTCM_RAM_DW-1:0] dtcm_ram [(2**E203_DTCM_RAM_AW)-1:0];\n\n  always @(posedge clk) begin\n    if (dtcm_ram_cs && dtcm_ram_we) begin\n      for (int i = 0; i < E203_DTCM_RAM_MW; i++) begin\n        if (dtcm_ram_wem[i])\n          dtcm_ram[dtcm_ram_addr][8*i+:8] <= dtcm_ram_din[8*i+:8];\n      end\n    end\n  end\n\n  assign dtcm_ram_dout = dtcm_ram[dtcm_ram_addr];\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 4, "code": "module e203_exu_wbck (\n    input wire alu_wbck_i_valid,\n    output wire alu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] alu_wbck_i_wdat,\n    input wire [E203_RFIDX_WIDTH-1:0] alu_wbck_i_rdidx,\n    input wire longp_wbck_i_valid,\n    output wire longp_wbck_i_ready,\n    input wire [E203_FLEN-1:0] longp_wbck_i_wdat,\n    input wire [4:0] longp_wbck_i_flags,\n    input wire [E203_RFIDX_WIDTH-1:0] longp_wbck_i_rdidx,\n    input wire longp_wbck_i_rdfpu,\n    output wire rf_wbck_o_ena,\n    output wire [E203_XLEN-1:0] rf_wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] rf_wbck_o_rdidx,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Arbitration logic\n    assign longp_wbck_i_ready = longp_wbck_i_valid;\n    assign alu_wbck_i_ready = !longp_wbck_i_valid & alu_wbck_i_valid;\n\n    // Write-back data selection\n    wire [E203_XLEN-1:0] selected_wdat = longp_wbck_i_valid ? longp_wbck_i_wdat : alu_wbck_i_wdat;\n    wire [E203_RFIDX_WIDTH-1:0] selected_rdidx = longp_wbck_i_valid ? longp_wbck_i_rdidx : alu_wbck_i_rdidx;\n    wire selected_rdfpu = longp_wbck_i_valid ? longp_wbck_i_rdfpu : 1'b0;\n\n    // Write-back enable logic\n    assign rf_wbck_o_ena = (alu_wbck_i_valid | longp_wbck_i_valid) & !selected_rdfpu;\n    assign rf_wbck_o_wdat = selected_wdat;\n    assign rf_wbck_o_rdidx = selected_rdidx;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 13, "code": "module e203_biu(\n    input wire clk,\n    input wire rst_n,\n\n    // Control signals\n    output wire biu_active,\n\n    // ICB interface from LSU\n    input wire lsu_icb_cmd_valid,\n    output wire lsu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] lsu_icb_cmd_addr,\n    input wire lsu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] lsu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] lsu_icb_cmd_wmask,\n    input wire [1:0] lsu_icb_cmd_burst,\n    input wire [1:0] lsu_icb_cmd_beat,\n    input wire lsu_icb_cmd_lock,\n    input wire lsu_icb_cmd_excl,\n    input wire [1:0] lsu_icb_cmd_size,\n    output wire lsu_icb_rsp_valid,\n    input wire lsu_icb_rsp_ready,\n    output wire lsu_icb_rsp_err,\n    output wire lsu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] lsu_icb_rsp_rdata,\n\n    // ICB interface from IFU\n    `ifdef E203_HAS_MEM_ITF\n    input wire ifu_icb_cmd_valid,\n    output wire ifu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] ifu_icb_cmd_addr,\n    input wire ifu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ifu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] ifu_icb_cmd_wmask,\n    input wire [1:0] ifu_icb_cmd_burst,\n    input wire [1:0] ifu_icb_cmd_beat,\n    input wire ifu_icb_cmd_lock,\n    input wire ifu_icb_cmd_excl,\n    input wire [1:0] ifu_icb_cmd_size,\n    output wire ifu_icb_rsp_valid,\n    input wire ifu_icb_rsp_ready,\n    output wire ifu_icb_rsp_err,\n    output wire ifu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] ifu_icb_rsp_rdata,\n    `endif\n\n    // ICB interface to MEM\n    `ifdef E203_HAS_MEM_ITF\n    output wire mem_icb_cmd_valid,\n    input wire mem_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] mem_icb_cmd_addr,\n    output wire mem_icb_cmd_read,\n    output wire [E203_XLEN-1:0] mem_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] mem_icb_cmd_wmask,\n    output wire [1:0] mem_icb_cmd_burst,\n    output wire [1:0] mem_icb_cmd_beat,\n    output wire mem_icb_cmd_lock,\n    output wire mem_icb_cmd_excl,\n    output wire [1:0] mem_icb_cmd_size,\n    input wire mem_icb_rsp_valid,\n    output wire mem_icb_rsp_ready,\n    input wire mem_icb_rsp_err,\n    input wire mem_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] mem_icb_rsp_rdata,\n    `endif\n\n    // Additional signals for peripherals (PPI, CLINT, PLIC, FIO)\n    input wire ppi_region_indic,\n    input wire ppi_icb_enable,\n    input wire clint_region_indic,\n    input wire clint_icb_enable,\n    input wire plic_region_indic,\n    input wire plic_icb_enable,\n    `ifdef E203_HAS_FIO\n    input wire fio_region_indic,\n    input wire fio_icb_enable,\n    `endif\n\n    // Outputs to peripherals\n    output wire ppi_icb_cmd_valid,\n    input wire ppi_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] ppi_icb_cmd_addr,\n    output wire ppi_icb_cmd_read,\n    output wire [E203_XLEN-1:0] ppi_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] ppi_icb_cmd_wmask,\n    output wire [1:0] ppi_icb_cmd_burst,\n    output wire [1:0] ppi_icb_cmd_beat,\n    output wire ppi_icb_cmd_lock,\n    output wire ppi_icb_cmd_excl,\n    output wire [1:0] ppi_icb_cmd_size,\n    input wire ppi_icb_rsp_valid,\n    output wire ppi_icb_rsp_ready,\n    input wire ppi_icb_rsp_err,\n    input wire ppi_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] ppi_icb_rsp_rdata,\n\n    output wire clint_icb_cmd_valid,\n    input wire clint_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] clint_icb_cmd_addr,\n    output wire clint_icb_cmd_read,\n    output wire [E203_XLEN-1:0] clint_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] clint_icb_cmd_wmask,\n    output wire [1:0] clint_icb_cmd_burst,\n    output wire [1:0] clint_icb_cmd_beat,\n    output wire clint_icb_cmd_lock,\n    output wire clint_icb_cmd_excl,\n    output wire [1:0] clint_icb_cmd_size,\n    input wire clint_icb_rsp_valid,\n    output wire clint_icb_rsp_ready,\n    input wire clint_icb_rsp_err,\n    input wire clint_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] clint_icb_rsp_rdata,\n\n    output wire plic_icb_cmd_valid,\n    input wire plic_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] plic_icb_cmd_addr,\n    output wire plic_icb_cmd_read,\n    output wire [E203_XLEN-1:0] plic_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] plic_icb_cmd_wmask,\n    output wire [1:0] plic_icb_cmd_burst,\n    output wire [1:0] plic_icb_cmd_beat,\n    output wire plic_icb_cmd_lock,\n    output wire plic_icb_cmd_excl,\n    output wire [1:0] plic_icb_cmd_size,\n    input wire plic_icb_rsp_valid,\n    output wire plic_icb_rsp_ready,\n    input wire plic_icb_rsp_err,\n    input wire plic_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] plic_icb_rsp_rdata,\n\n    `ifdef E203_HAS_FIO\n    output wire fio_icb_cmd_valid,\n    input wire fio_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] fio_icb_cmd_addr,\n    output wire fio_icb_cmd_read,\n    output wire [E203_XLEN-1:0] fio_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] fio_icb_cmd_wmask,\n    output wire [1:0] fio_icb_cmd_burst,\n    output wire [1:0] fio_icb_cmd_beat,\n    output wire fio_icb_cmd_lock,\n    output wire fio_icb_cmd_excl,\n    output wire [1:0] fio_icb_cmd_size,\n    input wire fio_icb_rsp_valid,\n    output wire fio_icb_rsp_ready,\n    input wire fio_icb_rsp_err,\n    input wire fio_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] fio_icb_rsp_rdata\n    `endif\n);\n    // Implementation of BIU logic here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 5, "code": "module e203_exu_regfile (\n    input [E203_RFIDX_WIDTH-1:0] read_src1_idx,\n    input [E203_RFIDX_WIDTH-1:0] read_src2_idx,\n    output [E203_XLEN-1:0] read_src1_dat,\n    output [E203_XLEN-1:0] read_src2_dat,\n    input wbck_dest_wen,\n    input [E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n    input [E203_XLEN-1:0] wbck_dest_dat,\n    output [E203_XLEN-1:0] x1_r,\n    input test_mode,\n    input clk,\n    input rst_n\n);\n\n// Register file storage\nreg [E203_XLEN-1:0] regfile [0:E203_RFREG_NUM-1];\n\n// Read logic\nassign read_src1_dat = (read_src1_idx == 0) ? 0 : regfile[read_src1_idx];\nassign read_src2_dat = (read_src2_idx == 0) ? 0 : regfile[read_src2_idx];\n\n// Write logic\nalways @(posedge clk) begin\n    if (wbck_dest_wen && wbck_dest_idx != 0) begin\n        regfile[wbck_dest_idx] <= wbck_dest_dat;\n    end\nend\n\n// Special register x1 output\nassign x1_r = regfile[1];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 4, "code": "module e203_exu_alu_dpath(\n    input wire alu_req_alu,\n    input wire alu_req_alu_add,\n    input wire alu_req_alu_sub,\n    input wire alu_req_alu_xor,\n    input wire alu_req_alu_sll,\n    input wire alu_req_alu_srl,\n    input wire alu_req_alu_sra,\n    input wire alu_req_alu_or,\n    input wire alu_req_alu_and,\n    input wire [E203_XLEN-1:0] alu_req_alu_op1,\n    input wire [E203_XLEN-1:0] alu_req_alu_op2,\n    input wire bjp_req_alu,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    input wire agu_req_alu,\n    input wire [E203_XLEN-1:0] agu_req_alu_op1,\n    input wire [E203_XLEN-1:0] agu_req_alu_op2,\n    input wire muldiv_req_alu,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    input wire muldiv_req_alu_add,\n    input wire muldiv_req_alu_sub,\n    input wire muldiv_sbf_0_ena,\n    input wire [32:0] muldiv_sbf_0_nxt,\n    input wire muldiv_sbf_1_ena,\n    input wire [32:0] muldiv_sbf_1_nxt,\n    input wire clk,\n    input wire rst_n,\n    output wire [E203_XLEN-1:0] alu_req_alu_res,\n    output wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    output wire bjp_req_alu_cmp_res,\n    output wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output wire [32:0] muldiv_sbf_0_r,\n    output wire [32:0] muldiv_sbf_1_r\n);\n\n    // Internal signals for ALU operations\n    wire [E203_XLEN-1:0] add_res;\n    wire [E203_XLEN-1:0] sub_res;\n    wire [E203_XLEN-1:0] xor_res;\n    wire [E203_XLEN-1:0] sll_res;\n    wire [E203_XLEN-1:0] srl_res;\n    wire [E203_XLEN-1:0] sra_res;\n    wire [E203_XLEN-1:0] or_res;\n    wire [E203_XLEN-1:0] and_res;\n\n    // Implement ALU operations\n    assign add_res = alu_req_alu_op1 + alu_req_alu_op2;\n    assign sub_res = alu_req_alu_op1 - alu_req_alu_op2;\n    assign xor_res = alu_req_alu_op1 ^ alu_req_alu_op2;\n    assign sll_res = alu_req_alu_op1 << alu_req_alu_op2[E203_XLEN-1:0];\n    assign srl_res = alu_req_alu_op1 >> alu_req_alu_op2[E203_XLEN-1:0];\n    assign sra_res = $signed(alu_req_alu_op1) >>> alu_req_alu_op2[E203_XLEN-1:0];\n    assign or_res = alu_req_alu_op1 | alu_req_alu_op2;\n    assign and_res = alu_req_alu_op1 & alu_req_alu_op2;\n\n    // Select the ALU result based on the operation\n    assign alu_req_alu_res = ({E203_XLEN{alu_req_alu_add}} & add_res) |\n                             ({E203_XLEN{alu_req_alu_sub}} & sub_res) |\n                             ({E203_XLEN{alu_req_alu_xor}} & xor_res) |\n                             ({E203_XLEN{alu_req_alu_sll}} & sll_res) |\n                             ({E203_XLEN{alu_req_alu_srl}} & srl_res) |\n                             ({E203_XLEN{alu_req_alu_sra}} & sra_res) |\n                             ({E203_XLEN{alu_req_alu_or}} & or_res) |\n                             ({E203_XLEN{alu_req_alu_and}} & and_res);\n\n    // BJP operations\n    assign bjp_req_alu_add_res = bjp_req_alu_op1 + bjp_req_alu_op2;\n    assign bjp_req_alu_cmp_res = (bjp_req_alu_op1 == bjp_req_alu_op2);\n\n    // AGU operations\n    assign agu_req_alu_res = (agu_req_alu_op1 + agu_req_alu_op2); // Example for add operation\n\n    // MULDIV operations\n    assign muldiv_req_alu_res = (muldiv_req_alu_add ? (muldiv_req_alu_op1 + muldiv_req_alu_op2) :\n                                muldiv_req_alu_sub ? (muldiv_req_alu_op1 - muldiv_req_alu_op2) : {E203_ALU_ADDER_WIDTH{1'b0}});\n\n    // Shared buffers\n    sirv_gnrl_dffl #(.DW(33)) sbf_0_dffl (\n        .lden(muldiv_sbf_0_ena),\n        .dnxt(muldiv_sbf_0_nxt),\n        .qout(muldiv_sbf_0_r),\n        .clk(clk)\n    );\n\n    sirv_gnrl_dffl #(.DW(33)) sbf_1_dffl (\n        .lden(muldiv_sbf_1_ena),\n        .dnxt(muldiv_sbf_1_nxt),\n        .qout(muldiv_sbf_1_r),\n        .clk(clk)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 5, "code": "module e203_exu_wbck(\n    input wire alu_wbck_i_valid,\n    output wire alu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] alu_wbck_i_wdat,\n    input wire [E203_RFIDX_WIDTH-1:0] alu_wbck_i_rdidx,\n    input wire longp_wbck_i_valid,\n    output wire longp_wbck_i_ready,\n    input wire [E203_FLEN-1:0] longp_wbck_i_wdat,\n    input wire [4:0] longp_wbck_i_flags,\n    input wire [E203_RFIDX_WIDTH-1:0] longp_wbck_i_rdidx,\n    input wire longp_wbck_i_rdfpu,\n    output wire rf_wbck_o_ena,\n    output wire [E203_XLEN-1:0] rf_wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] rf_wbck_o_rdidx,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Arbitration logic\n    assign longp_wbck_i_ready = longp_wbck_i_valid;\n    assign alu_wbck_i_ready = !longp_wbck_i_valid && alu_wbck_i_valid;\n\n    // Write-back data selection\n    wire [E203_XLEN-1:0] selected_wdat = longp_wbck_i_valid ? longp_wbck_i_wdat : alu_wbck_i_wdat;\n    wire [E203_RFIDX_WIDTH-1:0] selected_rdidx = longp_wbck_i_valid ? longp_wbck_i_rdidx : alu_wbck_i_rdidx;\n    wire selected_rdfpu = longp_wbck_i_valid ? longp_wbck_i_rdfpu : 1'b0;\n\n    // Write-back enable\n    assign rf_wbck_o_ena = (alu_wbck_i_valid || longp_wbck_i_valid) && !selected_rdfpu;\n\n    // Output assignment\n    assign rf_wbck_o_wdat = selected_wdat;\n    assign rf_wbck_o_rdidx = selected_rdidx;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 8, "code": "module e203_exu_alu_csrctrl(\n    input wire csr_i_valid,\n    output reg csr_i_ready,\n    input wire [E203_XLEN-1:0] csr_i_rs1,\n    input wire [E203_DECINFO_CSR_WIDTH-1:0] csr_i_info,\n    input wire csr_i_rdwen,\n    output reg csr_ena,\n    output reg csr_wr_en,\n    output reg csr_rd_en,\n    output reg [11:0] csr_idx,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output reg [E203_XLEN-1:0] wbck_csr_dat,\n    output reg csr_o_valid,\n    input wire csr_o_ready,\n    output reg [E203_XLEN-1:0] csr_o_wbck_wdat,\n    output reg csr_o_wbck_err,\n    input wire clk,\n    input wire rst_n,\n    input wire nice_xs_off,\n    output reg csr_sel_nice,\n    output reg nice_csr_valid,\n    input wire nice_csr_ready,\n    output reg [31:0] nice_csr_addr,\n    output reg nice_csr_wr,\n    output reg [31:0] nice_csr_wdata,\n    input wire [31:0] nice_csr_rdata\n);\n\n    always @(*) begin\n        csr_i_ready = csr_o_ready;\n        csr_o_valid = csr_i_valid && csr_o_ready;\n        csr_ena = csr_i_valid && csr_o_ready && !nice_xs_off;\n\n        csr_idx = csr_i_info[E203_DECINFO_CSR_CSRIDX +: 12];\n        csr_sel_nice = (csr_idx[11:8] == 4'hE) && !nice_xs_off;\n\n        if (csr_sel_nice) begin\n            nice_csr_valid = csr_i_valid && csr_o_ready;\n            nice_csr_addr = {20'h0, csr_idx};\n            nice_csr_wr = csr_i_info[E203_DECINFO_CSR_CSRRW];\n            nice_csr_wdata = csr_i_rs1;\n            wbck_csr_dat = nice_csr_rdata;\n        end else begin\n            nice_csr_valid = 1'b0;\n            csr_rd_en = csr_i_valid && (csr_i_info[E203_DECINFO_CSR_CSRRW] || csr_i_info[E203_DECINFO_CSR_CSRRS] || csr_i_info[E203_DECINFO_CSR_CSRRC]);\n            csr_wr_en = csr_i_valid && ((csr_i_info[E203_DECINFO_CSR_CSRRW] && csr_i_rdwen) || (csr_i_info[E203_DECINFO_CSR_CSRRS] && !csr_i_info[E203_DECINFO_CSR_RS1IS0]) || (csr_i_info[E203_DECINFO_CSR_CSRRC] && !csr_i_info[E203_DECINFO_CSR_RS1IS0]));\n            wbck_csr_dat = (csr_i_info[E203_DECINFO_CSR_CSRRW] ? csr_i_rs1 : (csr_i_info[E203_DECINFO_CSR_CSRRS] ? (read_csr_dat | csr_i_rs1) : (read_csr_dat & ~csr_i_rs1)));\n        end\n\n        csr_o_wbck_wdat = read_csr_dat;\n        csr_o_wbck_err = csr_access_ilgl;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 4, "code": "module e203_ifu_minidec #(\n  parameter E203_INSTR_SIZE = 32,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_XLEN = 32\n)(\n  input [E203_INSTR_SIZE-1:0] instr,\n  output dec_rs1en,\n  output dec_rs2en,\n  output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n  output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n  output dec_mulhsu,\n  output dec_mul,\n  output dec_div,\n  output dec_rem,\n  output dec_divu,\n  output dec_remu,\n  output dec_rv32,\n  output dec_bjp,\n  output dec_jal,\n  output dec_jalr,\n  output dec_bxx,\n  output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  output [E203_XLEN-1:0] dec_bjp_imm\n);\n\n  // Internal signals for decoding logic\n  wire [6:0] opcode = instr[6:0];\n  wire [2:0] funct3 = instr[14:12];\n  wire [6:0] funct7 = instr[31:25];\n\n  // Decode logic for register enable signals\n  assign dec_rs1en = (opcode == 7'b1100111) || (opcode == 7'b1100011) || (opcode == 7'b0100011);\n  assign dec_rs2en = (opcode == 7'b1100011) || (opcode == 7'b0100011);\n\n  // Decode logic for register indices\n  assign dec_rs1idx = instr[19:15];\n  assign dec_rs2idx = instr[24:20];\n  assign dec_jalr_rs1idx = (opcode == 7'b1100111) ? instr[19:15] : {E203_RFIDX_WIDTH{1'b0}};\n\n  // Decode logic for operation type flags\n  assign dec_mulhsu = (opcode == 7'b0110011) && (funct3 == 3'b010) && (funct7 == 7'b0000001);\n  assign dec_mul = (opcode == 7'b0110011) && (funct3 == 3'b000) && (funct7 == 7'b0000001);\n  assign dec_div = (opcode == 7'b0110011) && (funct3 == 3'b100) && (funct7 == 7'b0000001);\n  assign dec_rem = (opcode == 7'b0110011) && (funct3 == 3'b110) && (funct7 == 7'b0000001);\n  assign dec_divu = (opcode == 7'b0110011) && (funct3 == 3'b101) && (funct7 == 7'b0000001);\n  assign dec_remu = (opcode == 7'b0110011) && (funct3 == 3'b111) && (funct7 == 7'b0000001);\n\n  // Decode logic for instruction set flags\n  assign dec_rv32 = 1'b1; // Assuming RV32 for simplicity\n\n  // Decode logic for branch/jump flags\n  assign dec_bjp = (opcode == 7'b1100011) || (opcode == 7'b1101111) || (opcode == 7'b1100111);\n  assign dec_jal = (opcode == 7'b1101111);\n  assign dec_jalr = (opcode == 7'b1100111);\n  assign dec_bxx = (opcode == 7'b1100011);\n\n  // Immediate extraction for branch/jump instructions\n  assign dec_bjp_imm = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 7, "code": "module e203_exu_oitf #(\n  parameter E203_ITAG_WIDTH = 4,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_PC_SIZE = 32,\n  parameter E203_OITF_DEPTH = 8\n)(\n  input clk,\n  input rst_n,\n\n  output dis_ready,\n  input dis_ena,\n  input ret_ena,\n\n  output [E203_ITAG_WIDTH-1:0] dis_ptr,\n  output [E203_ITAG_WIDTH-1:0] ret_ptr,\n  output [E203_RFIDX_WIDTH-1:0] ret_rdidx,\n  output ret_rdwen,\n  output ret_rdfpu,\n  output [E203_PC_SIZE-1:0] ret_pc,\n\n  input disp_i_rs1en,\n  input disp_i_rs2en,\n  input disp_i_rs3en,\n  input disp_i_rdwen,\n  input disp_i_rs1fpu,\n  input disp_i_rs2fpu,\n  input disp_i_rs3fpu,\n  input disp_i_rdfpu,\n  input [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n  input [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n  input [E203_RFIDX_WIDTH-1:0] disp_i_rs3idx,\n  input [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n  input [E203_PC_SIZE-1:0] disp_i_pc,\n\n  output oitfrd_match_disprs1,\n  output oitfrd_match_disprs2,\n  output oitfrd_match_disprs3,\n  output oitfrd_match_disprd,\n  output oitf_empty\n);\n\n  reg [E203_RFIDX_WIDTH-1:0] rdidx [E203_OITF_DEPTH-1:0];\n  reg [E203_PC_SIZE-1:0] pc [E203_OITF_DEPTH-1:0];\n  reg [E203_OITF_DEPTH-1:0] rdwen;\n  reg [E203_OITF_DEPTH-1:0] rdfpu;\n  reg [E203_ITAG_WIDTH-1:0] head, tail;\n  reg full, empty;\n\n  assign dis_ready = !full;\n  assign oitf_empty = empty;\n\n  integer i;\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      head <= 0;\n      tail <= 0;\n      full <= 0;\n      empty <= 1;\n      for (i = 0; i < E203_OITF_DEPTH; i = i + 1) begin\n        rdwen[i] <= 0;\n        rdfpu[i] <= 0;\n      end\n    end else begin\n      if (dis_ena && dis_ready) begin\n        rdidx[tail] <= disp_i_rdidx;\n        pc[tail] <= disp_i_pc;\n        rdwen[tail] <= disp_i_rdwen;\n        rdfpu[tail] <= disp_i_rdfpu;\n        tail <= tail + 1;\n        empty <= 0;\n        if (tail + 1 == head) full <= 1;\n      end\n      if (ret_ena && !empty) begin\n        head <= head + 1;\n        full <= 0;\n        if (head + 1 == tail) empty <= 1;\n      end\n    end\n  end\n\n  assign ret_rdidx = rdidx[head];\n  assign ret_pc = pc[head];\n  assign ret_rdwen = rdwen[head];\n  assign ret_rdfpu = rdfpu[head];\n\n  assign oitfrd_match_disprs1 = |(rdwen & rdfpu & (rdidx == disp_i_rs1idx));\n  assign oitfrd_match_disprs2 = |(rdwen & rdfpu & (rdidx == disp_i_rs2idx));\n  assign oitfrd_match_disprs3 = |(rdwen & rdfpu & (rdidx == disp_i_rs3idx));\n  assign oitfrd_match_disprd = |(rdwen & rdfpu & (rdidx == disp_i_rdidx));\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 14, "code": "module e203_biu(\n    input wire clk,\n    input wire rst_n,\n    output wire biu_active,\n\n    // ICB Interface to LSU\n    input wire lsu_icb_cmd_valid,\n    output wire lsu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] lsu_icb_cmd_addr,\n    input wire lsu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] lsu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] lsu_icb_cmd_wmask,\n    input wire [1:0] lsu_icb_cmd_burst,\n    input wire [1:0] lsu_icb_cmd_beat,\n    input wire lsu_icb_cmd_lock,\n    input wire lsu_icb_cmd_excl,\n    input wire [1:0] lsu_icb_cmd_size,\n    output wire lsu_icb_rsp_valid,\n    input wire lsu_icb_rsp_ready,\n    output wire lsu_icb_rsp_err,\n    output wire lsu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] lsu_icb_rsp_rdata,\n\n    // ICB Interface to IFU\n    `ifdef E203_HAS_MEM_ITF\n    input wire ifu_icb_cmd_valid,\n    output wire ifu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] ifu_icb_cmd_addr,\n    input wire ifu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ifu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] ifu_icb_cmd_wmask,\n    input wire [1:0] ifu_icb_cmd_burst,\n    input wire [1:0] ifu_icb_cmd_beat,\n    input wire ifu_icb_cmd_lock,\n    input wire ifu_icb_cmd_excl,\n    input wire [1:0] ifu_icb_cmd_size,\n    output wire ifu_icb_rsp_valid,\n    input wire ifu_icb_rsp_ready,\n    output wire ifu_icb_rsp_err,\n    output wire ifu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] ifu_icb_rsp_rdata,\n    `endif\n\n    // ICB Interface to PPI\n    input wire ppi_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] ppi_region_indic,\n    input wire ppi_icb_cmd_valid,\n    output wire ppi_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] ppi_icb_cmd_addr,\n    input wire ppi_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ppi_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] ppi_icb_cmd_wmask,\n    input wire [1:0] ppi_icb_cmd_burst,\n    input wire [1:0] ppi_icb_cmd_beat,\n    input wire ppi_icb_cmd_lock,\n    input wire ppi_icb_cmd_excl,\n    input wire [1:0] ppi_icb_cmd_size,\n    output wire ppi_icb_rsp_valid,\n    input wire ppi_icb_rsp_ready,\n    output wire ppi_icb_rsp_err,\n    output wire ppi_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] ppi_icb_rsp_rdata,\n\n    // ICB Interface to CLINT\n    input wire clint_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] clint_region_indic,\n    input wire clint_icb_cmd_valid,\n    output wire clint_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] clint_icb_cmd_addr,\n    input wire clint_icb_cmd_read,\n    input wire [E203_XLEN-1:0] clint_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] clint_icb_cmd_wmask,\n    input wire [1:0] clint_icb_cmd_burst,\n    input wire [1:0] clint_icb_cmd_beat,\n    input wire clint_icb_cmd_lock,\n    input wire clint_icb_cmd_excl,\n    input wire [1:0] clint_icb_cmd_size,\n    output wire clint_icb_rsp_valid,\n    input wire clint_icb_rsp_ready,\n    output wire clint_icb_rsp_err,\n    output wire clint_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] clint_icb_rsp_rdata,\n\n    // ICB Interface to PLIC\n    input wire plic_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] plic_region_indic,\n    input wire plic_icb_cmd_valid,\n    output wire plic_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] plic_icb_cmd_addr,\n    input wire plic_icb_cmd_read,\n    input wire [E203_XLEN-1:0] plic_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] plic_icb_cmd_wmask,\n    input wire [1:0] plic_icb_cmd_burst,\n    input wire [1:0] plic_icb_cmd_beat,\n    input wire plic_icb_cmd_lock,\n    input wire plic_icb_cmd_excl,\n    input wire [1:0] plic_icb_cmd_size,\n    output wire plic_icb_rsp_valid,\n    input wire plic_icb_rsp_ready,\n    output wire plic_icb_rsp_err,\n    output wire plic_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] plic_icb_rsp_rdata,\n\n    // ICB Interface to FIO\n    `ifdef E203_HAS_FIO\n    input wire fio_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] fio_region_indic,\n    input wire fio_icb_cmd_valid,\n    output wire fio_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] fio_icb_cmd_addr,\n    input wire fio_icb_cmd_read,\n    input wire [E203_XLEN-1:0] fio_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] fio_icb_cmd_wmask,\n    input wire [1:0] fio_icb_cmd_burst,\n    input wire [1:0] fio_icb_cmd_beat,\n    input wire fio_icb_cmd_lock,\n    input wire fio_icb_cmd_excl,\n    input wire [1:0] fio_icb_cmd_size,\n    output wire fio_icb_rsp_valid,\n    input wire fio_icb_rsp_ready,\n    output wire fio_icb_rsp_err,\n    output wire fio_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] fio_icb_rsp_rdata,\n    `endif\n\n    // ICB Interface to MEM\n    `ifdef E203_HAS_MEM_ITF\n    input wire mem_icb_enable,\n    input wire mem_icb_cmd_valid,\n    output wire mem_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] mem_icb_cmd_addr,\n    input wire mem_icb_cmd_read,\n    input wire [E203_XLEN-1:0] mem_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] mem_icb_cmd_wmask,\n    input wire [1:0] mem_icb_cmd_burst,\n    input wire [1:0] mem_icb_cmd_beat,\n    input wire mem_icb_cmd_lock,\n    input wire mem_icb_cmd_excl,\n    input wire [1:0] mem_icb_cmd_size,\n    output wire mem_icb_rsp_valid,\n    input wire mem_icb_rsp_ready,\n    output wire mem_icb_rsp_err,\n    output wire mem_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] mem_icb_rsp_rdata\n    `endif\n);\n    // BIU logic implementation here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 5, "code": "`include \"e203_defines.v\"\n\nmodule e203_itcm_ram #(\n  parameter FORCE_X2ZERO = 0,\n  parameter DP = `E203_ITCM_RAM_DP,\n  parameter DW = `E203_ITCM_RAM_DW,\n  parameter MW = `E203_ITCM_RAM_MW,\n  parameter AW = `E203_ITCM_RAM_AW\n)(\n  input wire sd,\n  input wire ds,\n  input wire ls,\n  input wire cs,\n  input wire we,\n  input wire [AW-1:0] addr,\n  input wire [MW-1:0] wem,\n  input wire [DW-1:0] din,\n  input wire rst_n,\n  input wire clk,\n  output wire [DW-1:0] dout\n);\n\n  sirv_gnrl_ram #(\n    .FORCE_X2ZERO(FORCE_X2ZERO),\n    .DP(DP),\n    .DW(DW),\n    .MW(MW),\n    .AW(AW)\n  ) i_sirv_gnrl_ram (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 6, "code": "module e203_exu_alu_rglr(\n    input wire alu_i_valid,\n    output reg alu_i_ready,\n    input wire [E203_XLEN-1:0] alu_i_rs1,\n    input wire [E203_XLEN-1:0] alu_i_rs2,\n    input wire [E203_XLEN-1:0] alu_i_imm,\n    input wire [E203_PC_SIZE-1:0] alu_i_pc,\n    input wire [E203_DECINFO_ALU_WIDTH-1:0] alu_i_info,\n    output reg alu_o_valid,\n    input wire alu_o_ready,\n    output reg [E203_XLEN-1:0] alu_o_wbck_wdat,\n    output reg alu_o_wbck_err,\n    output reg alu_o_cmt_ecall,\n    output reg alu_o_cmt_ebreak,\n    output reg alu_o_cmt_wfi,\n    output reg alu_req_alu_add,\n    output reg alu_req_alu_sub,\n    output reg alu_req_alu_xor,\n    output reg alu_req_alu_sll,\n    output reg alu_req_alu_srl,\n    output reg alu_req_alu_sra,\n    output reg alu_req_alu_or,\n    output reg alu_req_alu_and,\n    output reg alu_req_alu_slt,\n    output reg alu_req_alu_sltu,\n    output reg alu_req_alu_lui,\n    output reg [E203_XLEN-1:0] alu_req_alu_op1,\n    output reg [E203_XLEN-1:0] alu_req_alu_op2,\n    output reg [E203_XLEN-1:0] alu_req_alu_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    always @(*) begin\n        // Handshake signals\n        alu_i_ready = alu_o_ready;\n        alu_o_valid = alu_i_valid;\n\n        // Default outputs\n        alu_o_wbck_wdat = 0;\n        alu_o_wbck_err = 0;\n        alu_o_cmt_ecall = 0;\n        alu_o_cmt_ebreak = 0;\n        alu_o_cmt_wfi = 0;\n\n        // Default ALU operation requests\n        alu_req_alu_add = 0;\n        alu_req_alu_sub = 0;\n        alu_req_alu_xor = 0;\n        alu_req_alu_sll = 0;\n        alu_req_alu_srl = 0;\n        alu_req_alu_sra = 0;\n        alu_req_alu_or = 0;\n        alu_req_alu_and = 0;\n        alu_req_alu_slt = 0;\n        alu_req_alu_sltu = 0;\n        alu_req_alu_lui = 0;\n\n        // Operand selection\n        alu_req_alu_op1 = (alu_i_info[E203_DECINFO_ALU_OP1PC]) ? alu_i_pc : alu_i_rs1;\n        alu_req_alu_op2 = (alu_i_info[E203_DECINFO_ALU_OP2IMM]) ? alu_i_imm : alu_i_rs2;\n\n        // Operation request generation\n        if (alu_i_valid) begin\n            case (1'b1) // synthesis parallel_case\n                alu_i_info[E203_DECINFO_ALU_ADD]: alu_req_alu_add = 1;\n                alu_i_info[E203_DECINFO_ALU_SUB]: alu_req_alu_sub = 1;\n                alu_i_info[E203_DECINFO_ALU_XOR]: alu_req_alu_xor = 1;\n                alu_i_info[E203_DECINFO_ALU_SLL]: alu_req_alu_sll = 1;\n                alu_i_info[E203_DECINFO_ALU_SRL]: alu_req_alu_srl = 1;\n                alu_i_info[E203_DECINFO_ALU_SRA]: alu_req_alu_sra = 1;\n                alu_i_info[E203_DECINFO_ALU_OR]: alu_req_alu_or = 1;\n                alu_i_info[E203_DECINFO_ALU_AND]: alu_req_alu_and = 1;\n                alu_i_info[E203_DECINFO_ALU_SLT]: alu_req_alu_slt = 1;\n                alu_i_info[E203_DECINFO_ALU_SLTU]: alu_req_alu_sltu = 1;\n                alu_i_info[E203_DECINFO_ALU_LUI]: alu_req_alu_lui = 1;\n            endcase\n\n            // Special instructions\n            alu_o_cmt_ecall = alu_i_info[E203_DECINFO_ALU_ECAL];\n            alu_o_cmt_ebreak = alu_i_info[E203_DECINFO_ALU_EBRK];\n            alu_o_cmt_wfi = alu_i_info[E203_DECINFO_ALU_WFI];\n\n            // Error handling for special instructions\n            if (alu_o_cmt_ecall || alu_o_cmt_ebreak || alu_o_cmt_wfi) begin\n                alu_o_wbck_err = 1;\n            end\n        end\n    end\n\n    // Result handling\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            alu_req_alu_res <= 0;\n        end else if (alu_i_valid && alu_o_ready) begin\n            alu_req_alu_res <= alu_o_wbck_wdat; // Assuming result is directly available\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 6, "code": "module e203_exu_wbck(\n    input wire alu_wbck_i_valid,\n    output reg alu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] alu_wbck_i_wdat,\n    input wire [E203_RFIDX_WIDTH-1:0] alu_wbck_i_rdidx,\n    input wire longp_wbck_i_valid,\n    output reg longp_wbck_i_ready,\n    input wire [E203_FLEN-1:0] longp_wbck_i_wdat,\n    input wire [4:0] longp_wbck_i_flags,\n    input wire [E203_RFIDX_WIDTH-1:0] longp_wbck_i_rdidx,\n    input wire longp_wbck_i_rdfpu,\n    output reg rf_wbck_o_ena,\n    output reg [E203_XLEN-1:0] rf_wbck_o_wdat,\n    output reg [E203_RFIDX_WIDTH-1:0] rf_wbck_o_rdidx,\n    input wire clk,\n    input wire rst_n\n);\n\n    always @(*) begin\n        // Default assignments\n        alu_wbck_i_ready = 1'b0;\n        longp_wbck_i_ready = 1'b0;\n        rf_wbck_o_ena = 1'b0;\n        rf_wbck_o_wdat = {E203_XLEN{1'b0}};\n        rf_wbck_o_rdidx = {E203_RFIDX_WIDTH{1'b0}};\n\n        // Arbitration logic\n        if (longp_wbck_i_valid) begin\n            longp_wbck_i_ready = 1'b1;\n            alu_wbck_i_ready = 1'b0;\n            rf_wbck_o_ena = !longp_wbck_i_rdfpu;\n            rf_wbck_o_wdat = longp_wbck_i_wdat;\n            rf_wbck_o_rdidx = longp_wbck_i_rdidx;\n        end else if (alu_wbck_i_valid) begin\n            alu_wbck_i_ready = 1'b1;\n            longp_wbck_i_ready = 1'b0;\n            rf_wbck_o_ena = 1'b1;\n            rf_wbck_o_wdat = alu_wbck_i_wdat;\n            rf_wbck_o_rdidx = alu_wbck_i_rdidx;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 7, "code": "module e203_exu_alu_rglr(\n    input wire alu_i_valid,\n    output reg alu_i_ready,\n    input wire [E203_XLEN-1:0] alu_i_rs1,\n    input wire [E203_XLEN-1:0] alu_i_rs2,\n    input wire [E203_XLEN-1:0] alu_i_imm,\n    input wire [E203_PC_SIZE-1:0] alu_i_pc,\n    input wire [E203_DECINFO_ALU_WIDTH-1:0] alu_i_info,\n    output reg alu_o_valid,\n    input wire alu_o_ready,\n    output reg [E203_XLEN-1:0] alu_o_wbck_wdat,\n    output reg alu_o_wbck_err,\n    output reg alu_o_cmt_ecall,\n    output reg alu_o_cmt_ebreak,\n    output reg alu_o_cmt_wfi,\n    output reg alu_req_alu_add,\n    output reg alu_req_alu_sub,\n    output reg alu_req_alu_xor,\n    output reg alu_req_alu_sll,\n    output reg alu_req_alu_srl,\n    output reg alu_req_alu_sra,\n    output reg alu_req_alu_or,\n    output reg alu_req_alu_and,\n    output reg alu_req_alu_slt,\n    output reg alu_req_alu_sltu,\n    output reg alu_req_alu_lui,\n    output reg [E203_XLEN-1:0] alu_req_alu_op1,\n    output reg [E203_XLEN-1:0] alu_req_alu_op2,\n    output reg [E203_XLEN-1:0] alu_req_alu_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    always @(*) begin\n        // Valid-ready handshake\n        alu_i_ready = alu_o_ready;\n        alu_o_valid = alu_i_valid;\n\n        // Default outputs\n        alu_o_wbck_wdat = 0;\n        alu_o_wbck_err = 0;\n        alu_o_cmt_ecall = 0;\n        alu_o_cmt_ebreak = 0;\n        alu_o_cmt_wfi = 0;\n\n        alu_req_alu_add = 0;\n        alu_req_alu_sub = 0;\n        alu_req_alu_xor = 0;\n        alu_req_alu_sll = 0;\n        alu_req_alu_srl = 0;\n        alu_req_alu_sra = 0;\n        alu_req_alu_or = 0;\n        alu_req_alu_and = 0;\n        alu_req_alu_slt = 0;\n        alu_req_alu_sltu = 0;\n        alu_req_alu_lui = 0;\n\n        // Select operands\n        alu_req_alu_op1 = (alu_i_info[E203_DECINFO_ALU_OP1PC]) ? alu_i_pc : alu_i_rs1;\n        alu_req_alu_op2 = (alu_i_info[E203_DECINFO_ALU_OP2IMM]) ? alu_i_imm : alu_i_rs2;\n\n        // Operation decoding\n        if (alu_i_valid) begin\n            case (1'b1)\n                alu_i_info[E203_DECINFO_ALU_ADD]: alu_req_alu_add = 1;\n                alu_i_info[E203_DECINFO_ALU_SUB]: alu_req_alu_sub = 1;\n                alu_i_info[E203_DECINFO_ALU_XOR]: alu_req_alu_xor = 1;\n                alu_i_info[E203_DECINFO_ALU_SLL]: alu_req_alu_sll = 1;\n                alu_i_info[E203_DECINFO_ALU_SRL]: alu_req_alu_srl = 1;\n                alu_i_info[E203_DECINFO_ALU_SRA]: alu_req_alu_sra = 1;\n                alu_i_info[E203_DECINFO_ALU_OR]: alu_req_alu_or = 1;\n                alu_i_info[E203_DECINFO_ALU_AND]: alu_req_alu_and = 1;\n                alu_i_info[E203_DECINFO_ALU_SLT]: alu_req_alu_slt = 1;\n                alu_i_info[E203_DECINFO_ALU_SLTU]: alu_req_alu_sltu = 1;\n                alu_i_info[E203_DECINFO_ALU_LUI]: alu_req_alu_lui = 1;\n            endcase\n\n            // Special instructions\n            if (alu_i_info[E203_DECINFO_ALU_ECAL]) begin\n                alu_o_cmt_ecall = 1;\n                alu_o_wbck_err = 1;\n            end\n            if (alu_i_info[E203_DECINFO_ALU_EBRK]) begin\n                alu_o_cmt_ebreak = 1;\n                alu_o_wbck_err = 1;\n            end\n            if (alu_i_info[E203_DECINFO_ALU_WFI]) begin\n                alu_o_cmt_wfi = 1;\n                alu_o_wbck_err = 1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 7, "code": "module e203_exu_wbck (\n    input wire alu_wbck_i_valid,\n    output wire alu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] alu_wbck_i_wdat,\n    input wire [E203_RFIDX_WIDTH-1:0] alu_wbck_i_rdidx,\n    input wire longp_wbck_i_valid,\n    output wire longp_wbck_i_ready,\n    input wire [E203_FLEN-1:0] longp_wbck_i_wdat,\n    input wire [4:0] longp_wbck_i_flags,\n    input wire [E203_RFIDX_WIDTH-1:0] longp_wbck_i_rdidx,\n    input wire longp_wbck_i_rdfpu,\n    output wire rf_wbck_o_ena,\n    output wire [E203_XLEN-1:0] rf_wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] rf_wbck_o_rdidx,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Arbitration logic\n    assign alu_wbck_i_ready = !longp_wbck_i_valid && alu_wbck_i_valid;\n    assign longp_wbck_i_ready = longp_wbck_i_valid;\n\n    // Write-back data selection\n    wire [E203_XLEN-1:0] selected_wdat = longp_wbck_i_valid ? longp_wbck_i_wdat : alu_wbck_i_wdat;\n    wire [E203_RFIDX_WIDTH-1:0] selected_rdidx = longp_wbck_i_valid ? longp_wbck_i_rdidx : alu_wbck_i_rdidx;\n    wire selected_rdfpu = longp_wbck_i_valid ? longp_wbck_i_rdfpu : 1'b0;\n\n    // Write-back enable\n    assign rf_wbck_o_ena = (alu_wbck_i_valid || longp_wbck_i_valid) && !selected_rdfpu;\n\n    // Output data to register file\n    assign rf_wbck_o_wdat = selected_wdat;\n    assign rf_wbck_o_rdidx = selected_rdidx;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 7, "code": "module e203_irq_sync (\n    input wire clk,\n    input wire rst_n,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire dbg_irq_a,\n    output wire ext_irq_r,\n    output wire sft_irq_r,\n    output wire tmr_irq_r,\n    output wire dbg_irq_r\n);\n\n    // Synchronization for external interrupt\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) ext_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(ext_irq_a),\n        .dout(ext_irq_r)\n    );\n\n    // Synchronization for software interrupt\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) sft_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(sft_irq_a),\n        .dout(sft_irq_r)\n    );\n\n    // Synchronization for timer interrupt\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) tmr_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(tmr_irq_a),\n        .dout(tmr_irq_r)\n    );\n\n    // Synchronization for debug interrupt\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) dbg_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(dbg_irq_a),\n        .dout(dbg_irq_r)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 6, "code": "module e203_exu_alu_lsuagu (\n    input wire agu_i_valid,\n    output wire agu_i_ready,\n    input wire [E203_XLEN-1:0] agu_i_rs1,\n    input wire [E203_XLEN-1:0] agu_i_rs2,\n    input wire [E203_XLEN-1:0] agu_i_imm,\n    input wire [E203_DECINFO_AGU_WIDTH-1:0] agu_i_info,\n    input wire [E203_ITAG_WIDTH-1:0] agu_i_itag,\n    output wire agu_i_longpipe,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire amo_wait,\n    input wire oitf_empty,\n    output wire agu_o_valid,\n    input wire agu_o_ready,\n    output wire [E203_XLEN-1:0] agu_o_wbck_wdat,\n    output wire agu_o_wbck_err,\n    output wire agu_o_cmt_misalgn,\n    output wire agu_o_cmt_ld,\n    output wire agu_o_cmt_stamo,\n    output wire agu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] agu_o_cmt_badaddr,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_cmd_usign,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire [E203_XLEN-1:0] agu_req_alu_op1,\n    output wire [E203_XLEN-1:0] agu_req_alu_op2,\n    output wire agu_req_alu_swap,\n    output wire agu_req_alu_add,\n    output wire agu_req_alu_and,\n    output wire agu_req_alu_or,\n    output wire agu_req_alu_xor,\n    output wire agu_req_alu_max,\n    output wire agu_req_alu_min,\n    output wire agu_req_alu_maxu,\n    output wire agu_req_alu_minu,\n    input wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire agu_sbf_0_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_0_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_0_r,\n    output wire agu_sbf_1_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_1_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_1_r,\n    input wire clk,\n    input wire rst_n\n);\n    // Implementation of the AGU logic goes here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 5, "code": "module e203_exu_alu_dpath(\n    input wire alu_req_alu,\n    input wire alu_req_alu_add,\n    input wire alu_req_alu_sub,\n    input wire alu_req_alu_xor,\n    input wire alu_req_alu_sll,\n    input wire alu_req_alu_srl,\n    input wire alu_req_alu_sra,\n    input wire alu_req_alu_or,\n    input wire alu_req_alu_and,\n    input wire [E203_XLEN-1:0] alu_req_alu_op1,\n    input wire [E203_XLEN-1:0] alu_req_alu_op2,\n    input wire bjp_req_alu,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    input wire agu_req_alu,\n    input wire [E203_XLEN-1:0] agu_req_alu_op1,\n    input wire [E203_XLEN-1:0] agu_req_alu_op2,\n    input wire muldiv_req_alu,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    input wire muldiv_req_alu_add,\n    input wire muldiv_req_alu_sub,\n    input wire muldiv_sbf_0_ena,\n    input wire [32:0] muldiv_sbf_0_nxt,\n    input wire muldiv_sbf_1_ena,\n    input wire [32:0] muldiv_sbf_1_nxt,\n    input wire clk,\n    input wire rst_n,\n    output wire [E203_XLEN-1:0] alu_req_alu_res,\n    output wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    output wire bjp_req_alu_cmp_res,\n    output wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output wire [32:0] muldiv_sbf_0_r,\n    output wire [32:0] muldiv_sbf_1_r\n);\n\n    // Internal signals for ALU operations\n    wire [E203_XLEN-1:0] add_res;\n    wire [E203_XLEN-1:0] sub_res;\n    wire [E203_XLEN-1:0] xor_res;\n    wire [E203_XLEN-1:0] sll_res;\n    wire [E203_XLEN-1:0] srl_res;\n    wire [E203_XLEN-1:0] sra_res;\n    wire [E203_XLEN-1:0] or_res;\n    wire [E203_XLEN-1:0] and_res;\n\n    // ALU operation implementations\n    assign add_res = alu_req_alu_op1 + alu_req_alu_op2;\n    assign sub_res = alu_req_alu_op1 - alu_req_alu_op2;\n    assign xor_res = alu_req_alu_op1 ^ alu_req_alu_op2;\n    assign sll_res = alu_req_alu_op1 << alu_req_alu_op2;\n    assign srl_res = alu_req_alu_op1 >> alu_req_alu_op2;\n    assign sra_res = $signed(alu_req_alu_op1) >>> alu_req_alu_op2;\n    assign or_res = alu_req_alu_op1 | alu_req_alu_op2;\n    assign and_res = alu_req_alu_op1 & alu_req_alu_op2;\n\n    // Result multiplexing based on operation type\n    assign alu_req_alu_res = ({E203_XLEN{alu_req_alu_add}} & add_res) |\n                             ({E203_XLEN{alu_req_alu_sub}} & sub_res) |\n                             ({E203_XLEN{alu_req_alu_xor}} & xor_res) |\n                             ({E203_XLEN{alu_req_alu_sll}} & sll_res) |\n                             ({E203_XLEN{alu_req_alu_srl}} & srl_res) |\n                             ({E203_XLEN{alu_req_alu_sra}} & sra_res) |\n                             ({E203_XLEN{alu_req_alu_or}} & or_res) |\n                             ({E203_XLEN{alu_req_alu_and}} & and_res);\n\n    // BJP, AGU, and MULDIV results (simplified for example)\n    assign bjp_req_alu_add_res = bjp_req_alu_op1 + bjp_req_alu_op2;\n    assign bjp_req_alu_cmp_res = (bjp_req_alu_op1 == bjp_req_alu_op2);\n    assign agu_req_alu_res = agu_req_alu_op1 + agu_req_alu_op2;\n    assign muldiv_req_alu_res = (muldiv_req_alu_add ? muldiv_req_alu_op1 + muldiv_req_alu_op2 :\n                                muldiv_req_alu_sub ? muldiv_req_alu_op1 - muldiv_req_alu_op2 : 0);\n\n    // Shared buffer handling\n    sirv_gnrl_dffl #(.DW(33)) sbf_0_dffl (\n        .lden(muldiv_sbf_0_ena),\n        .dnxt(muldiv_sbf_0_nxt),\n        .qout(muldiv_sbf_0_r),\n        .clk(clk)\n    );\n\n    sirv_gnrl_dffl #(.DW(33)) sbf_1_dffl (\n        .lden(muldiv_sbf_1_ena),\n        .dnxt(muldiv_sbf_1_nxt),\n        .qout(muldiv_sbf_1_r),\n        .clk(clk)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 6, "code": "module e203_exu_alu_dpath(\n    input wire alu_req_alu,\n    input wire alu_req_alu_add,\n    input wire alu_req_alu_sub,\n    input wire alu_req_alu_xor,\n    input wire alu_req_alu_sll,\n    input wire alu_req_alu_srl,\n    input wire alu_req_alu_sra,\n    input wire alu_req_alu_or,\n    input wire alu_req_alu_and,\n    input wire [E203_XLEN-1:0] alu_req_alu_op1,\n    input wire [E203_XLEN-1:0] alu_req_alu_op2,\n    input wire bjp_req_alu,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    input wire agu_req_alu,\n    input wire [E203_XLEN-1:0] agu_req_alu_op1,\n    input wire [E203_XLEN-1:0] agu_req_alu_op2,\n    input wire muldiv_req_alu,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    input wire muldiv_req_alu_add,\n    input wire muldiv_req_alu_sub,\n    input wire muldiv_sbf_0_ena,\n    input wire [32:0] muldiv_sbf_0_nxt,\n    input wire muldiv_sbf_1_ena,\n    input wire [32:0] muldiv_sbf_1_nxt,\n    input wire clk,\n    input wire rst_n,\n    output wire [E203_XLEN-1:0] alu_req_alu_res,\n    output wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    output wire bjp_req_alu_cmp_res,\n    output wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output wire [32:0] muldiv_sbf_0_r,\n    output wire [32:0] muldiv_sbf_1_r\n);\n\n    // Internal signals for ALU operations\n    wire [E203_XLEN-1:0] add_result;\n    wire [E203_XLEN-1:0] sub_result;\n    wire [E203_XLEN-1:0] xor_result;\n    wire [E203_XLEN-1:0] sll_result;\n    wire [E203_XLEN-1:0] srl_result;\n    wire [E203_XLEN-1:0] sra_result;\n    wire [E203_XLEN-1:0] or_result;\n    wire [E203_XLEN-1:0] and_result;\n\n    // ALU operation implementations\n    assign add_result = alu_req_alu_op1 + alu_req_alu_op2;\n    assign sub_result = alu_req_alu_op1 - alu_req_alu_op2;\n    assign xor_result = alu_req_alu_op1 ^ alu_req_alu_op2;\n    assign sll_result = alu_req_alu_op1 << alu_req_alu_op2;\n    assign srl_result = alu_req_alu_op1 >> alu_req_alu_op2;\n    assign sra_result = $signed(alu_req_alu_op1) >>> alu_req_alu_op2;\n    assign or_result = alu_req_alu_op1 | alu_req_alu_op2;\n    assign and_result = alu_req_alu_op1 & alu_req_alu_op2;\n\n    // Result multiplexing based on operation\n    assign alu_req_alu_res = ({E203_XLEN{alu_req_alu_add}} & add_result) |\n                             ({E203_XLEN{alu_req_alu_sub}} & sub_result) |\n                             ({E203_XLEN{alu_req_alu_xor}} & xor_result) |\n                             ({E203_XLEN{alu_req_alu_sll}} & sll_result) |\n                             ({E203_XLEN{alu_req_alu_srl}} & srl_result) |\n                             ({E203_XLEN{alu_req_alu_sra}} & sra_result) |\n                             ({E203_XLEN{alu_req_alu_or}} & or_result) |\n                             ({E203_XLEN{alu_req_alu_and}} & and_result);\n\n    // BJP operations\n    assign bjp_req_alu_add_res = bjp_req_alu_op1 + bjp_req_alu_op2;\n    assign bjp_req_alu_cmp_res = (bjp_req_alu_op1 == bjp_req_alu_op2);\n\n    // AGU operations\n    assign agu_req_alu_res = agu_req_alu_op1 + agu_req_alu_op2; // Example for AGU add operation\n\n    // MULDIV operations\n    assign muldiv_req_alu_res = (muldiv_req_alu_add ? muldiv_req_alu_op1 + muldiv_req_alu_op2 :\n                                muldiv_req_alu_sub ? muldiv_req_alu_op1 - muldiv_req_alu_op2 : 0);\n\n    // Shared buffers\n    sirv_gnrl_dffl #(.DW(33)) sbf_0_dffl (\n        .lden(muldiv_sbf_0_ena),\n        .dnxt(muldiv_sbf_0_nxt),\n        .qout(muldiv_sbf_0_r),\n        .clk(clk)\n    );\n\n    sirv_gnrl_dffl #(.DW(33)) sbf_1_dffl (\n        .lden(muldiv_sbf_1_ena),\n        .dnxt(muldiv_sbf_1_nxt),\n        .qout(muldiv_sbf_1_r),\n        .clk(clk)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 7, "code": "module e203_exu_alu_dpath(\n    input wire alu_req_alu,\n    input wire alu_req_alu_add,\n    input wire alu_req_alu_sub,\n    input wire alu_req_alu_xor,\n    input wire alu_req_alu_sll,\n    input wire alu_req_alu_srl,\n    input wire alu_req_alu_sra,\n    input wire alu_req_alu_or,\n    input wire alu_req_alu_and,\n    input wire [E203_XLEN-1:0] alu_req_alu_op1,\n    input wire [E203_XLEN-1:0] alu_req_alu_op2,\n    input wire bjp_req_alu,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    input wire agu_req_alu,\n    input wire [E203_XLEN-1:0] agu_req_alu_op1,\n    input wire [E203_XLEN-1:0] agu_req_alu_op2,\n    input wire muldiv_req_alu,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    input wire muldiv_req_alu_add,\n    input wire muldiv_req_alu_sub,\n    input wire muldiv_sbf_0_ena,\n    input wire [32:0] muldiv_sbf_0_nxt,\n    input wire muldiv_sbf_1_ena,\n    input wire [32:0] muldiv_sbf_1_nxt,\n    input wire clk,\n    input wire rst_n,\n    output wire [E203_XLEN-1:0] alu_req_alu_res,\n    output wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    output wire bjp_req_alu_cmp_res,\n    output wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output wire [32:0] muldiv_sbf_0_r,\n    output wire [32:0] muldiv_sbf_1_r\n);\n\n    // Internal signals for ALU operations\n    wire [E203_XLEN-1:0] add_result;\n    wire [E203_XLEN-1:0] sub_result;\n    wire [E203_XLEN-1:0] xor_result;\n    wire [E203_XLEN-1:0] or_result;\n    wire [E203_XLEN-1:0] and_result;\n    wire [E203_XLEN-1:0] sll_result;\n    wire [E203_XLEN-1:0] srl_result;\n    wire [E203_XLEN-1:0] sra_result;\n\n    // ALU operation implementations\n    assign add_result = alu_req_alu_op1 + alu_req_alu_op2;\n    assign sub_result = alu_req_alu_op1 - alu_req_alu_op2;\n    assign xor_result = alu_req_alu_op1 ^ alu_req_alu_op2;\n    assign or_result = alu_req_alu_op1 | alu_req_alu_op2;\n    assign and_result = alu_req_alu_op1 & alu_req_alu_op2;\n    assign sll_result = alu_req_alu_op1 << alu_req_alu_op2[E203_XLEN-1:0];\n    assign srl_result = alu_req_alu_op1 >> alu_req_alu_op2[E203_XLEN-1:0];\n    assign sra_result = $signed(alu_req_alu_op1) >>> alu_req_alu_op2[E203_XLEN-1:0];\n\n    // Result multiplexing based on operation type\n    assign alu_req_alu_res = ({E203_XLEN{alu_req_alu_add}} & add_result) |\n                             ({E203_XLEN{alu_req_alu_sub}} & sub_result) |\n                             ({E203_XLEN{alu_req_alu_xor}} & xor_result) |\n                             ({E203_XLEN{alu_req_alu_or}} & or_result) |\n                             ({E203_XLEN{alu_req_alu_and}} & and_result) |\n                             ({E203_XLEN{alu_req_alu_sll}} & sll_result) |\n                             ({E203_XLEN{alu_req_alu_srl}} & srl_result) |\n                             ({E203_XLEN{alu_req_alu_sra}} & sra_result);\n\n    // Shared buffer logic\n    sirv_gnrl_dffl #(.DW(33)) sbf_0_dffl (\n        .lden(muldiv_sbf_0_ena),\n        .dnxt(muldiv_sbf_0_nxt),\n        .qout(muldiv_sbf_0_r),\n        .clk(clk)\n    );\n\n    sirv_gnrl_dffl #(.DW(33)) sbf_1_dffl (\n        .lden(muldiv_sbf_1_ena),\n        .dnxt(muldiv_sbf_1_nxt),\n        .qout(muldiv_sbf_1_r),\n        .clk(clk)\n    );\n\n    // Additional logic for BJP, AGU, and MULDIV units can be added here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 8, "code": "module e203_exu_alu_rglr(\n    input wire alu_i_valid,\n    output wire alu_i_ready,\n    input wire [E203_XLEN-1:0] alu_i_rs1,\n    input wire [E203_XLEN-1:0] alu_i_rs2,\n    input wire [E203_XLEN-1:0] alu_i_imm,\n    input wire [E203_PC_SIZE-1:0] alu_i_pc,\n    input wire [E203_DECINFO_ALU_WIDTH-1:0] alu_i_info,\n    output wire alu_o_valid,\n    input wire alu_o_ready,\n    output wire [E203_XLEN-1:0] alu_o_wbck_wdat,\n    output wire alu_o_wbck_err,\n    output wire alu_o_cmt_ecall,\n    output wire alu_o_cmt_ebreak,\n    output wire alu_o_cmt_wfi,\n    output wire alu_req_alu_add,\n    output wire alu_req_alu_sub,\n    output wire alu_req_alu_xor,\n    output wire alu_req_alu_sll,\n    output wire alu_req_alu_srl,\n    output wire alu_req_alu_sra,\n    output wire alu_req_alu_or,\n    output wire alu_req_alu_and,\n    output wire alu_req_alu_slt,\n    output wire alu_req_alu_sltu,\n    output wire alu_req_alu_lui,\n    output wire [E203_XLEN-1:0] alu_req_alu_op1,\n    output wire [E203_XLEN-1:0] alu_req_alu_op2,\n    output wire [E203_XLEN-1:0] alu_req_alu_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Handshake signals\n    assign alu_i_ready = alu_o_ready;\n    assign alu_o_valid = alu_i_valid;\n\n    // Decode ALU operations from the info bus\n    wire op_add = alu_i_info[E203_DECINFO_ALU_ADD];\n    wire op_sub = alu_i_info[E203_DECINFO_ALU_SUB];\n    wire op_xor = alu_i_info[E203_DECINFO_ALU_XOR];\n    wire op_sll = alu_i_info[E203_DECINFO_ALU_SLL];\n    wire op_srl = alu_i_info[E203_DECINFO_ALU_SRL];\n    wire op_sra = alu_i_info[E203_DECINFO_ALU_SRA];\n    wire op_or  = alu_i_info[E203_DECINFO_ALU_OR];\n    wire op_and = alu_i_info[E203_DECINFO_ALU_AND];\n    wire op_slt = alu_i_info[E203_DECINFO_ALU_SLT];\n    wire op_sltu = alu_i_info[E203_DECINFO_ALU_SLTU];\n    wire op_lui = alu_i_info[E203_DECINFO_ALU_LUI];\n\n    // Special instructions\n    wire op_ecall = alu_i_info[E203_DECINFO_ALU_ECAL];\n    wire op_ebreak = alu_i_info[E203_DECINFO_ALU_EBRK];\n    wire op_wfi = alu_i_info[E203_DECINFO_ALU_WFI];\n\n    // Operand selection\n    wire op2imm = alu_i_info[E203_DECINFO_ALU_OP2IMM];\n    wire op1pc = alu_i_info[E203_DECINFO_ALU_OP1PC];\n\n    assign alu_req_alu_op1 = op1pc ? alu_i_pc : alu_i_rs1;\n    assign alu_req_alu_op2 = op2imm ? alu_i_imm : alu_i_rs2;\n\n    // ALU operation requests\n    assign alu_req_alu_add = op_add;\n    assign alu_req_alu_sub = op_sub;\n    assign alu_req_alu_xor = op_xor;\n    assign alu_req_alu_sll = op_sll;\n    assign alu_req_alu_srl = op_srl;\n    assign alu_req_alu_sra = op_sra;\n    assign alu_req_alu_or = op_or;\n    assign alu_req_alu_and = op_and;\n    assign alu_req_alu_slt = op_slt;\n    assign alu_req_alu_sltu = op_sltu;\n    assign alu_req_alu_lui = op_lui;\n\n    // Compute result based on operation\n    always @(*) begin\n        case (1'b1)\n            op_add: alu_req_alu_res = alu_req_alu_op1 + alu_req_alu_op2;\n            op_sub: alu_req_alu_res = alu_req_alu_op1 - alu_req_alu_op2;\n            op_xor: alu_req_alu_res = alu_req_alu_op1 ^ alu_req_alu_op2;\n            op_sll: alu_req_alu_res = alu_req_alu_op1 << alu_req_alu_op2;\n            op_srl: alu_req_alu_res = alu_req_alu_op1 >> alu_req_alu_op2;\n            op_sra: alu_req_alu_res = $signed(alu_req_alu_op1) >>> alu_req_alu_op2;\n            op_or: alu_req_alu_res = alu_req_alu_op1 | alu_req_alu_op2;\n            op_and: alu_req_alu_res = alu_req_alu_op1 & alu_req_alu_op2;\n            op_slt: alu_req_alu_res = ($signed(alu_req_alu_op1) < $signed(alu_req_alu_op2)) ? 1 : 0;\n            op_sltu: alu_req_alu_res = (alu_req_alu_op1 < alu_req_alu_op2) ? 1 : 0;\n            op_lui: alu_req_alu_res = alu_i_imm;\n            default: alu_req_alu_res = 0;\n        endcase\n    end\n\n    // Writeback and error handling\n    assign alu_o_wbck_wdat = alu_req_alu_res;\n    assign alu_o_wbck_err = op_ecall | op_ebreak | op_wfi;\n\n    // Commit signals for special instructions\n    assign alu_o_cmt_ecall = op_ecall;\n    assign alu_o_cmt_ebreak = op_ebreak;\n    assign alu_o_cmt_wfi = op_wfi;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 3, "code": "module e203_exu_commit(\n    input clk,\n    input rst_n,\n\n    // Inputs from ALU\n    input alu_cmt_i_valid,\n    output reg alu_cmt_i_ready,\n    input [E203_PC_SIZE-1:0] alu_cmt_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_cmt_i_instr,\n    input alu_cmt_i_pc_vld,\n    input [E203_XLEN-1:0] alu_cmt_i_imm,\n    input alu_cmt_i_rv32,\n    input alu_cmt_i_bjp,\n    input alu_cmt_i_wfi,\n    input alu_cmt_i_fencei,\n    input alu_cmt_i_mret,\n    input alu_cmt_i_dret,\n    input alu_cmt_i_ecall,\n    input alu_cmt_i_ebreak,\n    input alu_cmt_i_ifu_misalgn,\n    input alu_cmt_i_ifu_buserr,\n    input alu_cmt_i_ifu_ilegl,\n    input alu_cmt_i_bjp_prdt,\n    input alu_cmt_i_bjp_rslv,\n    input alu_cmt_i_misalgn,\n    input alu_cmt_i_ld,\n    input alu_cmt_i_stamo,\n    input alu_cmt_i_buserr,\n    input [E203_ADDR_SIZE-1:0] alu_cmt_i_badaddr,\n\n    // Outputs\n    output reg commit_mret,\n    output reg commit_trap,\n    output reg core_wfi,\n    output reg nonflush_cmt_ena,\n    output reg excp_active,\n    output reg wfi_halt_ifu_req,\n    output reg wfi_halt_exu_req,\n    output reg [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output reg cmt_badaddr_ena,\n    output reg [E203_PC_SIZE-1:0] cmt_epc,\n    output reg cmt_epc_ena,\n    output reg [E203_XLEN-1:0] cmt_cause,\n    output reg cmt_cause_ena,\n    output reg cmt_instret_ena,\n    output reg cmt_status_ena,\n    output reg [E203_PC_SIZE-1:0] cmt_dpc,\n    output reg cmt_dpc_ena,\n    output reg [2:0] cmt_dcause,\n    output reg cmt_dcause_ena,\n    output reg cmt_mret_ena,\n\n    // Inputs from CSR\n    input [E203_PC_SIZE-1:0] csr_epc_r,\n    input [E203_PC_SIZE-1:0] csr_dpc_r,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n\n    // Inputs from Debug & Interrupts\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n\n    // Inputs from long-pipe exceptions\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input longp_excp_i_insterr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n\n    // Handshake with IFU and EXU\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input amo_wait,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode\n);\n\n    // Commit logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            alu_cmt_i_ready <= 1'b0;\n            commit_mret <= 1'b0;\n            commit_trap <= 1'b0;\n            core_wfi <= 1'b0;\n            nonflush_cmt_ena <= 1'b0;\n            excp_active <= 1'b0;\n            wfi_halt_ifu_req <= 1'b0;\n            wfi_halt_exu_req <= 1'b0;\n            cmt_badaddr <= {E203_ADDR_SIZE{1'b0}};\n            cmt_badaddr_ena <= 1'b0;\n            cmt_epc <= {E203_PC_SIZE{1'b0}};\n            cmt_epc_ena <= 1'b0;\n            cmt_cause <= {E203_XLEN{1'b0}};\n            cmt_cause_ena <= 1'b0;\n            cmt_instret_ena <= 1'b0;\n            cmt_status_ena <= 1'b0;\n            cmt_dpc <= {E203_PC_SIZE{1'b0}};\n            cmt_dpc_ena <= 1'b0;\n            cmt_dcause <= 3'b000;\n            cmt_dcause_ena <= 1'b0;\n            cmt_mret_ena <= 1'b0;\n        end else begin\n            // Handle commit logic based on inputs\n            // This is a simplified example, real implementation would be more complex\n            if (alu_cmt_i_valid && !amo_wait) begin\n                alu_cmt_i_ready <= 1'b1;\n                if (alu_cmt_i_mret) begin\n                    commit_mret <= 1'b1;\n                    cmt_mret_ena <= 1'b1;\n                end\n                if (alu_cmt_i_wfi) begin\n                    core_wfi <= 1'b1;\n                    wfi_halt_ifu_req <= 1'b1;\n                    wfi_halt_exu_req <= 1'b1;\n                end\n                if (alu_cmt_i_ecall || alu_cmt_i_ebreak || alu_cmt_i_ifu_ilegl) begin\n                    commit_trap <= 1'b1;\n                    excp_active <= 1'b1;\n                    cmt_cause <= (alu_cmt_i_ecall ? `ECALL_CAUSE` : (alu_cmt_i_ebreak ? `EBREAK_CAUSE` : `ILLEGAL_INST_CAUSE`));\n                    cmt_cause_ena <= 1'b1;\n                end\n            end else begin\n                alu_cmt_i_ready <= 1'b0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 6, "code": "`include \"e203_defines.v\"\n\nmodule e203_itcm_ram #(\n  parameter FORCE_X2ZERO = 0,\n  parameter DP = `E203_ITCM_RAM_DP,\n  parameter DW = `E203_ITCM_RAM_DW,\n  parameter MW = `E203_ITCM_RAM_MW,\n  parameter AW = `E203_ITCM_RAM_AW\n)(\n  input wire sd,\n  input wire ds,\n  input wire ls,\n  input wire cs,\n  input wire we,\n  input wire [AW-1:0] addr,\n  input wire [MW-1:0] wem,\n  input wire [DW-1:0] din,\n  input wire rst_n,\n  input wire clk,\n  output wire [DW-1:0] dout\n);\n\n  // Instantiate the generic RAM module\n  sirv_gnrl_ram #(\n    .FORCE_X2ZERO(FORCE_X2ZERO),\n    .DP(DP),\n    .DW(DW),\n    .MW(MW),\n    .AW(AW)\n  ) u_sirv_gnrl_ram (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 2, "code": "module e203_ifu (\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire itcm_nohold,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input wire pipe_flush_req,\n    input wire ifu_halt_req,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire ifu_active,\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    output wire pipe_flush_ack,\n    `ifdef E203_HAS_ITCM\n    input wire ifu2itcm_holdup,\n    input wire [E203_ADDR_SIZE-1:0] itcm_region_indic,\n    output wire ifu2itcm_icb_cmd_valid,\n    input wire ifu2itcm_icb_cmd_ready,\n    output wire [E203_ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_rsp_valid,\n    output wire ifu2itcm_icb_rsp_ready,\n    input wire ifu2itcm_icb_rsp_err,\n    input wire [E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    `endif\n    `ifdef E203_HAS_MEM_ITF\n    output wire ifu2biu_icb_cmd_valid,\n    input wire ifu2biu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input wire ifu2biu_icb_rsp_valid,\n    output wire ifu2biu_icb_rsp_ready,\n    input wire ifu2biu_icb_rsp_err,\n    input wire [E203_SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata,\n    `endif\n    output wire ifu_halt_ack\n);\n\n    // Internal signals for module connections and logic\n    wire [E203_PC_SIZE-1:0] current_pc;\n    wire fetch_valid;\n    wire [E203_INSTR_SIZE-1:0] fetched_instr;\n    wire fetch_error;\n    wire [E203_PC_SIZE-1:0] next_pc;\n    wire ifetch_ready;\n\n    // Instantiate the IFETCH module\n    e203_ifu_ifetch ifetch (\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ifu_o_ready(ifu_o_ready),\n        .pipe_flush_req(pipe_flush_req),\n        .pipe_flush_add_op1(pipe_flush_add_op1),\n        .pipe_flush_add_op2(pipe_flush_add_op2),\n        .ifu_halt_req(ifu_halt_req),\n        .oitf_empty(oitf_empty),\n        .rf2ifu_x1(rf2ifu_x1),\n        .rf2ifu_rs1(rf2ifu_rs1),\n        .dec2ifu_rden(dec2ifu_rden),\n        .dec2ifu_rs1en(dec2ifu_rs1en),\n        .dec2ifu_rdidx(dec2ifu_rdidx),\n        .dec2ifu_mulhsu(dec2ifu_mulhsu),\n        .dec2ifu_div(dec2ifu_div),\n        .dec2ifu_rem(dec2ifu_rem),\n        .dec2ifu_divu(dec2ifu_divu),\n        .dec2ifu_remu(dec2ifu_remu),\n        .inspect_pc(inspect_pc),\n        .ifu_req_valid(fetch_valid),\n        .ifu_req_pc(current_pc),\n        .ifu_req_seq(),\n        .ifu_req_seq_rv32(),\n        .ifu_req_last_pc(next_pc),\n        .pipe_flush_ack(pipe_flush_ack),\n        .ifu_halt_ack(ifu_halt_ack),\n        .ifu_o_ir(fetched_instr),\n        .ifu_o_pc(ifu_o_pc),\n        .ifu_o_pc_vld(ifu_o_pc_vld),\n        .ifu_o_misalgn(ifu_o_misalgn),\n        .ifu_o_buserr(ifu_o_buserr),\n        .ifu_o_rs1idx(ifu_o_rs1idx),\n        .ifu_o_rs2idx(ifu_o_rs2idx),\n        .ifu_o_prdt_taken(ifu_o_prdt_taken),\n        .ifu_o_muldiv_b2b(ifu_o_muldiv_b2b),\n        .ifu_o_valid(ifu_o_valid)\n    );\n\n    // Instantiate the IFT2ICB module\n    e203_ifu_ift2icb ift2icb (\n        .clk(clk),\n        .rst_n(rst_n),\n        .ifu_req_valid(fetch_valid),\n        .ifu_req_pc(current_pc),\n        .ifu_req_seq(),\n        .ifu_req_seq_rv32(),\n        .ifu_req_last_pc(next_pc),\n        .ifu_rsp_ready(ifetch_ready),\n        .itcm_nohold(itcm_nohold),\n        .itcm_region_indic(itcm_region_indic),\n        .ifu2itcm_icb_cmd_ready(ifu2itcm_icb_cmd_ready),\n        .ifu2itcm_icb_rsp_valid(ifu2itcm_icb_rsp_valid),\n        .ifu2itcm_icb_rsp_err(ifu2itcm_icb_rsp_err),\n        .ifu2itcm_icb_rsp_rdata(ifu2itcm_icb_rsp_rdata),\n        .ifu2biu_icb_cmd_ready(ifu2biu_icb_cmd_ready),\n        .ifu2biu_icb_rsp_valid(ifu2biu_icb_rsp_valid),\n        .ifu2biu_icb_rsp_err(ifu2biu_icb_rsp_err),\n        .ifu2biu_icb_rsp_rdata(ifu2biu_icb_rsp_rdata),\n        .ifu_req_ready(ifetch_ready),\n        .ifu_rsp_valid(),\n        .ifu_rsp_err(fetch_error),\n        .ifu_rsp_instr(fetched_instr),\n        .ifu2itcm_icb_cmd_valid(ifu2itcm_icb_cmd_valid),\n        .ifu2itcm_icb_cmd_addr(ifu2itcm_icb_cmd_addr),\n        .ifu2itcm_icb_rsp_ready(ifu2itcm_icb_rsp_ready),\n        .ifu2biu_icb_cmd_valid(ifu2biu_icb_cmd_valid),\n        .ifu2biu_icb_cmd_addr(ifu2biu_icb_cmd_addr),\n        .ifu2biu_icb_rsp_ready(ifu2biu_icb_rsp_ready)\n    );\n\n    assign ifu_active = fetch_valid || ifetch_ready;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 8, "code": "module e203_exu_oitf #(\n  parameter E203_ITAG_WIDTH = 4,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_PC_SIZE = 32,\n  parameter E203_OITF_DEPTH = 16\n)(\n  input clk,\n  input rst_n,\n\n  output dis_ready,\n  input dis_ena,\n  input ret_ena,\n\n  output [E203_ITAG_WIDTH-1:0] dis_ptr,\n  output [E203_ITAG_WIDTH-1:0] ret_ptr,\n  output [E203_RFIDX_WIDTH-1:0] ret_rdidx,\n  output ret_rdwen,\n  output ret_rdfpu,\n  output [E203_PC_SIZE-1:0] ret_pc,\n\n  input disp_i_rs1en,\n  input disp_i_rs2en,\n  input disp_i_rs3en,\n  input disp_i_rdwen,\n  input disp_i_rs1fpu,\n  input disp_i_rs2fpu,\n  input disp_i_rs3fpu,\n  input disp_i_rdfpu,\n  input [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n  input [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n  input [E203_RFIDX_WIDTH-1:0] disp_i_rs3idx,\n  input [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n  input [E203_PC_SIZE-1:0] disp_i_pc,\n\n  output oitfrd_match_disprs1,\n  output oitfrd_match_disprs2,\n  output oitfrd_match_disprs3,\n  output oitfrd_match_disprd,\n  output oitf_empty\n);\n\n  reg [E203_RFIDX_WIDTH-1:0] rdidx [E203_OITF_DEPTH-1:0];\n  reg [E203_PC_SIZE-1:0] pc [E203_OITF_DEPTH-1:0];\n  reg [E203_OITF_DEPTH-1:0] rdwen;\n  reg [E203_OITF_DEPTH-1:0] rdfpu;\n  reg [E203_ITAG_WIDTH-1:0] head, tail;\n  reg full, empty;\n\n  assign dis_ready = !full;\n  assign oitf_empty = empty;\n\n  integer i;\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      head <= 0;\n      tail <= 0;\n      full <= 0;\n      empty <= 1;\n      for (i = 0; i < E203_OITF_DEPTH; i = i + 1) begin\n        rdwen[i] <= 0;\n        rdfpu[i] <= 0;\n      end\n    end else begin\n      if (dis_ena && dis_ready) begin\n        rdidx[tail] <= disp_i_rdidx;\n        pc[tail] <= disp_i_pc;\n        rdwen[tail] <= disp_i_rdwen;\n        rdfpu[tail] <= disp_i_rdfpu;\n        tail <= tail + 1;\n        empty <= 0;\n        if (tail + 1 == head) begin\n          full <= 1;\n        end\n      end\n      if (ret_ena && !empty) begin\n        head <= head + 1;\n        if (head + 1 == tail) begin\n          empty <= 1;\n        end\n        full <= 0;\n      end\n    end\n  end\n\n  assign ret_rdidx = rdidx[head];\n  assign ret_pc = pc[head];\n  assign ret_rdwen = rdwen[head];\n  assign ret_rdfpu = rdfpu[head];\n\n  assign oitfrd_match_disprs1 = |({E203_OITF_DEPTH{disp_i_rs1en}} & rdwen & (rdidx == disp_i_rs1idx));\n  assign oitfrd_match_disprs2 = |({E203_OITF_DEPTH{disp_i_rs2en}} & rdwen & (rdidx == disp_i_rs2idx));\n  assign oitfrd_match_disprs3 = |({E203_OITF_DEPTH{disp_i_rs3en}} & rdwen & (rdidx == disp_i_rs3idx));\n  assign oitfrd_match_disprd = |({E203_OITF_DEPTH{disp_i_rdwen}} & rdwen & (rdidx == disp_i_rdidx));\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 5, "code": "module e203_exu_nice (\n    input wire nice_i_xs_off,\n    input wire nice_i_valid,\n    output wire nice_i_ready,\n    input wire [E203_XLEN-1:0] nice_i_instr,\n    input wire [E203_XLEN-1:0] nice_i_rs1,\n    input wire [E203_XLEN-1:0] nice_i_rs2,\n    input wire [E203_ITAG_WIDTH-1:0] nice_i_itag,\n    output wire nice_o_longpipe,\n    output wire nice_o_valid,\n    input wire nice_o_ready,\n    output wire nice_o_itag_valid,\n    input wire nice_o_itag_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire clk,\n    input wire rst_n\n);\n\n// Internal signals\nwire fifo_i_vld, fifo_i_rdy, fifo_o_vld, fifo_o_rdy;\nwire [E203_ITAG_WIDTH-1:0] fifo_i_dat, fifo_o_dat;\n\n// Instantiate the FIFO\nsirv_gnrl_fifo #(\n    .CUT_READY(1),\n    .MSKO(0),\n    .DP(4),\n    .DW(E203_ITAG_WIDTH)\n) itag_fifo (\n    .i_vld(fifo_i_vld),\n    .i_rdy(fifo_i_rdy),\n    .i_dat(fifo_i_dat),\n    .o_vld(fifo_o_vld),\n    .o_rdy(fifo_o_rdy),\n    .o_dat(fifo_o_dat),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// Control logic\nassign nice_i_ready = nice_o_ready & nice_req_ready & ~nice_i_xs_off;\nassign nice_o_longpipe = ~nice_i_xs_off;\nassign nice_o_valid = nice_i_valid & nice_i_ready;\nassign nice_o_itag_valid = fifo_o_vld & nice_rsp_multicyc_valid & fifo_o_rdy;\nassign nice_o_itag = fifo_o_dat;\nassign fifo_i_vld = nice_i_valid & nice_i_ready;\nassign fifo_i_dat = nice_i_itag;\nassign fifo_o_rdy = nice_o_itag_ready & nice_rsp_multicyc_valid;\nassign nice_rsp_multicyc_ready = fifo_o_rdy;\n\n// Request to accelerator\nassign nice_req_valid = nice_i_valid & nice_i_ready & ~nice_i_xs_off;\nassign nice_req_instr = nice_i_instr;\nassign nice_req_rs1 = nice_i_rs1;\nassign nice_req_rs2 = nice_i_rs2;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 3, "code": "module e203_ifu_ift2icb (\n    input wire itcm_nohold,\n    input wire ifu_req_valid,\n    input wire [PC_SIZE-1:0] ifu_req_pc,\n    input wire ifu_req_seq,\n    input wire ifu_req_seq_rv32,\n    input wire [PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_ready,\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_ready,\n    output wire ifu_rsp_valid,\n    output wire ifu_rsp_err,\n    output wire [31:0] ifu_rsp_instr,\n    output wire ifu2itcm_icb_cmd_valid,\n    input wire ifu2itcm_icb_cmd_ready,\n    output wire [ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_rsp_valid,\n    output wire ifu2itcm_icb_rsp_ready,\n    input wire ifu2itcm_icb_rsp_err,\n    input wire [ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    output wire ifu2biu_icb_cmd_valid,\n    input wire ifu2biu_icb_cmd_ready,\n    output wire [ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input wire ifu2biu_icb_rsp_valid,\n    output wire ifu2biu_icb_rsp_ready,\n    input wire ifu2biu_icb_rsp_err,\n    input wire [SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata\n);\n\n    // State Definitions\n    localparam ICB_STATE_IDLE = 2'b00;\n    localparam ICB_STATE_1ST = 2'b01;\n    localparam ICB_STATE_WAIT2ND = 2'b10;\n    localparam ICB_STATE_2ND = 2'b11;\n\n    // State Variables\n    reg [1:0] icb_state;\n    reg [1:0] icb_state_nxt;\n\n    // Handshake signals\n    wire ifu_req_hsked = ifu_req_valid && ifu_req_ready;\n    wire ifu_icb_cmd_hsked = ifu2biu_icb_cmd_valid && ifu2biu_icb_cmd_ready;\n    wire ifu_icb_rsp_hsked = ifu2biu_icb_rsp_valid && ifu2biu_icb_rsp_ready;\n\n    // Next state logic\n    always @(*) begin\n        case (icb_state)\n            ICB_STATE_IDLE: icb_state_nxt = ifu_req_hsked ? ICB_STATE_1ST : ICB_STATE_IDLE;\n            ICB_STATE_1ST: icb_state_nxt = ifu_icb_rsp_hsked ? ICB_STATE_WAIT2ND : ICB_STATE_1ST;\n            ICB_STATE_WAIT2ND: icb_state_nxt = ifu_icb_cmd_ready ? ICB_STATE_2ND : ICB_STATE_WAIT2ND;\n            ICB_STATE_2ND: icb_state_nxt = ifu_icb_rsp_hsked ? ICB_STATE_IDLE : ICB_STATE_2ND;\n            default: icb_state_nxt = ICB_STATE_IDLE;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            icb_state <= ICB_STATE_IDLE;\n        else\n            icb_state <= icb_state_nxt;\n    end\n\n    // Output logic\n    assign ifu_req_ready = (icb_state == ICB_STATE_IDLE);\n    assign ifu_rsp_valid = (icb_state == ICB_STATE_2ND) && ifu_icb_rsp_valid;\n    assign ifu_rsp_err = ifu2biu_icb_rsp_err;\n    assign ifu_rsp_instr = ifu2biu_icb_rsp_rdata[31:0];\n\n    // ICB command interface\n    assign ifu2biu_icb_cmd_valid = (icb_state == ICB_STATE_IDLE) && ifu_req_valid;\n    assign ifu2biu_icb_cmd_addr = ifu_req_pc;\n\n    // ICB response interface\n    assign ifu2biu_icb_rsp_ready = (icb_state == ICB_STATE_2ND);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 6, "code": "module e203_exu_nice (\n    input wire nice_i_xs_off,\n    input wire nice_i_valid,\n    output wire nice_i_ready,\n    input wire [E203_XLEN-1:0] nice_i_instr,\n    input wire [E203_XLEN-1:0] nice_i_rs1,\n    input wire [E203_XLEN-1:0] nice_i_rs2,\n    input wire [E203_ITAG_WIDTH-1:0] nice_i_itag,\n    output wire nice_o_longpipe,\n    output wire nice_o_valid,\n    input wire nice_o_ready,\n    output wire nice_o_itag_valid,\n    input wire nice_o_itag_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire clk,\n    input wire rst_n\n);\n\n// Internal signals\nwire fifo_push, fifo_pop;\nwire [E203_ITAG_WIDTH-1:0] fifo_data_in, fifo_data_out;\nwire fifo_full, fifo_empty, fifo_valid;\n\n// Instantiate the FIFO for instruction tags\nsirv_gnrl_fifo #(\n    .CUT_READY(1),\n    .MSKO(0),\n    .DP(4),\n    .DW(E203_ITAG_WIDTH)\n) itag_fifo (\n    .i_vld(fifo_push),\n    .i_rdy(fifo_pop),\n    .i_dat(fifo_data_in),\n    .o_vld(fifo_valid),\n    .o_rdy(nice_o_itag_ready),\n    .o_dat(fifo_data_out),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// Control logic for pushing to and popping from the FIFO\nassign fifo_push = nice_i_valid && nice_i_ready && !nice_i_xs_off;\nassign fifo_pop = nice_rsp_multicyc_valid && nice_rsp_multicyc_ready;\nassign fifo_data_in = nice_i_itag;\n\n// Handling of requests to the accelerator\nassign nice_req_valid = nice_i_valid && !nice_i_xs_off && nice_req_ready;\nassign nice_req_instr = nice_i_instr;\nassign nice_req_rs1 = nice_i_rs1;\nassign nice_req_rs2 = nice_i_rs2;\n\n// Handling responses from the accelerator\nassign nice_rsp_multicyc_ready = !fifo_full;\nassign nice_o_itag = fifo_data_out;\nassign nice_o_itag_valid = fifo_valid && nice_rsp_multicyc_valid;\n\n// Output valid signal for commit interface\nassign nice_o_valid = nice_i_valid && nice_o_ready && !nice_i_xs_off;\n\n// Long pipeline handling\nassign nice_o_longpipe = !nice_i_xs_off;\n\n// Ready signal to accept input instruction\nassign nice_i_ready = !fifo_full && nice_o_ready && nice_req_ready;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 13, "code": "module e203_dtcm_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n\n    // LSU ICB Interface\n    input wire lsu2dtcm_icb_cmd_valid,\n    output wire lsu2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] lsu2dtcm_icb_cmd_addr,\n    input wire lsu2dtcm_icb_cmd_read,\n    input wire [31:0] lsu2dtcm_icb_cmd_wdata,\n    input wire [3:0] lsu2dtcm_icb_cmd_wmask,\n    output wire lsu2dtcm_icb_rsp_valid,\n    input wire lsu2dtcm_icb_rsp_ready,\n    output wire lsu2dtcm_icb_rsp_err,\n    output wire [31:0] lsu2dtcm_icb_rsp_rdata,\n\n    // External ICB Interface (Optional)\n    `ifdef E203_HAS_DTCM_EXTITF\n    input wire ext2dtcm_icb_cmd_valid,\n    output wire ext2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] ext2dtcm_icb_cmd_addr,\n    input wire ext2dtcm_icb_cmd_read,\n    input wire [31:0] ext2dtcm_icb_cmd_wdata,\n    input wire [3:0] ext2dtcm_icb_cmd_wmask,\n    output wire ext2dtcm_icb_rsp_valid,\n    input wire ext2dtcm_icb_rsp_ready,\n    output wire ext2dtcm_icb_rsp_err,\n    output wire [31:0] ext2dtcm_icb_rsp_rdata,\n    `endif\n\n    // DTCM RAM Interface\n    output wire dtcm_ram_cs,\n    output wire dtcm_ram_we,\n    output wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    output wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    output wire clk_dtcm_ram,\n\n    output wire dtcm_active\n);\n\n    // Internal signals\n    wire icb_cmd_valid;\n    wire icb_cmd_ready;\n    wire [E203_DTCM_ADDR_WIDTH-1:0] icb_cmd_addr;\n    wire icb_cmd_read;\n    wire [31:0] icb_cmd_wdata;\n    wire [3:0] icb_cmd_wmask;\n    wire icb_rsp_valid;\n    wire icb_rsp_ready;\n    wire icb_rsp_err;\n    wire [31:0] icb_rsp_rdata;\n\n    // Arbitration logic (if external interface is used)\n    `ifdef E203_HAS_DTCM_EXTITF\n    // Instantiate the bus arbiter\n    sirv_gnrl_icb_arbt #(\n        .ARBT_SCHEME(0),\n        .ALLOW_0CYCL_RSP(0),\n        .FIFO_OUTS_NUM(E203_DTCM_OUTS_NUM),\n        .FIFO_CUT_READY(0),\n        .USR_W(1),\n        .ARBT_NUM(DTCM_ARBT_I_NUM),\n        .AW(E203_DTCM_ADDR_WIDTH),\n        .DW(32),\n        .ARBT_PTR_W(DTCM_ARBT_I_PTR_W)\n    ) u_dtcm_arbiter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .i_bus_icb_cmd_valid({ext2dtcm_icb_cmd_valid, lsu2dtcm_icb_cmd_valid}),\n        .i_bus_icb_cmd_ready({ext2dtcm_icb_cmd_ready, lsu2dtcm_icb_cmd_ready}),\n        .i_bus_icb_cmd_addr({ext2dtcm_icb_cmd_addr, lsu2dtcm_icb_cmd_addr}),\n        .i_bus_icb_cmd_read({ext2dtcm_icb_cmd_read, lsu2dtcm_icb_cmd_read}),\n        .i_bus_icb_cmd_wdata({ext2dtcm_icb_cmd_wdata, lsu2dtcm_icb_cmd_wdata}),\n        .i_bus_icb_cmd_wmask({ext2dtcm_icb_cmd_wmask, lsu2dtcm_icb_cmd_wmask}),\n        .o_icb_cmd_valid(icb_cmd_valid),\n        .o_icb_cmd_ready(icb_cmd_ready),\n        .o_icb_cmd_addr(icb_cmd_addr),\n        .o_icb_cmd_read(icb_cmd_read),\n        .o_icb_cmd_wdata(icb_cmd_wdata),\n        .o_icb_cmd_wmask(icb_cmd_wmask),\n        .i_bus_icb_rsp_valid({ext2dtcm_icb_rsp_valid, lsu2dtcm_icb_rsp_valid}),\n        .i_bus_icb_rsp_ready({ext2dtcm_icb_rsp_ready, lsu2dtcm_icb_rsp_ready}),\n        .o_icb_rsp_valid(icb_rsp_valid),\n        .o_icb_rsp_ready(icb_rsp_ready),\n        .o_icb_rsp_err(icb_rsp_err),\n        .o_icb_rsp_rdata(icb_rsp_rdata)\n    );\n    `else\n    assign icb_cmd_valid = lsu2dtcm_icb_cmd_valid;\n    assign icb_cmd_ready = lsu2dtcm_icb_cmd_ready;\n    assign icb_cmd_addr = lsu2dtcm_icb_cmd_addr;\n    assign icb_cmd_read = lsu2dtcm_icb_cmd_read;\n    assign icb_cmd_wdata = lsu2dtcm_icb_cmd_wdata;\n    assign icb_cmd_wmask = lsu2dtcm_icb_cmd_wmask;\n    assign icb_rsp_valid = lsu2dtcm_icb_rsp_valid;\n    assign icb_rsp_ready = lsu2dtcm_icb_rsp_ready;\n    assign icb_rsp_err = lsu2dtcm_icb_rsp_err;\n    assign icb_rsp_rdata = lsu2dtcm_icb_rsp_rdata;\n    `endif\n\n    // SRAM controller logic\n    sirv_sram_icb_ctrl #(\n        .DW(E203_DTCM_DATA_WIDTH),\n        .AW(E203_DTCM_ADDR_WIDTH),\n        .MW(E203_DTCM_WMSK_WIDTH),\n        .AW_LSB(2),\n        .USR_W(1)\n    ) u_dtcm_sram_ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .tcm_cgstop(tcm_cgstop),\n        .i_icb_cmd_valid(icb_cmd_valid),\n        .i_icb_cmd_ready(icb_cmd_ready),\n        .i_icb_cmd_read(icb_cmd_read),\n        .i_icb_cmd_addr(icb_cmd_addr),\n        .i_icb_cmd_wdata(icb_cmd_wdata),\n        .i_icb_cmd_wmask(icb_cmd_wmask),\n        .i_icb_rsp_valid(icb_rsp_valid),\n        .i_icb_rsp_ready(icb_rsp_ready),\n        .i_icb_rsp_err(icb_rsp_err),\n        .i_icb_rsp_rdata(icb_rsp_rdata),\n        .ram_cs(dtcm_ram_cs),\n        .ram_we(dtcm_ram_we),\n        .ram_addr(dtcm_ram_addr),\n        .ram_wem(dtcm_ram_wem),\n        .ram_din(dtcm_ram_din),\n        .ram_dout(dtcm_ram_dout),\n        .clk_ram(clk_dtcm_ram),\n        .sram_ctrl_active(dtcm_active),\n        .test_mode(test_mode)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 4, "code": "module e203_exu_disp(\n    input wire wfi_halt_exu_req,\n    output wire wfi_halt_exu_ack,\n    input wire oitf_empty,\n    input wire amo_wait,\n    input wire disp_i_valid,\n    output wire disp_i_ready,\n    input wire disp_i_rs1x0,\n    input wire disp_i_rs2x0,\n    input wire disp_i_rs1en,\n    input wire disp_i_rs2en,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input wire [E203_XLEN-1:0] disp_i_rs1,\n    input wire [E203_XLEN-1:0] disp_i_rs2,\n    input wire disp_i_rdwen,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input wire [E203_DECINFO_WIDTH-1:0] disp_i_info,\n    input wire [E203_XLEN-1:0] disp_i_imm,\n    input wire [E203_PC_SIZE-1:0] disp_i_pc,\n    input wire disp_i_misalgn,\n    input wire disp_i_buserr,\n    input wire disp_i_ilegl,\n    output wire disp_o_alu_valid,\n    input wire disp_o_alu_ready,\n    input wire disp_o_alu_longpipe,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs1,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs2,\n    output wire disp_o_alu_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_o_alu_rdidx,\n    output wire [E203_DECINFO_WIDTH-1:0] disp_o_alu_info,\n    output wire [E203_XLEN-1:0] disp_o_alu_imm,\n    output wire [E203_PC_SIZE-1:0] disp_o_alu_pc,\n    output wire [E203_ITAG_WIDTH-1:0] disp_o_alu_itag,\n    output wire disp_o_alu_misalgn,\n    output wire disp_o_alu_buserr,\n    output wire disp_o_alu_ilegl,\n    input wire oitfrd_match_disprs1,\n    input wire oitfrd_match_disprs2,\n    input wire oitfrd_match_disprs3,\n    input wire oitfrd_match_disprd,\n    input wire [E203_ITAG_WIDTH-1:0] disp_oitf_ptr,\n    output wire disp_oitf_ena,\n    input wire disp_oitf_ready,\n    output wire disp_oitf_rs1fpu,\n    output wire disp_oitf_rs2fpu,\n    output wire disp_oitf_rs3fpu,\n    output wire disp_oitf_rdfpu,\n    output wire disp_oitf_rs1en,\n    output wire disp_oitf_rs2en,\n    output wire disp_oitf_rs3en,\n    output wire disp_oitf_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs2idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs3idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rdidx,\n    output wire [E203_PC_SIZE-1:0] disp_oitf_pc,\n    input wire clk,\n    input wire rst_n\n);\n\n// Implementation of the dispatch logic\n// This is a simplified example and may need to be expanded based on actual requirements\n\nassign disp_i_ready = !wfi_halt_exu_req && !amo_wait && disp_o_alu_ready && oitf_empty;\n\nassign disp_o_alu_valid = disp_i_valid && disp_i_ready;\nassign disp_o_alu_rs1 = disp_i_rs1;\nassign disp_o_alu_rs2 = disp_i_rs2;\nassign disp_o_alu_rdwen = disp_i_rdwen;\nassign disp_o_alu_rdidx = disp_i_rdidx;\nassign disp_o_alu_info = disp_i_info;\nassign disp_o_alu_imm = disp_i_imm;\nassign disp_o_alu_pc = disp_i_pc;\nassign disp_o_alu_itag = disp_oitf_ptr;\nassign disp_o_alu_misalgn = disp_i_misalgn;\nassign disp_o_alu_buserr = disp_i_buserr;\nassign disp_o_alu_ilegl = disp_i_ilegl;\n\nassign disp_oitf_ena = disp_o_alu_valid && disp_o_alu_longpipe && disp_oitf_ready;\nassign disp_oitf_rs1fpu = 0; // Assuming no FPU in this example\nassign disp_oitf_rs2fpu = 0;\nassign disp_oitf_rs3fpu = 0;\nassign disp_oitf_rdfpu = 0;\nassign disp_oitf_rs1en = disp_i_rs1en;\nassign disp_oitf_rs2en = disp_i_rs2en;\nassign disp_oitf_rs3en = 0; // Assuming no third operand\nassign disp_oitf_rdwen = disp_i_rdwen;\nassign disp_oitf_rs1idx = disp_i_rs1idx;\nassign disp_oitf_rs2idx = disp_i_rs2idx;\nassign disp_oitf_rs3idx = 0; // Assuming no third operand\nassign disp_oitf_rdidx = disp_i_rdidx;\nassign disp_oitf_pc = disp_i_pc;\n\nassign wfi_halt_exu_ack = wfi_halt_exu_req && oitf_empty && !amo_wait;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 7, "code": "module e203_exu_branchslv (\n    input wire cmt_i_valid,\n    output wire cmt_i_ready,\n    input wire cmt_i_rv32,\n    input wire cmt_i_dret,\n    input wire cmt_i_mret,\n    input wire cmt_i_fencei,\n    input wire cmt_i_bjp,\n    input wire cmt_i_bjp_prdt,\n    input wire cmt_i_bjp_rslv,\n    input wire [E203_PC_SIZE-1:0] cmt_i_pc,\n    input wire [E203_XLEN-1:0] cmt_i_imm,\n    input wire [E203_PC_SIZE-1:0] csr_epc_r,\n    input wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    input wire nonalu_excpirq_flush_req_raw,\n    input wire brchmis_flush_ack,\n    output wire brchmis_flush_req,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op1,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op2,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_pc,\n    output wire cmt_mret_ena,\n    output wire cmt_dret_ena,\n    output wire cmt_fencei_ena,\n    input wire clk,\n    input wire rst_n\n);\n\n    wire flush_need;\n    wire flush_target_mret;\n    wire flush_target_dret;\n    wire flush_target_fencei;\n    wire flush_target_bjp_mis;\n    wire flush_target_bjp_taken;\n    wire flush_target_bjp_not_taken;\n\n    assign flush_need = (cmt_i_fencei | cmt_i_mret | cmt_i_dret |\n                        (cmt_i_bjp & (cmt_i_bjp_prdt ^ cmt_i_bjp_rslv)));\n\n    assign flush_target_mret = cmt_i_mret;\n    assign flush_target_dret = cmt_i_dret;\n    assign flush_target_fencei = cmt_i_fencei;\n    assign flush_target_bjp_mis = cmt_i_bjp & (cmt_i_bjp_prdt ^ cmt_i_bjp_rslv);\n    assign flush_target_bjp_taken = cmt_i_bjp & cmt_i_bjp_rslv;\n    assign flush_target_bjp_not_taken = cmt_i_bjp & ~cmt_i_bjp_rslv;\n\n    assign brchmis_flush_req = flush_need & cmt_i_valid & ~nonalu_excpirq_flush_req_raw;\n    assign cmt_i_ready = ~flush_need | brchmis_flush_ack;\n\n    assign cmt_mret_ena = flush_target_mret & brchmis_flush_ack;\n    assign cmt_dret_ena = flush_target_dret & brchmis_flush_ack;\n    assign cmt_fencei_ena = flush_target_fencei & brchmis_flush_ack;\n\n    assign brchmis_flush_add_op1 = (flush_target_dret ? csr_dpc_r :\n                                   (flush_target_mret ? csr_epc_r : cmt_i_pc));\n\n    assign brchmis_flush_add_op2 = (flush_target_bjp_taken ? cmt_i_imm :\n                                   (cmt_i_rv32 ? 32'd4 : 32'd2));\n\n    assign brchmis_flush_pc = (flush_target_fencei | (flush_target_bjp_mis & cmt_i_bjp_prdt)) ? \n                              (cmt_i_pc + (cmt_i_rv32 ? 32'd4 : 32'd2)) :\n                              (flush_target_bjp_taken ? (cmt_i_pc + cmt_i_imm) :\n                              (flush_target_dret ? csr_dpc_r : csr_epc_r));\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 15, "code": "module e203_biu(\n    input wire clk,\n    input wire rst_n,\n    output wire biu_active,\n\n    // LSU Interface\n    input wire lsu_icb_cmd_valid,\n    output wire lsu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] lsu_icb_cmd_addr,\n    input wire lsu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] lsu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] lsu_icb_cmd_wmask,\n    input wire [1:0] lsu_icb_cmd_burst,\n    input wire [1:0] lsu_icb_cmd_beat,\n    input wire lsu_icb_cmd_lock,\n    input wire lsu_icb_cmd_excl,\n    input wire [1:0] lsu_icb_cmd_size,\n    output wire lsu_icb_rsp_valid,\n    input wire lsu_icb_rsp_ready,\n    output wire lsu_icb_rsp_err,\n    output wire lsu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] lsu_icb_rsp_rdata,\n\n    // IFU Interface\n    `ifdef E203_HAS_MEM_ITF\n    input wire ifu_icb_cmd_valid,\n    output wire ifu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] ifu_icb_cmd_addr,\n    input wire ifu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ifu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] ifu_icb_cmd_wmask,\n    input wire [1:0] ifu_icb_cmd_burst,\n    input wire [1:0] ifu_icb_cmd_beat,\n    input wire ifu_icb_cmd_lock,\n    input wire ifu_icb_cmd_excl,\n    input wire [1:0] ifu_icb_cmd_size,\n    output wire ifu_icb_rsp_valid,\n    input wire ifu_icb_rsp_ready,\n    output wire ifu_icb_rsp_err,\n    output wire ifu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] ifu_icb_rsp_rdata,\n    `endif\n\n    // PPI Interface\n    input wire ppi_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] ppi_region_indic,\n\n    // CLINT Interface\n    input wire clint_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] clint_region_indic,\n\n    // PLIC Interface\n    input wire plic_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] plic_region_indic,\n\n    // FIO Interface\n    `ifdef E203_HAS_FIO\n    input wire fio_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] fio_region_indic,\n    `endif\n\n    // MEM Interface\n    `ifdef E203_HAS_MEM_ITF\n    input wire mem_icb_enable,\n    `endif\n\n    // Outputs to external memory system\n    output wire ext_icb_cmd_valid,\n    input wire ext_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] ext_icb_cmd_addr,\n    output wire ext_icb_cmd_read,\n    output wire [E203_XLEN-1:0] ext_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] ext_icb_cmd_wmask,\n    output wire ext_icb_rsp_valid,\n    input wire ext_icb_rsp_ready,\n    output wire ext_icb_rsp_err,\n    output wire ext_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] ext_icb_rsp_rdata\n);\n\n    // Internal signals for arbitration and splitting logic\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_valid;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_ready;\n    wire [E203_ADDR_SIZE*BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_addr;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_read;\n    wire [E203_XLEN*BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_wdata;\n    wire [(E203_XLEN/8)*BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_wmask;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_valid;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_ready;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_err;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_excl_ok;\n    wire [E203_XLEN*BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_rdata;\n\n    // Instantiate the ICB Arbiter\n    sirv_gnrl_icb_arbt #(\n        .AW(E203_ADDR_SIZE),\n        .DW(E203_XLEN),\n        .ARBT_NUM(BIU_ARBT_I_NUM),\n        .ARBT_PTR_W(BIU_ARBT_I_PTR_W),\n        .USR_W(1),\n        .ARBT_SCHEME(0),\n        .ALLOW_0CYCL_RSP(0),\n        .FIFO_OUTS_NUM(E203_BIU_OUTS_NUM),\n        .FIFO_CUT_READY(E203_BIU_CMD_CUT_READY)\n    ) u_icb_arbt (\n        .clk(clk),\n        .rst_n(rst_n),\n        .i_bus_icb_cmd_valid(arbt_icb_cmd_valid),\n        .i_bus_icb_cmd_ready(arbt_icb_cmd_ready),\n        .i_bus_icb_cmd_addr(arbt_icb_cmd_addr),\n        .i_bus_icb_cmd_read(arbt_icb_cmd_read),\n        .i_bus_icb_cmd_wdata(arbt_icb_cmd_wdata),\n        .i_bus_icb_cmd_wmask(arbt_icb_cmd_wmask),\n        .o_icb_cmd_valid(ext_icb_cmd_valid),\n        .o_icb_cmd_ready(ext_icb_cmd_ready),\n        .o_icb_cmd_addr(ext_icb_cmd_addr),\n        .o_icb_cmd_read(ext_icb_cmd_read),\n        .o_icb_cmd_wdata(ext_icb_cmd_wdata),\n        .o_icb_cmd_wmask(ext_icb_cmd_wmask),\n        .i_bus_icb_rsp_valid(arbt_icb_rsp_valid),\n        .i_bus_icb_rsp_ready(arbt_icb_rsp_ready),\n        .i_bus_icb_rsp_err(arbt_icb_rsp_err),\n        .i_bus_icb_rsp_excl_ok(arbt_icb_rsp_excl_ok),\n        .i_bus_icb_rsp_rdata(arbt_icb_rsp_rdata),\n        .o_icb_rsp_valid(ext_icb_rsp_valid),\n        .o_icb_rsp_ready(ext_icb_rsp_ready),\n        .o_icb_rsp_err(ext_icb_rsp_err),\n        .o_icb_rsp_excl_ok(ext_icb_rsp_excl_ok),\n        .o_icb_rsp_rdata(ext_icb_rsp_rdata)\n    );\n\n    // Logic to connect LSU, IFU, and other interfaces to the arbiter\n    assign arbt_icb_cmd_valid = {`ifdef E203_HAS_MEM_ITF ifu_icb_cmd_valid, `endif lsu_icb_cmd_valid};\n    assign {`ifdef E203_HAS_MEM_ITF ifu_icb_cmd_ready, `endif lsu_icb_cmd_ready} = arbt_icb_cmd_ready;\n    assign arbt_icb_cmd_addr = {`ifdef E203_HAS_MEM_ITF ifu_icb_cmd_addr, `endif lsu_icb_cmd_addr};\n    assign arbt_icb_cmd_read = {`ifdef E203_HAS_MEM_ITF ifu_icb_cmd_read, `endif lsu_icb_cmd_read};\n    assign arbt_icb_cmd_wdata = {`ifdef E203_HAS_MEM_ITF ifu_icb_cmd_wdata, `endif lsu_icb_cmd_wdata};\n    assign arbt_icb_cmd_wmask = {`ifdef E203_HAS_MEM_ITF ifu_icb_cmd_wmask, `endif lsu_icb_cmd_wmask};\n    assign {`ifdef E203_HAS_MEM_ITF ifu_icb_rsp_valid, `endif lsu_icb_rsp_valid} = arbt_icb_rsp_valid;\n    assign arbt_icb_rsp_ready = {`ifdef E203_HAS_MEM_ITF ifu_icb_rsp_ready, `endif lsu_icb_rsp_ready};\n    assign {`ifdef E203_HAS_MEM_ITF ifu_icb_rsp_err, `endif lsu_icb_rsp_err} = arbt_icb_rsp_err;\n    assign {`ifdef E203_HAS_MEM_ITF ifu_icb_rsp_excl_ok, `endif lsu_icb_rsp_excl_ok} = arbt_icb_rsp_excl_ok;\n    assign {`ifdef E203_HAS_MEM_ITF ifu_icb_rsp_rdata, `endif lsu_icb_rsp_rdata} = arbt_icb_rsp_rdata;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 16, "code": "module e203_biu(\n    input wire clk,\n    input wire rst_n,\n    output wire biu_active,\n\n    // LSU Interface\n    input wire lsu_icb_cmd_valid,\n    output wire lsu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] lsu_icb_cmd_addr,\n    input wire lsu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] lsu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] lsu_icb_cmd_wmask,\n    input wire [1:0] lsu_icb_cmd_burst,\n    input wire [1:0] lsu_icb_cmd_beat,\n    input wire lsu_icb_cmd_lock,\n    input wire lsu_icb_cmd_excl,\n    input wire [1:0] lsu_icb_cmd_size,\n    output wire lsu_icb_rsp_valid,\n    input wire lsu_icb_rsp_ready,\n    output wire lsu_icb_rsp_err,\n    output wire lsu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] lsu_icb_rsp_rdata,\n\n    // IFU Interface\n    `ifdef E203_HAS_MEM_ITF\n    input wire ifu_icb_cmd_valid,\n    output wire ifu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] ifu_icb_cmd_addr,\n    input wire ifu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ifu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] ifu_icb_cmd_wmask,\n    input wire [1:0] ifu_icb_cmd_burst,\n    input wire [1:0] ifu_icb_cmd_beat,\n    input wire ifu_icb_cmd_lock,\n    input wire ifu_icb_cmd_excl,\n    input wire [1:0] ifu_icb_cmd_size,\n    output wire ifu_icb_rsp_valid,\n    input wire ifu_icb_rsp_ready,\n    output wire ifu_icb_rsp_err,\n    output wire ifu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] ifu_icb_rsp_rdata,\n    `endif\n\n    // PPI Interface\n    input wire ppi_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] ppi_region_indic,\n\n    // CLINT Interface\n    input wire clint_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] clint_region_indic,\n\n    // PLIC Interface\n    input wire plic_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] plic_region_indic,\n\n    // FIO Interface\n    `ifdef E203_HAS_FIO\n    input wire fio_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] fio_region_indic,\n    `endif\n\n    // MEM Interface\n    `ifdef E203_HAS_MEM_ITF\n    input wire mem_icb_enable,\n    `endif\n\n    // Output Interface to Memory\n    output wire mem_icb_cmd_valid,\n    input wire mem_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] mem_icb_cmd_addr,\n    output wire mem_icb_cmd_read,\n    output wire [E203_XLEN-1:0] mem_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] mem_icb_cmd_wmask,\n    output wire mem_icb_rsp_valid,\n    input wire mem_icb_rsp_ready,\n    output wire mem_icb_rsp_err,\n    output wire [E203_XLEN-1:0] mem_icb_rsp_rdata\n);\n\n    // Internal signals for arbitration and control logic\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_valid;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_ready;\n    wire [E203_ADDR_SIZE*BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_addr;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_read;\n    wire [E203_XLEN*BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_wdata;\n    wire [(E203_XLEN/8)*BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_wmask;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_valid;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_ready;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_err;\n    wire [E203_XLEN*BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_rdata;\n\n    // Arbitration logic\n    sirv_gnrl_icb_arbt #(\n        .AW(E203_ADDR_SIZE),\n        .DW(E203_XLEN),\n        .ARBT_NUM(BIU_ARBT_I_NUM),\n        .ARBT_PTR_W(BIU_ARBT_I_PTR_W),\n        .USR_W(1),\n        .ARBT_SCHEME(0),\n        .ALLOW_0CYCL_RSP(0),\n        .FIFO_OUTS_NUM(E203_BIU_OUTS_NUM),\n        .FIFO_CUT_READY(E203_BIU_CMD_CUT_READY)\n    ) u_icb_arbt (\n        .clk(clk),\n        .rst_n(rst_n),\n        .i_bus_icb_cmd_valid(arbt_icb_cmd_valid),\n        .i_bus_icb_cmd_ready(arbt_icb_cmd_ready),\n        .i_bus_icb_cmd_addr(arbt_icb_cmd_addr),\n        .i_bus_icb_cmd_read(arbt_icb_cmd_read),\n        .i_bus_icb_cmd_wdata(arbt_icb_cmd_wdata),\n        .i_bus_icb_cmd_wmask(arbt_icb_cmd_wmask),\n        .o_icb_cmd_valid(mem_icb_cmd_valid),\n        .o_icb_cmd_ready(mem_icb_cmd_ready),\n        .o_icb_cmd_addr(mem_icb_cmd_addr),\n        .o_icb_cmd_read(mem_icb_cmd_read),\n        .o_icb_cmd_wdata(mem_icb_cmd_wdata),\n        .o_icb_cmd_wmask(mem_icb_cmd_wmask),\n        .o_icb_rsp_valid(mem_icb_rsp_valid),\n        .o_icb_rsp_ready(mem_icb_rsp_ready),\n        .o_icb_rsp_err(mem_icb_rsp_err),\n        .o_icb_rsp_rdata(mem_icb_rsp_rdata)\n    );\n\n    // Logic to connect LSU, IFU, and other interfaces to the arbiter\n    assign arbt_icb_cmd_valid = {`ifdef E203_HAS_MEM_ITF ifu_icb_cmd_valid, `endif lsu_icb_cmd_valid};\n    assign {`ifdef E203_HAS_MEM_ITF ifu_icb_cmd_ready, `endif lsu_icb_cmd_ready} = arbt_icb_cmd_ready;\n    assign arbt_icb_cmd_addr = {`ifdef E203_HAS_MEM_ITF ifu_icb_cmd_addr, `endif lsu_icb_cmd_addr};\n    assign arbt_icb_cmd_read = {`ifdef E203_HAS_MEM_ITF ifu_icb_cmd_read, `endif lsu_icb_cmd_read};\n    assign arbt_icb_cmd_wdata = {`ifdef E203_HAS_MEM_ITF ifu_icb_cmd_wdata, `endif lsu_icb_cmd_wdata};\n    assign arbt_icb_cmd_wmask = {`ifdef E203_HAS_MEM_ITF ifu_icb_cmd_wmask, `endif lsu_icb_cmd_wmask};\n    assign {`ifdef E203_HAS_MEM_ITF ifu_icb_rsp_valid, `endif lsu_icb_rsp_valid} = arbt_icb_rsp_valid;\n    assign arbt_icb_rsp_ready = {`ifdef E203_HAS_MEM_ITF ifu_icb_rsp_ready, `endif lsu_icb_rsp_ready};\n    assign {`ifdef E203_HAS_MEM_ITF ifu_icb_rsp_err, `endif lsu_icb_rsp_err} = arbt_icb_rsp_err;\n    assign {`ifdef E203_HAS_MEM_ITF ifu_icb_rsp_rdata, `endif lsu_icb_rsp_rdata} = arbt_icb_rsp_rdata;\n\n    // Active status indication\n    assign biu_active = |arbt_icb_cmd_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 4, "code": "module e203_exu_longpwbck (\n    input wire lsu_wbck_i_valid,\n    output wire lsu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] lsu_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] lsu_wbck_i_itag,\n    input wire lsu_wbck_i_err,\n    input wire lsu_cmt_i_buserr,\n    input wire [E203_ADDR_SIZE-1:0] lsu_cmt_i_badaddr,\n    input wire lsu_cmt_i_ld,\n    input wire lsu_cmt_i_st,\n    output wire longp_wbck_o_valid,\n    input wire longp_wbck_o_ready,\n    output wire [E203_FLEN-1:0] longp_wbck_o_wdat,\n    output wire [4:0] longp_wbck_o_flags,\n    output wire [E203_RFIDX_WIDTH-1:0] longp_wbck_o_rdidx,\n    output wire longp_wbck_o_rdfpu,\n    output wire longp_excp_o_valid,\n    input wire longp_excp_o_ready,\n    output wire longp_excp_o_insterr,\n    output wire longp_excp_o_ld,\n    output wire longp_excp_o_st,\n    output wire longp_excp_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] longp_excp_o_badaddr,\n    output wire [E203_PC_SIZE-1:0] longp_excp_o_pc,\n    input wire oitf_empty,\n    input wire [E203_ITAG_WIDTH-1:0] oitf_ret_ptr,\n    input wire [E203_RFIDX_WIDTH-1:0] oitf_ret_rdidx,\n    input wire [E203_PC_SIZE-1:0] oitf_ret_pc,\n    input wire oitf_ret_rdwen,\n    input wire oitf_ret_rdfpu,\n    output wire oitf_ret_ena,\n    input wire clk,\n    input wire rst_n\n`ifdef E203_HAS_NICE\n    , input wire nice_longp_wbck_i_valid,\n    output wire nice_longp_wbck_i_ready,\n    input wire [E203_XLEN-1:0] nice_longp_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] nice_longp_wbck_i_itag,\n    input wire nice_longp_wbck_i_err\n`endif\n);\n\n    // Write-back and exception arbitration logic\n    wire wbck_need = (oitf_ret_rdwen && !lsu_wbck_i_err);\n    wire excp_need = (lsu_wbck_i_err || lsu_cmt_i_buserr);\n\n    assign lsu_wbck_i_ready = (wbck_need && longp_wbck_o_ready) && (excp_need && longp_excp_o_ready);\n    assign longp_wbck_o_valid = wbck_need && lsu_wbck_i_valid && !excp_need;\n    assign longp_excp_o_valid = excp_need && lsu_wbck_i_valid && !wbck_need;\n\n    assign longp_wbck_o_wdat = lsu_wbck_i_wdat;\n    assign longp_wbck_o_rdidx = oitf_ret_rdidx;\n    assign longp_wbck_o_rdfpu = oitf_ret_rdfpu;\n    assign longp_wbck_o_flags = {lsu_cmt_i_ld, lsu_cmt_i_st, 3'b000}; // Example flags\n\n    assign longp_excp_o_insterr = lsu_wbck_i_err;\n    assign longp_excp_o_ld = lsu_cmt_i_ld;\n    assign longp_excp_o_st = lsu_cmt_i_st;\n    assign longp_excp_o_buserr = lsu_cmt_i_buserr;\n    assign longp_excp_o_badaddr = lsu_cmt_i_badaddr;\n    assign longp_excp_o_pc = oitf_ret_pc;\n\n    assign oitf_ret_ena = lsu_wbck_i_ready && lsu_wbck_i_valid;\n\n`ifdef E203_HAS_NICE\n    assign nice_longp_wbck_i_ready = (wbck_need && longp_wbck_o_ready) && (excp_need && longp_excp_o_ready);\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 14, "code": "module e203_dtcm_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n    output wire dtcm_active,\n\n    // LSU ICB Interface\n    input wire lsu2dtcm_icb_cmd_valid,\n    output wire lsu2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] lsu2dtcm_icb_cmd_addr,\n    input wire lsu2dtcm_icb_cmd_read,\n    input wire [31:0] lsu2dtcm_icb_cmd_wdata,\n    input wire [3:0] lsu2dtcm_icb_cmd_wmask,\n    output wire lsu2dtcm_icb_rsp_valid,\n    input wire lsu2dtcm_icb_rsp_ready,\n    output wire lsu2dtcm_icb_rsp_err,\n    output wire [31:0] lsu2dtcm_icb_rsp_rdata,\n\n    // External ICB Interface (Optional)\n    `ifdef E203_HAS_DTCM_EXTITF\n    input wire ext2dtcm_icb_cmd_valid,\n    output wire ext2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] ext2dtcm_icb_cmd_addr,\n    input wire ext2dtcm_icb_cmd_read,\n    input wire [31:0] ext2dtcm_icb_cmd_wdata,\n    input wire [3:0] ext2dtcm_icb_cmd_wmask,\n    output wire ext2dtcm_icb_rsp_valid,\n    input wire ext2dtcm_icb_rsp_ready,\n    output wire ext2dtcm_icb_rsp_err,\n    output wire [31:0] ext2dtcm_icb_rsp_rdata,\n    `endif\n\n    // DTCM RAM Interface\n    output wire dtcm_ram_cs,\n    output wire dtcm_ram_we,\n    output wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    output wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    output wire clk_dtcm_ram\n);\n\n    // Internal signals for arbitration and control\n    wire arb_cmd_valid;\n    wire arb_cmd_ready;\n    wire arb_cmd_read;\n    wire [E203_DTCM_ADDR_WIDTH-1:0] arb_cmd_addr;\n    wire [31:0] arb_cmd_wdata;\n    wire [3:0] arb_cmd_wmask;\n    wire arb_rsp_valid;\n    wire arb_rsp_ready;\n    wire arb_rsp_err;\n    wire [31:0] arb_rsp_rdata;\n\n    // Instantiate the bus arbiter\n    sirv_gnrl_icb_arbt #(\n        .ARBT_SCHEME(0),\n        .ALLOW_0CYCL_RSP(0),\n        .FIFO_OUTS_NUM(E203_DTCM_OUTS_NUM),\n        .FIFO_CUT_READY(0),\n        .USR_W(1),\n        .ARBT_NUM(DTCM_ARBT_I_NUM),\n        .AW(E203_DTCM_ADDR_WIDTH),\n        .DW(32),\n        .ARBT_PTR_W(DTCM_ARBT_I_PTR_W)\n    ) u_dtcm_arbiter (\n        .o_icb_cmd_valid(arb_cmd_valid),\n        .o_icb_cmd_ready(arb_cmd_ready),\n        .o_icb_cmd_read(arb_cmd_read),\n        .o_icb_cmd_addr(arb_cmd_addr),\n        .o_icb_cmd_wdata(arb_cmd_wdata),\n        .o_icb_cmd_wmask(arb_cmd_wmask),\n        .o_icb_rsp_valid(arb_rsp_valid),\n        .o_icb_rsp_ready(arb_rsp_ready),\n        .o_icb_rsp_err(arb_rsp_err),\n        .o_icb_rsp_rdata(arb_rsp_rdata),\n        .i_bus_icb_cmd_ready({ext2dtcm_icb_cmd_ready, lsu2dtcm_icb_cmd_ready}),\n        .i_bus_icb_cmd_valid({ext2dtcm_icb_cmd_valid, lsu2dtcm_icb_cmd_valid}),\n        .i_bus_icb_cmd_read({ext2dtcm_icb_cmd_read, lsu2dtcm_icb_cmd_read}),\n        .i_bus_icb_cmd_addr({ext2dtcm_icb_cmd_addr, lsu2dtcm_icb_cmd_addr}),\n        .i_bus_icb_cmd_wdata({ext2dtcm_icb_cmd_wdata, lsu2dtcm_icb_cmd_wdata}),\n        .i_bus_icb_cmd_wmask({ext2dtcm_icb_cmd_wmask, lsu2dtcm_icb_cmd_wmask}),\n        .i_bus_icb_rsp_valid({ext2dtcm_icb_rsp_valid, lsu2dtcm_icb_rsp_valid}),\n        .i_bus_icb_rsp_ready({ext2dtcm_icb_rsp_ready, lsu2dtcm_icb_rsp_ready}),\n        .i_bus_icb_rsp_err({ext2dtcm_icb_rsp_err, lsu2dtcm_icb_rsp_err}),\n        .i_bus_icb_rsp_rdata({ext2dtcm_icb_rsp_rdata, lsu2dtcm_icb_rsp_rdata}),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\n    // SRAM controller\n    sirv_sram_icb_ctrl #(\n        .DW(E203_DTCM_DATA_WIDTH),\n        .AW(E203_DTCM_ADDR_WIDTH),\n        .MW(E203_DTCM_WMSK_WIDTH),\n        .AW_LSB(2),\n        .USR_W(1)\n    ) u_dtcm_sram_ctrl (\n        .sram_ctrl_active(dtcm_active),\n        .tcm_cgstop(tcm_cgstop),\n        .i_icb_cmd_valid(arb_cmd_valid),\n        .i_icb_cmd_ready(arb_cmd_ready),\n        .i_icb_cmd_read(arb_cmd_read),\n        .i_icb_cmd_addr(arb_cmd_addr),\n        .i_icb_cmd_wdata(arb_cmd_wdata),\n        .i_icb_cmd_wmask(arb_cmd_wmask),\n        .i_icb_rsp_valid(arb_rsp_valid),\n        .i_icb_rsp_ready(arb_rsp_ready),\n        .i_icb_rsp_rdata(arb_rsp_rdata),\n        .ram_cs(dtcm_ram_cs),\n        .ram_we(dtcm_ram_we),\n        .ram_addr(dtcm_ram_addr),\n        .ram_wem(dtcm_ram_wem),\n        .ram_din(dtcm_ram_din),\n        .ram_dout(dtcm_ram_dout),\n        .clk_ram(clk_dtcm_ram),\n        .test_mode(test_mode),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 15, "code": "module e203_dtcm_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n    output wire dtcm_active,\n\n    // LSU ICB Interface\n    input wire lsu2dtcm_icb_cmd_valid,\n    output wire lsu2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] lsu2dtcm_icb_cmd_addr,\n    input wire lsu2dtcm_icb_cmd_read,\n    input wire [31:0] lsu2dtcm_icb_cmd_wdata,\n    input wire [3:0] lsu2dtcm_icb_cmd_wmask,\n    output wire lsu2dtcm_icb_rsp_valid,\n    input wire lsu2dtcm_icb_rsp_ready,\n    output wire lsu2dtcm_icb_rsp_err,\n    output wire [31:0] lsu2dtcm_icb_rsp_rdata,\n\n    // External ICB Interface (Optional)\n    `ifdef E203_HAS_DTCM_EXTITF\n    input wire ext2dtcm_icb_cmd_valid,\n    output wire ext2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] ext2dtcm_icb_cmd_addr,\n    input wire ext2dtcm_icb_cmd_read,\n    input wire [31:0] ext2dtcm_icb_cmd_wdata,\n    input wire [3:0] ext2dtcm_icb_cmd_wmask,\n    output wire ext2dtcm_icb_rsp_valid,\n    input wire ext2dtcm_icb_rsp_ready,\n    output wire ext2dtcm_icb_rsp_err,\n    output wire [31:0] ext2dtcm_icb_rsp_rdata,\n    `endif\n\n    // DTCM RAM Interface\n    output wire dtcm_ram_cs,\n    output wire dtcm_ram_we,\n    output wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    output wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    output wire clk_dtcm_ram\n);\n\n    // Internal signals for arbitration and control logic\n    wire arb_cmd_valid;\n    wire arb_cmd_ready;\n    wire [E203_DTCM_ADDR_WIDTH-1:0] arb_cmd_addr;\n    wire arb_cmd_read;\n    wire [31:0] arb_cmd_wdata;\n    wire [3:0] arb_cmd_wmask;\n    wire arb_rsp_valid;\n    wire arb_rsp_ready;\n    wire arb_rsp_err;\n    wire [31:0] arb_rsp_rdata;\n\n    // Instantiate the bus arbiter\n    sirv_gnrl_icb_arbt #(\n        .ARBT_SCHEME(0),\n        .ALLOW_0CYCL_RSP(0),\n        .FIFO_OUTS_NUM(E203_DTCM_OUTS_NUM),\n        .FIFO_CUT_READY(0),\n        .USR_W(1),\n        .ARBT_NUM(DTCM_ARBT_I_NUM),\n        .AW(E203_DTCM_ADDR_WIDTH),\n        .DW(32),\n        .ARBT_PTR_W(DTCM_ARBT_I_PTR_W)\n    ) u_dtcm_arbiter (\n        .o_icb_cmd_valid(arb_cmd_valid),\n        .o_icb_cmd_ready(arb_cmd_ready),\n        .o_icb_cmd_read(arb_cmd_read),\n        .o_icb_cmd_addr(arb_cmd_addr),\n        .o_icb_cmd_wdata(arb_cmd_wdata),\n        .o_icb_cmd_wmask(arb_cmd_wmask),\n        .o_icb_rsp_valid(arb_rsp_valid),\n        .o_icb_rsp_ready(arb_rsp_ready),\n        .o_icb_rsp_err(arb_rsp_err),\n        .o_icb_rsp_rdata(arb_rsp_rdata),\n        .i_bus_icb_cmd_ready({lsu2dtcm_icb_cmd_ready, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_cmd_ready `endif}),\n        .i_bus_icb_cmd_valid({lsu2dtcm_icb_cmd_valid, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_cmd_valid `endif}),\n        .i_bus_icb_cmd_read({lsu2dtcm_icb_cmd_read, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_cmd_read `endif}),\n        .i_bus_icb_cmd_addr({lsu2dtcm_icb_cmd_addr, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_cmd_addr `endif}),\n        .i_bus_icb_cmd_wdata({lsu2dtcm_icb_cmd_wdata, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_cmd_wdata `endif}),\n        .i_bus_icb_cmd_wmask({lsu2dtcm_icb_cmd_wmask, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_cmd_wmask `endif}),\n        .i_bus_icb_rsp_valid({lsu2dtcm_icb_rsp_valid, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_rsp_valid `endif}),\n        .i_bus_icb_rsp_ready({lsu2dtcm_icb_rsp_ready, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_rsp_ready `endif}),\n        .i_bus_icb_rsp_err({lsu2dtcm_icb_rsp_err, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_rsp_err `endif}),\n        .i_bus_icb_rsp_rdata({lsu2dtcm_icb_rsp_rdata, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_rsp_rdata `endif}),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\n    // SRAM controller logic\n    assign dtcm_ram_cs = arb_cmd_valid && arb_cmd_ready;\n    assign dtcm_ram_we = !arb_cmd_read;\n    assign dtcm_ram_addr = arb_cmd_addr[E203_DTCM_RAM_AW-1:0];\n    assign dtcm_ram_wem = arb_cmd_wmask;\n    assign dtcm_ram_din = arb_cmd_wdata;\n    assign clk_dtcm_ram = clk;\n\n    // Response logic\n    assign arb_rsp_valid = dtcm_ram_cs && !arb_cmd_read;\n    assign arb_rsp_rdata = dtcm_ram_dout;\n    assign arb_rsp_err = 0; // No error handling in this example\n\n    // Activity indicator\n    assign dtcm_active = arb_cmd_valid || arb_rsp_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 9, "code": "module e203_exu_oitf #(\n  parameter E203_ITAG_WIDTH = 4, // Width of the instruction tag\n  parameter E203_RFIDX_WIDTH = 5, // Width of the register file index\n  parameter E203_PC_SIZE = 32 // Size of the program counter\n)(\n  input clk,\n  input rst_n,\n  output reg dis_ready,\n  input dis_ena,\n  input ret_ena,\n  output reg [E203_ITAG_WIDTH-1:0] dis_ptr,\n  output reg [E203_ITAG_WIDTH-1:0] ret_ptr,\n  output reg [E203_RFIDX_WIDTH-1:0] ret_rdidx,\n  output reg ret_rdwen,\n  output reg ret_rdfpu,\n  output reg [E203_PC_SIZE-1:0] ret_pc,\n  input disp_i_rs1en,\n  input disp_i_rs2en,\n  input disp_i_rs3en,\n  input disp_i_rdwen,\n  input disp_i_rs1fpu,\n  input disp_i_rs2fpu,\n  input disp_i_rs3fpu,\n  input disp_i_rdfpu,\n  input [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n  input [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n  input [E203_RFIDX_WIDTH-1:0] disp_i_rs3idx,\n  input [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n  input [E203_PC_SIZE-1:0] disp_i_pc,\n  output reg oitfrd_match_disprs1,\n  output reg oitfrd_match_disprs2,\n  output reg oitfrd_match_disprs3,\n  output reg oitfrd_match_disprd,\n  output reg oitf_empty\n);\n\n  // Internal FIFO storage for outstanding instructions\n  reg [E203_RFIDX_WIDTH-1:0] fifo_rdidx[E203_ITAG_WIDTH-1:0];\n  reg [E203_PC_SIZE-1:0] fifo_pc[E203_ITAG_WIDTH-1:0];\n  reg fifo_rdwen[E203_ITAG_WIDTH-1:0];\n  reg fifo_rdfpu[E203_ITAG_WIDTH-1:0];\n\n  // Pointers for dispatch and retire\n  reg [E203_ITAG_WIDTH:0] dis_ptr_next, ret_ptr_next;\n  reg full, empty;\n\n  // Update pointers and check full/empty status\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      dis_ptr <= 0;\n      ret_ptr <= 0;\n      dis_ready <= 1;\n      oitf_empty <= 1;\n      full <= 0;\n    end else begin\n      dis_ptr <= dis_ptr_next;\n      ret_ptr <= ret_ptr_next;\n      dis_ready <= !full;\n      oitf_empty <= empty;\n    end\n  end\n\n  // Calculate next pointers and full/empty flags\n  always @* begin\n    dis_ptr_next = dis_ptr;\n    ret_ptr_next = ret_ptr;\n    full = (dis_ptr_next == ret_ptr) && (dis_ena && !ret_ena);\n    empty = (dis_ptr == ret_ptr) && !dis_ena;\n\n    if (dis_ena && !full) begin\n      dis_ptr_next = dis_ptr + 1;\n    end\n    if (ret_ena && !empty) begin\n      ret_ptr_next = ret_ptr + 1;\n    end\n  end\n\n  // Handle dispatch of new instructions\n  always @(posedge clk) begin\n    if (dis_ena && !full) begin\n      fifo_rdidx[dis_ptr] <= disp_i_rdidx;\n      fifo_pc[dis_ptr] <= disp_i_pc;\n      fifo_rdwen[dis_ptr] <= disp_i_rdwen;\n      fifo_rdfpu[dis_ptr] <= disp_i_rdfpu;\n    end\n  end\n\n  // Handle retirement of instructions\n  always @(posedge clk) begin\n    if (ret_ena && !empty) begin\n      ret_rdidx <= fifo_rdidx[ret_ptr];\n      ret_pc <= fifo_pc[ret_ptr];\n      ret_rdwen <= fifo_rdwen[ret_ptr];\n      ret_rdfpu <= fifo_rdfpu[ret_ptr];\n    end\n  end\n\n  // Dependency checking logic\n  integer i;\n  always @* begin\n    oitfrd_match_disprs1 = 0;\n    oitfrd_match_disprs2 = 0;\n    oitfrd_match_disprs3 = 0;\n    oitfrd_match_disprd = 0;\n\n    for (i = 0; i < E203_ITAG_WIDTH; i = i + 1) begin\n      if (fifo_rdwen[i]) begin\n        if (disp_i_rs1en && (disp_i_rs1idx == fifo_rdidx[i]) && (disp_i_rs1fpu == fifo_rdfpu[i]))\n          oitfrd_match_disprs1 = 1;\n        if (disp_i_rs2en && (disp_i_rs2idx == fifo_rdidx[i]) && (disp_i_rs2fpu == fifo_rdfpu[i]))\n          oitfrd_match_disprs2 = 1;\n        if (disp_i_rs3en && (disp_i_rs3idx == fifo_rdidx[i]) && (disp_i_rs3fpu == fifo_rdfpu[i]))\n          oitfrd_match_disprs3 = 1;\n        if (disp_i_rdwen && (disp_i_rdidx == fifo_rdidx[i]) && (disp_i_rdfpu == fifo_rdfpu[i]))\n          oitfrd_match_disprd = 1;\n      end\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 17, "code": "module e203_biu(\n    input wire clk,\n    input wire rst_n,\n\n    // Control signals\n    output wire biu_active,\n\n    // ICB interface signals\n    input wire lsu_icb_cmd_valid,\n    output wire lsu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] lsu_icb_cmd_addr,\n    input wire lsu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] lsu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] lsu_icb_cmd_wmask,\n    input wire [1:0] lsu_icb_cmd_burst,\n    input wire [1:0] lsu_icb_cmd_beat,\n    input wire lsu_icb_cmd_lock,\n    input wire lsu_icb_cmd_excl,\n    input wire [1:0] lsu_icb_cmd_size,\n    output wire lsu_icb_rsp_valid,\n    input wire lsu_icb_rsp_ready,\n    output wire lsu_icb_rsp_err,\n    output wire lsu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] lsu_icb_rsp_rdata,\n\n    input wire ifu_icb_cmd_valid,\n    output wire ifu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] ifu_icb_cmd_addr,\n    input wire ifu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ifu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] ifu_icb_cmd_wmask,\n    input wire [1:0] ifu_icb_cmd_burst,\n    input wire [1:0] ifu_icb_cmd_beat,\n    input wire ifu_icb_cmd_lock,\n    input wire ifu_icb_cmd_excl,\n    input wire [1:0] ifu_icb_cmd_size,\n    output wire ifu_icb_rsp_valid,\n    input wire ifu_icb_rsp_ready,\n    output wire ifu_icb_rsp_err,\n    output wire ifu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] ifu_icb_rsp_rdata,\n\n    input wire ppi_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] ppi_region_indic,\n\n    input wire clint_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] clint_region_indic,\n\n    input wire plic_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] plic_region_indic,\n\n    input wire mem_icb_enable\n);\n\n    // Internal signals for arbitration and splitting\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_valid;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_ready;\n    wire [BIU_ARBT_I_NUM*E203_ADDR_SIZE-1:0] arbt_icb_cmd_addr;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_read;\n    wire [BIU_ARBT_I_NUM*E203_XLEN-1:0] arbt_icb_cmd_wdata;\n    wire [BIU_ARBT_I_NUM*(E203_XLEN/8)-1:0] arbt_icb_cmd_wmask;\n    wire [BIU_ARBT_I_NUM*2-1:0] arbt_icb_cmd_burst;\n    wire [BIU_ARBT_I_NUM*2-1:0] arbt_icb_cmd_beat;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_lock;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_excl;\n    wire [BIU_ARBT_I_NUM*2-1:0] arbt_icb_cmd_size;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_valid;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_ready;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_err;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_excl_ok;\n    wire [BIU_ARBT_I_NUM*E203_XLEN-1:0] arbt_icb_rsp_rdata;\n\n    // Instantiate the ICB Arbiter\n    sirv_gnrl_icb_arbt #(\n        .AW(E203_ADDR_SIZE),\n        .DW(E203_XLEN),\n        .ARBT_NUM(BIU_ARBT_I_NUM),\n        .ARBT_PTR_W(BIU_ARBT_I_PTR_W),\n        .USR_W(1),\n        .ARBT_SCHEME(0),\n        .ALLOW_0CYCL_RSP(0),\n        .FIFO_OUTS_NUM(E203_BIU_OUTS_NUM),\n        .FIFO_CUT_READY(E203_BIU_CMD_CUT_READY)\n    ) u_icb_arbt (\n        .clk(clk),\n        .rst_n(rst_n),\n        .i_bus_icb_cmd_valid({ifu_icb_cmd_valid, lsu_icb_cmd_valid}),\n        .i_bus_icb_cmd_ready({ifu_icb_cmd_ready, lsu_icb_cmd_ready}),\n        .i_bus_icb_cmd_addr({ifu_icb_cmd_addr, lsu_icb_cmd_addr}),\n        .i_bus_icb_cmd_read({ifu_icb_cmd_read, lsu_icb_cmd_read}),\n        .i_bus_icb_cmd_wdata({ifu_icb_cmd_wdata, lsu_icb_cmd_wdata}),\n        .i_bus_icb_cmd_wmask({ifu_icb_cmd_wmask, lsu_icb_cmd_wmask}),\n        .i_bus_icb_cmd_burst({ifu_icb_cmd_burst, lsu_icb_cmd_burst}),\n        .i_bus_icb_cmd_beat({ifu_icb_cmd_beat, lsu_icb_cmd_beat}),\n        .i_bus_icb_cmd_lock({ifu_icb_cmd_lock, lsu_icb_cmd_lock}),\n        .i_bus_icb_cmd_excl({ifu_icb_cmd_excl, lsu_icb_cmd_excl}),\n        .i_bus_icb_cmd_size({ifu_icb_cmd_size, lsu_icb_cmd_size}),\n        .o_bus_icb_rsp_valid({ifu_icb_rsp_valid, lsu_icb_rsp_valid}),\n        .o_bus_icb_rsp_ready({ifu_icb_rsp_ready, lsu_icb_rsp_ready}),\n        .o_bus_icb_rsp_err({ifu_icb_rsp_err, lsu_icb_rsp_err}),\n        .o_bus_icb_rsp_excl_ok({ifu_icb_rsp_excl_ok, lsu_icb_rsp_excl_ok}),\n        .o_bus_icb_rsp_rdata({ifu_icb_rsp_rdata, lsu_icb_rsp_rdata})\n    );\n\n    // Additional logic for BIU operation, splitting, and peripheral handling would be here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 18, "code": "module e203_extend_csr (\n    input wire clk,\n    input wire rst_n,\n    input wire nice_csr_valid,\n    output wire nice_csr_ready,\n    input wire [31:0] nice_csr_addr,\n    input wire nice_csr_wr,\n    input wire [31:0] nice_csr_wdata,\n    output wire [31:0] nice_csr_rdata\n);\n\n`ifdef E203_HAS_CSR_NICE\n    // CSR access ready signal, always 1\n    assign nice_csr_ready = 1'b1;\n    // CSR read data, always 0\n    assign nice_csr_rdata = 32'b0;\n\n    // Additional functionality can be implemented here\n`else\n    // When the module is disabled, outputs are set to default values\n    assign nice_csr_ready = 1'b0;\n    assign nice_csr_rdata = 32'b0;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 19, "code": "`include \"e203_defines.v\"\n\nmodule e203_extend_csr (\n    input wire clk,\n    input wire rst_n,\n    input wire nice_csr_valid,\n    output wire nice_csr_ready,\n    input wire [31:0] nice_csr_addr,\n    input wire nice_csr_wr,\n    input wire [31:0] nice_csr_wdata,\n    output wire [31:0] nice_csr_rdata\n);\n\n`ifdef E203_HAS_CSR_NICE\n    // CSR access ready signal, always 1\n    assign nice_csr_ready = 1'b1;\n\n    // CSR read data, always 0\n    assign nice_csr_rdata = 32'b0;\n\n    // Unused signals\n    wire unused = nice_csr_valid | nice_csr_wr | rst_n;\n    wire [31:0] unused_addr = nice_csr_addr;\n    wire [31:0] unused_wdata = nice_csr_wdata;\n`else\n    assign nice_csr_ready = 1'b0;\n    assign nice_csr_rdata = 32'b0;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 8, "code": "module e203_exu_alu_muldiv(\n    input mdv_nob2b,\n    input muldiv_i_valid,\n    output muldiv_i_ready,\n    input [E203_XLEN-1:0] muldiv_i_rs1,\n    input [E203_XLEN-1:0] muldiv_i_rs2,\n    input [E203_XLEN-1:0] muldiv_i_imm,\n    input [E203_DECINFO_MULDIV_WIDTH-1:0] muldiv_i_info,\n    input [E203_ITAG_WIDTH-1:0] muldiv_i_itag,\n    output muldiv_i_longpipe,\n    input flush_pulse,\n    output muldiv_o_valid,\n    input muldiv_o_ready,\n    output [E203_XLEN-1:0] muldiv_o_wbck_wdat,\n    output muldiv_o_wbck_err,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    output muldiv_req_alu_add,\n    output muldiv_req_alu_sub,\n    input [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output muldiv_sbf_0_ena,\n    output [32:0] muldiv_sbf_0_nxt,\n    input [32:0] muldiv_sbf_0_r,\n    output muldiv_sbf_1_ena,\n    output [32:0] muldiv_sbf_1_nxt,\n    input [32:0] muldiv_sbf_1_r,\n    input clk,\n    input rst_n\n);\n\n// Internal signals and registers\nreg [4:0] state;\nreg [E203_XLEN-1:0] operand1, operand2;\nwire [E203_XLEN-1:0] result;\nreg muldiv_i_ready_reg, muldiv_o_valid_reg;\nreg [E203_XLEN-1:0] muldiv_o_wbck_wdat_reg;\nreg muldiv_o_wbck_err_reg;\n\n// State machine for handling multiplier and divider operations\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        state <= MULDIV_STATE_0TH;\n        muldiv_i_ready_reg <= 1'b0;\n        muldiv_o_valid_reg <= 1'b0;\n        muldiv_o_wbck_wdat_reg <= {E203_XLEN{1'b0}};\n        muldiv_o_wbck_err_reg <= 1'b0;\n    end else begin\n        case (state)\n            MULDIV_STATE_0TH: begin\n                if (muldiv_i_valid && muldiv_i_ready) begin\n                    operand1 <= muldiv_i_rs1;\n                    operand2 <= muldiv_i_rs2;\n                    state <= MULDIV_STATE_EXEC;\n                    muldiv_i_ready_reg <= 1'b0;\n                end else begin\n                    muldiv_i_ready_reg <= 1'b1;\n                end\n            end\n            MULDIV_STATE_EXEC: begin\n                // Execute multiplication or division\n                if (execution_complete) begin\n                    muldiv_o_wbck_wdat_reg <= result;\n                    muldiv_o_valid_reg <= 1'b1;\n                    state <= MULDIV_STATE_0TH;\n                end\n            end\n            default: state <= MULDIV_STATE_0TH;\n        endcase\n    end\nend\n\n// Output assignments\nassign muldiv_i_ready = muldiv_i_ready_reg;\nassign muldiv_o_valid = muldiv_o_valid_reg;\nassign muldiv_o_wbck_wdat = muldiv_o_wbck_wdat_reg;\nassign muldiv_o_wbck_err = muldiv_o_wbck_err_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 3, "code": "module e203_ifu(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire itcm_nohold,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input wire pipe_flush_req,\n    input wire ifu_halt_req,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire ifu_active,\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    output wire pipe_flush_ack,\n    output wire ifu_halt_ack\n);\n\n    // Internal signals\n    wire ifu_req_valid;\n    wire [E203_PC_SIZE-1:0] ifu_req_pc;\n    wire ifu_req_seq;\n    wire ifu_req_seq_rv32;\n    wire [E203_PC_SIZE-1:0] ifu_req_last_pc;\n    wire ifu_req_ready;\n    wire ifu_rsp_valid;\n    wire ifu_rsp_err;\n    wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr;\n\n    // Instantiate the IFU fetch module\n    e203_ifu_ifetch ifetch (\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ifu_o_ready(ifu_o_ready),\n        .pipe_flush_req(pipe_flush_req),\n        .pipe_flush_add_op1(pipe_flush_add_op1),\n        .pipe_flush_add_op2(pipe_flush_add_op2),\n        .ifu_halt_req(ifu_halt_req),\n        .oitf_empty(oitf_empty),\n        .rf2ifu_x1(rf2ifu_x1),\n        .rf2ifu_rs1(rf2ifu_rs1),\n        .dec2ifu_rden(dec2ifu_rden),\n        .dec2ifu_rs1en(dec2ifu_rs1en),\n        .dec2ifu_rdidx(dec2ifu_rdidx),\n        .dec2ifu_mulhsu(dec2ifu_mulhsu),\n        .dec2ifu_div(dec2ifu_div),\n        .dec2ifu_rem(dec2ifu_rem),\n        .dec2ifu_divu(dec2ifu_divu),\n        .dec2ifu_remu(dec2ifu_remu),\n        .inspect_pc(inspect_pc),\n        .ifu_req_valid(ifu_req_valid),\n        .ifu_req_pc(ifu_req_pc),\n        .ifu_req_seq(ifu_req_seq),\n        .ifu_req_seq_rv32(ifu_req_seq_rv32),\n        .ifu_req_last_pc(ifu_req_last_pc),\n        .pipe_flush_ack(pipe_flush_ack),\n        .ifu_halt_ack(ifu_halt_ack),\n        .ifu_o_ir(ifu_o_ir),\n        .ifu_o_pc(ifu_o_pc),\n        .ifu_o_pc_vld(ifu_o_pc_vld),\n        .ifu_o_misalgn(ifu_o_misalgn),\n        .ifu_o_buserr(ifu_o_buserr),\n        .ifu_o_rs1idx(ifu_o_rs1idx),\n        .ifu_o_rs2idx(ifu_o_rs2idx),\n        .ifu_o_prdt_taken(ifu_o_prdt_taken),\n        .ifu_o_muldiv_b2b(ifu_o_muldiv_b2b),\n        .ifu_o_valid(ifu_o_valid)\n    );\n\n    // Instantiate the IFU to ICB interface module\n    e203_ifu_ift2icb ift2icb (\n        .clk(clk),\n        .rst_n(rst_n),\n        .ifu_req_valid(ifu_req_valid),\n        .ifu_req_pc(ifu_req_pc),\n        .ifu_req_seq(ifu_req_seq),\n        .ifu_req_seq_rv32(ifu_req_seq_rv32),\n        .ifu_req_last_pc(ifu_req_last_pc),\n        .ifu_rsp_ready(ifu_o_ready),\n        .itcm_nohold(itcm_nohold),\n        .ifu_req_ready(ifu_req_ready),\n        .ifu_rsp_valid(ifu_rsp_valid),\n        .ifu_rsp_err(ifu_rsp_err),\n        .ifu_rsp_instr(ifu_rsp_instr)\n    );\n\n    // Connect internal signals to outputs\n    assign ifu_active = ifu_req_valid || ifu_rsp_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 6, "code": "module e203_exu_regfile (\n    input  wire                   clk,\n    input  wire                   rst_n,\n    input  wire [E203_RFIDX_WIDTH-1:0] read_src1_idx,\n    input  wire [E203_RFIDX_WIDTH-1:0] read_src2_idx,\n    output wire [E203_XLEN-1:0]    read_src1_dat,\n    output wire [E203_XLEN-1:0]    read_src2_dat,\n    input  wire                   wbck_dest_wen,\n    input  wire [E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n    input  wire [E203_XLEN-1:0]    wbck_dest_dat,\n    output wire [E203_XLEN-1:0]    x1_r,\n    input  wire                   test_mode\n);\n\n// Register file storage\nreg [E203_XLEN-1:0] regfile [0:E203_RFREG_NUM-1];\n\n// Read logic\nassign read_src1_dat = (read_src1_idx == 0) ? 0 : regfile[read_src1_idx];\nassign read_src2_dat = (read_src2_idx == 0) ? 0 : regfile[read_src2_idx];\n\n// Write logic\nalways @(posedge clk) begin\n    if (wbck_dest_wen && wbck_dest_idx != 0) begin\n        regfile[wbck_dest_idx] <= wbck_dest_dat;\n    end\nend\n\n// Special register x1 output\nassign x1_r = regfile[1];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 7, "code": "module e203_exu_regfile #(\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_XLEN = 32\n)(\n  input [E203_RFIDX_WIDTH-1:0] read_src1_idx,\n  input [E203_RFIDX_WIDTH-1:0] read_src2_idx,\n  output [E203_XLEN-1:0] read_src1_dat,\n  output [E203_XLEN-1:0] read_src2_dat,\n  input wbck_dest_wen,\n  input [E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n  input [E203_XLEN-1:0] wbck_dest_dat,\n  output [E203_XLEN-1:0] x1_r,\n  input test_mode,\n  input clk,\n  input rst_n\n);\n\n`include \"e203_defines.v\"\n\nlocalparam REG_NUM = `E203_CFG_REGNUM_IS_32 ? 32 : 16;\nreg [E203_XLEN-1:0] regfile [0:REG_NUM-1];\n\nassign read_src1_dat = (read_src1_idx == 0) ? 0 : regfile[read_src1_idx];\nassign read_src2_dat = (read_src2_idx == 0) ? 0 : regfile[read_src2_idx];\nassign x1_r = regfile[1];\n\nalways @(posedge clk) begin\n  if (wbck_dest_wen && wbck_dest_idx != 0) begin\n    regfile[wbck_dest_idx] <= wbck_dest_dat;\n  end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 7, "code": "module e203_exu_nice (\n    input wire nice_i_xs_off,\n    input wire nice_i_valid,\n    output wire nice_i_ready,\n    input wire [E203_XLEN-1:0] nice_i_instr,\n    input wire [E203_XLEN-1:0] nice_i_rs1,\n    input wire [E203_XLEN-1:0] nice_i_rs2,\n    input wire [E203_ITAG_WIDTH-1:0] nice_i_itag,\n    output wire nice_o_longpipe,\n    output wire nice_o_valid,\n    input wire nice_o_ready,\n    output wire nice_o_itag_valid,\n    input wire nice_o_itag_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Internal signals\n    wire fifo_full, fifo_empty;\n    wire [E203_ITAG_WIDTH-1:0] fifo_data_out;\n    wire fifo_push, fifo_pop;\n\n    // Control signals\n    assign nice_i_ready = !fifo_full && nice_o_ready && !nice_i_xs_off;\n    assign nice_o_valid = nice_i_valid && nice_i_ready;\n    assign nice_o_longpipe = !nice_i_xs_off;\n\n    // FIFO control for instruction tags\n    assign fifo_push = nice_i_valid && nice_i_ready;\n    assign fifo_pop = nice_rsp_multicyc_valid && nice_o_itag_ready;\n\n    // Request to custom accelerator\n    assign nice_req_valid = nice_i_valid && nice_i_ready && !nice_i_xs_off;\n    assign nice_req_instr = nice_i_instr;\n    assign nice_req_rs1 = nice_i_rs1;\n    assign nice_req_rs2 = nice_i_rs2;\n\n    // Response from custom accelerator\n    assign nice_rsp_multicyc_ready = !fifo_empty;\n\n    // Tag writeback\n    assign nice_o_itag_valid = nice_rsp_multicyc_valid && !fifo_empty;\n    assign nice_o_itag = fifo_data_out;\n\n    // Instantiate the FIFO for instruction tags\n    sirv_gnrl_fifo #(\n        .CUT_READY(1),\n        .MSKO(0),\n        .DP(4),\n        .DW(E203_ITAG_WIDTH)\n    ) itag_fifo (\n        .i_vld(fifo_push),\n        .i_rdy(fifo_full),\n        .i_dat(nice_i_itag),\n        .o_vld(nice_o_itag_valid),\n        .o_rdy(nice_o_itag_ready),\n        .o_dat(fifo_data_out),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 1, "code": "module e203_lsu_ctrl(\n    input wire commit_mret,\n    input wire commit_trap,\n    output wire lsu_ctrl_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    input wire nice_mem_holdup,\n    input wire nice_icb_cmd_valid,\n    output wire nice_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] nice_icb_cmd_addr,\n    input wire nice_icb_cmd_read,\n    input wire [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] nice_icb_cmd_wmask,\n    output wire nice_icb_rsp_valid,\n    input wire nice_icb_rsp_ready,\n    output wire nice_icb_rsp_err,\n    output wire [E203_XLEN-1:0] nice_icb_rsp_rdata,\n\n    output wire dcache_icb_cmd_valid,\n    input wire dcache_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] dcache_icb_cmd_addr,\n    output wire dcache_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dcache_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dcache_icb_cmd_wmask,\n    output wire dcache_icb_cmd_lock,\n    output wire dcache_icb_cmd_excl,\n    output wire [1:0] dcache_icb_cmd_size,\n    input wire dcache_icb_rsp_valid,\n    output wire dcache_icb_rsp_ready,\n    input wire dcache_icb_rsp_err,\n    input wire dcache_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dcache_icb_rsp_rdata,\n\n    output wire dtcm_icb_cmd_valid,\n    input wire dtcm_icb_cmd_ready,\n    output wire [E203_DTCM_ADDR_WIDTH-1:0] dtcm_icb_cmd_addr,\n    output wire dtcm_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dtcm_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dtcm_icb_cmd_wmask,\n    output wire dtcm_icb_cmd_lock,\n    output wire dtcm_icb_cmd_excl,\n    output wire [1:0] dtcm_icb_cmd_size,\n    input wire dtcm_icb_rsp_valid,\n    output wire dtcm_icb_rsp_ready,\n    input wire dtcm_icb_rsp_err,\n    input wire dtcm_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dtcm_icb_rsp_rdata,\n    input wire [E203_ADDR_SIZE-1:0] dtcm_region_indic,\n\n    output wire biu_icb_cmd_valid,\n    input wire biu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,\n    output wire biu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] biu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] biu_icb_cmd_wmask,\n    output wire biu_icb_cmd_lock,\n    output wire biu_icb_cmd_excl,\n    output wire [1:0] biu_icb_cmd_size,\n    input wire biu_icb_rsp_valid,\n    output wire biu_icb_rsp_ready,\n    input wire biu_icb_rsp_err,\n    input wire biu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] biu_icb_rsp_rdata\n);\n    // Module implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 3, "code": "module e203_exu_alu(\n    input wire clk,\n    input wire rst_n,\n    input wire i_valid,\n    output wire i_ready,\n    input wire [E203_XLEN-1:0] i_rs1,\n    input wire [E203_XLEN-1:0] i_rs2,\n    input wire [E203_XLEN-1:0] i_imm,\n    input wire [E203_DECINFO_WIDTH-1:0] i_info,\n    input wire [E203_PC_SIZE-1:0] i_pc,\n    input wire [E203_INSTR_SIZE-1:0] i_instr,\n    input wire i_pc_vld,\n    input wire [E203_RFIDX_WIDTH-1:0] i_rdidx,\n    input wire i_rdwen,\n    input wire i_ilegl,\n    input wire i_buserr,\n    input wire i_misalgn,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire cmt_o_valid,\n    input wire cmt_o_ready,\n    output wire [E203_PC_SIZE-1:0] cmt_o_pc,\n    output wire [E203_INSTR_SIZE-1:0] cmt_o_instr,\n    output wire [E203_XLEN-1:0] cmt_o_imm,\n    output wire cmt_o_rv32,\n    output wire cmt_o_bjp,\n    output wire cmt_o_mret,\n    output wire cmt_o_dret,\n    output wire cmt_o_ecall,\n    output wire cmt_o_ebreak,\n    output wire cmt_o_fencei,\n    output wire cmt_o_wfi,\n    output wire cmt_o_ifu_misalgn,\n    output wire cmt_o_ifu_buserr,\n    output wire cmt_o_ifu_ilegl,\n    output wire cmt_o_bjp_prdt,\n    output wire cmt_o_bjp_rslv,\n    output wire cmt_o_misalgn,\n    output wire cmt_o_ld,\n    output wire cmt_o_stamo,\n    output wire cmt_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] cmt_o_badaddr,\n    output wire wbck_o_valid,\n    input wire wbck_o_ready,\n    output wire [E203_XLEN-1:0] wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] wbck_o_rdidx,\n    input wire mdv_nob2b,\n    output wire csr_ena,\n    output wire csr_wr_en,\n    output wire csr_rd_en,\n    output wire [11:0] csr_idx,\n    input wire nonflush_cmt_ena,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output wire [E203_XLEN-1:0] wbck_csr_dat,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_usign,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_longp_wbck_valid,\n    input wire nice_longp_wbck_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire i_nice_cmt_off_ilgl\n);\n\n    // Internal signals for ALU operations\n    wire alu_op_add;\n    wire alu_op_sub;\n    wire alu_op_and;\n    wire alu_op_or;\n    wire alu_op_xor;\n    wire alu_op_sll;\n    wire alu_op_srl;\n    wire alu_op_sra;\n    wire alu_op_slt;\n    wire alu_op_sltu;\n    wire alu_op_lui;\n    wire [E203_XLEN-1:0] alu_result;\n    wire alu_valid;\n    wire alu_ready;\n\n    // Decode instruction information\n    assign alu_op_add = i_info[E203_DECINFO_ALU_ADD];\n    assign alu_op_sub = i_info[E203_DECINFO_ALU_SUB];\n    assign alu_op_and = i_info[E203_DECINFO_ALU_AND];\n    assign alu_op_or = i_info[E203_DECINFO_ALU_OR];\n    assign alu_op_xor = i_info[E203_DECINFO_ALU_XOR];\n    assign alu_op_sll = i_info[E203_DECINFO_ALU_SLL];\n    assign alu_op_srl = i_info[E203_DECINFO_ALU_SRL];\n    assign alu_op_sra = i_info[E203_DECINFO_ALU_SRA];\n    assign alu_op_slt = i_info[E203_DECINFO_ALU_SLT];\n    assign alu_op_sltu = i_info[E203_DECINFO_ALU_SLTU];\n    assign alu_op_lui = i_info[E203_DECINFO_ALU_LUI];\n\n    // ALU core\n    e203_alu_core u_alu_core (\n        .clk(clk),\n        .rst_n(rst_n),\n        .op_add(alu_op_add),\n        .op_sub(alu_op_sub),\n        .op_and(alu_op_and),\n        .op_or(alu_op_or),\n        .op_xor(alu_op_xor),\n        .op_sll(alu_op_sll),\n        .op_srl(alu_op_srl),\n        .op_sra(alu_op_sra),\n        .op_slt(alu_op_slt),\n        .op_sltu(alu_op_sltu),\n        .op_lui(alu_op_lui),\n        .rs1(i_rs1),\n        .rs2(i_rs2),\n        .imm(i_imm),\n        .result(alu_result),\n        .valid(alu_valid),\n        .ready(alu_ready)\n    );\n\n    // Commit logic\n    assign cmt_o_valid = alu_valid && alu_ready;\n    assign wbck_o_valid = cmt_o_valid;\n    assign wbck_o_wdat = alu_result;\n    assign wbck_o_rdidx = i_rdidx;\n\n    // Ready/Valid handshake\n    assign i_ready = !i_valid || alu_ready;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 10, "code": "module e203_srams #(\n  parameter E203_ITCM_RAM_AW = 12, // Address width for ITCM\n  parameter E203_ITCM_RAM_MW = 4,  // Write mask width for ITCM\n  parameter E203_ITCM_RAM_DW = 32, // Data width for ITCM\n  parameter E203_DTCM_RAM_AW = 12, // Address width for DTCM\n  parameter E203_DTCM_RAM_MW = 4,  // Write mask width for DTCM\n  parameter E203_DTCM_RAM_DW = 32  // Data width for DTCM\n)(\n  input  wire                     clk,\n  input  wire                     rst_n,\n  // ITCM Interface\n  input  wire                     itcm_ram_cs,\n  input  wire                     itcm_ram_we,\n  input  wire [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n  input  wire [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n  input  wire [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n  output wire [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n  // DTCM Interface\n  input  wire                     dtcm_ram_cs,\n  input  wire                     dtcm_ram_we,\n  input  wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n  input  wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n  input  wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n  output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout\n);\n\n`ifdef E203_HAS_ITCM\n  // ITCM Memory Array\n  reg [E203_ITCM_RAM_DW-1:0] itcm_mem [0:(1<<E203_ITCM_RAM_AW)-1];\n\n  always @(posedge clk) begin\n    if (itcm_ram_cs && itcm_ram_we) begin\n      for (int i = 0; i < E203_ITCM_RAM_MW; i++) begin\n        if (itcm_ram_wem[i])\n          itcm_mem[itcm_ram_addr][i*8 +: 8] <= itcm_ram_din[i*8 +: 8];\n      end\n    end\n  end\n\n  assign itcm_ram_dout = itcm_mem[itcm_ram_addr];\n`endif\n\n`ifdef E203_HAS_DTCM\n  // DTCM Memory Array\n  reg [E203_DTCM_RAM_DW-1:0] dtcm_mem [0:(1<<E203_DTCM_RAM_AW)-1];\n\n  always @(posedge clk) begin\n    if (dtcm_ram_cs && dtcm_ram_we) begin\n      for (int i = 0; i < E203_DTCM_RAM_MW; i++) begin\n        if (dtcm_ram_wem[i])\n          dtcm_mem[dtcm_ram_addr][i*8 +: 8] <= dtcm_ram_din[i*8 +: 8];\n      end\n    end\n  end\n\n  assign dtcm_ram_dout = dtcm_mem[dtcm_ram_addr];\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 8, "code": "module e203_exu_nice(\n    input wire nice_i_xs_off,\n    input wire nice_i_valid,\n    output wire nice_i_ready,\n    input wire [E203_XLEN-1:0] nice_i_instr,\n    input wire [E203_XLEN-1:0] nice_i_rs1,\n    input wire [E203_XLEN-1:0] nice_i_rs2,\n    input wire [E203_ITAG_WIDTH-1:0] nice_i_itag,\n    output wire nice_o_longpipe,\n    output wire nice_o_valid,\n    input wire nice_o_ready,\n    output wire nice_o_itag_valid,\n    input wire nice_o_itag_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Internal signals\n    wire fifo_full, fifo_empty;\n    wire fifo_push, fifo_pop;\n    wire [E203_ITAG_WIDTH-1:0] fifo_data_in, fifo_data_out;\n\n    // FIFO instantiation for instruction tags\n    sirv_gnrl_fifo #(\n        .CUT_READY(1),\n        .MSKO(0),\n        .DP(4),\n        .DW(E203_ITAG_WIDTH)\n    ) itag_fifo (\n        .i_vld(fifo_push),\n        .i_rdy(fifo_pop),\n        .i_dat(fifo_data_in),\n        .o_vld(nice_o_itag_valid),\n        .o_rdy(nice_o_itag_ready),\n        .o_dat(nice_o_itag),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\n    // Control logic for FIFO\n    assign fifo_push = nice_i_valid && nice_i_ready && !nice_i_xs_off;\n    assign fifo_pop = nice_rsp_multicyc_valid && nice_rsp_multicyc_ready;\n    assign fifo_data_in = nice_i_itag;\n\n    // Control signals for NICE request and response\n    assign nice_req_valid = nice_i_valid && !nice_i_xs_off && nice_req_ready;\n    assign nice_req_instr = nice_i_instr;\n    assign nice_req_rs1 = nice_i_rs1;\n    assign nice_req_rs2 = nice_i_rs2;\n\n    // Ready signals\n    assign nice_i_ready = !fifo_full && nice_o_ready && !nice_i_xs_off;\n    assign nice_rsp_multicyc_ready = !fifo_empty;\n\n    // Long pipeline handling\n    assign nice_o_longpipe = !nice_i_xs_off;\n\n    // Valid signal for commit interface\n    assign nice_o_valid = nice_i_valid && nice_i_ready && nice_o_ready;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 5, "code": "module e203_exu_longpwbck (\n    input wire lsu_wbck_i_valid,\n    output wire lsu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] lsu_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] lsu_wbck_i_itag,\n    input wire lsu_wbck_i_err,\n    input wire lsu_cmt_i_buserr,\n    input wire [E203_ADDR_SIZE-1:0] lsu_cmt_i_badaddr,\n    input wire lsu_cmt_i_ld,\n    input wire lsu_cmt_i_st,\n    output wire longp_wbck_o_valid,\n    input wire longp_wbck_o_ready,\n    output wire [E203_FLEN-1:0] longp_wbck_o_wdat,\n    output wire [4:0] longp_wbck_o_flags,\n    output wire [E203_RFIDX_WIDTH-1:0] longp_wbck_o_rdidx,\n    output wire longp_wbck_o_rdfpu,\n    output wire longp_excp_o_valid,\n    input wire longp_excp_o_ready,\n    output wire longp_excp_o_insterr,\n    output wire longp_excp_o_ld,\n    output wire longp_excp_o_st,\n    output wire longp_excp_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] longp_excp_o_badaddr,\n    output wire [E203_PC_SIZE-1:0] longp_excp_o_pc,\n    input wire oitf_empty,\n    input wire [E203_ITAG_WIDTH-1:0] oitf_ret_ptr,\n    input wire [E203_RFIDX_WIDTH-1:0] oitf_ret_rdidx,\n    input wire [E203_PC_SIZE-1:0] oitf_ret_pc,\n    input wire oitf_ret_rdwen,\n    input wire oitf_ret_rdfpu,\n    output wire oitf_ret_ena,\n    input wire clk,\n    input wire rst_n\n`ifdef E203_HAS_NICE\n    , input wire nice_longp_wbck_i_valid,\n    output wire nice_longp_wbck_i_ready,\n    input wire [E203_XLEN-1:0] nice_longp_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] nice_longp_wbck_i_itag,\n    input wire nice_longp_wbck_i_err\n`endif\n);\n\n    // Write-back arbitration logic\n    wire wbck_i_valid = lsu_wbck_i_valid `ifdef E203_HAS_NICE || nice_longp_wbck_i_valid`endif;\n    wire [E203_XLEN-1:0] wbck_i_wdat = lsu_wbck_i_valid ? lsu_wbck_i_wdat : `ifdef E203_HAS_NICE nice_longp_wbck_i_wdat`endif;\n    wire wbck_i_err = lsu_wbck_i_valid ? lsu_wbck_i_err : `ifdef E203_HAS_NICE nice_longp_wbck_i_err`endif;\n    wire wbck_i_ready = longp_wbck_o_ready && longp_excp_o_ready;\n\n    assign lsu_wbck_i_ready = wbck_i_ready;\n    `ifdef E203_HAS_NICE\n    assign nice_longp_wbck_i_ready = wbck_i_ready;\n    `endif\n\n    // Exception handling\n    wire excp_need = wbck_i_err && wbck_i_valid;\n    assign longp_excp_o_valid = excp_need && longp_excp_o_ready;\n    assign longp_excp_o_insterr = wbck_i_err;\n    assign longp_excp_o_ld = lsu_cmt_i_ld;\n    assign longp_excp_o_st = lsu_cmt_i_st;\n    assign longp_excp_o_buserr = lsu_cmt_i_buserr;\n    assign longp_excp_o_badaddr = lsu_cmt_i_badaddr;\n    assign longp_excp_o_pc = oitf_ret_pc;\n\n    // Write-back needs\n    wire wb_need = wbck_i_valid && !wbck_i_err && oitf_ret_rdwen;\n    assign longp_wbck_o_valid = wb_need && longp_wbck_o_ready;\n    assign longp_wbck_o_wdat = wbck_i_wdat;\n    assign longp_wbck_o_rdidx = oitf_ret_rdidx;\n    assign longp_wbck_o_rdfpu = oitf_ret_rdfpu;\n    assign longp_wbck_o_flags = {4'b0, wbck_i_err};\n\n    // OITF control logic\n    assign oitf_ret_ena = wbck_i_ready && wbck_i_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 18, "code": "module e203_biu(\n    input wire clk,\n    input wire rst_n,\n    output wire biu_active,\n    // ICB Interface for LSU\n    input wire lsu_icb_cmd_valid,\n    output wire lsu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] lsu_icb_cmd_addr,\n    input wire lsu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] lsu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] lsu_icb_cmd_wmask,\n    input wire [1:0] lsu_icb_cmd_burst,\n    input wire [1:0] lsu_icb_cmd_beat,\n    input wire lsu_icb_cmd_lock,\n    input wire lsu_icb_cmd_excl,\n    input wire [1:0] lsu_icb_cmd_size,\n    output wire lsu_icb_rsp_valid,\n    input wire lsu_icb_rsp_ready,\n    output wire lsu_icb_rsp_err,\n    output wire lsu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] lsu_icb_rsp_rdata,\n    // ICB Interface for IFU\n    `ifdef E203_HAS_MEM_ITF\n    input wire ifu_icb_cmd_valid,\n    output wire ifu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] ifu_icb_cmd_addr,\n    input wire ifu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ifu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] ifu_icb_cmd_wmask,\n    input wire [1:0] ifu_icb_cmd_burst,\n    input wire [1:0] ifu_icb_cmd_beat,\n    input wire ifu_icb_cmd_lock,\n    input wire ifu_icb_cmd_excl,\n    input wire [1:0] ifu_icb_cmd_size,\n    output wire ifu_icb_rsp_valid,\n    input wire ifu_icb_rsp_ready,\n    output wire ifu_icb_rsp_err,\n    output wire ifu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] ifu_icb_rsp_rdata,\n    `endif\n    // ICB Interface for PPI\n    input wire ppi_icb_cmd_valid,\n    output wire ppi_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] ppi_icb_cmd_addr,\n    input wire ppi_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ppi_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] ppi_icb_cmd_wmask,\n    input wire [1:0] ppi_icb_cmd_burst,\n    input wire [1:0] ppi_icb_cmd_beat,\n    input wire ppi_icb_cmd_lock,\n    input wire ppi_icb_cmd_excl,\n    input wire [1:0] ppi_icb_cmd_size,\n    output wire ppi_icb_rsp_valid,\n    input wire ppi_icb_rsp_ready,\n    output wire ppi_icb_rsp_err,\n    output wire ppi_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] ppi_icb_rsp_rdata,\n    // Additional signals for PPI\n    input wire [E203_ADDR_SIZE-1:0] ppi_region_indic,\n    input wire ppi_icb_enable,\n    // ICB Interface for CLINT\n    input wire clint_icb_cmd_valid,\n    output wire clint_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] clint_icb_cmd_addr,\n    input wire clint_icb_cmd_read,\n    input wire [E203_XLEN-1:0] clint_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] clint_icb_cmd_wmask,\n    input wire [1:0] clint_icb_cmd_burst,\n    input wire [1:0] clint_icb_cmd_beat,\n    input wire clint_icb_cmd_lock,\n    input wire clint_icb_cmd_excl,\n    input wire [1:0] clint_icb_cmd_size,\n    output wire clint_icb_rsp_valid,\n    input wire clint_icb_rsp_ready,\n    output wire clint_icb_rsp_err,\n    output wire clint_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] clint_icb_rsp_rdata,\n    // Additional signals for CLINT\n    input wire [E203_ADDR_SIZE-1:0] clint_region_indic,\n    input wire clint_icb_enable,\n    // ICB Interface for PLIC\n    input wire plic_icb_cmd_valid,\n    output wire plic_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] plic_icb_cmd_addr,\n    input wire plic_icb_cmd_read,\n    input wire [E203_XLEN-1:0] plic_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] plic_icb_cmd_wmask,\n    input wire [1:0] plic_icb_cmd_burst,\n    input wire [1:0] plic_icb_cmd_beat,\n    input wire plic_icb_cmd_lock,\n    input wire plic_icb_cmd_excl,\n    input wire [1:0] plic_icb_cmd_size,\n    output wire plic_icb_rsp_valid,\n    input wire plic_icb_rsp_ready,\n    output wire plic_icb_rsp_err,\n    output wire plic_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] plic_icb_rsp_rdata,\n    // Additional signals for PLIC\n    input wire [E203_ADDR_SIZE-1:0] plic_region_indic,\n    input wire plic_icb_enable,\n    // ICB Interface for FIO (if E203_HAS_FIO is defined)\n    `ifdef E203_HAS_FIO\n    input wire fio_icb_cmd_valid,\n    output wire fio_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] fio_icb_cmd_addr,\n    input wire fio_icb_cmd_read,\n    input wire [E203_XLEN-1:0] fio_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] fio_icb_cmd_wmask,\n    input wire [1:0] fio_icb_cmd_burst,\n    input wire [1:0] fio_icb_cmd_beat,\n    input wire fio_icb_cmd_lock,\n    input wire fio_icb_cmd_excl,\n    input wire [1:0] fio_icb_cmd_size,\n    output wire fio_icb_rsp_valid,\n    input wire fio_icb_rsp_ready,\n    output wire fio_icb_rsp_err,\n    output wire fio_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] fio_icb_rsp_rdata,\n    // Additional signals for FIO\n    input wire [E203_ADDR_SIZE-1:0] fio_region_indic,\n    input wire fio_icb_enable,\n    `endif\n    // ICB Interface for MEM (if E203_HAS_MEM_ITF is defined)\n    `ifdef E203_HAS_MEM_ITF\n    input wire mem_icb_cmd_valid,\n    output wire mem_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] mem_icb_cmd_addr,\n    input wire mem_icb_cmd_read,\n    input wire [E203_XLEN-1:0] mem_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] mem_icb_cmd_wmask,\n    input wire [1:0] mem_icb_cmd_burst,\n    input wire [1:0] mem_icb_cmd_beat,\n    input wire mem_icb_cmd_lock,\n    input wire mem_icb_cmd_excl,\n    input wire [1:0] mem_icb_cmd_size,\n    output wire mem_icb_rsp_valid,\n    input wire mem_icb_rsp_ready,\n    output wire mem_icb_rsp_err,\n    output wire mem_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] mem_icb_rsp_rdata,\n    // Additional signals for MEM\n    input wire mem_icb_enable,\n    `endif\n    // Control signals\n    input wire [E203_ADDR_SIZE-1:0] addr_base,\n    input wire [E203_ADDR_SIZE-1:0] region_base\n);\n    // Internal signals\n    wire [E203_ADDR_SIZE-1:0] internal_addr;\n    wire internal_cmd_valid;\n    wire internal_cmd_ready;\n    wire internal_cmd_read;\n    wire [E203_XLEN-1:0] internal_cmd_wdata;\n    wire [(E203_XLEN/8)-1:0] internal_cmd_wmask;\n    wire [1:0] internal_cmd_burst;\n    wire [1:0] internal_cmd_beat;\n    wire internal_cmd_lock;\n    wire internal_cmd_excl;\n    wire [1:0] internal_cmd_size;\n    wire internal_rsp_valid;\n    wire internal_rsp_ready;\n    wire internal_rsp_err;\n    wire internal_rsp_excl_ok;\n    wire [E203_XLEN-1:0] internal_rsp_rdata;\n\n    // Implementation of BIU logic\n    // Add your implementation here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 16, "code": "module e203_dtcm_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n    output wire dtcm_active,\n\n    // LSU ICB Interface\n    input wire lsu2dtcm_icb_cmd_valid,\n    output wire lsu2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] lsu2dtcm_icb_cmd_addr,\n    input wire lsu2dtcm_icb_cmd_read,\n    input wire [31:0] lsu2dtcm_icb_cmd_wdata,\n    input wire [3:0] lsu2dtcm_icb_cmd_wmask,\n    output wire lsu2dtcm_icb_rsp_valid,\n    input wire lsu2dtcm_icb_rsp_ready,\n    output wire lsu2dtcm_icb_rsp_err,\n    output wire [31:0] lsu2dtcm_icb_rsp_rdata,\n\n    // External ICB Interface (Optional)\n    `ifdef E203_HAS_DTCM_EXTITF\n    input wire ext2dtcm_icb_cmd_valid,\n    output wire ext2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] ext2dtcm_icb_cmd_addr,\n    input wire ext2dtcm_icb_cmd_read,\n    input wire [31:0] ext2dtcm_icb_cmd_wdata,\n    input wire [3:0] ext2dtcm_icb_cmd_wmask,\n    output wire ext2dtcm_icb_rsp_valid,\n    input wire ext2dtcm_icb_rsp_ready,\n    output wire ext2dtcm_icb_rsp_err,\n    output wire [31:0] ext2dtcm_icb_rsp_rdata,\n    `endif\n\n    // DTCM RAM Interface\n    output wire dtcm_ram_cs,\n    output wire dtcm_ram_we,\n    output wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    output wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    output wire clk_dtcm_ram\n);\n\n    // Internal signals for arbitration and control\n    wire arb_cmd_valid;\n    wire arb_cmd_ready;\n    wire [E203_DTCM_ADDR_WIDTH-1:0] arb_cmd_addr;\n    wire arb_cmd_read;\n    wire [31:0] arb_cmd_wdata;\n    wire [3:0] arb_cmd_wmask;\n    wire arb_rsp_valid;\n    wire arb_rsp_ready;\n    wire arb_rsp_err;\n    wire [31:0] arb_rsp_rdata;\n\n    // Instantiate the bus arbiter\n    sirv_gnrl_icb_arbt #(\n        .ARBT_SCHEME(0),\n        .ALLOW_0CYCL_RSP(0),\n        .FIFO_OUTS_NUM(E203_DTCM_OUTS_NUM),\n        .FIFO_CUT_READY(0),\n        .USR_W(1),\n        .ARBT_NUM(DTCM_ARBT_I_NUM),\n        .AW(E203_DTCM_ADDR_WIDTH),\n        .DW(32),\n        .ARBT_PTR_W(DTCM_ARBT_I_PTR_W)\n    ) u_dtcm_arbiter (\n        .o_icb_cmd_valid(arb_cmd_valid),\n        .o_icb_cmd_ready(arb_cmd_ready),\n        .o_icb_cmd_read(arb_cmd_read),\n        .o_icb_cmd_addr(arb_cmd_addr),\n        .o_icb_cmd_wdata(arb_cmd_wdata),\n        .o_icb_cmd_wmask(arb_cmd_wmask),\n        .o_icb_rsp_valid(arb_rsp_valid),\n        .o_icb_rsp_ready(arb_rsp_ready),\n        .o_icb_rsp_err(arb_rsp_err),\n        .o_icb_rsp_rdata(arb_rsp_rdata),\n        .i_bus_icb_cmd_ready({lsu2dtcm_icb_cmd_ready, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_cmd_ready `endif}),\n        .i_bus_icb_cmd_valid({lsu2dtcm_icb_cmd_valid, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_cmd_valid `endif}),\n        .i_bus_icb_cmd_read({lsu2dtcm_icb_cmd_read, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_cmd_read `endif}),\n        .i_bus_icb_cmd_addr({lsu2dtcm_icb_cmd_addr, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_cmd_addr `endif}),\n        .i_bus_icb_cmd_wdata({lsu2dtcm_icb_cmd_wdata, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_cmd_wdata `endif}),\n        .i_bus_icb_cmd_wmask({lsu2dtcm_icb_cmd_wmask, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_cmd_wmask `endif}),\n        .i_bus_icb_rsp_valid({lsu2dtcm_icb_rsp_valid, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_rsp_valid `endif}),\n        .i_bus_icb_rsp_ready({lsu2dtcm_icb_rsp_ready, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_rsp_ready `endif}),\n        .i_bus_icb_rsp_err({lsu2dtcm_icb_rsp_err, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_rsp_err `endif}),\n        .i_bus_icb_rsp_rdata({lsu2dtcm_icb_rsp_rdata, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_rsp_rdata `endif}),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\n    // Instantiate the SRAM controller\n    sirv_sram_icb_ctrl #(\n        .DW(E203_DTCM_DATA_WIDTH),\n        .AW(E203_DTCM_ADDR_WIDTH),\n        .MW(E203_DTCM_WMSK_WIDTH),\n        .AW_LSB(2),\n        .USR_W(1)\n    ) u_dtcm_sram_ctrl (\n        .sram_ctrl_active(dtcm_active),\n        .tcm_cgstop(tcm_cgstop),\n        .i_icb_cmd_valid(arb_cmd_valid),\n        .i_icb_cmd_ready(arb_cmd_ready),\n        .i_icb_cmd_read(arb_cmd_read),\n        .i_icb_cmd_addr(arb_cmd_addr),\n        .i_icb_cmd_wdata(arb_cmd_wdata),\n        .i_icb_cmd_wmask(arb_cmd_wmask),\n        .i_icb_cmd_usr(1'b0),\n        .i_icb_rsp_valid(arb_rsp_valid),\n        .i_icb_rsp_ready(arb_rsp_ready),\n        .i_icb_rsp_rdata(arb_rsp_rdata),\n        .i_icb_rsp_usr(1'b0),\n        .ram_cs(dtcm_ram_cs),\n        .ram_we(dtcm_ram_we),\n        .ram_addr(dtcm_ram_addr),\n        .ram_wem(dtcm_ram_wem),\n        .ram_din(dtcm_ram_din),\n        .ram_dout(dtcm_ram_dout),\n        .clk_ram(clk_dtcm_ram),\n        .test_mode(test_mode),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 6, "code": "module e203_exu_longpwbck (\n    input wire lsu_wbck_i_valid,\n    output wire lsu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] lsu_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] lsu_wbck_i_itag,\n    input wire lsu_wbck_i_err,\n    input wire lsu_cmt_i_buserr,\n    input wire [E203_ADDR_SIZE-1:0] lsu_cmt_i_badaddr,\n    input wire lsu_cmt_i_ld,\n    input wire lsu_cmt_i_st,\n    output wire longp_wbck_o_valid,\n    input wire longp_wbck_o_ready,\n    output wire [E203_FLEN-1:0] longp_wbck_o_wdat,\n    output wire [4:0] longp_wbck_o_flags,\n    output wire [E203_RFIDX_WIDTH-1:0] longp_wbck_o_rdidx,\n    output wire longp_wbck_o_rdfpu,\n    output wire longp_excp_o_valid,\n    input wire longp_excp_o_ready,\n    output wire longp_excp_o_insterr,\n    output wire longp_excp_o_ld,\n    output wire longp_excp_o_st,\n    output wire longp_excp_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] longp_excp_o_badaddr,\n    output wire [E203_PC_SIZE-1:0] longp_excp_o_pc,\n    input wire oitf_empty,\n    input wire [E203_ITAG_WIDTH-1:0] oitf_ret_ptr,\n    input wire [E203_RFIDX_WIDTH-1:0] oitf_ret_rdidx,\n    input wire [E203_PC_SIZE-1:0] oitf_ret_pc,\n    input wire oitf_ret_rdwen,\n    input wire oitf_ret_rdfpu,\n    output wire oitf_ret_ena,\n    input wire clk,\n    input wire rst_n\n    `ifdef E203_HAS_NICE\n    , input wire nice_longp_wbck_i_valid,\n    output wire nice_longp_wbck_i_ready,\n    input wire [E203_XLEN-1:0] nice_longp_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] nice_longp_wbck_i_itag,\n    input wire nice_longp_wbck_i_err\n    `endif\n);\n\n    // Write-back and exception arbitration logic\n    wire wbck_need = (oitf_ret_rdwen && !lsu_wbck_i_err);\n    wire excp_need = (lsu_wbck_i_err || lsu_cmt_i_buserr);\n    wire wbck_ready_cond = (wbck_need && longp_wbck_o_ready) || !wbck_need;\n    wire excp_ready_cond = (excp_need && longp_excp_o_ready) || !excp_need;\n\n    assign lsu_wbck_i_ready = wbck_ready_cond && excp_ready_cond;\n\n    wire valid_wbck = lsu_wbck_i_valid && (lsu_wbck_i_itag == oitf_ret_ptr) && !oitf_empty;\n    wire valid_excp = valid_wbck && excp_need;\n\n    assign longp_wbck_o_valid = valid_wbck && wbck_need;\n    assign longp_wbck_o_wdat = lsu_wbck_i_wdat;\n    assign longp_wbck_o_rdidx = oitf_ret_rdidx;\n    assign longp_wbck_o_rdfpu = oitf_ret_rdfpu;\n    assign longp_wbck_o_flags = {lsu_cmt_i_ld, lsu_cmt_i_st, 3'b000}; // Example flags\n\n    assign longp_excp_o_valid = valid_excp;\n    assign longp_excp_o_insterr = lsu_wbck_i_err;\n    assign longp_excp_o_ld = lsu_cmt_i_ld;\n    assign longp_excp_o_st = lsu_cmt_i_st;\n    assign longp_excp_o_buserr = lsu_cmt_i_buserr;\n    assign longp_excp_o_badaddr = lsu_cmt_i_badaddr;\n    assign longp_excp_o_pc = oitf_ret_pc;\n\n    assign oitf_ret_ena = lsu_wbck_i_ready && lsu_wbck_i_valid;\n\n    `ifdef E203_HAS_NICE\n    wire valid_nice_wbck = nice_longp_wbck_i_valid && (nice_longp_wbck_i_itag == oitf_ret_ptr) && !oitf_empty;\n    wire valid_nice_excp = valid_nice_wbck && nice_longp_wbck_i_err;\n\n    assign nice_longp_wbck_i_ready = wbck_ready_cond && excp_ready_cond;\n\n    // Arbitration between LSU and NICE write-backs\n    assign longp_wbck_o_valid = (valid_wbck && wbck_need) || (valid_nice_wbck && !lsu_wbck_i_valid);\n    assign longp_wbck_o_wdat = valid_nice_wbck ? nice_longp_wbck_i_wdat : lsu_wbck_i_wdat;\n\n    assign longp_excp_o_valid = valid_excp || valid_nice_excp;\n    assign longp_excp_o_insterr = valid_nice_excp ? nice_longp_wbck_i_err : lsu_wbck_i_err;\n    `endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 8, "code": "module e203_exu_branchslv(\n    input wire cmt_i_valid,\n    output wire cmt_i_ready,\n    input wire cmt_i_rv32,\n    input wire cmt_i_dret,\n    input wire cmt_i_mret,\n    input wire cmt_i_fencei,\n    input wire cmt_i_bjp,\n    input wire cmt_i_bjp_prdt,\n    input wire cmt_i_bjp_rslv,\n    input wire [E203_PC_SIZE-1:0] cmt_i_pc,\n    input wire [E203_XLEN-1:0] cmt_i_imm,\n    input wire [E203_PC_SIZE-1:0] csr_epc_r,\n    input wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    input wire nonalu_excpirq_flush_req_raw,\n    input wire brchmis_flush_ack,\n    output wire brchmis_flush_req,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op1,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op2,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_pc,\n    output wire cmt_mret_ena,\n    output wire cmt_dret_ena,\n    output wire cmt_fencei_ena,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Determine if a flush is needed\n    wire flush_needed = (cmt_i_bjp & (cmt_i_bjp_prdt ^ cmt_i_bjp_rslv)) | cmt_i_fencei | cmt_i_mret | cmt_i_dret;\n    \n    // Calculate the flush target address\n    wire [E203_PC_SIZE-1:0] next_pc = cmt_i_rv32 ? (cmt_i_pc + 4) : (cmt_i_pc + 2);\n    wire [E203_PC_SIZE-1:0] branch_target = cmt_i_pc + cmt_i_imm[E203_PC_SIZE-1:0];\n\n    assign brchmis_flush_add_op1 = cmt_i_pc;\n    assign brchmis_flush_add_op2 = cmt_i_imm;\n\n    // Select the correct flush target based on the type of instruction or misprediction\n    always @(*) begin\n        if (cmt_i_fencei | (cmt_i_bjp & cmt_i_bjp_prdt & ~cmt_i_bjp_rslv)) begin\n            brchmis_flush_pc = next_pc;\n        end else if (cmt_i_bjp & ~cmt_i_bjp_prdt & cmt_i_bjp_rslv) begin\n            brchmis_flush_pc = branch_target;\n        end else if (cmt_i_dret) begin\n            brchmis_flush_pc = csr_dpc_r;\n        end else begin\n            brchmis_flush_pc = csr_epc_r;\n        end\n    end\n\n    // Generate flush request\n    assign brchmis_flush_req = flush_needed & cmt_i_valid & ~nonalu_excpirq_flush_req_raw;\n\n    // Generate commit enable signals for special instructions\n    assign cmt_mret_ena = cmt_i_mret & flush_needed;\n    assign cmt_dret_ena = cmt_i_dret & flush_needed;\n    assign cmt_fencei_ena = cmt_i_fencei & flush_needed;\n\n    // Control the ready signal\n    assign cmt_i_ready = ~flush_needed & ~nonalu_excpirq_flush_req_raw | brchmis_flush_ack;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 5, "code": "module e203_ifu_minidec #(\n  parameter E203_INSTR_SIZE = 32,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_XLEN = 32\n)(\n  input [E203_INSTR_SIZE-1:0] instr,\n  output dec_rs1en,\n  output dec_rs2en,\n  output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n  output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n  output dec_mulhsu,\n  output dec_mul,\n  output dec_div,\n  output dec_rem,\n  output dec_divu,\n  output dec_remu,\n  output dec_rv32,\n  output dec_bjp,\n  output dec_jal,\n  output dec_jalr,\n  output dec_bxx,\n  output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  output [E203_XLEN-1:0] dec_bjp_imm\n);\n\n  // Internal signals for decoding\n  wire [6:0] opcode = instr[6:0];\n  wire [2:0] funct3 = instr[14:12];\n  wire [6:0] funct7 = instr[31:25];\n\n  // Decode logic for register file access\n  assign dec_rs1en = (opcode == 7'b1100111) || (opcode == 7'b0100011) || (opcode == 7'b0000011);\n  assign dec_rs2en = (opcode == 7'b0100011);\n  assign dec_rs1idx = instr[19:15];\n  assign dec_rs2idx = instr[24:20];\n\n  // Decode logic for multiplication and division instructions\n  assign dec_mul = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b000);\n  assign dec_mulhsu = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b010);\n  assign dec_div = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b100);\n  assign dec_rem = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b110);\n  assign dec_divu = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b101);\n  assign dec_remu = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b111);\n\n  // Decode logic for branch and jump instructions\n  assign dec_bjp = (opcode == 7'b1101111) || (opcode == 7'b1100111) || (opcode == 7'b1100011);\n  assign dec_jal = (opcode == 7'b1101111);\n  assign dec_jalr = (opcode == 7'b1100111);\n  assign dec_bxx = (opcode == 7'b1100011);\n  assign dec_jalr_rs1idx = instr[19:15];\n  assign dec_bjp_imm = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};\n\n  // RV32 instruction set flag\n  assign dec_rv32 = 1'b1;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 8, "code": "module e203_irq_sync (\n    input wire clk,\n    input wire rst_n,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire dbg_irq_a,\n    output wire ext_irq_r,\n    output wire sft_irq_r,\n    output wire tmr_irq_r,\n    output wire dbg_irq_r\n);\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) ext_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(ext_irq_a),\n        .dout(ext_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) sft_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(sft_irq_a),\n        .dout(sft_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) tmr_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(tmr_irq_a),\n        .dout(tmr_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) dbg_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(dbg_irq_a),\n        .dout(dbg_irq_r)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 10, "code": "module e203_exu_alu_bjp (\n    input wire bjp_i_valid,\n    output wire bjp_i_ready,\n    input wire [E203_XLEN-1:0] bjp_i_rs1,\n    input wire [E203_XLEN-1:0] bjp_i_rs2,\n    input wire [E203_XLEN-1:0] bjp_i_imm,\n    input wire [E203_PC_SIZE-1:0] bjp_i_pc,\n    input wire [E203_DECINFO_BJP_WIDTH-1:0] bjp_i_info,\n    output wire bjp_o_valid,\n    input wire bjp_o_ready,\n    output wire [E203_XLEN-1:0] bjp_o_wbck_wdat,\n    output wire bjp_o_wbck_err,\n    output wire bjp_o_cmt_bjp,\n    output wire bjp_o_cmt_mret,\n    output wire bjp_o_cmt_dret,\n    output wire bjp_o_cmt_fencei,\n    output wire bjp_o_cmt_prdt,\n    output wire bjp_o_cmt_rslv,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    output wire bjp_req_alu_cmp_eq,\n    output wire bjp_req_alu_cmp_ne,\n    output wire bjp_req_alu_cmp_lt,\n    output wire bjp_req_alu_cmp_gt,\n    output wire bjp_req_alu_cmp_ltu,\n    output wire bjp_req_alu_cmp_gtu,\n    output wire bjp_req_alu_add,\n    input wire bjp_req_alu_cmp_res,\n    input wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    input wire clk,\n    input wire rst_n\n);\n\n// Handshake mechanism\nassign bjp_i_ready = bjp_o_ready;\nassign bjp_o_valid = bjp_i_valid;\n\n// Default assignments\nassign bjp_o_wbck_err = 1'b0;\nassign bjp_o_wbck_wdat = bjp_req_alu_add_res;\n\n// Operand selection\nassign bjp_req_alu_op1 = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? bjp_i_pc : bjp_i_rs1;\nassign bjp_req_alu_op2 = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? (E203_XLEN_IS_32 ? 32'd4 : 32'd2) : bjp_i_rs2;\n\n// ALU operation requests\nassign bjp_req_alu_cmp_eq = bjp_i_info[E203_DECINFO_BJP_BEQ];\nassign bjp_req_alu_cmp_ne = bjp_i_info[E203_DECINFO_BJP_BNE];\nassign bjp_req_alu_cmp_lt = bjp_i_info[E203_DECINFO_BJP_BLT];\nassign bjp_req_alu_cmp_gt = bjp_i_info[E203_DECINFO_BJP_BGT];\nassign bjp_req_alu_cmp_ltu = bjp_i_info[E203_DECINFO_BJP_BLTU];\nassign bjp_req_alu_cmp_gtu = bjp_i_info[E203_DECINFO_BJP_BGTU];\nassign bjp_req_alu_add = bjp_i_info[E203_DECINFO_BJP_JUMP];\n\n// Commit signals\nassign bjp_o_cmt_bjp = bjp_i_info[E203_DECINFO_BJP_BXX] | bjp_i_info[E203_DECINFO_BJP_JUMP];\nassign bjp_o_cmt_mret = bjp_i_info[E203_DECINFO_BJP_MRET];\nassign bjp_o_cmt_dret = bjp_i_info[E203_DECINFO_BJP_DRET];\nassign bjp_o_cmt_fencei = bjp_i_info[E203_DECINFO_BJP_FENCEI];\n\n// Predicted and resolved results\nassign bjp_o_cmt_prdt = bjp_i_info[E203_DECINFO_BJP_BPRDT];\nassign bjp_o_cmt_rslv = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? 1'b1 : bjp_req_alu_cmp_res;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 8, "code": "module e203_exu_regfile #(\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_XLEN = 32\n)(\n  input  wire [E203_RFIDX_WIDTH-1:0] read_src1_idx,\n  input  wire [E203_RFIDX_WIDTH-1:0] read_src2_idx,\n  output wire [E203_XLEN-1:0] read_src1_dat,\n  output wire [E203_XLEN-1:0] read_src2_dat,\n  input  wire wbck_dest_wen,\n  input  wire [E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n  input  wire [E203_XLEN-1:0] wbck_dest_dat,\n  output wire [E203_XLEN-1:0] x1_r,\n  input  wire test_mode,\n  input  wire clk,\n  input  wire rst_n\n);\n\n  // Register file storage\n  reg [E203_XLEN-1:0] regfile [0:(1<<E203_RFIDX_WIDTH)-1];\n\n  // Read logic\n  assign read_src1_dat = (read_src1_idx == 0) ? 0 : regfile[read_src1_idx];\n  assign read_src2_dat = (read_src2_idx == 0) ? 0 : regfile[read_src2_idx];\n\n  // Write logic\n  always @(posedge clk) begin\n    if (wbck_dest_wen && (wbck_dest_idx != 0)) begin\n      regfile[wbck_dest_idx] <= wbck_dest_dat;\n    end\n  end\n\n  // Output register x1\n  assign x1_r = regfile[1];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 5, "code": "module e203_exu_disp (\n    input wire wfi_halt_exu_req,\n    output wire wfi_halt_exu_ack,\n    input wire oitf_empty,\n    input wire amo_wait,\n    input wire disp_i_valid,\n    output wire disp_i_ready,\n    input wire disp_i_rs1x0,\n    input wire disp_i_rs2x0,\n    input wire disp_i_rs1en,\n    input wire disp_i_rs2en,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input wire [E203_XLEN-1:0] disp_i_rs1,\n    input wire [E203_XLEN-1:0] disp_i_rs2,\n    input wire disp_i_rdwen,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input wire [E203_DECINFO_WIDTH-1:0] disp_i_info,\n    input wire [E203_XLEN-1:0] disp_i_imm,\n    input wire [E203_PC_SIZE-1:0] disp_i_pc,\n    input wire disp_i_misalgn,\n    input wire disp_i_buserr,\n    input wire disp_i_ilegl,\n    output wire disp_o_alu_valid,\n    input wire disp_o_alu_ready,\n    input wire disp_o_alu_longpipe,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs1,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs2,\n    output wire disp_o_alu_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_o_alu_rdidx,\n    output wire [E203_DECINFO_WIDTH-1:0] disp_o_alu_info,\n    output wire [E203_XLEN-1:0] disp_o_alu_imm,\n    output wire [E203_PC_SIZE-1:0] disp_o_alu_pc,\n    output wire [E203_ITAG_WIDTH-1:0] disp_o_alu_itag,\n    output wire disp_o_alu_misalgn,\n    output wire disp_o_alu_buserr,\n    output wire disp_o_alu_ilegl,\n    input wire oitfrd_match_disprs1,\n    input wire oitfrd_match_disprs2,\n    input wire oitfrd_match_disprs3,\n    input wire oitfrd_match_disprd,\n    input wire [E203_ITAG_WIDTH-1:0] disp_oitf_ptr,\n    output wire disp_oitf_ena,\n    input wire disp_oitf_ready,\n    output wire disp_oitf_rs1fpu,\n    output wire disp_oitf_rs2fpu,\n    output wire disp_oitf_rs3fpu,\n    output wire disp_oitf_rdfpu,\n    output wire disp_oitf_rs1en,\n    output wire disp_oitf_rs2en,\n    output wire disp_oitf_rs3en,\n    output wire disp_oitf_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs2idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs3idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rdidx,\n    output wire [E203_PC_SIZE-1:0] disp_oitf_pc,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Implementation of the dispatch logic\n    // Note: The actual logic for handling dispatch, dependencies, and WFI is not shown here\n    // and should be implemented according to the specific requirements and architecture.\n\n    assign disp_i_ready = !amo_wait && disp_o_alu_ready && !wfi_halt_exu_req;\n    assign disp_o_alu_valid = disp_i_valid && disp_i_ready;\n    assign disp_o_alu_rs1 = disp_i_rs1;\n    assign disp_o_alu_rs2 = disp_i_rs2;\n    assign disp_o_alu_rdwen = disp_i_rdwen;\n    assign disp_o_alu_rdidx = disp_i_rdidx;\n    assign disp_o_alu_info = disp_i_info;\n    assign disp_o_alu_imm = disp_i_imm;\n    assign disp_o_alu_pc = disp_i_pc;\n    assign disp_o_alu_itag = disp_oitf_ptr;\n    assign disp_o_alu_misalgn = disp_i_misalgn;\n    assign disp_o_alu_buserr = disp_i_buserr;\n    assign disp_o_alu_ilegl = disp_i_ilegl;\n\n    assign wfi_halt_exu_ack = wfi_halt_exu_req && oitf_empty;\n\n    // OITF dispatch logic\n    assign disp_oitf_ena = disp_o_alu_valid && disp_o_alu_longpipe && disp_oitf_ready;\n    assign disp_oitf_rs1fpu = 0; // Assuming no FPU in this configuration\n    assign disp_oitf_rs2fpu = 0;\n    assign disp_oitf_rs3fpu = 0;\n    assign disp_oitf_rdfpu = 0;\n    assign disp_oitf_rs1en = disp_i_rs1en;\n    assign disp_oitf_rs2en = disp_i_rs2en;\n    assign disp_oitf_rs3en = 0; // Assuming no third operand\n    assign disp_oitf_rdwen = disp_i_rdwen;\n    assign disp_oitf_rs1idx = disp_i_rs1idx;\n    assign disp_oitf_rs2idx = disp_i_rs2idx;\n    assign disp_oitf_rs3idx = 0; // Assuming no third operand\n    assign disp_oitf_rdidx = disp_i_rdidx;\n    assign disp_oitf_pc = disp_i_pc;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 7, "code": "module e203_exu_alu_lsuagu (\n    input wire agu_i_valid,\n    output wire agu_i_ready,\n    input wire [E203_XLEN-1:0] agu_i_rs1,\n    input wire [E203_XLEN-1:0] agu_i_rs2,\n    input wire [E203_XLEN-1:0] agu_i_imm,\n    input wire [E203_DECINFO_AGU_WIDTH-1:0] agu_i_info,\n    input wire [E203_ITAG_WIDTH-1:0] agu_i_itag,\n    output wire agu_i_longpipe,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire amo_wait,\n    input wire oitf_empty,\n    output wire agu_o_valid,\n    input wire agu_o_ready,\n    output wire [E203_XLEN-1:0] agu_o_wbck_wdat,\n    output wire agu_o_wbck_err,\n    output wire agu_o_cmt_misalgn,\n    output wire agu_o_cmt_ld,\n    output wire agu_o_cmt_stamo,\n    output wire agu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] agu_o_cmt_badaddr,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_cmd_usign,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire [E203_XLEN-1:0] agu_req_alu_op1,\n    output wire [E203_XLEN-1:0] agu_req_alu_op2,\n    output wire agu_req_alu_swap,\n    output wire agu_req_alu_add,\n    output wire agu_req_alu_and,\n    output wire agu_req_alu_or,\n    output wire agu_req_alu_xor,\n    output wire agu_req_alu_max,\n    output wire agu_req_alu_min,\n    output wire agu_req_alu_maxu,\n    output wire agu_req_alu_minu,\n    input wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire agu_sbf_0_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_0_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_0_r,\n    output wire agu_sbf_1_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_1_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_1_r,\n    input wire clk,\n    input wire rst_n\n);\n    // Implementation of the AGU logic goes here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 4, "code": "module e203_exu_alu(\n    input wire clk,\n    input wire rst_n,\n    input wire i_valid,\n    output wire i_ready,\n    input wire [E203_XLEN-1:0] i_rs1,\n    input wire [E203_XLEN-1:0] i_rs2,\n    input wire [E203_XLEN-1:0] i_imm,\n    input wire [E203_DECINFO_WIDTH-1:0] i_info,\n    input wire [E203_PC_SIZE-1:0] i_pc,\n    input wire [E203_INSTR_SIZE-1:0] i_instr,\n    input wire i_pc_vld,\n    input wire [E203_RFIDX_WIDTH-1:0] i_rdidx,\n    input wire i_rdwen,\n    input wire i_ilegl,\n    input wire i_buserr,\n    input wire i_misalgn,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire cmt_o_valid,\n    input wire cmt_o_ready,\n    output wire [E203_PC_SIZE-1:0] cmt_o_pc,\n    output wire [E203_INSTR_SIZE-1:0] cmt_o_instr,\n    output wire [E203_XLEN-1:0] cmt_o_imm,\n    output wire cmt_o_rv32,\n    output wire cmt_o_bjp,\n    output wire cmt_o_mret,\n    output wire cmt_o_dret,\n    output wire cmt_o_ecall,\n    output wire cmt_o_ebreak,\n    output wire cmt_o_fencei,\n    output wire cmt_o_wfi,\n    output wire cmt_o_ifu_misalgn,\n    output wire cmt_o_ifu_buserr,\n    output wire cmt_o_ifu_ilegl,\n    output wire cmt_o_bjp_prdt,\n    output wire cmt_o_bjp_rslv,\n    output wire cmt_o_misalgn,\n    output wire cmt_o_ld,\n    output wire cmt_o_stamo,\n    output wire cmt_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] cmt_o_badaddr,\n    output wire wbck_o_valid,\n    input wire wbck_o_ready,\n    output wire [E203_XLEN-1:0] wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] wbck_o_rdidx,\n    input wire mdv_nob2b,\n    output wire csr_ena,\n    output wire csr_wr_en,\n    output wire csr_rd_en,\n    output wire [11:0] csr_idx,\n    input wire nonflush_cmt_ena,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output wire [E203_XLEN-1:0] wbck_csr_dat,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_usign,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_longp_wbck_valid,\n    input wire nice_longp_wbck_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire i_nice_cmt_off_ilgl\n);\n    // ALU core logic implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 2, "code": "module e203_exu_excp(\n    output commit_trap,\n    output core_wfi,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input amo_wait,\n    input alu_excp_i_valid,\n    input alu_excp_i_ld,\n    input alu_excp_i_stamo,\n    input alu_excp_i_misalgn,\n    input alu_excp_i_buserr,\n    input alu_excp_i_ecall,\n    input alu_excp_i_ebreak,\n    input alu_excp_i_wfi,\n    input alu_excp_i_ifu_misalgn,\n    input alu_excp_i_ifu_buserr,\n    input alu_excp_i_ifu_ilegl,\n    input [E203_PC_SIZE-1:0] alu_excp_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_excp_i_instr,\n    input alu_excp_i_pc_vld,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input longp_excp_i_insterr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input excpirq_flush_ack,\n    output excpirq_flush_req,\n    output nonalu_excpirq_flush_req_raw,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op1,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op2,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input cmt_dret_ena,\n    input cmt_ena,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_badaddr_ena,\n    output cmt_epc_ena,\n    output cmt_cause_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output excp_active,\n    input clk,\n    input rst_n\n);\n\n    // Implementation of exception handling logic\n    // Note: This is a simplified example and does not include all functionality\n\n    reg [E203_PC_SIZE-1:0] mtvec;\n    reg [E203_PC_SIZE-1:0] mepc;\n    reg [E203_XLEN-1:0] mcause;\n    reg [E203_ADDR_SIZE-1:0] mtval;\n    reg mstatus;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            mtvec <= 0;\n            mepc <= 0;\n            mcause <= 0;\n            mtval <= 0;\n            mstatus <= 0;\n        end else begin\n            if (alu_excp_i_valid) begin\n                mepc <= alu_excp_i_pc;\n                case (1'b1) // Synthesized priority encoder\n                    alu_excp_i_ecall: mcause <= 11; // Environment call from M-mode\n                    alu_excp_i_ebreak: mcause <= 3; // Breakpoint\n                    alu_excp_i_misalgn: mcause <= 0; // Instruction address misaligned\n                    alu_excp_i_buserr: mcause <= 1; // Instruction access fault\n                    alu_excp_i_ifu_misalgn: mcause <= 0; // Instruction address misaligned\n                    alu_excp_i_ifu_buserr: mcause <= 1; // Instruction access fault\n                    alu_excp_i_ifu_ilegl: mcause <= 2; // Illegal instruction\n                    default: mcause <= 31; // Reserved\n                endcase\n                mtval <= alu_excp_i_pc; // Simplified example\n            end\n        end\n    end\n\n    assign excpirq_flush_req = alu_excp_i_valid;\n    assign excpirq_flush_add_op1 = csr_mtvec_r;\n    assign excpirq_flush_add_op2 = 0;\n\n    assign cmt_epc = mepc;\n    assign cmt_cause = mcause;\n    assign cmt_badaddr = mtval;\n\n    assign cmt_epc_ena = alu_excp_i_valid;\n    assign cmt_cause_ena = alu_excp_i_valid;\n    assign cmt_badaddr_ena = alu_excp_i_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 9, "code": "module e203_exu_alu_rglr(\n    input wire alu_i_valid,\n    output wire alu_i_ready,\n    input wire [E203_XLEN-1:0] alu_i_rs1,\n    input wire [E203_XLEN-1:0] alu_i_rs2,\n    input wire [E203_XLEN-1:0] alu_i_imm,\n    input wire [E203_PC_SIZE-1:0] alu_i_pc,\n    input wire [E203_DECINFO_ALU_WIDTH-1:0] alu_i_info,\n    output wire alu_o_valid,\n    input wire alu_o_ready,\n    output wire [E203_XLEN-1:0] alu_o_wbck_wdat,\n    output wire alu_o_wbck_err,\n    output wire alu_o_cmt_ecall,\n    output wire alu_o_cmt_ebreak,\n    output wire alu_o_cmt_wfi,\n    output wire alu_req_alu_add,\n    output wire alu_req_alu_sub,\n    output wire alu_req_alu_xor,\n    output wire alu_req_alu_sll,\n    output wire alu_req_alu_srl,\n    output wire alu_req_alu_sra,\n    output wire alu_req_alu_or,\n    output wire alu_req_alu_and,\n    output wire alu_req_alu_slt,\n    output wire alu_req_alu_sltu,\n    output wire alu_req_alu_lui,\n    output wire [E203_XLEN-1:0] alu_req_alu_op1,\n    output wire [E203_XLEN-1:0] alu_req_alu_op2,\n    output wire [E203_XLEN-1:0] alu_req_alu_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Handshake signals\n    assign alu_i_ready = alu_o_ready;\n    assign alu_o_valid = alu_i_valid;\n\n    // Selecting operands based on instruction info\n    assign alu_req_alu_op1 = (alu_i_info[E203_DECINFO_ALU_OP1PC]) ? alu_i_pc : alu_i_rs1;\n    assign alu_req_alu_op2 = (alu_i_info[E203_DECINFO_ALU_OP2IMM]) ? alu_i_imm : alu_i_rs2;\n\n    // Operation request signals\n    assign alu_req_alu_add = alu_i_info[E203_DECINFO_ALU_ADD] & ~alu_i_info[E203_DECINFO_ALU_NOP];\n    assign alu_req_alu_sub = alu_i_info[E203_DECINFO_ALU_SUB];\n    assign alu_req_alu_xor = alu_i_info[E203_DECINFO_ALU_XOR];\n    assign alu_req_alu_sll = alu_i_info[E203_DECINFO_ALU_SLL];\n    assign alu_req_alu_srl = alu_i_info[E203_DECINFO_ALU_SRL];\n    assign alu_req_alu_sra = alu_i_info[E203_DECINFO_ALU_SRA];\n    assign alu_req_alu_or  = alu_i_info[E203_DECINFO_ALU_OR];\n    assign alu_req_alu_and = alu_i_info[E203_DECINFO_ALU_AND];\n    assign alu_req_alu_slt = alu_i_info[E203_DECINFO_ALU_SLT];\n    assign alu_req_alu_sltu = alu_i_info[E203_DECINFO_ALU_SLTU];\n    assign alu_req_alu_lui = alu_i_info[E203_DECINFO_ALU_LUI];\n\n    // Calculation result\n    assign alu_o_wbck_wdat = alu_req_alu_res;\n\n    // Error and special instruction signals\n    assign alu_o_wbck_err = alu_i_info[E203_DECINFO_ALU_ECAL] | alu_i_info[E203_DECINFO_ALU_EBRK] | alu_i_info[E203_DECINFO_ALU_WFI];\n    assign alu_o_cmt_ecall = alu_i_info[E203_DECINFO_ALU_ECAL];\n    assign alu_o_cmt_ebreak = alu_i_info[E203_DECINFO_ALU_EBRK];\n    assign alu_o_cmt_wfi = alu_i_info[E203_DECINFO_ALU_WFI];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 6, "code": "module e203_ifu_minidec #(\n  parameter E203_INSTR_SIZE = 32,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_XLEN = 32\n)(\n  input [E203_INSTR_SIZE-1:0] instr,\n  output reg dec_rs1en,\n  output reg dec_rs2en,\n  output reg [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n  output reg [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n  output reg dec_mulhsu,\n  output reg dec_mul,\n  output reg dec_div,\n  output reg dec_rem,\n  output reg dec_divu,\n  output reg dec_remu,\n  output reg dec_rv32,\n  output reg dec_bjp,\n  output reg dec_jal,\n  output reg dec_jalr,\n  output reg dec_bxx,\n  output reg [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  output reg [E203_XLEN-1:0] dec_bjp_imm\n);\n\n  // Local parameters or internal signals\n  localparam OPCODE_RTYPE = 7'b0110011;\n  localparam OPCODE_ITYPE = 7'b0010011;\n  localparam OPCODE_JAL = 7'b1101111;\n  localparam OPCODE_JALR = 7'b1100111;\n  localparam OPCODE_BRANCH = 7'b1100011;\n\n  wire [6:0] opcode = instr[6:0];\n  wire [2:0] funct3 = instr[14:12];\n  wire [6:0] funct7 = instr[31:25];\n\n  always @(*) begin\n    // Default values\n    dec_rs1en = 1'b0;\n    dec_rs2en = 1'b0;\n    dec_rs1idx = {E203_RFIDX_WIDTH{1'b0}};\n    dec_rs2idx = {E203_RFIDX_WIDTH{1'b0}};\n    dec_mulhsu = 1'b0;\n    dec_mul = 1'b0;\n    dec_div = 1'b0;\n    dec_rem = 1'b0;\n    dec_divu = 1'b0;\n    dec_remu = 1'b0;\n    dec_rv32 = 1'b1; // Assuming RV32\n    dec_bjp = 1'b0;\n    dec_jal = 1'b0;\n    dec_jalr = 1'b0;\n    dec_bxx = 1'b0;\n    dec_jalr_rs1idx = {E203_RFIDX_WIDTH{1'b0}};\n    dec_bjp_imm = {E203_XLEN{1'b0}};\n\n    case (opcode)\n      OPCODE_RTYPE: begin\n        dec_rs1en = 1'b1;\n        dec_rs2en = 1'b1;\n        dec_rs1idx = instr[19:15];\n        dec_rs2idx = instr[24:20];\n        case (funct7)\n          7'b0000001: begin\n            case (funct3)\n              3'b000: dec_mul = 1'b1;\n              3'b001: dec_mulh = 1'b1;\n              3'b010: dec_mulhsu = 1'b1;\n              3'b011: dec_mulhu = 1'b1;\n              3'b100: dec_div = 1'b1;\n              3'b101: dec_divu = 1'b1;\n              3'b110: dec_rem = 1'b1;\n              3'b111: dec_remu = 1'b1;\n            endcase\n          end\n        endcase\n      end\n      OPCODE_ITYPE: begin\n        dec_rs1en = 1'b1;\n        dec_rs1idx = instr[19:15];\n        // Handle specific I-type operations\n      end\n      OPCODE_JAL: begin\n        dec_jal = 1'b1;\n        dec_bjp = 1'b1;\n        dec_bjp_imm = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0};\n      end\n      OPCODE_JALR: begin\n        dec_jalr = 1'b1;\n        dec_bjp = 1'b1;\n        dec_rs1en = 1'b1;\n        dec_jalr_rs1idx = instr[19:15];\n        dec_bjp_imm = {{20{instr[31]}}, instr[31:20]};\n      end\n      OPCODE_BRANCH: begin\n        dec_bxx = 1'b1;\n        dec_bjp = 1'b1;\n        dec_rs1en = 1'b1;\n        dec_rs2en = 1'b1;\n        dec_rs1idx = instr[19:15];\n        dec_rs2idx = instr[24:20];\n        dec_bjp_imm = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};\n      end\n    endcase\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 7, "code": "module e203_ifu_minidec #(\n  parameter E203_INSTR_SIZE = 32,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_XLEN = 32\n)(\n  input [E203_INSTR_SIZE-1:0] instr,\n  output dec_rs1en,\n  output dec_rs2en,\n  output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n  output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n  output dec_mulhsu,\n  output dec_mul,\n  output dec_div,\n  output dec_rem,\n  output dec_divu,\n  output dec_remu,\n  output dec_rv32,\n  output dec_bjp,\n  output dec_jal,\n  output dec_jalr,\n  output dec_bxx,\n  output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  output [E203_XLEN-1:0] dec_bjp_imm\n);\n\n  // Internal signals for decoding\n  wire [6:0] opcode = instr[6:0];\n  wire [2:0] funct3 = instr[14:12];\n  wire [6:0] funct7 = instr[31:25];\n\n  // Register enable signals\n  assign dec_rs1en = (opcode != 7'b0110111) && (opcode != 7'b0010111);\n  assign dec_rs2en = (opcode == 7'b0110011) || (opcode == 7'b1100011) || (opcode == 7'b0100011);\n\n  // Register indices\n  assign dec_rs1idx = instr[19:15];\n  assign dec_rs2idx = instr[24:20];\n\n  // Instruction type flags\n  assign dec_mulhsu = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b010);\n  assign dec_mul = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b000);\n  assign dec_div = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b100);\n  assign dec_rem = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b110);\n  assign dec_divu = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b101);\n  assign dec_remu = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b111);\n  assign dec_rv32 = 1'b1; // Assuming RV32 only\n\n  // Branch and jump instructions\n  assign dec_bjp = (opcode == 7'b1101111) || (opcode == 7'b1100111) || (opcode == 7'b1100011);\n  assign dec_jal = (opcode == 7'b1101111);\n  assign dec_jalr = (opcode == 7'b1100111);\n  assign dec_bxx = (opcode == 7'b1100011);\n\n  // JALR specific RS1 index\n  assign dec_jalr_rs1idx = (dec_jalr ? instr[19:15] : {E203_RFIDX_WIDTH{1'b0}});\n\n  // Immediate for branch/jump instructions\n  assign dec_bjp_imm = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 11, "code": "module e203_srams #(\n  parameter E203_ITCM_RAM_AW = 10, // Address width for ITCM\n  parameter E203_ITCM_RAM_MW = 4,  // Write mask width for ITCM\n  parameter E203_ITCM_RAM_DW = 32, // Data width for ITCM\n  parameter E203_DTCM_RAM_AW = 10, // Address width for DTCM\n  parameter E203_DTCM_RAM_MW = 4,  // Write mask width for DTCM\n  parameter E203_DTCM_RAM_DW = 32  // Data width for DTCM\n)(\n  input wire clk,\n  input wire rst_n,\n\n  // ITCM Interface\n  input wire itcm_ram_cs,\n  input wire itcm_ram_we,\n  input wire [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n  input wire [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n  input wire [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n  output wire [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n\n  // DTCM Interface\n  input wire dtcm_ram_cs,\n  input wire dtcm_ram_we,\n  input wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n  input wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n  input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n  output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout\n);\n\n`ifdef E203_HAS_ITCM\n  // ITCM Memory Array\n  reg [E203_ITCM_RAM_DW-1:0] itcm_mem [0:(1<<E203_ITCM_RAM_AW)-1];\n\n  always @(posedge clk) begin\n    if (itcm_ram_cs && itcm_ram_we) begin\n      for (int i = 0; i < E203_ITCM_RAM_MW; i++) begin\n        if (itcm_ram_wem[i]) begin\n          itcm_mem[itcm_ram_addr][8*i +: 8] <= itcm_ram_din[8*i +: 8];\n        end\n      end\n    end\n  end\n\n  assign itcm_ram_dout = itcm_mem[itcm_ram_addr];\n`endif\n\n`ifdef E203_HAS_DTCM\n  // DTCM Memory Array\n  reg [E203_DTCM_RAM_DW-1:0] dtcm_mem [0:(1<<E203_DTCM_RAM_AW)-1];\n\n  always @(posedge clk) begin\n    if (dtcm_ram_cs && dtcm_ram_we) begin\n      for (int i = 0; i < E203_DTCM_RAM_MW; i++) begin\n        if (dtcm_ram_wem[i]) begin\n          dtcm_mem[dtcm_ram_addr][8*i +: 8] <= dtcm_ram_din[8*i +: 8];\n        end\n      end\n    end\n  end\n\n  assign dtcm_ram_dout = dtcm_mem[dtcm_ram_addr];\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 3, "code": "module e203_exu_excp(\n    output commit_trap,\n    output core_wfi,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input amo_wait,\n    input alu_excp_i_valid,\n    input alu_excp_i_ld,\n    input alu_excp_i_stamo,\n    input alu_excp_i_misalgn,\n    input alu_excp_i_buserr,\n    input alu_excp_i_ecall,\n    input alu_excp_i_ebreak,\n    input alu_excp_i_wfi,\n    input alu_excp_i_ifu_misalgn,\n    input alu_excp_i_ifu_buserr,\n    input alu_excp_i_ifu_ilegl,\n    input [E203_PC_SIZE-1:0] alu_excp_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_excp_i_instr,\n    input alu_excp_i_pc_vld,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input longp_excp_i_insterr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input excpirq_flush_ack,\n    output excpirq_flush_req,\n    output nonalu_excpirq_flush_req_raw,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op1,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op2,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input cmt_dret_ena,\n    input cmt_ena,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_badaddr_ena,\n    output cmt_epc_ena,\n    output cmt_cause_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output excp_active,\n    input clk,\n    input rst_n\n);\n    // Implementation of exception handling logic\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 19, "code": "module e203_cpu_top(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire tcm_sd,\n    input wire tcm_ds,\n    input wire [E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input wire ext2itcm_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ext2itcm_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] ext2itcm_icb_cmd_wmask,\n    input wire ext2itcm_icb_rsp_ready,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire dbg_irq_r,\n    output wire ext2itcm_icb_cmd_valid,\n    output wire ext2itcm_icb_cmd_ready,\n    output wire ext2itcm_icb_rsp_valid,\n    output wire ext2itcm_icb_rsp_err,\n    output wire [E203_XLEN-1:0] ext2itcm_icb_rsp_rdata\n);\n\n    // Internal signals\n    wire core_clk = clk;\n    wire core_rst_n = rst_n;\n\n    // Instantiate the E203 CPU core\n    e203_cpu u_e203_cpu(\n        .clk(core_clk),\n        .rst_n(core_rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ext_irq_a(ext_irq_a),\n        .sft_irq_a(sft_irq_a),\n        .tmr_irq_a(tmr_irq_a),\n        .inspect_pc(inspect_pc),\n        .inspect_dbg_irq(inspect_dbg_irq),\n        .inspect_mem_cmd_valid(inspect_mem_cmd_valid),\n        .inspect_mem_cmd_ready(inspect_mem_cmd_ready),\n        .inspect_mem_rsp_valid(inspect_mem_rsp_valid),\n        .inspect_mem_rsp_ready(inspect_mem_rsp_ready),\n        .inspect_core_clk(inspect_core_clk),\n        .core_csr_clk(core_csr_clk),\n        .core_wfi(core_wfi),\n        .tm_stop(tm_stop),\n        .dbg_irq_r(dbg_irq_r)\n    );\n\n    // SRAM control logic\n    e203_srams u_e203_srams(\n        .clk(core_clk),\n        .rst_n(core_rst_n),\n        .tcm_sd(tcm_sd),\n        .tcm_ds(tcm_ds),\n        .ext2itcm_icb_cmd_valid(ext2itcm_icb_cmd_valid),\n        .ext2itcm_icb_cmd_ready(ext2itcm_icb_cmd_ready),\n        .ext2itcm_icb_cmd_addr(ext2itcm_icb_cmd_addr),\n        .ext2itcm_icb_cmd_read(ext2itcm_icb_cmd_read),\n        .ext2itcm_icb_cmd_wdata(ext2itcm_icb_cmd_wdata),\n        .ext2itcm_icb_cmd_wmask(ext2itcm_icb_cmd_wmask),\n        .ext2itcm_icb_rsp_valid(ext2itcm_icb_rsp_valid),\n        .ext2itcm_icb_rsp_ready(ext2itcm_icb_rsp_ready),\n        .ext2itcm_icb_rsp_err(ext2itcm_icb_rsp_err),\n        .ext2itcm_icb_rsp_rdata(ext2itcm_icb_rsp_rdata)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 8, "code": "module e203_exu_alu_dpath(\n    input wire alu_req_alu,\n    input wire alu_req_alu_add,\n    input wire alu_req_alu_sub,\n    input wire alu_req_alu_xor,\n    input wire alu_req_alu_sll,\n    input wire alu_req_alu_srl,\n    input wire alu_req_alu_sra,\n    input wire alu_req_alu_or,\n    input wire alu_req_alu_and,\n    input wire [E203_XLEN-1:0] alu_req_alu_op1,\n    input wire [E203_XLEN-1:0] alu_req_alu_op2,\n    input wire bjp_req_alu,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    input wire agu_req_alu,\n    input wire [E203_XLEN-1:0] agu_req_alu_op1,\n    input wire [E203_XLEN-1:0] agu_req_alu_op2,\n    input wire muldiv_req_alu,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    input wire muldiv_req_alu_add,\n    input wire muldiv_req_alu_sub,\n    input wire muldiv_sbf_0_ena,\n    input wire [32:0] muldiv_sbf_0_nxt,\n    input wire muldiv_sbf_1_ena,\n    input wire [32:0] muldiv_sbf_1_nxt,\n    input wire clk,\n    input wire rst_n,\n    output wire [E203_XLEN-1:0] alu_req_alu_res,\n    output wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    output wire bjp_req_alu_cmp_res,\n    output wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output wire [32:0] muldiv_sbf_0_r,\n    output wire [32:0] muldiv_sbf_1_r\n);\n\n    // Internal signals for ALU operations\n    wire [E203_XLEN-1:0] add_res, sub_res, and_res, or_res, xor_res;\n    wire [E203_XLEN-1:0] sll_res, srl_res, sra_res;\n\n    // ALU operations\n    assign add_res = alu_req_alu_op1 + alu_req_alu_op2;\n    assign sub_res = alu_req_alu_op1 - alu_req_alu_op2;\n    assign and_res = alu_req_alu_op1 & alu_req_alu_op2;\n    assign or_res  = alu_req_alu_op1 | alu_req_alu_op2;\n    assign xor_res = alu_req_alu_op1 ^ alu_req_alu_op2;\n    assign sll_res = alu_req_alu_op1 << alu_req_alu_op2[E203_XLEN-1:0];\n    assign srl_res = alu_req_alu_op1 >> alu_req_alu_op2[E203_XLEN-1:0];\n    assign sra_res = $signed(alu_req_alu_op1) >>> alu_req_alu_op2[E203_XLEN-1:0];\n\n    // Result multiplexing\n    assign alu_req_alu_res = ({E203_XLEN{alu_req_alu_add}} & add_res) |\n                             ({E203_XLEN{alu_req_alu_sub}} & sub_res) |\n                             ({E203_XLEN{alu_req_alu_and}} & and_res) |\n                             ({E203_XLEN{alu_req_alu_or}} & or_res) |\n                             ({E203_XLEN{alu_req_alu_xor}} & xor_res) |\n                             ({E203_XLEN{alu_req_alu_sll}} & sll_res) |\n                             ({E203_XLEN{alu_req_alu_srl}} & srl_res) |\n                             ({E203_XLEN{alu_req_alu_sra}} & sra_res);\n\n    // BJP operations\n    assign bjp_req_alu_add_res = bjp_req_alu_op1 + bjp_req_alu_op2;\n    assign bjp_req_alu_cmp_res = (bjp_req_alu_op1 == bjp_req_alu_op2);\n\n    // AGU operations\n    assign agu_req_alu_res = agu_req_alu_op1 + agu_req_alu_op2; // Example: simple add for address calculation\n\n    // MULDIV operations\n    wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_add_res, muldiv_sub_res;\n    assign muldiv_add_res = muldiv_req_alu_op1 + muldiv_req_alu_op2;\n    assign muldiv_sub_res = muldiv_req_alu_op1 - muldiv_req_alu_op2;\n    assign muldiv_req_alu_res = (muldiv_req_alu_add ? muldiv_add_res : muldiv_sub_res);\n\n    // Shared buffer handling\n    sirv_gnrl_dffl #(.DW(33)) sbf_0_dffl (\n        .lden(muldiv_sbf_0_ena),\n        .dnxt(muldiv_sbf_0_nxt),\n        .qout(muldiv_sbf_0_r),\n        .clk(clk)\n    );\n\n    sirv_gnrl_dffl #(.DW(33)) sbf_1_dffl (\n        .lden(muldiv_sbf_1_ena),\n        .dnxt(muldiv_sbf_1_nxt),\n        .qout(muldiv_sbf_1_r),\n        .clk(clk)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 1, "code": "module itcm_controller (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n    output wire itcm_active,\n    // IFU Interface\n    input wire ifu2itcm_icb_cmd_valid,\n    output wire ifu2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] ifu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] ifu2itcm_icb_cmd_wmask,\n    output wire ifu2itcm_icb_rsp_valid,\n    input wire ifu2itcm_icb_rsp_ready,\n    output wire ifu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    // LSU Interface\n    input wire lsu2itcm_icb_cmd_valid,\n    output wire lsu2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] lsu2itcm_icb_cmd_addr,\n    input wire lsu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] lsu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] lsu2itcm_icb_cmd_wmask,\n    output wire lsu2itcm_icb_rsp_valid,\n    input wire lsu2itcm_icb_rsp_ready,\n    output wire lsu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] lsu2itcm_icb_rsp_rdata,\n    // External Interface\n    `ifdef E203_HAS_ITCM_EXTITF\n    input wire ext2itcm_icb_cmd_valid,\n    output wire ext2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input wire ext2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] ext2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] ext2itcm_icb_cmd_wmask,\n    output wire ext2itcm_icb_rsp_valid,\n    input wire ext2itcm_icb_rsp_ready,\n    output wire ext2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] ext2itcm_icb_rsp_rdata,\n    `endif\n    // RAM Interface\n    output wire itcm_ram_cs,\n    output wire itcm_ram_we,\n    output wire [RAM_AW-1:0] itcm_ram_addr,\n    output wire [RAM_MW-1:0] itcm_ram_wem,\n    output wire [RAM_DW-1:0] itcm_ram_din,\n    input wire [RAM_DW-1:0] itcm_ram_dout,\n    output wire clk_itcm_ram\n);\n\n    // Internal logic and state machine for handling ITCM access\n    // Priority arbitration, data width conversion, and timing control logic here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 9, "code": "module e203_exu_nice (\n    input wire nice_i_xs_off,\n    input wire nice_i_valid,\n    output wire nice_i_ready,\n    input wire [E203_XLEN-1:0] nice_i_instr,\n    input wire [E203_XLEN-1:0] nice_i_rs1,\n    input wire [E203_XLEN-1:0] nice_i_rs2,\n    input wire [E203_ITAG_WIDTH-1:0] nice_i_itag,\n    output wire nice_o_longpipe,\n    output wire nice_o_valid,\n    input wire nice_o_ready,\n    output wire nice_o_itag_valid,\n    input wire nice_o_itag_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire clk,\n    input wire rst_n\n);\n\n// Internal signals\nwire fifo_i_vld, fifo_i_rdy, fifo_o_vld, fifo_o_rdy;\nwire [E203_ITAG_WIDTH-1:0] fifo_i_dat, fifo_o_dat;\n\n// Instantiate the FIFO\nsirv_gnrl_fifo #(\n    .CUT_READY(1),\n    .MSKO(0),\n    .DP(4),\n    .DW(E203_ITAG_WIDTH)\n) itag_fifo (\n    .i_vld(fifo_i_vld),\n    .i_rdy(fifo_i_rdy),\n    .i_dat(fifo_i_dat),\n    .o_vld(fifo_o_vld),\n    .o_rdy(fifo_o_rdy),\n    .o_dat(fifo_o_dat),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// Control logic\nassign nice_i_ready = nice_o_ready & nice_o_itag_ready & ~nice_i_xs_off;\nassign nice_o_longpipe = ~nice_i_xs_off;\nassign nice_o_valid = nice_i_valid & nice_i_ready;\nassign nice_o_itag_valid = fifo_o_vld & nice_rsp_multicyc_valid;\nassign nice_rsp_multicyc_ready = fifo_o_rdy;\nassign fifo_i_vld = nice_i_valid & nice_i_ready;\nassign fifo_i_dat = nice_i_itag;\nassign nice_o_itag = fifo_o_dat;\n\n// Request to accelerator\nassign nice_req_valid = nice_i_valid & nice_i_ready & ~nice_i_xs_off;\nassign nice_req_instr = nice_i_instr;\nassign nice_req_rs1 = nice_i_rs1;\nassign nice_req_rs2 = nice_i_rs2;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 9, "code": "module e203_exu_regfile #(\n  parameter E203_RFIDX_WIDTH = 5, // Width of the register index\n  parameter E203_XLEN = 32        // Width of the register data\n)(\n  input  wire                     clk,\n  input  wire                     rst_n,\n  input  wire [E203_RFIDX_WIDTH-1:0] read_src1_idx,\n  input  wire [E203_RFIDX_WIDTH-1:0] read_src2_idx,\n  output wire [E203_XLEN-1:0]     read_src1_dat,\n  output wire [E203_XLEN-1:0]     read_src2_dat,\n  input  wire                     wbck_dest_wen,\n  input  wire [E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n  input  wire [E203_XLEN-1:0]     wbck_dest_dat,\n  output wire [E203_XLEN-1:0]     x1_r,\n  input  wire                     test_mode\n);\n\n  // Define the number of registers based on configuration\n  `ifdef E203_CFG_REGNUM_IS_32\n    localparam NUM_REGS = 32;\n  `elsif E203_CFG_REGNUM_IS_16\n    localparam NUM_REGS = 16;\n  `else\n    localparam NUM_REGS = 32; // Default to 32 if not specified\n  `endif\n\n  reg [E203_XLEN-1:0] regfile [NUM_REGS-1:0];\n\n  // Read logic\n  assign read_src1_dat = (read_src1_idx == 0) ? 0 : regfile[read_src1_idx];\n  assign read_src2_dat = (read_src2_idx == 0) ? 0 : regfile[read_src2_idx];\n\n  // Write logic\n  always @(posedge clk) begin\n    if (wbck_dest_wen && (wbck_dest_idx != 0)) begin\n      regfile[wbck_dest_idx] <= wbck_dest_dat;\n    end\n  end\n\n  // Output register x1\n  assign x1_r = regfile[1];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 10, "code": "module e203_exu_regfile #(\n  parameter E203_RFIDX_WIDTH = 5, // Width of the register index\n  parameter E203_XLEN = 32        // Width of the register data\n)(\n  input  wire                        clk,\n  input  wire                        rst_n,\n  input  wire [E203_RFIDX_WIDTH-1:0] read_src1_idx,\n  input  wire [E203_RFIDX_WIDTH-1:0] read_src2_idx,\n  output wire [E203_XLEN-1:0]        read_src1_dat,\n  output wire [E203_XLEN-1:0]        read_src2_dat,\n  input  wire                        wbck_dest_wen,\n  input  wire [E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n  input  wire [E203_XLEN-1:0]        wbck_dest_dat,\n  output wire [E203_XLEN-1:0]        x1_r,\n  input  wire                        test_mode\n);\n\n  // Define the number of registers based on configuration\n  `ifdef E203_CFG_REGNUM_IS_32\n    localparam NUM_REGS = 32;\n  `elsif E203_CFG_REGNUM_IS_16\n    localparam NUM_REGS = 16;\n  `else\n    localparam NUM_REGS = 32; // Default to 32 if not specified\n  `endif\n\n  reg [E203_XLEN-1:0] regfile [NUM_REGS-1:0];\n\n  // Read logic\n  assign read_src1_dat = (read_src1_idx == 0) ? 0 : regfile[read_src1_idx];\n  assign read_src2_dat = (read_src2_idx == 0) ? 0 : regfile[read_src2_idx];\n\n  // Write logic\n  always @(posedge clk) begin\n    if (wbck_dest_wen && wbck_dest_idx != 0) begin\n      regfile[wbck_dest_idx] <= wbck_dest_dat;\n    end\n  end\n\n  // Special register x1 output\n  assign x1_r = regfile[1];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 9, "code": "module e203_exu_alu_muldiv (\n    input mdv_nob2b,\n    input muldiv_i_valid,\n    output muldiv_i_ready,\n    input [E203_XLEN-1:0] muldiv_i_rs1,\n    input [E203_XLEN-1:0] muldiv_i_rs2,\n    input [E203_XLEN-1:0] muldiv_i_imm,\n    input [E203_DECINFO_MULDIV_WIDTH-1:0] muldiv_i_info,\n    input [E203_ITAG_WIDTH-1:0] muldiv_i_itag,\n    output muldiv_i_longpipe,\n    input flush_pulse,\n    output muldiv_o_valid,\n    input muldiv_o_ready,\n    output [E203_XLEN-1:0] muldiv_o_wbck_wdat,\n    output muldiv_o_wbck_err,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    output muldiv_req_alu_add,\n    output muldiv_req_alu_sub,\n    input [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output muldiv_sbf_0_ena,\n    output [32:0] muldiv_sbf_0_nxt,\n    input [32:0] muldiv_sbf_0_r,\n    output muldiv_sbf_1_ena,\n    output [32:0] muldiv_sbf_1_nxt,\n    input [32:0] muldiv_sbf_1_r,\n    input clk,\n    input rst_n\n);\n\n// Internal signals and registers\nreg [4:0] state;\nreg [4:0] next_state;\n\n// State definitions\nlocalparam MULDIV_STATE_0TH = 5'd0;\nlocalparam MULDIV_STATE_EXEC = 5'd1;\nlocalparam MULDIV_STATE_REMD_CHCK = 5'd2;\nlocalparam MULDIV_STATE_QUOT_CORR = 5'd3;\nlocalparam MULDIV_STATE_REMD_CORR = 5'd4;\n\n// FSM for handling multiplier and divider operations\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        state <= MULDIV_STATE_0TH;\n    else if (flush_pulse)\n        state <= MULDIV_STATE_0TH;\n    else\n        state <= next_state;\nend\n\n// Next state logic\nalways @(*) begin\n    case (state)\n        MULDIV_STATE_0TH: begin\n            if (muldiv_i_valid)\n                next_state = MULDIV_STATE_EXEC;\n            else\n                next_state = MULDIV_STATE_0TH;\n        end\n        MULDIV_STATE_EXEC: begin\n            if (muldiv_i_info[0]) // Assuming LSB indicates completion\n                next_state = MULDIV_STATE_REMD_CHCK;\n            else\n                next_state = MULDIV_STATE_EXEC;\n        end\n        MULDIV_STATE_REMD_CHCK: begin\n            if (some_condition) // Placeholder for actual condition\n                next_state = MULDIV_STATE_QUOT_CORR;\n            else\n                next_state = MULDIV_STATE_0TH;\n        end\n        MULDIV_STATE_QUOT_CORR: begin\n            next_state = MULDIV_STATE_REMD_CORR;\n        end\n        MULDIV_STATE_REMD_CORR: begin\n            next_state = MULDIV_STATE_0TH;\n        end\n        default: begin\n            next_state = MULDIV_STATE_0TH;\n        end\n    endcase\nend\n\n// Output logic\nassign muldiv_i_ready = (state == MULDIV_STATE_0TH);\nassign muldiv_o_valid = (state == MULDIV_STATE_REMD_CORR);\nassign muldiv_o_wbck_wdat = muldiv_req_alu_res; // Placeholder for actual computation result\nassign muldiv_o_wbck_err = 1'b0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 19, "code": "module e203_biu(\n    input wire clk,\n    input wire rst_n,\n    output wire biu_active,\n\n    // ICB Interface to LSU\n    input wire lsu_icb_cmd_valid,\n    output wire lsu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] lsu_icb_cmd_addr,\n    input wire lsu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] lsu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] lsu_icb_cmd_wmask,\n    input wire [1:0] lsu_icb_cmd_burst,\n    input wire [1:0] lsu_icb_cmd_beat,\n    input wire lsu_icb_cmd_lock,\n    input wire lsu_icb_cmd_excl,\n    input wire [1:0] lsu_icb_cmd_size,\n    output wire lsu_icb_rsp_valid,\n    input wire lsu_icb_rsp_ready,\n    output wire lsu_icb_rsp_err,\n    output wire lsu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] lsu_icb_rsp_rdata,\n\n    // ICB Interface to IFU\n    `ifdef E203_HAS_MEM_ITF\n    input wire ifu_icb_cmd_valid,\n    output wire ifu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] ifu_icb_cmd_addr,\n    input wire ifu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ifu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] ifu_icb_cmd_wmask,\n    input wire [1:0] ifu_icb_cmd_burst,\n    input wire [1:0] ifu_icb_cmd_beat,\n    input wire ifu_icb_cmd_lock,\n    input wire ifu_icb_cmd_excl,\n    input wire [1:0] ifu_icb_cmd_size,\n    output wire ifu_icb_rsp_valid,\n    input wire ifu_icb_rsp_ready,\n    output wire ifu_icb_rsp_err,\n    output wire ifu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] ifu_icb_rsp_rdata,\n    `endif\n\n    // ICB Interface to PPI\n    input wire ppi_icb_cmd_valid,\n    output wire ppi_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] ppi_icb_cmd_addr,\n    input wire ppi_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ppi_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] ppi_icb_cmd_wmask,\n    input wire [1:0] ppi_icb_cmd_burst,\n    input wire [1:0] ppi_icb_cmd_beat,\n    input wire ppi_icb_cmd_lock,\n    input wire ppi_icb_cmd_excl,\n    input wire [1:0] ppi_icb_cmd_size,\n    output wire ppi_icb_rsp_valid,\n    input wire ppi_icb_rsp_ready,\n    output wire ppi_icb_rsp_err,\n    output wire ppi_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] ppi_icb_rsp_rdata,\n\n    // Additional signals for PPI\n    input wire [E203_ADDR_SIZE-1:0] ppi_region_indic,\n    input wire ppi_icb_enable,\n\n    // ICB Interface to CLINT\n    input wire clint_icb_cmd_valid,\n    output wire clint_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] clint_icb_cmd_addr,\n    input wire clint_icb_cmd_read,\n    input wire [E203_XLEN-1:0] clint_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] clint_icb_cmd_wmask,\n    input wire [1:0] clint_icb_cmd_burst,\n    input wire [1:0] clint_icb_cmd_beat,\n    input wire clint_icb_cmd_lock,\n    input wire clint_icb_cmd_excl,\n    input wire [1:0] clint_icb_cmd_size,\n    output wire clint_icb_rsp_valid,\n    input wire clint_icb_rsp_ready,\n    output wire clint_icb_rsp_err,\n    output wire clint_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] clint_icb_rsp_rdata,\n\n    // Additional signals for CLINT\n    input wire [E203_ADDR_SIZE-1:0] clint_region_indic,\n    input wire clint_icb_enable,\n\n    // ICB Interface to PLIC\n    input wire plic_icb_cmd_valid,\n    output wire plic_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] plic_icb_cmd_addr,\n    input wire plic_icb_cmd_read,\n    input wire [E203_XLEN-1:0] plic_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] plic_icb_cmd_wmask,\n    input wire [1:0] plic_icb_cmd_burst,\n    input wire [1:0] plic_icb_cmd_beat,\n    input wire plic_icb_cmd_lock,\n    input wire plic_icb_cmd_excl,\n    input wire [1:0] plic_icb_cmd_size,\n    output wire plic_icb_rsp_valid,\n    input wire plic_icb_rsp_ready,\n    output wire plic_icb_rsp_err,\n    output wire plic_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] plic_icb_rsp_rdata,\n\n    // Additional signals for PLIC\n    input wire [E203_ADDR_SIZE-1:0] plic_region_indic,\n    input wire plic_icb_enable,\n\n    // ICB Interface to MEM\n    `ifdef E203_HAS_MEM_ITF\n    input wire mem_icb_cmd_valid,\n    output wire mem_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] mem_icb_cmd_addr,\n    input wire mem_icb_cmd_read,\n    input wire [E203_XLEN-1:0] mem_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] mem_icb_cmd_wmask,\n    input wire [1:0] mem_icb_cmd_burst,\n    input wire [1:0] mem_icb_cmd_beat,\n    input wire mem_icb_cmd_lock,\n    input wire mem_icb_cmd_excl,\n    input wire [1:0] mem_icb_cmd_size,\n    output wire mem_icb_rsp_valid,\n    input wire mem_icb_rsp_ready,\n    output wire mem_icb_rsp_err,\n    output wire mem_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] mem_icb_rsp_rdata,\n\n    // Additional signals for MEM\n    input wire mem_icb_enable,\n    `endif\n\n    // ICB Interface to FIO\n    `ifdef E203_HAS_FIO\n    input wire fio_icb_cmd_valid,\n    output wire fio_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] fio_icb_cmd_addr,\n    input wire fio_icb_cmd_read,\n    input wire [E203_XLEN-1:0] fio_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] fio_icb_cmd_wmask,\n    input wire [1:0] fio_icb_cmd_burst,\n    input wire [1:0] fio_icb_cmd_beat,\n    input wire fio_icb_cmd_lock,\n    input wire fio_icb_cmd_excl,\n    input wire [1:0] fio_icb_cmd_size,\n    output wire fio_icb_rsp_valid,\n    input wire fio_icb_rsp_ready,\n    output wire fio_icb_rsp_err,\n    output wire fio_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] fio_icb_rsp_rdata,\n\n    // Additional signals for FIO\n    input wire [E203_ADDR_SIZE-1:0] fio_region_indic,\n    input wire fio_icb_enable,\n    `endif\n);\n    // Internal signals and logic for BIU operation will be implemented here.\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 10, "code": "module e203_exu_alu_rglr(\n    input wire alu_i_valid,\n    output reg alu_i_ready,\n    input wire [E203_XLEN-1:0] alu_i_rs1,\n    input wire [E203_XLEN-1:0] alu_i_rs2,\n    input wire [E203_XLEN-1:0] alu_i_imm,\n    input wire [E203_PC_SIZE-1:0] alu_i_pc,\n    input wire [E203_DECINFO_ALU_WIDTH-1:0] alu_i_info,\n    output reg alu_o_valid,\n    input wire alu_o_ready,\n    output reg [E203_XLEN-1:0] alu_o_wbck_wdat,\n    output reg alu_o_wbck_err,\n    output reg alu_o_cmt_ecall,\n    output reg alu_o_cmt_ebreak,\n    output reg alu_o_cmt_wfi,\n    output reg alu_req_alu_add,\n    output reg alu_req_alu_sub,\n    output reg alu_req_alu_xor,\n    output reg alu_req_alu_sll,\n    output reg alu_req_alu_srl,\n    output reg alu_req_alu_sra,\n    output reg alu_req_alu_or,\n    output reg alu_req_alu_and,\n    output reg alu_req_alu_slt,\n    output reg alu_req_alu_sltu,\n    output reg alu_req_alu_lui,\n    output reg [E203_XLEN-1:0] alu_req_alu_op1,\n    output reg [E203_XLEN-1:0] alu_req_alu_op2,\n    output reg [E203_XLEN-1:0] alu_req_alu_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Handshake mechanism\n    always @(*) begin\n        alu_i_ready = alu_o_ready;\n        alu_o_valid = alu_i_valid;\n    end\n\n    // Operation decoding\n    always @(*) begin\n        alu_req_alu_add = alu_i_info[E203_DECINFO_ALU_ADD];\n        alu_req_alu_sub = alu_i_info[E203_DECINFO_ALU_SUB];\n        alu_req_alu_xor = alu_i_info[E203_DECINFO_ALU_XOR];\n        alu_req_alu_sll = alu_i_info[E203_DECINFO_ALU_SLL];\n        alu_req_alu_srl = alu_i_info[E203_DECINFO_ALU_SRL];\n        alu_req_alu_sra = alu_i_info[E203_DECINFO_ALU_SRA];\n        alu_req_alu_or = alu_i_info[E203_DECINFO_ALU_OR];\n        alu_req_alu_and = alu_i_info[E203_DECINFO_ALU_AND];\n        alu_req_alu_slt = alu_i_info[E203_DECINFO_ALU_SLT];\n        alu_req_alu_sltu = alu_i_info[E203_DECINFO_ALU_SLTU];\n        alu_req_alu_lui = alu_i_info[E203_DECINFO_ALU_LUI];\n    end\n\n    // Operand selection\n    always @(*) begin\n        alu_req_alu_op1 = alu_i_info[E203_DECINFO_ALU_OP1PC] ? alu_i_pc : alu_i_rs1;\n        alu_req_alu_op2 = alu_i_info[E203_DECINFO_ALU_OP2IMM] ? alu_i_imm : alu_i_rs2;\n    end\n\n    // Result and error handling\n    always @(*) begin\n        alu_o_wbck_wdat = alu_req_alu_res;\n        alu_o_wbck_err = alu_i_info[E203_DECINFO_ALU_ECAL] | alu_i_info[E203_DECINFO_ALU_EBRK] | alu_i_info[E203_DECINFO_ALU_WFI];\n        alu_o_cmt_ecall = alu_i_info[E203_DECINFO_ALU_ECAL];\n        alu_o_cmt_ebreak = alu_i_info[E203_DECINFO_ALU_EBRK];\n        alu_o_cmt_wfi = alu_i_info[E203_DECINFO_ALU_WFI];\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 11, "code": "module e203_exu_alu_bjp (\n    input wire bjp_i_valid,\n    output wire bjp_i_ready,\n    input wire [E203_XLEN-1:0] bjp_i_rs1,\n    input wire [E203_XLEN-1:0] bjp_i_rs2,\n    input wire [E203_XLEN-1:0] bjp_i_imm,\n    input wire [E203_PC_SIZE-1:0] bjp_i_pc,\n    input wire [E203_DECINFO_BJP_WIDTH-1:0] bjp_i_info,\n    output wire bjp_o_valid,\n    input wire bjp_o_ready,\n    output wire [E203_XLEN-1:0] bjp_o_wbck_wdat,\n    output wire bjp_o_wbck_err,\n    output wire bjp_o_cmt_bjp,\n    output wire bjp_o_cmt_mret,\n    output wire bjp_o_cmt_dret,\n    output wire bjp_o_cmt_fencei,\n    output wire bjp_o_cmt_prdt,\n    output wire bjp_o_cmt_rslv,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    output wire bjp_req_alu_cmp_eq,\n    output wire bjp_req_alu_cmp_ne,\n    output wire bjp_req_alu_cmp_lt,\n    output wire bjp_req_alu_cmp_gt,\n    output wire bjp_req_alu_cmp_ltu,\n    output wire bjp_req_alu_cmp_gtu,\n    output wire bjp_req_alu_add,\n    input wire bjp_req_alu_cmp_res,\n    input wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Handshake mechanism\n    assign bjp_i_ready = bjp_o_ready;\n    assign bjp_o_valid = bjp_i_valid;\n\n    // Default outputs\n    assign bjp_o_wbck_err = 1'b0;\n    assign bjp_o_cmt_mret = 1'b0;\n    assign bjp_o_cmt_dret = 1'b0;\n    assign bjp_o_cmt_fencei = 1'b0;\n\n    // Decode branch/jump information\n    wire is_beq = bjp_i_info[E203_DECINFO_BJP_BEQ];\n    wire is_bne = bjp_i_info[E203_DECINFO_BJP_BNE];\n    wire is_blt = bjp_i_info[E203_DECINFO_BJP_BLT];\n    wire is_bgt = bjp_i_info[E203_DECINFO_BJP_BGT];\n    wire is_bltu = bjp_i_info[E203_DECINFO_BJP_BLTU];\n    wire is_bgtu = bjp_i_info[E203_DECINFO_BJP_BGTU];\n    wire is_jump = bjp_i_info[E203_DECINFO_BJP_JUMP];\n\n    // ALU operation requests\n    assign bjp_req_alu_cmp_eq = is_beq;\n    assign bjp_req_alu_cmp_ne = is_bne;\n    assign bjp_req_alu_cmp_lt = is_blt;\n    assign bjp_req_alu_cmp_gt = is_bgt;\n    assign bjp_req_alu_cmp_ltu = is_bltu;\n    assign bjp_req_alu_cmp_gtu = is_bgtu;\n    assign bjp_req_alu_add = is_jump;\n\n    // Operand selection\n    assign bjp_req_alu_op1 = is_jump ? bjp_i_pc : bjp_i_rs1;\n    assign bjp_req_alu_op2 = is_jump ? bjp_i_imm : bjp_i_rs2;\n\n    // Commit signals\n    assign bjp_o_cmt_bjp = bjp_i_valid & (is_beq | is_bne | is_blt | is_bgt | is_bltu | is_bgtu | is_jump);\n    assign bjp_o_cmt_prdt = bjp_i_info[E203_DECINFO_BJP_BPRDT];\n    assign bjp_o_cmt_rslv = is_jump ? 1'b1 : bjp_req_alu_cmp_res;\n\n    // Write back data\n    assign bjp_o_wbck_wdat = bjp_req_alu_add_res;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 3, "code": "module e203_exu_decode (\n    input [E203_INSTR_SIZE-1:0] i_instr,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_prdt_taken,\n    input i_misalgn,\n    input i_buserr,\n    input i_muldiv_b2b,\n    input dbg_mode,\n    output dec_rs1x0,\n    output dec_rs2x0,\n    output dec_rs1en,\n    output dec_rs2en,\n    output dec_rdwen,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rdidx,\n    output [E203_DECINFO_WIDTH-1:0] dec_info,\n    output [E203_XLEN-1:0] dec_imm,\n    output [E203_PC_SIZE-1:0] dec_pc,\n    output dec_misalgn,\n    output dec_buserr,\n    output dec_ilegl,\n    output dec_mulhsu,\n    output dec_mul,\n    output dec_div,\n    output dec_rem,\n    output dec_divu,\n    output dec_remu,\n    output dec_rv32,\n    output dec_bjp,\n    output dec_jal,\n    output dec_jalr,\n    output dec_bxx,\n    output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    output [E203_XLEN-1:0] dec_bjp_imm\n);\n\n    // Instruction decoding logic here\n    // This is a placeholder for the actual decoding logic\n    // which would involve parsing `i_instr` according to the RISC-V encoding\n    // and setting the output signals accordingly.\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 10, "code": "module e203_exu_nice (\n    input wire nice_i_xs_off,\n    input wire nice_i_valid,\n    output wire nice_i_ready,\n    input wire [E203_XLEN-1:0] nice_i_instr,\n    input wire [E203_XLEN-1:0] nice_i_rs1,\n    input wire [E203_XLEN-1:0] nice_i_rs2,\n    input wire [E203_ITAG_WIDTH-1:0] nice_i_itag,\n    output wire nice_o_longpipe,\n    output wire nice_o_valid,\n    input wire nice_o_ready,\n    output wire nice_o_itag_valid,\n    input wire nice_o_itag_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire clk,\n    input wire rst_n\n);\n\n// Internal signals\nwire fifo_push, fifo_pop;\nwire [E203_ITAG_WIDTH-1:0] fifo_data_in, fifo_data_out;\nwire fifo_full, fifo_empty, fifo_valid;\n\n// FIFO instantiation for instruction tags\nsirv_gnrl_fifo #(\n    .CUT_READY(1),\n    .MSKO(0),\n    .DP(4),\n    .DW(E203_ITAG_WIDTH)\n) itag_fifo (\n    .i_vld(fifo_push),\n    .i_rdy(!fifo_full),\n    .i_dat(fifo_data_in),\n    .o_vld(fifo_valid),\n    .o_rdy(fifo_pop),\n    .o_dat(fifo_data_out),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// Control logic for pushing to and popping from FIFO\nassign fifo_push = nice_i_valid && nice_i_ready && !nice_i_xs_off;\nassign fifo_data_in = nice_i_itag;\nassign fifo_pop = nice_rsp_multicyc_valid && nice_rsp_multicyc_ready;\n\n// Ready signals\nassign nice_i_ready = !fifo_full && nice_o_ready && !nice_i_xs_off;\nassign nice_rsp_multicyc_ready = !fifo_empty && nice_o_itag_ready;\n\n// Output valid signals\nassign nice_o_valid = nice_i_valid && nice_i_ready;\nassign nice_o_itag_valid = fifo_valid && nice_rsp_multicyc_valid;\n\n// Output data assignments\nassign nice_o_itag = fifo_data_out;\nassign nice_o_longpipe = !nice_i_xs_off;\n\n// Request to custom accelerator\nassign nice_req_valid = nice_i_valid && nice_i_ready && !nice_i_xs_off;\nassign nice_req_instr = nice_i_instr;\nassign nice_req_rs1 = nice_i_rs1;\nassign nice_req_rs2 = nice_i_rs2;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 11, "code": "module e203_exu_regfile #(\n  parameter E203_RFIDX_WIDTH = 5, // Width of the register file index\n  parameter E203_XLEN = 32        // Width of the register file data\n)(\n  input  wire                     clk,\n  input  wire                     rst_n,\n  input  wire [E203_RFIDX_WIDTH-1:0] read_src1_idx,\n  input  wire [E203_RFIDX_WIDTH-1:0] read_src2_idx,\n  output wire [E203_XLEN-1:0]     read_src1_dat,\n  output wire [E203_XLEN-1:0]     read_src2_dat,\n  input  wire                     wbck_dest_wen,\n  input  wire [E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n  input  wire [E203_XLEN-1:0]     wbck_dest_dat,\n  output wire [E203_XLEN-1:0]     x1_r,\n  input  wire                     test_mode\n);\n\n  // Local parameters for register file size\n  `ifdef E203_CFG_REGNUM_IS_32\n    localparam NUM_REGS = 32;\n  `elsif E203_CFG_REGNUM_IS_16\n    localparam NUM_REGS = 16;\n  `else\n    localparam NUM_REGS = 32; // Default to 32 if not specified\n  `endif\n\n  // Register array\n  reg [E203_XLEN-1:0] regs [0:NUM_REGS-1];\n\n  // Read logic\n  assign read_src1_dat = (read_src1_idx == 0) ? 0 : regs[read_src1_idx];\n  assign read_src2_dat = (read_src2_idx == 0) ? 0 : regs[read_src2_idx];\n\n  // Write logic\n  always @(posedge clk) begin\n    if (wbck_dest_wen && (wbck_dest_idx != 0)) begin\n      regs[wbck_dest_idx] <= wbck_dest_dat;\n    end\n  end\n\n  // Output for register x1\n  assign x1_r = regs[1];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 11, "code": "module e203_exu_nice (\n    input wire nice_i_xs_off,\n    input wire nice_i_valid,\n    output wire nice_i_ready,\n    input wire [E203_XLEN-1:0] nice_i_instr,\n    input wire [E203_XLEN-1:0] nice_i_rs1,\n    input wire [E203_XLEN-1:0] nice_i_rs2,\n    input wire [E203_ITAG_WIDTH-1:0] nice_i_itag,\n    output wire nice_o_longpipe,\n    output wire nice_o_valid,\n    input wire nice_o_ready,\n    output wire nice_o_itag_valid,\n    input wire nice_o_itag_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire clk,\n    input wire rst_n\n);\n\n// Internal signals\nwire fifo_i_vld, fifo_i_rdy, fifo_o_vld, fifo_o_rdy;\nwire [E203_ITAG_WIDTH-1:0] fifo_i_dat, fifo_o_dat;\n\n// Instantiate the general-purpose FIFO\nsirv_gnrl_fifo #(\n    .CUT_READY(1),\n    .MSKO(0),\n    .DP(4),\n    .DW(E203_ITAG_WIDTH)\n) itag_fifo (\n    .i_vld(fifo_i_vld),\n    .i_rdy(fifo_i_rdy),\n    .i_dat(fifo_i_dat),\n    .o_vld(fifo_o_vld),\n    .o_rdy(fifo_o_rdy),\n    .o_dat(fifo_o_dat),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// Control logic for NICE interface\nassign nice_i_ready = nice_o_ready && (nice_i_xs_off ? 1'b1 : nice_req_ready);\nassign nice_req_valid = nice_i_valid && !nice_i_xs_off && nice_i_ready;\nassign nice_req_instr = nice_i_instr;\nassign nice_req_rs1 = nice_i_rs1;\nassign nice_req_rs2 = nice_i_rs2;\n\n// FIFO control for instruction tags\nassign fifo_i_vld = nice_i_valid && nice_i_ready && !nice_i_xs_off;\nassign fifo_i_dat = nice_i_itag;\nassign nice_rsp_multicyc_ready = fifo_o_rdy;\n\n// Output control\nassign nice_o_valid = nice_i_valid && nice_i_ready;\nassign nice_o_longpipe = !nice_i_xs_off;\nassign nice_o_itag_valid = fifo_o_vld && nice_rsp_multicyc_valid;\nassign nice_o_itag = fifo_o_dat;\nassign fifo_o_rdy = nice_o_itag_ready && nice_o_itag_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 20, "code": "module e203_biu(\n    input wire clk,\n    input wire rst_n,\n    output wire biu_active,\n\n    // ICB Interface to LSU\n    input wire lsu_icb_cmd_valid,\n    output wire lsu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] lsu_icb_cmd_addr,\n    input wire lsu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] lsu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] lsu_icb_cmd_wmask,\n    input wire [1:0] lsu_icb_cmd_burst,\n    input wire [1:0] lsu_icb_cmd_beat,\n    input wire lsu_icb_cmd_lock,\n    input wire lsu_icb_cmd_excl,\n    input wire [1:0] lsu_icb_cmd_size,\n    output wire lsu_icb_rsp_valid,\n    input wire lsu_icb_rsp_ready,\n    output wire lsu_icb_rsp_err,\n    output wire lsu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] lsu_icb_rsp_rdata,\n\n    // ICB Interface to IFU\n    input wire ifu_icb_cmd_valid,\n    output wire ifu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] ifu_icb_cmd_addr,\n    input wire ifu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ifu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] ifu_icb_cmd_wmask,\n    input wire [1:0] ifu_icb_cmd_burst,\n    input wire [1:0] ifu_icb_cmd_beat,\n    input wire ifu_icb_cmd_lock,\n    input wire ifu_icb_cmd_excl,\n    input wire [1:0] ifu_icb_cmd_size,\n    output wire ifu_icb_rsp_valid,\n    input wire ifu_icb_rsp_ready,\n    output wire ifu_icb_rsp_err,\n    output wire ifu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] ifu_icb_rsp_rdata,\n\n    // ICB Interface to PPI\n    input wire ppi_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] ppi_region_indic,\n\n    // ICB Interface to CLINT\n    input wire clint_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] clint_region_indic,\n\n    // ICB Interface to PLIC\n    input wire plic_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] plic_region_indic,\n\n    // ICB Interface to FIO\n    input wire fio_icb_enable,\n    input wire [E203_ADDR_SIZE-1:0] fio_region_indic,\n\n    // ICB Interface to MEM\n    input wire mem_icb_enable\n);\n\n    // Internal signals for arbitration and command/response handling\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_valid;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_ready;\n    wire [BIU_ARBT_I_NUM*E203_ADDR_SIZE-1:0] arbt_icb_cmd_addr;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_read;\n    wire [BIU_ARBT_I_NUM*E203_XLEN-1:0] arbt_icb_cmd_wdata;\n    wire [BIU_ARBT_I_NUM*(E203_XLEN/8)-1:0] arbt_icb_cmd_wmask;\n    wire [BIU_ARBT_I_NUM*2-1:0] arbt_icb_cmd_burst;\n    wire [BIU_ARBT_I_NUM*2-1:0] arbt_icb_cmd_beat;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_lock;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_cmd_excl;\n    wire [BIU_ARBT_I_NUM*2-1:0] arbt_icb_cmd_size;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_valid;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_ready;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_err;\n    wire [BIU_ARBT_I_NUM-1:0] arbt_icb_rsp_excl_ok;\n    wire [BIU_ARBT_I_NUM*E203_XLEN-1:0] arbt_icb_rsp_rdata;\n\n    // Instantiate the ICB Arbiter\n    sirv_gnrl_icb_arbt #(\n        .AW(E203_ADDR_SIZE),\n        .DW(E203_XLEN),\n        .ARBT_NUM(BIU_ARBT_I_NUM),\n        .ARBT_PTR_W(BIU_ARBT_I_PTR_W),\n        .USR_W(1),\n        .ARBT_SCHEME(0),\n        .ALLOW_0CYCL_RSP(0),\n        .FIFO_OUTS_NUM(E203_BIU_OUTS_NUM),\n        .FIFO_CUT_READY(E203_BIU_CMD_CUT_READY)\n    ) u_icb_arbt (\n        .clk(clk),\n        .rst_n(rst_n),\n        .i_bus_icb_cmd_valid(arbt_icb_cmd_valid),\n        .i_bus_icb_cmd_ready(arbt_icb_cmd_ready),\n        .i_bus_icb_cmd_addr(arbt_icb_cmd_addr),\n        .i_bus_icb_cmd_read(arbt_icb_cmd_read),\n        .i_bus_icb_cmd_wdata(arbt_icb_cmd_wdata),\n        .i_bus_icb_cmd_wmask(arbt_icb_cmd_wmask),\n        .i_bus_icb_cmd_burst(arbt_icb_cmd_burst),\n        .i_bus_icb_cmd_beat(arbt_icb_cmd_beat),\n        .i_bus_icb_cmd_lock(arbt_icb_cmd_lock),\n        .i_bus_icb_cmd_excl(arbt_icb_cmd_excl),\n        .i_bus_icb_cmd_size(arbt_icb_cmd_size),\n        .i_bus_icb_rsp_valid(arbt_icb_rsp_valid),\n        .i_bus_icb_rsp_ready(arbt_icb_rsp_ready),\n        .i_bus_icb_rsp_err(arbt_icb_rsp_err),\n        .i_bus_icb_rsp_excl_ok(arbt_icb_rsp_excl_ok),\n        .i_bus_icb_rsp_rdata(arbt_icb_rsp_rdata)\n    );\n\n    // Logic to connect LSU and IFU to the arbiter\n    assign arbt_icb_cmd_valid = {ifu_icb_cmd_valid, lsu_icb_cmd_valid};\n    assign {ifu_icb_cmd_ready, lsu_icb_cmd_ready} = arbt_icb_cmd_ready;\n    assign arbt_icb_cmd_addr = {ifu_icb_cmd_addr, lsu_icb_cmd_addr};\n    assign arbt_icb_cmd_read = {ifu_icb_cmd_read, lsu_icb_cmd_read};\n    assign arbt_icb_cmd_wdata = {ifu_icb_cmd_wdata, lsu_icb_cmd_wdata};\n    assign arbt_icb_cmd_wmask = {ifu_icb_cmd_wmask, lsu_icb_cmd_wmask};\n    assign arbt_icb_cmd_burst = {ifu_icb_cmd_burst, lsu_icb_cmd_burst};\n    assign arbt_icb_cmd_beat = {ifu_icb_cmd_beat, lsu_icb_cmd_beat};\n    assign arbt_icb_cmd_lock = {ifu_icb_cmd_lock, lsu_icb_cmd_lock};\n    assign arbt_icb_cmd_excl = {ifu_icb_cmd_excl, lsu_icb_cmd_excl};\n    assign arbt_icb_cmd_size = {ifu_icb_cmd_size, lsu_icb_cmd_size};\n    assign {ifu_icb_rsp_valid, lsu_icb_rsp_valid} = arbt_icb_rsp_valid;\n    assign arbt_icb_rsp_ready = {ifu_icb_rsp_ready, lsu_icb_rsp_ready};\n    assign {ifu_icb_rsp_err, lsu_icb_rsp_err} = arbt_icb_rsp_err;\n    assign {ifu_icb_rsp_excl_ok, lsu_icb_rsp_excl_ok} = arbt_icb_rsp_excl_ok;\n    assign {ifu_icb_rsp_rdata, lsu_icb_rsp_rdata} = arbt_icb_rsp_rdata;\n\n    // Additional logic for handling PPI, CLINT, PLIC, FIO, and MEM interfaces\n    // would be implemented here.\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 4, "code": "module e203_exu_commit(\n    output commit_mret,\n    output commit_trap,\n    output core_wfi,\n    output nonflush_cmt_ena,\n    output excp_active,\n    input amo_wait,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input alu_cmt_i_valid,\n    output alu_cmt_i_ready,\n    input [E203_PC_SIZE-1:0] alu_cmt_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_cmt_i_instr,\n    input alu_cmt_i_pc_vld,\n    input [E203_XLEN-1:0] alu_cmt_i_imm,\n    input alu_cmt_i_rv32,\n    input alu_cmt_i_bjp,\n    input alu_cmt_i_wfi,\n    input alu_cmt_i_fencei,\n    input alu_cmt_i_mret,\n    input alu_cmt_i_dret,\n    input alu_cmt_i_ecall,\n    input alu_cmt_i_ebreak,\n    input alu_cmt_i_ifu_misalgn,\n    input alu_cmt_i_ifu_buserr,\n    input alu_cmt_i_ifu_ilegl,\n    input alu_cmt_i_bjp_prdt,\n    input alu_cmt_i_bjp_rslv,\n    input alu_cmt_i_misalgn,\n    input alu_cmt_i_ld,\n    input alu_cmt_i_stamo,\n    input alu_cmt_i_buserr,\n    input [E203_ADDR_SIZE-1:0] alu_cmt_i_badaddr,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output cmt_badaddr_ena,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output cmt_epc_ena,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_cause_ena,\n    output cmt_instret_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output cmt_mret_ena,\n    input [E203_PC_SIZE-1:0] csr_epc_r,\n    input [E203_PC_SIZE-1:0] csr_dpc_r,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output longp_excp_i_ready,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input longp_excp_i_insterr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc\n);\n    // Module implementation\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 9, "code": "module e203_exu_alu_dpath(\n    input wire alu_req_alu,\n    input wire alu_req_alu_add,\n    input wire alu_req_alu_sub,\n    input wire alu_req_alu_xor,\n    input wire alu_req_alu_sll,\n    input wire alu_req_alu_srl,\n    input wire alu_req_alu_sra,\n    input wire alu_req_alu_or,\n    input wire alu_req_alu_and,\n    input wire [E203_XLEN-1:0] alu_req_alu_op1,\n    input wire [E203_XLEN-1:0] alu_req_alu_op2,\n    input wire bjp_req_alu,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    input wire agu_req_alu,\n    input wire [E203_XLEN-1:0] agu_req_alu_op1,\n    input wire [E203_XLEN-1:0] agu_req_alu_op2,\n    input wire muldiv_req_alu,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    input wire muldiv_req_alu_add,\n    input wire muldiv_req_alu_sub,\n    input wire muldiv_sbf_0_ena,\n    input wire [32:0] muldiv_sbf_0_nxt,\n    input wire muldiv_sbf_1_ena,\n    input wire [32:0] muldiv_sbf_1_nxt,\n    input wire clk,\n    input wire rst_n,\n    output wire [E203_XLEN-1:0] alu_req_alu_res,\n    output wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    output wire bjp_req_alu_cmp_res,\n    output wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output wire [32:0] muldiv_sbf_0_r,\n    output wire [32:0] muldiv_sbf_1_r\n);\n\n    // Internal signals for ALU operations\n    wire [E203_XLEN-1:0] add_res;\n    wire [E203_XLEN-1:0] sub_res;\n    wire [E203_XLEN-1:0] and_res;\n    wire [E203_XLEN-1:0] or_res;\n    wire [E203_XLEN-1:0] xor_res;\n    wire [E203_XLEN-1:0] sll_res;\n    wire [E203_XLEN-1:0] srl_res;\n    wire [E203_XLEN-1:0] sra_res;\n\n    // ALU operations\n    assign add_res = alu_req_alu_op1 + alu_req_alu_op2;\n    assign sub_res = alu_req_alu_op1 - alu_req_alu_op2;\n    assign and_res = alu_req_alu_op1 & alu_req_alu_op2;\n    assign or_res  = alu_req_alu_op1 | alu_req_alu_op2;\n    assign xor_res = alu_req_alu_op1 ^ alu_req_alu_op2;\n    assign sll_res = alu_req_alu_op1 << alu_req_alu_op2[E203_XLEN-1:0];\n    assign srl_res = alu_req_alu_op1 >> alu_req_alu_op2[E203_XLEN-1:0];\n    assign sra_res = $signed(alu_req_alu_op1) >>> alu_req_alu_op2[E203_XLEN-1:0];\n\n    // Result multiplexing\n    assign alu_req_alu_res = ({E203_XLEN{alu_req_alu_add}} & add_res) |\n                             ({E203_XLEN{alu_req_alu_sub}} & sub_res) |\n                             ({E203_XLEN{alu_req_alu_and}} & and_res) |\n                             ({E203_XLEN{alu_req_alu_or}} & or_res) |\n                             ({E203_XLEN{alu_req_alu_xor}} & xor_res) |\n                             ({E203_XLEN{alu_req_alu_sll}} & sll_res) |\n                             ({E203_XLEN{alu_req_alu_srl}} & srl_res) |\n                             ({E203_XLEN{alu_req_alu_sra}} & sra_res);\n\n    // BJP operations\n    assign bjp_req_alu_add_res = bjp_req_alu_op1 + bjp_req_alu_op2;\n    assign bjp_req_alu_cmp_res = (bjp_req_alu_op1 == bjp_req_alu_op2);\n\n    // AGU operations\n    assign agu_req_alu_res = agu_req_alu_op1 + agu_req_alu_op2; // Example for AGU add operation\n\n    // MULDIV operations\n    assign muldiv_req_alu_res = (muldiv_req_alu_add ? muldiv_req_alu_op1 + muldiv_req_alu_op2 :\n                                muldiv_req_alu_sub ? muldiv_req_alu_op1 - muldiv_req_alu_op2 : 0);\n\n    // Shared buffer handling\n    sirv_gnrl_dffl #(.DW(33)) sbf_0_dffl (\n        .lden(muldiv_sbf_0_ena),\n        .dnxt(muldiv_sbf_0_nxt),\n        .qout(muldiv_sbf_0_r),\n        .clk(clk)\n    );\n\n    sirv_gnrl_dffl #(.DW(33)) sbf_1_dffl (\n        .lden(muldiv_sbf_1_ena),\n        .dnxt(muldiv_sbf_1_nxt),\n        .qout(muldiv_sbf_1_r),\n        .clk(clk)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 10, "code": "module e203_exu_oitf #(\n  parameter E203_ITAG_WIDTH = 4,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_PC_SIZE = 32,\n  parameter E203_OITF_DEPTH = 16\n)(\n  input clk,\n  input rst_n,\n\n  // Dispatch interface\n  input dis_ena,\n  output reg dis_ready,\n  output reg [E203_ITAG_WIDTH-1:0] dis_ptr,\n\n  // Retirement interface\n  input ret_ena,\n  output reg [E203_ITAG_WIDTH-1:0] ret_ptr,\n  output reg [E203_RFIDX_WIDTH-1:0] ret_rdidx,\n  output reg ret_rdwen,\n  output reg ret_rdfpu,\n  output reg [E203_PC_SIZE-1:0] ret_pc,\n\n  // Dispatch instruction details\n  input [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n  input disp_i_rdwen,\n  input disp_i_rdfpu,\n  input [E203_PC_SIZE-1:0] disp_i_pc,\n\n  // Dependency check outputs\n  output reg oitfrd_match_disprs1,\n  output reg oitfrd_match_disprs2,\n  output reg oitfrd_match_disprs3,\n  output reg oitfrd_match_disprd,\n  output reg oitf_empty\n);\n\n  // Internal OITF storage\n  reg [E203_RFIDX_WIDTH-1:0] rdidx [0:E203_OITF_DEPTH-1];\n  reg [E203_PC_SIZE-1:0] pc [0:E203_OITF_DEPTH-1];\n  reg rdwen [0:E203_OITF_DEPTH-1];\n  reg rdfpu [0:E203_OITF_DEPTH-1];\n\n  reg [E203_ITAG_WIDTH-1:0] head, tail;\n  reg full, empty;\n\n  // Initialize pointers and flags\n  initial begin\n    head = 0;\n    tail = 0;\n    full = 0;\n    empty = 1;\n    dis_ready = 1;\n  end\n\n  // Handle dispatch of new instructions\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      head <= 0;\n      tail <= 0;\n      full <= 0;\n      empty <= 1;\n      dis_ready <= 1;\n    end else begin\n      if (dis_ena && dis_ready) begin\n        rdidx[tail] <= disp_i_rdidx;\n        pc[tail] <= disp_i_pc;\n        rdwen[tail] <= disp_i_rdwen;\n        rdfpu[tail] <= disp_i_rdfpu;\n        tail <= tail + 1;\n        empty <= 0;\n        if (tail + 1 == head) begin\n          full <= 1;\n          dis_ready <= 0;\n        end\n      end\n\n      if (ret_ena && !empty) begin\n        ret_rdidx <= rdidx[head];\n        ret_pc <= pc[head];\n        ret_rdwen <= rdwen[head];\n        ret_rdfpu <= rdfpu[head];\n        head <= head + 1;\n        full <= 0;\n        if (head + 1 == tail) begin\n          empty <= 1;\n          dis_ready <= 1;\n        end\n      end\n    end\n  end\n\n  // Dependency checking logic\n  integer i;\n  always @(*) begin\n    oitfrd_match_disprs1 = 0;\n    oitfrd_match_disprs2 = 0;\n    oitfrd_match_disprs3 = 0;\n    oitfrd_match_disprd = 0;\n    for (i = head; i != tail; i = i + 1) begin\n      if (rdwen[i] && (rdidx[i] == disp_i_rdidx)) begin\n        oitfrd_match_disprd = 1;\n      end\n    end\n  end\n\n  // Update pointers for dispatch and retirement\n  always @(posedge clk) begin\n    dis_ptr <= tail;\n    ret_ptr <= head;\n    oitf_empty <= empty;\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 8, "code": "module e203_exu_wbck (\n    input wire alu_wbck_i_valid,\n    output wire alu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] alu_wbck_i_wdat,\n    input wire [E203_RFIDX_WIDTH-1:0] alu_wbck_i_rdidx,\n    input wire longp_wbck_i_valid,\n    output wire longp_wbck_i_ready,\n    input wire [E203_FLEN-1:0] longp_wbck_i_wdat,\n    input wire [4:0] longp_wbck_i_flags,\n    input wire [E203_RFIDX_WIDTH-1:0] longp_wbck_i_rdidx,\n    input wire longp_wbck_i_rdfpu,\n    output wire rf_wbck_o_ena,\n    output wire [E203_XLEN-1:0] rf_wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] rf_wbck_o_rdidx,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Arbitration logic\n    assign longp_wbck_i_ready = longp_wbck_i_valid;\n    assign alu_wbck_i_ready = !longp_wbck_i_valid & alu_wbck_i_valid;\n\n    // Write-back data selection\n    wire [E203_XLEN-1:0] selected_wdat = longp_wbck_i_valid ? longp_wbck_i_wdat : alu_wbck_i_wdat;\n    wire [E203_RFIDX_WIDTH-1:0] selected_rdidx = longp_wbck_i_valid ? longp_wbck_i_rdidx : alu_wbck_i_rdidx;\n    wire selected_rdfpu = longp_wbck_i_valid ? longp_wbck_i_rdfpu : 1'b0;\n\n    // Write-back enable\n    assign rf_wbck_o_ena = (alu_wbck_i_valid | longp_wbck_i_valid) & !selected_rdfpu;\n\n    // Output data and register index\n    assign rf_wbck_o_wdat = selected_wdat;\n    assign rf_wbck_o_rdidx = selected_rdidx;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 7, "code": "`include \"e203_defines.v\"\n\nmodule e203_itcm_ram #(\n  parameter FORCE_X2ZERO = 0,\n  parameter DP = `E203_ITCM_RAM_DP,\n  parameter DW = `E203_ITCM_RAM_DW,\n  parameter MW = `E203_ITCM_RAM_MW,\n  parameter AW = `E203_ITCM_RAM_AW\n)(\n  input wire sd,\n  input wire ds,\n  input wire ls,\n  input wire cs,\n  input wire we,\n  input wire [AW-1:0] addr,\n  input wire [MW-1:0] wem,\n  input wire [DW-1:0] din,\n  input wire rst_n,\n  input wire clk,\n  output wire [DW-1:0] dout\n);\n\n  // Instantiate the generic RAM module\n  sirv_gnrl_ram #(\n    .FORCE_X2ZERO(FORCE_X2ZERO),\n    .DP(DP),\n    .DW(DW),\n    .MW(MW),\n    .AW(AW)\n  ) u_sirv_gnrl_ram (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 8, "code": "`include \"e203_defines.v\"\n\nmodule e203_itcm_ram #(\n  parameter FORCE_X2ZERO = 0,\n  parameter DP = `E203_ITCM_RAM_DP,\n  parameter DW = `E203_ITCM_RAM_DW,\n  parameter MW = `E203_ITCM_RAM_MW,\n  parameter AW = `E203_ITCM_RAM_AW\n)(\n  input wire sd,\n  input wire ds,\n  input wire ls,\n  input wire cs,\n  input wire we,\n  input wire [AW-1:0] addr,\n  input wire [MW-1:0] wem,\n  input wire [DW-1:0] din,\n  input wire rst_n,\n  input wire clk,\n  output wire [DW-1:0] dout\n);\n\n  sirv_gnrl_ram #(\n    .FORCE_X2ZERO(FORCE_X2ZERO),\n    .DP(DP),\n    .DW(DW),\n    .MW(MW),\n    .AW(AW)\n  ) u_sirv_gnrl_ram (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 11, "code": "module e203_exu_oitf #(\n  parameter E203_ITAG_WIDTH = 4,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_PC_SIZE = 32,\n  parameter E203_OITF_DEPTH = 16\n)(\n  output wire dis_ready,\n  input wire dis_ena,\n  input wire ret_ena,\n  output wire [E203_ITAG_WIDTH-1:0] dis_ptr,\n  output wire [E203_ITAG_WIDTH-1:0] ret_ptr,\n  output wire [E203_RFIDX_WIDTH-1:0] ret_rdidx,\n  output wire ret_rdwen,\n  output wire ret_rdfpu,\n  output wire [E203_PC_SIZE-1:0] ret_pc,\n  input wire disp_i_rs1en,\n  input wire disp_i_rs2en,\n  input wire disp_i_rs3en,\n  input wire disp_i_rdwen,\n  input wire disp_i_rs1fpu,\n  input wire disp_i_rs2fpu,\n  input wire disp_i_rs3fpu,\n  input wire disp_i_rdfpu,\n  input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n  input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n  input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs3idx,\n  input wire [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n  input wire [E203_PC_SIZE-1:0] disp_i_pc,\n  output wire oitfrd_match_disprs1,\n  output wire oitfrd_match_disprs2,\n  output wire oitfrd_match_disprs3,\n  output wire oitfrd_match_disprd,\n  output wire oitf_empty,\n  input wire clk,\n  input wire rst_n\n);\n\n  reg [E203_RFIDX_WIDTH-1:0] rdidx [0:E203_OITF_DEPTH-1];\n  reg [E203_PC_SIZE-1:0] pc [0:E203_OITF_DEPTH-1];\n  reg [E203_OITF_DEPTH-1:0] rdwen;\n  reg [E203_OITF_DEPTH-1:0] rdfpu;\n  reg [E203_ITAG_WIDTH-1:0] head, tail;\n  wire full, empty;\n\n  assign full = ((head == tail) && (rdwen[head] != 0));\n  assign empty = ((head == tail) && (rdwen[head] == 0));\n  assign oitf_empty = empty;\n  assign dis_ready = !full;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      head <= 0;\n      tail <= 0;\n      rdwen <= 0;\n    end else begin\n      if (dis_ena && dis_ready) begin\n        rdidx[head] <= disp_i_rdidx;\n        pc[head] <= disp_i_pc;\n        rdwen[head] <= disp_i_rdwen;\n        rdfpu[head] <= disp_i_rdfpu;\n        head <= head + 1;\n      end\n      if (ret_ena && !empty) begin\n        rdwen[tail] <= 0;\n        tail <= tail + 1;\n      end\n    end\n  end\n\n  assign dis_ptr = head;\n  assign ret_ptr = tail;\n  assign ret_rdidx = rdidx[tail];\n  assign ret_rdwen = rdwen[tail];\n  assign ret_rdfpu = rdfpu[tail];\n  assign ret_pc = pc[tail];\n\n  integer i;\n  reg match_rs1, match_rs2, match_rs3, match_rd;\n  always @(*) begin\n    match_rs1 = 0;\n    match_rs2 = 0;\n    match_rs3 = 0;\n    match_rd = 0;\n    for (i = 0; i < E203_OITF_DEPTH; i = i + 1) begin\n      if (rdwen[i]) begin\n        if (disp_i_rs1en && (disp_i_rs1idx == rdidx[i]) && (disp_i_rs1fpu == rdfpu[i])) match_rs1 = 1;\n        if (disp_i_rs2en && (disp_i_rs2idx == rdidx[i]) && (disp_i_rs2fpu == rdfpu[i])) match_rs2 = 1;\n        if (disp_i_rs3en && (disp_i_rs3idx == rdidx[i]) && (disp_i_rs3fpu == rdfpu[i])) match_rs3 = 1;\n        if (disp_i_rdwen && (disp_i_rdidx == rdidx[i]) && (disp_i_rdfpu == rdfpu[i])) match_rd = 1;\n      end\n    end\n  end\n\n  assign oitfrd_match_disprs1 = match_rs1;\n  assign oitfrd_match_disprs2 = match_rs2;\n  assign oitfrd_match_disprs3 = match_rs3;\n  assign oitfrd_match_disprd = match_rd;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 9, "code": "module e203_itcm_ram #(\n  parameter FORCE_X2ZERO = 0,\n  parameter DP = `E203_ITCM_RAM_DP,\n  parameter DW = `E203_ITCM_RAM_DW,\n  parameter MW = `E203_ITCM_RAM_MW,\n  parameter AW = `E203_ITCM_RAM_AW\n)(\n  input wire sd,\n  input wire ds,\n  input wire ls,\n  input wire cs,\n  input wire we,\n  input wire [AW-1:0] addr,\n  input wire [MW-1:0] wem,\n  input wire [DW-1:0] din,\n  input wire rst_n,\n  input wire clk,\n  output wire [DW-1:0] dout\n);\n\n  // Instantiate the generic RAM module\n  sirv_gnrl_ram #(\n    .FORCE_X2ZERO(FORCE_X2ZERO),\n    .DP(DP),\n    .DW(DW),\n    .MW(MW),\n    .AW(AW)\n  ) u_sirv_gnrl_ram (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 10, "code": "`include \"e203_defines.v\"\n\nmodule e203_itcm_ram #(\n  parameter FORCE_X2ZERO = 0,\n  parameter DP = `E203_ITCM_RAM_DP,\n  parameter DW = `E203_ITCM_RAM_DW,\n  parameter MW = `E203_ITCM_RAM_MW,\n  parameter AW = `E203_ITCM_RAM_AW\n)(\n  input wire sd,\n  input wire ds,\n  input wire ls,\n  input wire cs,\n  input wire we,\n  input wire [AW-1:0] addr,\n  input wire [MW-1:0] wem,\n  input wire [DW-1:0] din,\n  input wire rst_n,\n  input wire clk,\n  output wire [DW-1:0] dout\n);\n\n  sirv_gnrl_ram #(\n    .FORCE_X2ZERO(FORCE_X2ZERO),\n    .DP(DP),\n    .DW(DW),\n    .MW(MW),\n    .AW(AW)\n  ) u_sirv_gnrl_ram (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 12, "code": "module e203_srams (\n  input wire itcm_ram_sd,\n  input wire itcm_ram_ds,\n  input wire itcm_ram_ls,\n  input wire itcm_ram_cs,\n  input wire itcm_ram_we,\n  input wire [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n  input wire [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n  input wire [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n  output wire [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n  input wire clk_itcm_ram,\n  input wire rst_itcm,\n\n  input wire dtcm_ram_sd,\n  input wire dtcm_ram_ds,\n  input wire dtcm_ram_ls,\n  input wire dtcm_ram_cs,\n  input wire dtcm_ram_we,\n  input wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n  input wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n  input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n  output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n  input wire clk_dtcm_ram,\n  input wire rst_dtcm\n);\n\n`ifdef E203_HAS_ITCM\n  e203_itcm_ram itcm (\n    .sd(itcm_ram_sd),\n    .ds(itcm_ram_ds),\n    .ls(itcm_ram_ls),\n    .cs(itcm_ram_cs),\n    .we(itcm_ram_we),\n    .addr(itcm_ram_addr),\n    .wem(itcm_ram_wem),\n    .din(itcm_ram_din),\n    .dout(itcm_ram_dout),\n    .clk(clk_itcm_ram),\n    .rst_n(rst_itcm)\n  );\n`endif\n\n`ifdef E203_HAS_DTCM\n  e203_dtcm_ram dtcm (\n    .sd(dtcm_ram_sd),\n    .ds(dtcm_ram_ds),\n    .ls(dtcm_ram_ls),\n    .cs(dtcm_ram_cs),\n    .we(dtcm_ram_we),\n    .addr(dtcm_ram_addr),\n    .wem(dtcm_ram_wem),\n    .din(dtcm_ram_din),\n    .dout(dtcm_ram_dout),\n    .clk(clk_dtcm_ram),\n    .rst_n(rst_dtcm)\n  );\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 13, "code": "module e203_srams #(\n  parameter E203_ITCM_RAM_AW = 12,\n  parameter E203_ITCM_RAM_MW = 4,\n  parameter E203_ITCM_RAM_DW = 32,\n  parameter E203_DTCM_RAM_AW = 12,\n  parameter E203_DTCM_RAM_MW = 4,\n  parameter E203_DTCM_RAM_DW = 32\n)(\n  input  wire itcm_ram_sd,\n  input  wire itcm_ram_ds,\n  input  wire itcm_ram_ls,\n  input  wire itcm_ram_cs,\n  input  wire itcm_ram_we,\n  input  wire [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n  input  wire [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n  input  wire [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n  output wire [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n  input  wire clk_itcm_ram,\n  input  wire rst_itcm,\n\n  input  wire dtcm_ram_sd,\n  input  wire dtcm_ram_ds,\n  input  wire dtcm_ram_ls,\n  input  wire dtcm_ram_cs,\n  input  wire dtcm_ram_we,\n  input  wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n  input  wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n  input  wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n  output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n  input  wire clk_dtcm_ram,\n  input  wire rst_dtcm\n);\n\n`ifdef E203_HAS_ITCM\n  itcm_ram #(\n    .AW(E203_ITCM_RAM_AW),\n    .MW(E203_ITCM_RAM_MW),\n    .DW(E203_ITCM_RAM_DW)\n  ) u_itcm_ram (\n    .sd(itcm_ram_sd),\n    .ds(itcm_ram_ds),\n    .ls(itcm_ram_ls),\n    .cs(itcm_ram_cs),\n    .we(itcm_ram_we),\n    .addr(itcm_ram_addr),\n    .wem(itcm_ram_wem),\n    .din(itcm_ram_din),\n    .dout(itcm_ram_dout),\n    .clk(clk_itcm_ram),\n    .rst_n(rst_itcm)\n  );\n`endif\n\n`ifdef E203_HAS_DTCM\n  dtcm_ram #(\n    .AW(E203_DTCM_RAM_AW),\n    .MW(E203_DTCM_RAM_MW),\n    .DW(E203_DTCM_RAM_DW)\n  ) u_dtcm_ram (\n    .sd(dtcm_ram_sd),\n    .ds(dtcm_ram_ds),\n    .ls(dtcm_ram_ls),\n    .cs(dtcm_ram_cs),\n    .we(dtcm_ram_we),\n    .addr(dtcm_ram_addr),\n    .wem(dtcm_ram_wem),\n    .din(dtcm_ram_din),\n    .dout(dtcm_ram_dout),\n    .clk(clk_dtcm_ram),\n    .rst_n(rst_dtcm)\n  );\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 5, "code": "module e203_exu_commit(\n    output commit_mret,\n    output commit_trap,\n    output core_wfi,\n    output nonflush_cmt_ena,\n    output excp_active,\n    input amo_wait,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input alu_cmt_i_valid,\n    output alu_cmt_i_ready,\n    input [E203_PC_SIZE-1:0] alu_cmt_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_cmt_i_instr,\n    input alu_cmt_i_pc_vld,\n    input [E203_XLEN-1:0] alu_cmt_i_imm,\n    input alu_cmt_i_rv32,\n    input alu_cmt_i_bjp,\n    input alu_cmt_i_wfi,\n    input alu_cmt_i_fencei,\n    input alu_cmt_i_mret,\n    input alu_cmt_i_dret,\n    input alu_cmt_i_ecall,\n    input alu_cmt_i_ebreak,\n    input alu_cmt_i_ifu_misalgn,\n    input alu_cmt_i_ifu_buserr,\n    input alu_cmt_i_ifu_ilegl,\n    input alu_cmt_i_bjp_prdt,\n    input alu_cmt_i_bjp_rslv,\n    input alu_cmt_i_misalgn,\n    input alu_cmt_i_ld,\n    input alu_cmt_i_stamo,\n    input alu_cmt_i_buserr,\n    input [E203_ADDR_SIZE-1:0] alu_cmt_i_badaddr,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output cmt_badaddr_ena,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output cmt_epc_ena,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_cause_ena,\n    output cmt_instret_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output cmt_mret_ena,\n    input [E203_PC_SIZE-1:0] csr_epc_r,\n    input [E203_PC_SIZE-1:0] csr_dpc_r,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output longp_excp_i_ready,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input longp_excp_i_insterr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc\n);\n    // Module implementation\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 9, "code": "module e203_irq_sync (\n    input wire clk,\n    input wire rst_n,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire dbg_irq_a,\n    output wire ext_irq_r,\n    output wire sft_irq_r,\n    output wire tmr_irq_r,\n    output wire dbg_irq_r\n);\n\n// Synchronization instances for each interrupt signal\nsirv_gnrl_sync #(\n    .DP(2),\n    .DW(1)\n) u_ext_sync (\n    .clk(clk),\n    .rst_n(rst_n),\n    .din_a(ext_irq_a),\n    .dout(ext_irq_r)\n);\n\nsirv_gnrl_sync #(\n    .DP(2),\n    .DW(1)\n) u_sft_sync (\n    .clk(clk),\n    .rst_n(rst_n),\n    .din_a(sft_irq_a),\n    .dout(sft_irq_r)\n);\n\nsirv_gnrl_sync #(\n    .DP(2),\n    .DW(1)\n) u_tmr_sync (\n    .clk(clk),\n    .rst_n(rst_n),\n    .din_a(tmr_irq_a),\n    .dout(tmr_irq_r)\n);\n\nsirv_gnrl_sync #(\n    .DP(2),\n    .DW(1)\n) u_dbg_sync (\n    .clk(clk),\n    .rst_n(rst_n),\n    .din_a(dbg_irq_a),\n    .dout(dbg_irq_r)\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 10, "code": "module e203_exu_alu_muldiv(\n    input wire mdv_nob2b,\n    input wire muldiv_i_valid,\n    output wire muldiv_i_ready,\n    input wire [E203_XLEN-1:0] muldiv_i_rs1,\n    input wire [E203_XLEN-1:0] muldiv_i_rs2,\n    input wire [E203_XLEN-1:0] muldiv_i_imm,\n    input wire [E203_DECINFO_MULDIV_WIDTH-1:0] muldiv_i_info,\n    input wire [E203_ITAG_WIDTH-1:0] muldiv_i_itag,\n    output wire muldiv_i_longpipe,\n    input wire flush_pulse,\n    output wire muldiv_o_valid,\n    input wire muldiv_o_ready,\n    output wire [E203_XLEN-1:0] muldiv_o_wbck_wdat,\n    output wire muldiv_o_wbck_err,\n    output wire [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    output wire [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    output wire muldiv_req_alu_add,\n    output wire muldiv_req_alu_sub,\n    input wire [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output wire muldiv_sbf_0_ena,\n    output wire [32:0] muldiv_sbf_0_nxt,\n    input wire [32:0] muldiv_sbf_0_r,\n    output wire muldiv_sbf_1_ena,\n    output wire [32:0] muldiv_sbf_1_nxt,\n    input wire [32:0] muldiv_sbf_1_r,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Internal signals\n    reg [4:0] state;\n    reg [4:0] next_state;\n\n    // State definitions\n    localparam MULDIV_STATE_0TH = 5'd0;\n    localparam MULDIV_STATE_EXEC = 5'd1;\n    localparam MULDIV_STATE_REMD_CHCK = 5'd2;\n    localparam MULDIV_STATE_QUOT_CORR = 5'd3;\n    localparam MULDIV_STATE_REMD_CORR = 5'd4;\n\n    // FSM for handling multiplier and divider operations\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= MULDIV_STATE_0TH;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            MULDIV_STATE_0TH: begin\n                if (muldiv_i_valid && !flush_pulse)\n                    next_state = MULDIV_STATE_EXEC;\n                else\n                    next_state = MULDIV_STATE_0TH;\n            end\n            MULDIV_STATE_EXEC: begin\n                if (flush_pulse)\n                    next_state = MULDIV_STATE_0TH;\n                else if (/* condition for completing execution */)\n                    next_state = MULDIV_STATE_REMD_CHCK;\n                else\n                    next_state = MULDIV_STATE_EXEC;\n            end\n            MULDIV_STATE_REMD_CHCK: begin\n                if (flush_pulse)\n                    next_state = MULDIV_STATE_0TH;\n                else if (/* condition for needing correction */)\n                    next_state = MULDIV_STATE_QUOT_CORR;\n                else\n                    next_state = MULDIV_STATE_0TH;\n            end\n            MULDIV_STATE_QUOT_CORR: begin\n                next_state = MULDIV_STATE_REMD_CORR;\n            end\n            MULDIV_STATE_REMD_CORR: begin\n                if (flush_pulse)\n                    next_state = MULDIV_STATE_0TH;\n                else\n                    next_state = MULDIV_STATE_0TH;\n            end\n            default: next_state = MULDIV_STATE_0TH;\n        endcase\n    end\n\n    // Output logic and other internal logic\n    assign muldiv_i_ready = (state == MULDIV_STATE_0TH);\n    assign muldiv_o_valid = (state == MULDIV_STATE_REMD_CORR);\n    assign muldiv_o_wbck_wdat = muldiv_req_alu_res; // Example assignment\n    assign muldiv_o_wbck_err = 0;\n\n    // More logic as required for the module\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 4, "code": "module e203_ifu_ift2icb (\n    input wire itcm_nohold,\n    input wire ifu_req_valid,\n    input wire [PC_SIZE-1:0] ifu_req_pc,\n    input wire ifu_req_seq,\n    input wire ifu_req_seq_rv32,\n    input wire [PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_ready,\n    input wire clk,\n    input wire rst_n,\n\n    output wire ifu_req_ready,\n    output wire ifu_rsp_valid,\n    output wire ifu_rsp_err,\n    output wire [31:0] ifu_rsp_instr,\n\n    output wire ifu2itcm_icb_cmd_valid,\n    input wire ifu2itcm_icb_cmd_ready,\n    output wire [ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_rsp_valid,\n    output wire ifu2itcm_icb_rsp_ready,\n    input wire ifu2itcm_icb_rsp_err,\n    input wire [ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n\n    output wire ifu2biu_icb_cmd_valid,\n    input wire ifu2biu_icb_cmd_ready,\n    output wire [ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input wire ifu2biu_icb_rsp_valid,\n    output wire ifu2biu_icb_rsp_ready,\n    input wire ifu2biu_icb_rsp_err,\n    input wire [SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata\n);\n\n    // State machine states\n    localparam ICB_STATE_IDLE = 2'b00;\n    localparam ICB_STATE_1ST = 2'b01;\n    localparam ICB_STATE_WAIT2ND = 2'b10;\n    localparam ICB_STATE_2ND = 2'b11;\n\n    reg [1:0] icb_state, icb_state_nxt;\n\n    // State transition logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            icb_state <= ICB_STATE_IDLE;\n        end else begin\n            if (icb_state_ena) begin\n                icb_state <= icb_state_nxt;\n            end\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        icb_state_nxt = icb_state; // Default to hold current state\n        case (icb_state)\n            ICB_STATE_IDLE: begin\n                if (ifu_req_valid && ifu_req_ready) begin\n                    icb_state_nxt = ICB_STATE_1ST;\n                end\n            end\n            ICB_STATE_1ST: begin\n                if (ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid) begin\n                    icb_state_nxt = ifu_req_valid ? ICB_STATE_1ST : ICB_STATE_IDLE;\n                end\n            end\n            ICB_STATE_WAIT2ND: begin\n                if (ifu2itcm_icb_cmd_ready || ifu2biu_icb_cmd_ready) begin\n                    icb_state_nxt = ICB_STATE_2ND;\n                end\n            end\n            ICB_STATE_2ND: begin\n                if (ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid) begin\n                    icb_state_nxt = ifu_req_valid ? ICB_STATE_1ST : ICB_STATE_IDLE;\n                end\n            end\n        endcase\n    end\n\n    // Output logic\n    assign ifu_req_ready = (icb_state == ICB_STATE_IDLE);\n    assign ifu_rsp_valid = (icb_state == ICB_STATE_1ST) && (ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid);\n    assign ifu_rsp_err = ifu2itcm_icb_rsp_err || ifu2biu_icb_rsp_err;\n    assign ifu_rsp_instr = (icb_state == ICB_STATE_1ST) ? ifu2itcm_icb_rsp_rdata : ifu2biu_icb_rsp_rdata;\n\n    // ICB command logic\n    assign ifu2itcm_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && (ifu_req_pc < `ITCM_ADDR_LIMIT);\n    assign ifu2itcm_icb_cmd_addr = ifu_req_pc;\n    assign ifu2itcm_icb_rsp_ready = (icb_state == ICB_STATE_1ST);\n\n    assign ifu2biu_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && (ifu_req_pc >= `ITCM_ADDR_LIMIT);\n    assign ifu2biu_icb_cmd_addr = ifu_req_pc;\n    assign ifu2biu_icb_rsp_ready = (icb_state == ICB_STATE_1ST);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 9, "code": "module e203_exu_wbck (\n    input wire alu_wbck_i_valid,\n    output wire alu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] alu_wbck_i_wdat,\n    input wire [E203_RFIDX_WIDTH-1:0] alu_wbck_i_rdidx,\n    input wire longp_wbck_i_valid,\n    output wire longp_wbck_i_ready,\n    input wire [E203_FLEN-1:0] longp_wbck_i_wdat,\n    input wire [4:0] longp_wbck_i_flags,\n    input wire [E203_RFIDX_WIDTH-1:0] longp_wbck_i_rdidx,\n    input wire longp_wbck_i_rdfpu,\n    output wire rf_wbck_o_ena,\n    output wire [E203_XLEN-1:0] rf_wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] rf_wbck_o_rdidx,\n    input wire clk,\n    input wire rst_n\n);\n\n// Arbitration logic\nassign longp_wbck_i_ready = longp_wbck_i_valid;\nassign alu_wbck_i_ready = !longp_wbck_i_valid && alu_wbck_i_valid;\n\n// Selecting write-back data and index\nwire [E203_XLEN-1:0] selected_wdat = longp_wbck_i_valid ? longp_wbck_i_wdat : alu_wbck_i_wdat;\nwire [E203_RFIDX_WIDTH-1:0] selected_rdidx = longp_wbck_i_valid ? longp_wbck_i_rdidx : alu_wbck_i_rdidx;\nwire selected_rdfpu = longp_wbck_i_valid ? longp_wbck_i_rdfpu : 1'b0;\n\n// Write-back enable logic\nassign rf_wbck_o_ena = (longp_wbck_i_valid || alu_wbck_i_valid) && !selected_rdfpu;\n\n// Output assignments\nassign rf_wbck_o_wdat = selected_wdat;\nassign rf_wbck_o_rdidx = selected_rdidx;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 17, "code": "module e203_dtcm_ram (\n    input wire sd,\n    input wire ds,\n    input wire ls,\n    input wire cs,\n    input wire we,\n    input wire [E203_DTCM_RAM_AW-1:0] addr,\n    input wire [E203_DTCM_RAM_MW-1:0] wem,\n    input wire [E203_DTCM_RAM_DW-1:0] din,\n    input wire rst_n,\n    input wire clk,\n    output wire [E203_DTCM_RAM_DW-1:0] dout\n);\n\n    sirv_gnrl_ram #(\n        .DP(E203_DTCM_RAM_DP),\n        .DW(E203_DTCM_RAM_DW),\n        .FORCE_X2ZERO(1),\n        .MW(E203_DTCM_RAM_MW),\n        .AW(E203_DTCM_RAM_AW)\n    ) u_203_dtcm_gnrl_ram (\n        .sd(sd),\n        .ds(ds),\n        .ls(ls),\n        .rst_n(rst_n),\n        .clk(clk),\n        .cs(cs),\n        .we(we),\n        .addr(addr),\n        .din(din),\n        .wem(wem),\n        .dout(dout)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 9, "code": "module e203_exu_branchslv(\n    input wire cmt_i_valid,\n    output wire cmt_i_ready,\n    input wire cmt_i_rv32,\n    input wire cmt_i_dret,\n    input wire cmt_i_mret,\n    input wire cmt_i_fencei,\n    input wire cmt_i_bjp,\n    input wire cmt_i_bjp_prdt,\n    input wire cmt_i_bjp_rslv,\n    input wire [E203_PC_SIZE-1:0] cmt_i_pc,\n    input wire [E203_XLEN-1:0] cmt_i_imm,\n    input wire [E203_PC_SIZE-1:0] csr_epc_r,\n    input wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    input wire nonalu_excpirq_flush_req_raw,\n    input wire brchmis_flush_ack,\n    output wire brchmis_flush_req,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op1,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op2,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_pc,\n    output wire cmt_mret_ena,\n    output wire cmt_dret_ena,\n    output wire cmt_fencei_ena,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Determine if a flush is needed\n    wire flush_needed = (cmt_i_bjp & (cmt_i_bjp_prdt != cmt_i_bjp_rslv)) | cmt_i_fencei | cmt_i_mret | cmt_i_dret;\n\n    // Calculate flush address\n    wire [E203_PC_SIZE-1:0] next_pc = cmt_i_rv32 ? (cmt_i_pc + 32'd4) : (cmt_i_pc + 32'd2);\n    wire [E203_PC_SIZE-1:0] branch_target = cmt_i_pc + cmt_i_imm[E203_PC_SIZE-1:0];\n\n    assign brchmis_flush_add_op1 = cmt_i_pc;\n    assign brchmis_flush_add_op2 = cmt_i_imm;\n\n    // Select flush PC based on the type of flush\n    always @(*) begin\n        if (cmt_i_fencei | (cmt_i_bjp & cmt_i_bjp_prdt & ~cmt_i_bjp_rslv)) begin\n            brchmis_flush_pc = next_pc;\n        end else if (cmt_i_bjp & ~cmt_i_bjp_prdt & cmt_i_bjp_rslv) begin\n            brchmis_flush_pc = branch_target;\n        end else if (cmt_i_dret) begin\n            brchmis_flush_pc = csr_dpc_r;\n        end else begin\n            brchmis_flush_pc = csr_epc_r;\n        end\n    end\n\n    // Flush request logic\n    assign brchmis_flush_req = flush_needed & cmt_i_valid & ~nonalu_excpirq_flush_req_raw;\n\n    // Ready signal logic\n    assign cmt_i_ready = ~flush_needed & ~nonalu_excpirq_flush_req_raw & brchmis_flush_ack;\n\n    // Special control signals\n    assign cmt_mret_ena = cmt_i_mret & flush_needed;\n    assign cmt_dret_ena = cmt_i_dret & flush_needed;\n    assign cmt_fencei_ena = cmt_i_fencei & flush_needed;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 2, "code": "module e203_ifu_litebpu #(\n  parameter E203_PC_SIZE = 32,\n  parameter E203_XLEN = 32,\n  parameter E203_RFIDX_WIDTH = 5\n)(\n  input clk,\n  input rst_n,\n  input [E203_PC_SIZE-1:0] pc,\n  input dec_jal,\n  input dec_jalr,\n  input dec_bxx,\n  input [E203_XLEN-1:0] dec_bjp_imm,\n  input [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  input oitf_empty,\n  input ir_empty,\n  input ir_rs1en,\n  input jalr_rs1idx_cam_irrdidx,\n  input dec_i_valid,\n  input ir_valid_clr,\n  input [E203_XLEN-1:0] rf2bpu_x1,\n  input [E203_XLEN-1:0] rf2bpu_rs1,\n  output reg prdt_taken,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op1,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op2,\n  output reg bpu_wait,\n  output reg bpu2rf_rs1_ena\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      prdt_taken <= 1'b0;\n      prdt_pc_add_op1 <= {E203_PC_SIZE{1'b0}};\n      prdt_pc_add_op2 <= {E203_PC_SIZE{1'b0}};\n      bpu_wait <= 1'b0;\n      bpu2rf_rs1_ena <= 1'b0;\n    end else begin\n      // Default assignments\n      prdt_taken <= 1'b0;\n      prdt_pc_add_op1 <= pc;\n      prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n      bpu_wait <= 1'b0;\n      bpu2rf_rs1_ena <= 1'b0;\n\n      // Handle JAL instruction\n      if (dec_jal) begin\n        prdt_taken <= 1'b1;\n        prdt_pc_add_op1 <= pc;\n        prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n      end\n\n      // Handle JALR instruction\n      if (dec_jalr) begin\n        prdt_taken <= 1'b1;\n        case (dec_jalr_rs1idx)\n          5'd0: prdt_pc_add_op1 <= {E203_PC_SIZE{1'b0}};\n          5'd1: begin\n            prdt_pc_add_op1 <= rf2bpu_x1;\n            if (!oitf_empty || jalr_rs1idx_cam_irrdidx) begin\n              bpu_wait <= 1'b1;\n            end\n          end\n          default: begin\n            prdt_pc_add_op1 <= rf2bpu_rs1;\n            if (!ir_empty && ir_rs1en) begin\n              bpu_wait <= 1'b1;\n              bpu2rf_rs1_ena <= 1'b1;\n            end\n          end\n        endcase\n      end\n\n      // Handle conditional branches\n      if (dec_bxx) begin\n        if (dec_bjp_imm[E203_XLEN-1]) begin // Check if the immediate is negative\n          prdt_taken <= 1'b1;\n        end else begin\n          prdt_taken <= 1'b0;\n        end\n      end\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 8, "code": "module e203_ifu_minidec #(\n  parameter E203_INSTR_SIZE = 32,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_XLEN = 32\n)(\n  input [E203_INSTR_SIZE-1:0] instr,\n  output reg dec_rs1en,\n  output reg dec_rs2en,\n  output reg [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n  output reg [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n  output reg dec_mulhsu,\n  output reg dec_mul,\n  output reg dec_div,\n  output reg dec_rem,\n  output reg dec_divu,\n  output reg dec_remu,\n  output reg dec_rv32,\n  output reg dec_bjp,\n  output reg dec_jal,\n  output reg dec_jalr,\n  output reg dec_bxx,\n  output reg [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  output reg [E203_XLEN-1:0] dec_bjp_imm\n);\n\n  // Internal signals for decoding\n  wire [6:0] opcode = instr[6:0];\n  wire [2:0] funct3 = instr[14:12];\n  wire [6:0] funct7 = instr[31:25];\n\n  always @(*) begin\n    // Default assignments\n    dec_rs1en = 1'b0;\n    dec_rs2en = 1'b0;\n    dec_rs1idx = instr[19:15];\n    dec_rs2idx = instr[24:20];\n    dec_mulhsu = 1'b0;\n    dec_mul = 1'b0;\n    dec_div = 1'b0;\n    dec_rem = 1'b0;\n    dec_divu = 1'b0;\n    dec_remu = 1'b0;\n    dec_rv32 = 1'b1; // Assuming RV32 as default\n    dec_bjp = 1'b0;\n    dec_jal = 1'b0;\n    dec_jalr = 1'b0;\n    dec_bxx = 1'b0;\n    dec_jalr_rs1idx = instr[19:15];\n    dec_bjp_imm = {E203_XLEN{1'b0}};\n\n    case (opcode)\n      7'b0110011: begin // R-type\n        dec_rs1en = 1'b1;\n        dec_rs2en = 1'b1;\n        case (funct3)\n          3'b000: begin\n            if (funct7 == 7'b0000001) begin\n              dec_mul = 1'b1; // MUL\n            end\n          end\n          3'b001: begin\n            if (funct7 == 7'b0000001) begin\n              dec_mulhsu = 1'b1; // MULHSU\n            end\n          end\n          3'b100: begin\n            if (funct7 == 7'b0000001) begin\n              dec_div = 1'b1; // DIV\n            end\n          end\n          3'b110: begin\n            if (funct7 == 7'b0000001) begin\n              dec_rem = 1'b1; // REM\n            end\n          end\n        endcase\n      end\n      7'b1101111: begin // JAL\n        dec_jal = 1'b1;\n        dec_bjp = 1'b1;\n        dec_bjp_imm = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0};\n      end\n      7'b1100111: begin // JALR\n        dec_jalr = 1'b1;\n        dec_bjp = 1'b1;\n        dec_jalr_rs1idx = instr[19:15];\n        dec_bjp_imm = {{20{instr[31]}}, instr[31:20]};\n      end\n      7'b1100011: begin // Branches\n        dec_bxx = 1'b1;\n        dec_bjp = 1'b1;\n        dec_bjp_imm = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};\n      end\n    endcase\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 13, "code": "module e203_reset_ctrl #(\n    parameter MASTER = 1,\n    parameter RST_SYNC_LEVEL = `E203_ASYNC_FF_LEVELS\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    output wire rst_core,\n    output wire rst_itcm,\n    output wire rst_dtcm,\n    output wire rst_aon\n);\n\nreg [RST_SYNC_LEVEL-1:0] rst_sync_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        rst_sync_reg <= {RST_SYNC_LEVEL{1'b1}};\n    end else begin\n        if (test_mode) begin\n            rst_sync_reg <= {RST_SYNC_LEVEL{rst_n}};\n        end else begin\n            rst_sync_reg <= {rst_sync_reg[RST_SYNC_LEVEL-2:0], 1'b1};\n        end\n    end\nend\n\nassign rst_core = (MASTER == 1) ? rst_sync_reg[RST_SYNC_LEVEL-1] : rst_n;\nassign rst_itcm = (MASTER == 1) ? rst_sync_reg[RST_SYNC_LEVEL-1] : rst_n;\nassign rst_dtcm = (MASTER == 1) ? rst_sync_reg[RST_SYNC_LEVEL-1] : rst_n;\nassign rst_aon = (MASTER == 1) ? rst_sync_reg[RST_SYNC_LEVEL-1] : rst_n;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 9, "code": "module e203_exu_alu_csrctrl (\n    input wire csr_i_valid,\n    output reg csr_i_ready,\n    input wire [E203_XLEN-1:0] csr_i_rs1,\n    input wire [E203_DECINFO_CSR_WIDTH-1:0] csr_i_info,\n    input wire csr_i_rdwen,\n    output reg csr_ena,\n    output reg csr_wr_en,\n    output reg csr_rd_en,\n    output reg [11:0] csr_idx,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output reg [E203_XLEN-1:0] wbck_csr_dat,\n    output reg csr_o_valid,\n    input wire csr_o_ready,\n    output reg [E203_XLEN-1:0] csr_o_wbck_wdat,\n    output reg csr_o_wbck_err,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Decode CSR instruction information\n    wire csrrw = csr_i_info[E203_DECINFO_CSR_CSRRW];\n    wire csrrs = csr_i_info[E203_DECINFO_CSR_CSRRS];\n    wire csrrc = csr_i_info[E203_DECINFO_CSR_CSRRC];\n    wire rs1imm = csr_i_info[E203_DECINFO_CSR_RS1IMM];\n    wire rs1is0 = csr_i_info[E203_DECINFO_CSR_RS1IS0];\n    wire [4:0] zimm = csr_i_info[E203_DECINFO_CSR_ZIMMM];\n    wire [11:0] csr_idx_info = csr_i_info[E203_DECINFO_CSR_CSRIDX];\n\n    // Prepare Operand 1\n    wire [E203_XLEN-1:0] csr_op1 = rs1imm ? { {(E203_XLEN-5){1'b0}}, zimm } : csr_i_rs1;\n\n    // CSR Read and Write Enable Logic\n    always @(*) begin\n        csr_rd_en = csr_i_valid && ((csrrw && csr_i_rdwen) || csrrs || csrrc);\n        csr_wr_en = csr_i_valid && (csrrw || (csrrs && !rs1is0) || (csrrc && !rs1is0));\n        csr_idx = csr_idx_info;\n        csr_ena = csr_o_valid && csr_o_ready; // Assuming csr_o_valid means CSR operation is ongoing\n    end\n\n    // Write-back Data Preparation\n    always @(*) begin\n        case ({csrrw, csrrs, csrrc})\n            3'b100: wbck_csr_dat = csr_op1; // CSRRW\n            3'b010: wbck_csr_dat = csr_op1 | read_csr_dat; // CSRRS\n            3'b001: wbck_csr_dat = ~csr_op1 & read_csr_dat; // CSRRC\n            default: wbck_csr_dat = {E203_XLEN{1'b0}};\n        endcase\n    end\n\n    // Valid and Ready Handshake\n    always @(*) begin\n        csr_i_ready = csr_o_ready;\n        csr_o_valid = csr_i_valid && csr_i_ready;\n    end\n\n    // Error Handling\n    always @(*) begin\n        csr_o_wbck_wdat = read_csr_dat;\n        csr_o_wbck_err = csr_access_ilgl;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 5, "code": "module e203_exu(\n    // Basic Interface\n    output commit_mret,\n    output commit_trap,\n    output exu_active,\n    output excp_active,\n    output core_wfi,\n    output tm_stop,\n    output itcm_nohold,\n    output core_cgstop,\n    output tcm_cgstop,\n    input [E203_HART_ID_W-1:0] core_mhartid,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    output wfi_halt_ifu_req,\n    input wfi_halt_ifu_ack,\n    output oitf_empty,\n    output [E203_XLEN-1:0] rf2ifu_x1,\n    output [E203_XLEN-1:0] rf2ifu_rs1,\n    output dec2ifu_rden,\n    output dec2ifu_rs1en,\n    output [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    output dec2ifu_mulhsu,\n    output dec2ifu_div,\n    output dec2ifu_rem,\n    output dec2ifu_divu,\n    output dec2ifu_remu,\n    input test_mode,\n    input clk_aon,\n    input clk,\n    input rst_n,\n\n    // From/To debug ctrl module\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output wr_dcsr_ena,\n    output wr_dpc_ena,\n    output wr_dscratch_ena,\n    output [E203_XLEN-1:0] wr_csr_nxt,\n    input [E203_XLEN-1:0] dcsr_r,\n    input [E203_PC_SIZE-1:0] dpc_r,\n    input [E203_XLEN-1:0] dscratch_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input dbg_stopcycle,\n\n    // IFU IR stage to EXU interface\n    input i_valid,\n    output i_ready,\n    input [E203_INSTR_SIZE-1:0] i_ir,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_pc_vld,\n    input i_misalgn,\n    input i_buserr,\n    input i_prdt_taken,\n    input i_muldiv_b2b,\n    input [E203_RFIDX_WIDTH-1:0] i_rs1idx,\n    input [E203_RFIDX_WIDTH-1:0] i_rs2idx,\n\n    // Flush interface to IFU\n    input pipe_flush_ack,\n    output pipe_flush_req,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    `ifdef E203_TIMING_BOOST\n    output [E203_PC_SIZE-1:0] pipe_flush_pc,\n    `endif\n\n    // LSU Write-Back Interface\n    input lsu_o_valid,\n    output lsu_o_ready,\n    input [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    input [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    input lsu_o_wbck_err,\n    input lsu_o_cmt_ld,\n    input lsu_o_cmt_st,\n    input [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    input lsu_o_cmt_buserr,\n\n    // AGU ICB Interface to LSU-ctrl\n    output agu_icb_cmd_valid,\n    input agu_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output agu_icb_cmd_read,\n    output [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    output agu_icb_cmd_lock,\n    output agu_icb_cmd_excl,\n    output [1:0] agu_icb_cmd_size,\n    output agu_icb_cmd_back2agu,\n    output agu_icb_cmd_usign,\n    output [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input agu_icb_rsp_valid,\n    output agu_icb_rsp_ready,\n    input agu_icb_rsp_err,\n    input agu_icb_rsp_excl_ok,\n    input [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    // CSR_NICE Interface(optional)\n    `ifdef E203_HAS_CSR_NICE\n    output nice_csr_valid,\n    input nice_csr_ready,\n    output [31:0] nice_csr_addr,\n    output nice_csr_wr,\n    output [31:0] nice_csr_wdata,\n    input [31:0] nice_csr_rdata,\n    `endif\n\n    // NICE Interface(optional)\n    `ifdef E203_HAS_NICE\n    output nice_req_valid,\n    input nice_req_ready,\n    output [E203_XLEN-1:0] nice_req_inst,\n    output [E203_XLEN-1:0] nice_req_rs1,\n    output [E203_XLEN-1:0] nice_req_rs2,\n    input nice_rsp_multicyc_valid,\n    output nice_rsp_multicyc_ready,\n    input [E203_XLEN-1:0] nice_rsp_multicyc_dat,\n    input nice_rsp_multicyc_err\n    `endif\n);\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 10, "code": "module e203_exu_wbck (\n    input wire alu_wbck_i_valid,\n    output wire alu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] alu_wbck_i_wdat,\n    input wire [E203_RFIDX_WIDTH-1:0] alu_wbck_i_rdidx,\n    input wire longp_wbck_i_valid,\n    output wire longp_wbck_i_ready,\n    input wire [E203_FLEN-1:0] longp_wbck_i_wdat,\n    input wire [4:0] longp_wbck_i_flags,\n    input wire [E203_RFIDX_WIDTH-1:0] longp_wbck_i_rdidx,\n    input wire longp_wbck_i_rdfpu,\n    output wire rf_wbck_o_ena,\n    output wire [E203_XLEN-1:0] rf_wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] rf_wbck_o_rdidx,\n    input wire clk,\n    input wire rst_n\n);\n\n  wire longp_wbck_active = longp_wbck_i_valid && !longp_wbck_i_rdfpu;\n  wire alu_wbck_active = alu_wbck_i_valid && !longp_wbck_i_valid;\n\n  assign longp_wbck_i_ready = longp_wbck_i_valid;\n  assign alu_wbck_i_ready = !longp_wbck_i_valid && alu_wbck_i_valid;\n\n  assign rf_wbck_o_ena = longp_wbck_active || alu_wbck_active;\n  assign rf_wbck_o_rdidx = longp_wbck_active ? longp_wbck_i_rdidx : alu_wbck_i_rdidx;\n\n  generate\n    if (E203_FLEN_IS_32) begin\n      assign rf_wbck_o_wdat = longp_wbck_active ? longp_wbck_i_wdat : alu_wbck_i_wdat;\n    end else begin\n      assign rf_wbck_o_wdat = longp_wbck_active ? longp_wbck_i_wdat : {E203_FLEN-E203_XLEN{1'b0}, alu_wbck_i_wdat};\n    end\n  endgenerate\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 7, "code": "module e203_exu_longpwbck (\n    input wire lsu_wbck_i_valid,\n    output wire lsu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] lsu_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] lsu_wbck_i_itag,\n    input wire lsu_wbck_i_err,\n    input wire lsu_cmt_i_buserr,\n    input wire [E203_ADDR_SIZE-1:0] lsu_cmt_i_badaddr,\n    input wire lsu_cmt_i_ld,\n    input wire lsu_cmt_i_st,\n    output wire longp_wbck_o_valid,\n    input wire longp_wbck_o_ready,\n    output wire [E203_FLEN-1:0] longp_wbck_o_wdat,\n    output wire [4:0] longp_wbck_o_flags,\n    output wire [E203_RFIDX_WIDTH-1:0] longp_wbck_o_rdidx,\n    output wire longp_wbck_o_rdfpu,\n    output wire longp_excp_o_valid,\n    input wire longp_excp_o_ready,\n    output wire longp_excp_o_insterr,\n    output wire longp_excp_o_ld,\n    output wire longp_excp_o_st,\n    output wire longp_excp_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] longp_excp_o_badaddr,\n    output wire [E203_PC_SIZE-1:0] longp_excp_o_pc,\n    input wire oitf_empty,\n    input wire [E203_ITAG_WIDTH-1:0] oitf_ret_ptr,\n    input wire [E203_RFIDX_WIDTH-1:0] oitf_ret_rdidx,\n    input wire [E203_PC_SIZE-1:0] oitf_ret_pc,\n    input wire oitf_ret_rdwen,\n    input wire oitf_ret_rdfpu,\n    output wire oitf_ret_ena,\n    input wire clk,\n    input wire rst_n\n`ifdef E203_HAS_NICE\n    , input wire nice_longp_wbck_i_valid,\n    output wire nice_longp_wbck_i_ready,\n    input wire [E203_XLEN-1:0] nice_longp_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] nice_longp_wbck_i_itag,\n    input wire nice_longp_wbck_i_err\n`endif\n);\n\n    // Write-back arbitration logic\n    wire wb_need = (oitf_ret_rdwen && !lsu_wbck_i_err);\n    wire excp_need = (lsu_wbck_i_err || lsu_cmt_i_buserr);\n    wire wb_valid = (lsu_wbck_i_valid && (oitf_ret_ptr == lsu_wbck_i_itag) && !oitf_empty);\n    wire excp_valid = (wb_valid && excp_need);\n\n    assign lsu_wbck_i_ready = longp_wbck_o_ready && longp_excp_o_ready;\n    assign longp_wbck_o_valid = wb_valid && wb_need && longp_wbck_o_ready;\n    assign longp_wbck_o_wdat = lsu_wbck_i_wdat;\n    assign longp_wbck_o_rdidx = oitf_ret_rdidx;\n    assign longp_wbck_o_rdfpu = oitf_ret_rdfpu;\n    assign longp_wbck_o_flags = {lsu_cmt_i_ld, lsu_cmt_i_st, 3'b000}; // Example flags\n\n    assign longp_excp_o_valid = excp_valid && longp_excp_o_ready;\n    assign longp_excp_o_insterr = lsu_wbck_i_err;\n    assign longp_excp_o_ld = lsu_cmt_i_ld;\n    assign longp_excp_o_st = lsu_cmt_i_st;\n    assign longp_excp_o_buserr = lsu_cmt_i_buserr;\n    assign longp_excp_o_badaddr = lsu_cmt_i_badaddr;\n    assign longp_excp_o_pc = oitf_ret_pc;\n\n    assign oitf_ret_ena = lsu_wbck_i_ready && lsu_wbck_i_valid;\n\n`ifdef E203_HAS_NICE\n    // NICE write-back handling\n    wire nice_wb_valid = (nice_longp_wbck_i_valid && (oitf_ret_ptr == nice_longp_wbck_i_itag) && !oitf_empty);\n    wire nice_excp_valid = (nice_wb_valid && nice_longp_wbck_i_err);\n\n    assign nice_longp_wbck_i_ready = longp_wbck_o_ready && longp_excp_o_ready;\n    // Arbitration between LSU and NICE write-back requests\n    // Assuming priority to LSU over NICE for simplicity\n    assign longp_wbck_o_valid = (wb_valid && wb_need) || (nice_wb_valid && !wb_valid);\n    assign longp_wbck_o_wdat = wb_valid ? lsu_wbck_i_wdat : nice_longp_wbck_i_wdat;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 6, "code": "module e203_exu_disp (\n    input wire wfi_halt_exu_req,\n    output wire wfi_halt_exu_ack,\n    input wire oitf_empty,\n    input wire amo_wait,\n    input wire disp_i_valid,\n    output wire disp_i_ready,\n    input wire disp_i_rs1x0,\n    input wire disp_i_rs2x0,\n    input wire disp_i_rs1en,\n    input wire disp_i_rs2en,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input wire [E203_XLEN-1:0] disp_i_rs1,\n    input wire [E203_XLEN-1:0] disp_i_rs2,\n    input wire disp_i_rdwen,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input wire [E203_DECINFO_WIDTH-1:0] disp_i_info,\n    input wire [E203_XLEN-1:0] disp_i_imm,\n    input wire [E203_PC_SIZE-1:0] disp_i_pc,\n    input wire disp_i_misalgn,\n    input wire disp_i_buserr,\n    input wire disp_i_ilegl,\n    output wire disp_o_alu_valid,\n    input wire disp_o_alu_ready,\n    input wire disp_o_alu_longpipe,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs1,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs2,\n    output wire disp_o_alu_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_o_alu_rdidx,\n    output wire [E203_DECINFO_WIDTH-1:0] disp_o_alu_info,\n    output wire [E203_XLEN-1:0] disp_o_alu_imm,\n    output wire [E203_PC_SIZE-1:0] disp_o_alu_pc,\n    output wire [E203_ITAG_WIDTH-1:0] disp_o_alu_itag,\n    output wire disp_o_alu_misalgn,\n    output wire disp_o_alu_buserr,\n    output wire disp_o_alu_ilegl,\n    input wire oitfrd_match_disprs1,\n    input wire oitfrd_match_disprs2,\n    input wire oitfrd_match_disprs3,\n    input wire oitfrd_match_disprd,\n    input wire [E203_ITAG_WIDTH-1:0] disp_oitf_ptr,\n    output wire disp_oitf_ena,\n    input wire disp_oitf_ready,\n    output wire disp_oitf_rs1fpu,\n    output wire disp_oitf_rs2fpu,\n    output wire disp_oitf_rs3fpu,\n    output wire disp_oitf_rdfpu,\n    output wire disp_oitf_rs1en,\n    output wire disp_oitf_rs2en,\n    output wire disp_oitf_rs3en,\n    output wire disp_oitf_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs2idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs3idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rdidx,\n    output wire [E203_PC_SIZE-1:0] disp_oitf_pc,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Implementation of dispatch logic, dependency checks, and WFI handling\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 14, "code": "module e203_reset_ctrl #(\n    parameter MASTER = 1,\n    parameter RST_SYNC_LEVEL = `E203_ASYNC_FF_LEVELS\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    output wire rst_core,\n    output wire rst_itcm,\n    output wire rst_dtcm,\n    output wire rst_aon\n);\n\nreg [RST_SYNC_LEVEL-1:0] rst_sync_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        rst_sync_reg <= {RST_SYNC_LEVEL{1'b1}};\n    end else if (test_mode) begin\n        rst_sync_reg <= {RST_SYNC_LEVEL{rst_n}};\n    end else begin\n        rst_sync_reg <= {rst_sync_reg[RST_SYNC_LEVEL-2:0], 1'b1};\n    end\nend\n\nassign rst_core = (MASTER == 1) ? rst_sync_reg[RST_SYNC_LEVEL-1] : rst_n;\nassign rst_aon = rst_sync_reg[RST_SYNC_LEVEL-1];\n\n`ifdef E203_HAS_ITCM\n    assign rst_itcm = rst_sync_reg[RST_SYNC_LEVEL-1];\n`endif\n\n`ifdef E203_HAS_DTCM\n    assign rst_dtcm = rst_sync_reg[RST_SYNC_LEVEL-1];\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 10, "code": "module e203_exu_branchslv(\n    input wire cmt_i_valid,\n    output wire cmt_i_ready,\n    input wire cmt_i_rv32,\n    input wire cmt_i_dret,\n    input wire cmt_i_mret,\n    input wire cmt_i_fencei,\n    input wire cmt_i_bjp,\n    input wire cmt_i_bjp_prdt,\n    input wire cmt_i_bjp_rslv,\n    input wire [E203_PC_SIZE-1:0] cmt_i_pc,\n    input wire [E203_XLEN-1:0] cmt_i_imm,\n    input wire [E203_PC_SIZE-1:0] csr_epc_r,\n    input wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    input wire nonalu_excpirq_flush_req_raw,\n    input wire brchmis_flush_ack,\n    output wire brchmis_flush_req,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op1,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op2,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_pc,\n    output wire cmt_mret_ena,\n    output wire cmt_dret_ena,\n    output wire cmt_fencei_ena,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Flush need generation logic\n    wire flush_need_misprdt = cmt_i_bjp && (cmt_i_bjp_prdt != cmt_i_bjp_rslv);\n    wire flush_need_fencei = cmt_i_fencei;\n    wire flush_need_mret_dret = cmt_i_mret || cmt_i_dret;\n\n    assign brchmis_flush_req = cmt_i_valid && (flush_need_misprdt || flush_need_fencei || flush_need_mret_dret) && !nonalu_excpirq_flush_req_raw;\n\n    // Flush target calculation logic\n    wire [E203_PC_SIZE-1:0] next_pc = cmt_i_rv32 ? cmt_i_pc + 4 : cmt_i_pc + 2;\n    wire [E203_PC_SIZE-1:0] branch_target = cmt_i_pc + cmt_i_imm;\n\n    always @(*) begin\n        if (cmt_i_fencei || (cmt_i_bjp && cmt_i_bjp_prdt && !cmt_i_bjp_rslv)) begin\n            brchmis_flush_add_op1 = cmt_i_pc;\n            brchmis_flush_add_op2 = cmt_i_rv32 ? 4 : 2;\n        end else if (cmt_i_bjp && !cmt_i_bjp_prdt && cmt_i_bjp_rslv) begin\n            brchmis_flush_add_op1 = cmt_i_pc;\n            brchmis_flush_add_op2 = cmt_i_imm;\n        end else if (cmt_i_dret) begin\n            brchmis_flush_add_op1 = csr_dpc_r;\n            brchmis_flush_add_op2 = 0;\n        end else begin\n            brchmis_flush_add_op1 = csr_epc_r;\n            brchmis_flush_add_op2 = 0;\n        end\n    end\n\n    // Pipeline flush control logic\n    assign brchmis_flush_pc = brchmis_flush_add_op1 + brchmis_flush_add_op2;\n\n    // Ready signal logic\n    assign cmt_i_ready = !cmt_i_bjp && !cmt_i_fencei && !cmt_i_mret && !cmt_i_dret && !nonalu_excpirq_flush_req_raw && !brchmis_flush_req;\n\n    // Special signal commit logic\n    assign cmt_mret_ena = cmt_i_mret && brchmis_flush_req && brchmis_flush_ack;\n    assign cmt_dret_ena = cmt_i_dret && brchmis_flush_req && brchmis_flush_ack;\n    assign cmt_fencei_ena = cmt_i_fencei && brchmis_flush_req && brchmis_flush_ack;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 9, "code": "module e203_ifu_minidec #(\n  parameter E203_INSTR_SIZE = 32,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_XLEN = 32\n)(\n  input [E203_INSTR_SIZE-1:0] instr,\n  output dec_rs1en,\n  output dec_rs2en,\n  output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n  output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n  output dec_mulhsu,\n  output dec_mul,\n  output dec_div,\n  output dec_rem,\n  output dec_divu,\n  output dec_remu,\n  output dec_rv32,\n  output dec_bjp,\n  output dec_jal,\n  output dec_jalr,\n  output dec_bxx,\n  output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  output [E203_XLEN-1:0] dec_bjp_imm\n);\n\n  // Internal signals for decoding logic\n  wire [6:0] opcode = instr[6:0];\n  wire [2:0] funct3 = instr[14:12];\n  wire [6:0] funct7 = instr[31:25];\n\n  // Register enable signals\n  assign dec_rs1en = (opcode == 7'b1100111) ? 1'b1 : 1'b0; // JALR uses RS1\n  assign dec_rs2en = (opcode == 7'b0110011) ? 1'b1 : 1'b0; // R-type instructions use RS2\n\n  // Register index extraction\n  assign dec_rs1idx = instr[19:15];\n  assign dec_rs2idx = instr[24:20];\n\n  // Decode multiplication and division instructions\n  assign dec_mulhsu = (opcode == 7'b0110011 && funct3 == 3'b010 && funct7 == 7'b0000001) ? 1'b1 : 1'b0;\n  assign dec_mul = (opcode == 7'b0110011 && funct3 == 3'b000 && funct7 == 7'b0000001) ? 1'b1 : 1'b0;\n  assign dec_div = (opcode == 7'b0110011 && funct3 == 3'b100 && funct7 == 7'b0000001) ? 1'b1 : 1'b0;\n  assign dec_rem = (opcode == 7'b0110011 && funct3 == 3'b110 && funct7 == 7'b0000001) ? 1'b1 : 1'b0;\n  assign dec_divu = (opcode == 7'b0110011 && funct3 == 3'b101 && funct7 == 7'b0000001) ? 1'b1 : 1'b0;\n  assign dec_remu = (opcode == 7'b0110011 && funct3 == 3'b111 && funct7 == 7'b0000001) ? 1'b1 : 1'b0;\n\n  // Decode branch and jump instructions\n  assign dec_rv32 = 1'b1; // Assuming RV32 ISA\n  assign dec_bjp = (opcode == 7'b1101111 || opcode == 7'b1100111 || opcode == 7'b1100011) ? 1'b1 : 1'b0;\n  assign dec_jal = (opcode == 7'b1101111) ? 1'b1 : 1'b0;\n  assign dec_jalr = (opcode == 7'b1100111) ? 1'b1 : 1'b0;\n  assign dec_bxx = (opcode == 7'b1100011) ? 1'b1 : 1'b0;\n\n  // Specific RS1 index for JALR\n  assign dec_jalr_rs1idx = (dec_jalr) ? dec_rs1idx : {E203_RFIDX_WIDTH{1'b0}};\n\n  // Immediate extraction for branch/jump instructions\n  assign dec_bjp_imm = (dec_jal || dec_jalr) ? {{(E203_XLEN-12){instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0} : \n                       (dec_bxx) ? {{(E203_XLEN-13){instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0} : \n                       {E203_XLEN{1'b0}};\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 12, "code": "module e203_exu_alu_bjp (\n    input wire bjp_i_valid,\n    output wire bjp_i_ready,\n    input wire [E203_XLEN-1:0] bjp_i_rs1,\n    input wire [E203_XLEN-1:0] bjp_i_rs2,\n    input wire [E203_XLEN-1:0] bjp_i_imm,\n    input wire [E203_PC_SIZE-1:0] bjp_i_pc,\n    input wire [E203_DECINFO_BJP_WIDTH-1:0] bjp_i_info,\n    output wire bjp_o_valid,\n    input wire bjp_o_ready,\n    output wire [E203_XLEN-1:0] bjp_o_wbck_wdat,\n    output wire bjp_o_wbck_err,\n    output wire bjp_o_cmt_bjp,\n    output wire bjp_o_cmt_mret,\n    output wire bjp_o_cmt_dret,\n    output wire bjp_o_cmt_fencei,\n    output wire bjp_o_cmt_prdt,\n    output wire bjp_o_cmt_rslv,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    output wire bjp_req_alu_cmp_eq,\n    output wire bjp_req_alu_cmp_ne,\n    output wire bjp_req_alu_cmp_lt,\n    output wire bjp_req_alu_cmp_gt,\n    output wire bjp_req_alu_cmp_ltu,\n    output wire bjp_req_alu_cmp_gtu,\n    output wire bjp_req_alu_add,\n    input wire bjp_req_alu_cmp_res,\n    input wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    assign bjp_i_ready = bjp_o_ready;\n    assign bjp_o_valid = bjp_i_valid;\n\n    wire is_beq = bjp_i_info[E203_DECINFO_BJP_BEQ];\n    wire is_bne = bjp_i_info[E203_DECINFO_BJP_BNE];\n    wire is_blt = bjp_i_info[E203_DECINFO_BJP_BLT];\n    wire is_bgt = bjp_i_info[E203_DECINFO_BJP_BGT];\n    wire is_bltu = bjp_i_info[E203_DECINFO_BJP_BLTU];\n    wire is_bgtu = bjp_i_info[E203_DECINFO_BJP_BGTU];\n    wire is_jump = bjp_i_info[E203_DECINFO_BJP_JUMP];\n    wire is_mret = bjp_i_info[E203_DECINFO_BJP_MRET];\n    wire is_dret = bjp_i_info[E203_DECINFO_BJP_DRET];\n    wire is_fencei = bjp_i_info[E203_DECINFO_BJP_FENCEI];\n\n    assign bjp_req_alu_cmp_eq = is_beq;\n    assign bjp_req_alu_cmp_ne = is_bne;\n    assign bjp_req_alu_cmp_lt = is_blt;\n    assign bjp_req_alu_cmp_gt = is_bgt;\n    assign bjp_req_alu_cmp_ltu = is_bltu;\n    assign bjp_req_alu_cmp_gtu = is_bgtu;\n    assign bjp_req_alu_add = is_jump;\n\n    assign bjp_o_cmt_bjp = bjp_i_valid && (is_beq || is_bne || is_blt || is_bgt || is_bltu || is_bgtu || is_jump);\n    assign bjp_o_cmt_mret = is_mret;\n    assign bjp_o_cmt_dret = is_dret;\n    assign bjp_o_cmt_fencei = is_fencei;\n\n    assign bjp_o_cmt_prdt = bjp_i_info[E203_DECINFO_BJP_BPRDT];\n    assign bjp_o_cmt_rslv = is_jump ? 1'b1 : bjp_req_alu_cmp_res;\n\n    assign bjp_o_wbck_wdat = bjp_req_alu_add_res;\n    assign bjp_o_wbck_err = 1'b0;\n\n    assign bjp_req_alu_op1 = is_jump ? bjp_i_pc : bjp_i_rs1;\n    assign bjp_req_alu_op2 = is_jump ? bjp_i_imm : bjp_i_rs2;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 8, "code": "module e203_exu_alu_lsuagu (\n    input wire agu_i_valid,\n    output wire agu_i_ready,\n    input wire [E203_XLEN-1:0] agu_i_rs1,\n    input wire [E203_XLEN-1:0] agu_i_rs2,\n    input wire [E203_XLEN-1:0] agu_i_imm,\n    input wire [E203_DECINFO_AGU_WIDTH-1:0] agu_i_info,\n    input wire [E203_ITAG_WIDTH-1:0] agu_i_itag,\n    output wire agu_i_longpipe,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire amo_wait,\n    input wire oitf_empty,\n    output wire agu_o_valid,\n    input wire agu_o_ready,\n    output wire [E203_XLEN-1:0] agu_o_wbck_wdat,\n    output wire agu_o_wbck_err,\n    output wire agu_o_cmt_misalgn,\n    output wire agu_o_cmt_ld,\n    output wire agu_o_cmt_stamo,\n    output wire agu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] agu_o_cmt_badaddr,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_cmd_usign,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire [E203_XLEN-1:0] agu_req_alu_op1,\n    output wire [E203_XLEN-1:0] agu_req_alu_op2,\n    output wire agu_req_alu_swap,\n    output wire agu_req_alu_add,\n    output wire agu_req_alu_and,\n    output wire agu_req_alu_or,\n    output wire agu_req_alu_xor,\n    output wire agu_req_alu_max,\n    output wire agu_req_alu_min,\n    output wire agu_req_alu_maxu,\n    output wire agu_req_alu_minu,\n    input wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire agu_sbf_0_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_0_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_0_r,\n    output wire agu_sbf_1_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_1_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_1_r,\n    input wire clk,\n    input wire rst_n\n);\n    // Implementation of the AGU logic goes here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 11, "code": "module e203_exu_branchslv(\n    input wire cmt_i_valid,\n    output wire cmt_i_ready,\n    input wire cmt_i_rv32,\n    input wire cmt_i_dret,\n    input wire cmt_i_mret,\n    input wire cmt_i_fencei,\n    input wire cmt_i_bjp,\n    input wire cmt_i_bjp_prdt,\n    input wire cmt_i_bjp_rslv,\n    input wire [E203_PC_SIZE-1:0] cmt_i_pc,\n    input wire [E203_XLEN-1:0] cmt_i_imm,\n    input wire [E203_PC_SIZE-1:0] csr_epc_r,\n    input wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    input wire nonalu_excpirq_flush_req_raw,\n    input wire brchmis_flush_ack,\n    output wire brchmis_flush_req,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op1,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op2,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_pc,\n    output wire cmt_mret_ena,\n    output wire cmt_dret_ena,\n    output wire cmt_fencei_ena,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Flush need generation\n    wire flush_need = (cmt_i_bjp & (cmt_i_bjp_prdt != cmt_i_bjp_rslv)) | cmt_i_fencei | cmt_i_mret | cmt_i_dret;\n\n    // Flush target calculation\n    wire [E203_PC_SIZE-1:0] flush_target;\n    assign flush_target = cmt_i_dret ? csr_dpc_r :\n                          cmt_i_mret ? csr_epc_r :\n                          (cmt_i_bjp & ~cmt_i_bjp_prdt) ? (cmt_i_pc + cmt_i_imm) :\n                          (cmt_i_bjp & cmt_i_bjp_prdt) ? (cmt_i_rv32 ? cmt_i_pc + 4 : cmt_i_pc + 2) :\n                          csr_epc_r;\n\n    // Pipeline flush control\n    assign brchmis_flush_req = flush_need & cmt_i_valid & ~nonalu_excpirq_flush_req_raw;\n    assign brchmis_flush_add_op1 = cmt_i_pc;\n    assign brchmis_flush_add_op2 = cmt_i_imm;\n    assign brchmis_flush_pc = flush_target;\n\n    // Special signal commit\n    assign cmt_mret_ena = cmt_i_mret & flush_need;\n    assign cmt_dret_ena = cmt_i_dret & flush_need;\n    assign cmt_fencei_ena = cmt_i_fencei & flush_need;\n\n    // Controls the ready signal for the instruction\n    assign cmt_i_ready = ~flush_need & ~nonalu_excpirq_flush_req_raw & brchmis_flush_ack;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 12, "code": "module e203_exu_nice (\n    input wire nice_i_xs_off,\n    input wire nice_i_valid,\n    output wire nice_i_ready,\n    input wire [E203_XLEN-1:0] nice_i_instr,\n    input wire [E203_XLEN-1:0] nice_i_rs1,\n    input wire [E203_XLEN-1:0] nice_i_rs2,\n    input wire [E203_ITAG_WIDTH-1:0] nice_i_itag,\n    output wire nice_o_longpipe,\n    output wire nice_o_valid,\n    input wire nice_o_ready,\n    output wire nice_o_itag_valid,\n    input wire nice_o_itag_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Internal signals\n    wire fifo_full, fifo_empty;\n    wire fifo_push, fifo_pop;\n    wire [E203_ITAG_WIDTH-1:0] fifo_data_in, fifo_data_out;\n\n    // Control signals\n    assign nice_i_ready = !nice_i_xs_off && nice_req_ready && !fifo_full;\n    assign nice_o_longpipe = !nice_i_xs_off;\n    assign nice_o_valid = nice_i_valid && nice_i_ready && nice_o_ready;\n    assign nice_o_itag_valid = nice_rsp_multicyc_valid && !fifo_empty && nice_o_itag_ready;\n    assign nice_req_valid = nice_i_valid && nice_i_ready;\n    assign fifo_push = nice_i_valid && nice_i_ready;\n    assign fifo_pop = nice_rsp_multicyc_valid && nice_o_itag_ready;\n    assign fifo_data_in = nice_i_itag;\n\n    // Data forwarding\n    assign nice_req_instr = nice_i_instr;\n    assign nice_req_rs1 = nice_i_rs1;\n    assign nice_req_rs2 = nice_i_rs2;\n    assign nice_o_itag = fifo_data_out;\n\n    // FIFO for instruction tags\n    sirv_gnrl_fifo #(\n        .CUT_READY(1),\n        .MSKO(0),\n        .DP(4),\n        .DW(E203_ITAG_WIDTH)\n    ) itag_fifo (\n        .i_vld(fifo_push),\n        .i_rdy(fifo_full),\n        .i_dat(fifo_data_in),\n        .o_vld(!fifo_empty),\n        .o_rdy(fifo_pop),\n        .o_dat(fifo_data_out),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 10, "code": "module e203_exu_alu_csrctrl (\n    input wire csr_i_valid,\n    output reg csr_i_ready,\n    input wire [E203_XLEN-1:0] csr_i_rs1,\n    input wire [E203_DECINFO_CSR_WIDTH-1:0] csr_i_info,\n    input wire csr_i_rdwen,\n    output reg csr_ena,\n    output reg csr_wr_en,\n    output reg csr_rd_en,\n    output reg [11:0] csr_idx,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output reg [E203_XLEN-1:0] wbck_csr_dat,\n    output reg csr_o_valid,\n    input wire csr_o_ready,\n    output reg [E203_XLEN-1:0] csr_o_wbck_wdat,\n    output reg csr_o_wbck_err,\n    input wire clk,\n    input wire rst_n,\n    input wire nice_xs_off,\n    output reg csr_sel_nice,\n    output reg nice_csr_valid,\n    input wire nice_csr_ready,\n    output reg [31:0] nice_csr_addr,\n    output reg nice_csr_wr,\n    output reg [31:0] nice_csr_wdata,\n    input wire [31:0] nice_csr_rdata\n);\n\n    // Decode CSR instruction information\n    wire csrrw = csr_i_info[E203_DECINFO_CSR_CSRRW];\n    wire csrrs = csr_i_info[E203_DECINFO_CSR_CSRRS];\n    wire csrrc = csr_i_info[E203_DECINFO_CSR_CSRRC];\n    wire rs1imm = csr_i_info[E203_DECINFO_CSR_RS1IMM];\n    wire rs1is0 = csr_i_info[E203_DECINFO_CSR_RS1IS0];\n    wire [4:0] zimm = csr_i_info[E203_DECINFO_CSR_ZIMMM];\n    wire [11:0] csr_index = csr_i_info[E203_DECINFO_CSR_CSRIDX];\n\n    // CSR address index\n    assign csr_idx = csr_index;\n\n    // Prepare operand 1\n    wire [E203_XLEN-1:0] csr_op1 = rs1imm ? {E203_XLEN-5{1'b0}, zimm} : csr_i_rs1;\n\n    // Control signals\n    always @(*) begin\n        csr_i_ready = csr_o_ready;\n        csr_o_valid = csr_i_valid && csr_o_ready;\n        csr_ena = csr_i_valid && csr_o_ready && !csr_access_ilgl;\n        csr_wr_en = (csrrw || (csrrs && !rs1is0) || (csrrc && !rs1is0)) && csr_i_valid;\n        csr_rd_en = ((csrrw && csr_i_rdwen) || csrrs || csrrc) && csr_i_valid;\n        wbck_csr_dat = (csrrw ? csr_op1 : (csrrs ? (csr_op1 | read_csr_dat) : (csr_op1 & ~read_csr_dat)));\n\n        // NICE interface handling\n        csr_sel_nice = (csr_idx[11:8] == 4'hE) && !nice_xs_off;\n        nice_csr_valid = csr_i_valid && csr_o_ready && csr_sel_nice;\n        nice_csr_addr = {20'h0, csr_idx};\n        nice_csr_wr = csr_wr_en && csr_sel_nice;\n        nice_csr_wdata = wbck_csr_dat;\n\n        // Error handling\n        csr_o_wbck_wdat = csr_sel_nice ? nice_csr_rdata : read_csr_dat;\n        csr_o_wbck_err = csr_access_ilgl;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 5, "code": "module e203_ifu_ift2icb (\n    input wire itcm_nohold,\n    input wire ifu_req_valid,\n    input wire [PC_SIZE-1:0] ifu_req_pc,\n    input wire ifu_req_seq,\n    input wire ifu_req_seq_rv32,\n    input wire [PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_ready,\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_ready,\n    output wire ifu_rsp_valid,\n    output wire ifu_rsp_err,\n    output wire [31:0] ifu_rsp_instr,\n    output wire ifu2itcm_icb_cmd_valid,\n    input wire ifu2itcm_icb_cmd_ready,\n    output wire [ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_rsp_valid,\n    output wire ifu2itcm_icb_rsp_ready,\n    input wire ifu2itcm_icb_rsp_err,\n    input wire [ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    output wire ifu2biu_icb_cmd_valid,\n    input wire ifu2biu_icb_cmd_ready,\n    output wire [ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input wire ifu2biu_icb_rsp_valid,\n    output wire ifu2biu_icb_rsp_ready,\n    input wire ifu2biu_icb_rsp_err,\n    input wire [SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata\n);\n\n    // State machine for handling ICB requests and responses\n    reg [1:0] icb_state;\n    reg [1:0] icb_state_nxt;\n\n    // State definitions\n    localparam ICB_STATE_IDLE = 2'b00;\n    localparam ICB_STATE_1ST = 2'b01;\n    localparam ICB_STATE_WAIT2ND = 2'b10;\n    localparam ICB_STATE_2ND = 2'b11;\n\n    // State transition logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            icb_state <= ICB_STATE_IDLE;\n        end else begin\n            icb_state <= icb_state_nxt;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (icb_state)\n            ICB_STATE_IDLE: begin\n                if (ifu_req_valid && ifu_req_ready)\n                    icb_state_nxt = ICB_STATE_1ST;\n                else\n                    icb_state_nxt = ICB_STATE_IDLE;\n            end\n            ICB_STATE_1ST: begin\n                if (ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid)\n                    icb_state_nxt = ICB_STATE_WAIT2ND;\n                else\n                    icb_state_nxt = ICB_STATE_1ST;\n            end\n            ICB_STATE_WAIT2ND: begin\n                if (ifu2itcm_icb_cmd_ready || ifu2biu_icb_cmd_ready)\n                    icb_state_nxt = ICB_STATE_2ND;\n                else\n                    icb_state_nxt = ICB_STATE_WAIT2ND;\n            end\n            ICB_STATE_2ND: begin\n                if (ifu_rsp_ready)\n                    icb_state_nxt = ICB_STATE_IDLE;\n                else\n                    icb_state_nxt = ICB_STATE_2ND;\n            end\n            default: icb_state_nxt = ICB_STATE_IDLE;\n        endcase\n    end\n\n    // Command and response handling logic\n    assign ifu_req_ready = (icb_state == ICB_STATE_IDLE);\n    assign ifu_rsp_valid = (icb_state == ICB_STATE_2ND) && (ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid);\n    assign ifu_rsp_err = (icb_state == ICB_STATE_2ND) && (ifu2itcm_icb_rsp_err || ifu2biu_icb_rsp_err);\n    assign ifu_rsp_instr = (icb_state == ICB_STATE_2ND) ? (ifu2itcm_icb_rsp_rdata[31:0] : ifu2biu_icb_rsp_rdata[31:0]);\n\n    // ICB command generation\n    assign ifu2itcm_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && (ifu_req_pc < ITCM_ADDR_BASE + ITCM_SIZE);\n    assign ifu2itcm_icb_cmd_addr = ifu_req_pc[ITCM_ADDR_WIDTH-1:0];\n    assign ifu2itcm_icb_rsp_ready = (icb_state == ICB_STATE_1ST);\n\n    assign ifu2biu_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && (ifu_req_pc >= ITCM_ADDR_BASE + ITCM_SIZE);\n    assign ifu2biu_icb_cmd_addr = ifu_req_pc[ADDR_SIZE-1:0];\n    assign ifu2biu_icb_rsp_ready = (icb_state == ICB_STATE_1ST);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 11, "code": "module e203_exu_alu_csrctrl (\n    input wire csr_i_valid,\n    output reg csr_i_ready,\n    input wire [E203_XLEN-1:0] csr_i_rs1,\n    input wire [E203_DECINFO_CSR_WIDTH-1:0] csr_i_info,\n    input wire csr_i_rdwen,\n    output reg csr_ena,\n    output reg csr_wr_en,\n    output reg csr_rd_en,\n    output reg [11:0] csr_idx,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output reg [E203_XLEN-1:0] wbck_csr_dat,\n    output reg csr_o_valid,\n    input wire csr_o_ready,\n    output reg [E203_XLEN-1:0] csr_o_wbck_wdat,\n    output reg csr_o_wbck_err,\n    input wire clk,\n    input wire rst_n,\n    input wire nice_xs_off,\n    output reg csr_sel_nice,\n    output reg nice_csr_valid,\n    input wire nice_csr_ready,\n    output reg [31:0] nice_csr_addr,\n    output reg nice_csr_wr,\n    output reg [31:0] nice_csr_wdata,\n    input wire [31:0] nice_csr_rdata\n);\n\n    always @(*) begin\n        csr_i_ready = csr_o_ready;\n        csr_o_valid = csr_i_valid && csr_o_ready && !csr_access_ilgl;\n        csr_ena = csr_i_valid && csr_o_ready && !nice_xs_off;\n        csr_sel_nice = (csr_idx[11:8] == 4'hE) && !nice_xs_off;\n\n        if (csr_sel_nice) begin\n            nice_csr_valid = csr_i_valid && csr_o_ready;\n            nice_csr_addr = {20'h0, csr_idx};\n            nice_csr_wr = csr_i_info[E203_DECINFO_CSR_CSRRW];\n            nice_csr_wdata = csr_i_rs1;\n            wbck_csr_dat = nice_csr_rdata;\n        end else begin\n            nice_csr_valid = 1'b0;\n            nice_csr_addr = 32'h0;\n            nice_csr_wr = 1'b0;\n            nice_csr_wdata = 32'h0;\n            wbck_csr_dat = read_csr_dat;\n        end\n\n        csr_wr_en = csr_i_valid && ((csr_i_info[E203_DECINFO_CSR_CSRRW] && csr_i_rdwen) ||\n                                    (csr_i_info[E203_DECINFO_CSR_CSRRS] && !csr_i_info[E203_DECINFO_CSR_RS1IS0]) ||\n                                    (csr_i_info[E203_DECINFO_CSR_CSRRC] && !csr_i_info[E203_DECINFO_CSR_RS1IS0]));\n        csr_rd_en = csr_i_valid && (csr_i_info[E203_DECINFO_CSR_CSRRW] || csr_i_info[E203_DECINFO_CSR_CSRRS] || csr_i_info[E203_DECINFO_CSR_CSRRC]);\n        csr_idx = csr_i_info[E203_DECINFO_CSR_CSRIDX];\n\n        csr_o_wbck_wdat = wbck_csr_dat;\n        csr_o_wbck_err = csr_access_ilgl;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 10, "code": "module e203_irq_sync (\n    input wire clk,\n    input wire rst_n,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire dbg_irq_a,\n    output wire ext_irq_r,\n    output wire sft_irq_r,\n    output wire tmr_irq_r,\n    output wire dbg_irq_r\n);\n\n    // Synchronization instances for each interrupt type\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) ext_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(ext_irq_a),\n        .dout(ext_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) sft_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(sft_irq_a),\n        .dout(sft_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) tmr_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(tmr_irq_a),\n        .dout(tmr_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) dbg_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(dbg_irq_a),\n        .dout(dbg_irq_r)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 11, "code": "module e203_irq_sync (\n    input wire clk,\n    input wire rst_n,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire dbg_irq_a,\n    output wire ext_irq_r,\n    output wire sft_irq_r,\n    output wire tmr_irq_r,\n    output wire dbg_irq_r\n);\n\n    // Synchronization using sirv_gnrl_sync module for each interrupt type\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) ext_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(ext_irq_a),\n        .dout(ext_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) sft_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(sft_irq_a),\n        .dout(sft_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) tmr_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(tmr_irq_a),\n        .dout(tmr_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) dbg_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(dbg_irq_a),\n        .dout(dbg_irq_r)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 8, "code": "module e203_exu_longpwbck (\n    input wire lsu_wbck_i_valid,\n    output wire lsu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] lsu_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] lsu_wbck_i_itag,\n    input wire lsu_wbck_i_err,\n    input wire lsu_cmt_i_buserr,\n    input wire [E203_ADDR_SIZE-1:0] lsu_cmt_i_badaddr,\n    input wire lsu_cmt_i_ld,\n    input wire lsu_cmt_i_st,\n    output wire longp_wbck_o_valid,\n    input wire longp_wbck_o_ready,\n    output wire [E203_FLEN-1:0] longp_wbck_o_wdat,\n    output wire [4:0] longp_wbck_o_flags,\n    output wire [E203_RFIDX_WIDTH-1:0] longp_wbck_o_rdidx,\n    output wire longp_wbck_o_rdfpu,\n    output wire longp_excp_o_valid,\n    input wire longp_excp_o_ready,\n    output wire longp_excp_o_insterr,\n    output wire longp_excp_o_ld,\n    output wire longp_excp_o_st,\n    output wire longp_excp_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] longp_excp_o_badaddr,\n    output wire [E203_PC_SIZE-1:0] longp_excp_o_pc,\n    input wire oitf_empty,\n    input wire [E203_ITAG_WIDTH-1:0] oitf_ret_ptr,\n    input wire [E203_RFIDX_WIDTH-1:0] oitf_ret_rdidx,\n    input wire [E203_PC_SIZE-1:0] oitf_ret_pc,\n    input wire oitf_ret_rdwen,\n    input wire oitf_ret_rdfpu,\n    output wire oitf_ret_ena,\n    input wire clk,\n    input wire rst_n\n    `ifdef E203_HAS_NICE\n    , input wire nice_longp_wbck_i_valid,\n    output wire nice_longp_wbck_i_ready,\n    input wire [E203_XLEN-1:0] nice_longp_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] nice_longp_wbck_i_itag,\n    input wire nice_longp_wbck_i_err\n    `endif\n);\n\n    // Internal signals for arbitration and control logic\n    wire wbck_i_valid;\n    wire wbck_i_ready;\n    wire [E203_XLEN-1:0] wbck_i_wdat;\n    wire [E203_ITAG_WIDTH-1:0] wbck_i_itag;\n    wire wbck_i_err;\n\n    // Arbitration logic\n    assign wbck_i_valid = lsu_wbck_i_valid || (`ifdef E203_HAS_NICE nice_longp_wbck_i_valid `endif);\n    assign wbck_i_wdat = lsu_wbck_i_valid ? lsu_wbck_i_wdat : (`ifdef E203_HAS_NICE nice_longp_wbck_i_wdat `endif);\n    assign wbck_i_itag = lsu_wbck_i_valid ? lsu_wbck_i_itag : (`ifdef E203_HAS_NICE nice_longp_wbck_i_itag `endif);\n    assign wbck_i_err = lsu_wbck_i_valid ? lsu_wbck_i_err : (`ifdef E203_HAS_NICE nice_longp_wbck_i_err `endif);\n\n    // Control logic for write-back and exception needs\n    wire wb_need = wbck_i_valid && oitf_ret_rdwen && !wbck_i_err;\n    wire excp_need = wbck_i_valid && wbck_i_err;\n\n    // Ready signals\n    assign lsu_wbck_i_ready = wb_need && longp_wbck_o_ready && excp_need && longp_excp_o_ready;\n    `ifdef E203_HAS_NICE\n    assign nice_longp_wbck_i_ready = wb_need && longp_wbck_o_ready && excp_need && longp_excp_o_ready;\n    `endif\n\n    // Output valid signals\n    assign longp_wbck_o_valid = wb_need && wbck_i_valid && !excp_need;\n    assign longp_excp_o_valid = excp_need && wbck_i_valid && !wb_need;\n\n    // Data and flags output\n    assign longp_wbck_o_wdat = wbck_i_wdat;\n    assign longp_wbck_o_flags = {lsu_cmt_i_ld, lsu_cmt_i_st, lsu_cmt_i_buserr, 2'b00}; // Example flag assignment\n    assign longp_wbck_o_rdidx = oitf_ret_rdidx;\n    assign longp_wbck_o_rdfpu = oitf_ret_rdfpu;\n\n    // Exception outputs\n    assign longp_excp_o_insterr = wbck_i_err;\n    assign longp_excp_o_ld = lsu_cmt_i_ld;\n    assign longp_excp_o_st = lsu_cmt_i_st;\n    assign longp_excp_o_buserr = lsu_cmt_i_buserr;\n    assign longp_excp_o_badaddr = lsu_cmt_i_badaddr;\n    assign longp_excp_o_pc = oitf_ret_pc;\n\n    // OITF control\n    assign oitf_ret_ena = wbck_i_ready && wbck_i_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 18, "code": "module e203_dtcm_ram (\n    input wire sd,\n    input wire ds,\n    input wire ls,\n    input wire cs,\n    input wire we,\n    input wire [E203_DTCM_RAM_AW-1:0] addr,\n    input wire [E203_DTCM_RAM_MW-1:0] wem,\n    input wire [E203_DTCM_RAM_DW-1:0] din,\n    input wire rst_n,\n    input wire clk,\n    output wire [E203_DTCM_RAM_DW-1:0] dout\n);\n\n    // Instantiate the generic RAM module\n    sirv_gnrl_ram #(\n        .DP(E203_DTCM_RAM_DP),\n        .DW(E203_DTCM_RAM_DW),\n        .FORCE_X2ZERO(1),\n        .MW(E203_DTCM_RAM_MW),\n        .AW(E203_DTCM_RAM_AW)\n    ) u_203_dtcm_gnrl_ram (\n        .sd(sd),\n        .ds(ds),\n        .ls(ls),\n        .rst_n(rst_n),\n        .clk(clk),\n        .cs(cs),\n        .we(we),\n        .addr(addr),\n        .din(din),\n        .wem(wem),\n        .dout(dout)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 19, "code": "module e203_dtcm_ram (\n    input wire sd,\n    input wire ds,\n    input wire ls,\n    input wire cs,\n    input wire we,\n    input wire [E203_DTCM_RAM_AW-1:0] addr,\n    input wire [E203_DTCM_RAM_MW-1:0] wem,\n    input wire [E203_DTCM_RAM_DW-1:0] din,\n    input wire rst_n,\n    input wire clk,\n    output wire [E203_DTCM_RAM_DW-1:0] dout\n);\n\n    sirv_gnrl_ram #(\n        .DP(E203_DTCM_RAM_DP),\n        .DW(E203_DTCM_RAM_DW),\n        .FORCE_X2ZERO(1),\n        .MW(E203_DTCM_RAM_MW),\n        .AW(E203_DTCM_RAM_AW)\n    ) u_203_dtcm_gnrl_ram (\n        .sd(sd),\n        .ds(ds),\n        .ls(ls),\n        .rst_n(rst_n),\n        .clk(clk),\n        .cs(cs),\n        .we(we),\n        .addr(addr),\n        .din(din),\n        .wem(wem),\n        .dout(dout)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 11, "code": "module e203_exu_wbck (\n    input wire alu_wbck_i_valid,\n    output wire alu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] alu_wbck_i_wdat,\n    input wire [E203_RFIDX_WIDTH-1:0] alu_wbck_i_rdidx,\n    input wire longp_wbck_i_valid,\n    output wire longp_wbck_i_ready,\n    input wire [E203_FLEN-1:0] longp_wbck_i_wdat,\n    input wire [4:0] longp_wbck_i_flags,\n    input wire [E203_RFIDX_WIDTH-1:0] longp_wbck_i_rdidx,\n    input wire longp_wbck_i_rdfpu,\n    output wire rf_wbck_o_ena,\n    output wire [E203_XLEN-1:0] rf_wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] rf_wbck_o_rdidx,\n    input wire clk,\n    input wire rst_n\n);\n\n// Arbitration logic\nassign longp_wbck_i_ready = longp_wbck_i_valid;\nassign alu_wbck_i_ready = !longp_wbck_i_valid && alu_wbck_i_valid;\n\n// Write-back data selection\nwire [E203_XLEN-1:0] selected_wdat = longp_wbck_i_valid ? longp_wbck_i_wdat : alu_wbck_i_wdat;\nwire [E203_RFIDX_WIDTH-1:0] selected_rdidx = longp_wbck_i_valid ? longp_wbck_i_rdidx : alu_wbck_i_rdidx;\nwire selected_rdfpu = longp_wbck_i_valid ? longp_wbck_i_rdfpu : 1'b0;\n\n// Write-back enable\nassign rf_wbck_o_ena = (alu_wbck_i_valid || longp_wbck_i_valid) && !selected_rdfpu;\n\n// Output assignment\nassign rf_wbck_o_wdat = selected_wdat;\nassign rf_wbck_o_rdidx = selected_rdidx;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 9, "code": "module e203_exu_longpwbck(\n    input wire lsu_wbck_i_valid,\n    output wire lsu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] lsu_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] lsu_wbck_i_itag,\n    input wire lsu_wbck_i_err,\n    input wire lsu_cmt_i_buserr,\n    input wire [E203_ADDR_SIZE-1:0] lsu_cmt_i_badaddr,\n    input wire lsu_cmt_i_ld,\n    input wire lsu_cmt_i_st,\n    output wire longp_wbck_o_valid,\n    input wire longp_wbck_o_ready,\n    output wire [E203_FLEN-1:0] longp_wbck_o_wdat,\n    output wire [4:0] longp_wbck_o_flags,\n    output wire [E203_RFIDX_WIDTH-1:0] longp_wbck_o_rdidx,\n    output wire longp_wbck_o_rdfpu,\n    output wire longp_excp_o_valid,\n    input wire longp_excp_o_ready,\n    output wire longp_excp_o_insterr,\n    output wire longp_excp_o_ld,\n    output wire longp_excp_o_st,\n    output wire longp_excp_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] longp_excp_o_badaddr,\n    output wire [E203_PC_SIZE-1:0] longp_excp_o_pc,\n    input wire oitf_empty,\n    input wire [E203_ITAG_WIDTH-1:0] oitf_ret_ptr,\n    input wire [E203_RFIDX_WIDTH-1:0] oitf_ret_rdidx,\n    input wire [E203_PC_SIZE-1:0] oitf_ret_pc,\n    input wire oitf_ret_rdwen,\n    input wire oitf_ret_rdfpu,\n    output wire oitf_ret_ena,\n    input wire clk,\n    input wire rst_n\n    `ifdef E203_HAS_NICE\n    , input wire nice_longp_wbck_i_valid,\n    output wire nice_longp_wbck_i_ready,\n    input wire [E203_XLEN-1:0] nice_longp_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] nice_longp_wbck_i_itag,\n    input wire nice_longp_wbck_i_err\n    `endif\n);\n\n    // Internal signals\n    wire wbck_need, excp_need, wbck_ready, wbck_valid;\n    wire [E203_XLEN-1:0] wbck_data;\n    wire [E203_ITAG_WIDTH-1:0] wbck_itag;\n    wire wbck_err;\n\n    // Write-back needs calculation\n    assign wbck_need = (lsu_wbck_i_valid && oitf_ret_rdwen && !lsu_wbck_i_err);\n    assign excp_need = (lsu_wbck_i_valid && lsu_wbck_i_err);\n\n    // Write-back ready and valid signals\n    assign wbck_ready = longp_wbck_o_ready && (wbck_need || !excp_need);\n    assign wbck_valid = wbck_need && longp_wbck_o_ready;\n\n    // Exception handling\n    assign longp_excp_o_valid = excp_need && longp_excp_o_ready;\n    assign longp_excp_o_insterr = lsu_wbck_i_err;\n    assign longp_excp_o_ld = lsu_cmt_i_ld;\n    assign longp_excp_o_st = lsu_cmt_i_st;\n    assign longp_excp_o_buserr = lsu_cmt_i_buserr;\n    assign longp_excp_o_badaddr = lsu_cmt_i_badaddr;\n    assign longp_excp_o_pc = oitf_ret_pc;\n\n    // Write-back data handling\n    assign longp_wbck_o_valid = wbck_valid;\n    assign longp_wbck_o_wdat = lsu_wbck_i_wdat;\n    assign longp_wbck_o_rdidx = oitf_ret_rdidx;\n    assign longp_wbck_o_rdfpu = oitf_ret_rdfpu;\n\n    // OITF control\n    assign oitf_ret_ena = wbck_ready && wbck_valid;\n\n    // Ready signals\n    assign lsu_wbck_i_ready = wbck_ready;\n\n    `ifdef E203_HAS_NICE\n    // NICE module handling\n    assign nice_longp_wbck_i_ready = wbck_ready && (oitf_ret_ptr == nice_longp_wbck_i_itag);\n    `endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 20, "code": "module e203_cpu_top(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire tcm_sd,\n    input wire tcm_ds,\n    input wire [E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input wire ext2itcm_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ext2itcm_icb_cmd_wdata,\n    input wire [E203_XLEN/8-1:0] ext2itcm_icb_cmd_wmask,\n    input wire ext2itcm_icb_cmd_valid,\n    input wire ext2itcm_icb_rsp_ready,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire dbg_irq_r,\n    output wire ext2itcm_icb_cmd_ready,\n    output wire [E203_XLEN-1:0] ext2itcm_icb_rsp_rdata,\n    output wire ext2itcm_icb_rsp_valid,\n    output wire ext2itcm_icb_rsp_err\n);\n\n    // Internal signals\n    wire core_clk = clk;\n    wire core_rst_n = rst_n;\n\n    // Instantiate the E203 CPU core\n    e203_cpu u_e203_cpu(\n        .clk(core_clk),\n        .rst_n(core_rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ext_irq_a(ext_irq_a),\n        .sft_irq_a(sft_irq_a),\n        .tmr_irq_a(tmr_irq_a),\n        .inspect_pc(inspect_pc),\n        .inspect_dbg_irq(inspect_dbg_irq),\n        .inspect_mem_cmd_valid(inspect_mem_cmd_valid),\n        .inspect_mem_cmd_ready(inspect_mem_cmd_ready),\n        .inspect_mem_rsp_valid(inspect_mem_rsp_valid),\n        .inspect_mem_rsp_ready(inspect_mem_rsp_ready),\n        .inspect_core_clk(inspect_core_clk),\n        .core_csr_clk(core_csr_clk),\n        .core_wfi(core_wfi),\n        .tm_stop(tm_stop),\n        .dbg_irq_r(dbg_irq_r)\n    );\n\n    // Instantiate the SRAM control logic\n    e203_srams u_e203_srams(\n        .clk(core_clk),\n        .rst_n(core_rst_n),\n        .tcm_sd(tcm_sd),\n        .tcm_ds(tcm_ds),\n        .ext2itcm_icb_cmd_addr(ext2itcm_icb_cmd_addr),\n        .ext2itcm_icb_cmd_read(ext2itcm_icb_cmd_read),\n        .ext2itcm_icb_cmd_wdata(ext2itcm_icb_cmd_wdata),\n        .ext2itcm_icb_cmd_wmask(ext2itcm_icb_cmd_wmask),\n        .ext2itcm_icb_cmd_valid(ext2itcm_icb_cmd_valid),\n        .ext2itcm_icb_rsp_ready(ext2itcm_icb_rsp_ready),\n        .ext2itcm_icb_cmd_ready(ext2itcm_icb_cmd_ready),\n        .ext2itcm_icb_rsp_rdata(ext2itcm_icb_rsp_rdata),\n        .ext2itcm_icb_rsp_valid(ext2itcm_icb_rsp_valid),\n        .ext2itcm_icb_rsp_err(ext2itcm_icb_rsp_err)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 10, "code": "module e203_exu_alu_dpath(\n    input wire alu_req_alu,\n    input wire alu_req_alu_add,\n    input wire alu_req_alu_sub,\n    input wire alu_req_alu_xor,\n    input wire alu_req_alu_sll,\n    input wire alu_req_alu_srl,\n    input wire alu_req_alu_sra,\n    input wire alu_req_alu_or,\n    input wire alu_req_alu_and,\n    input wire [E203_XLEN-1:0] alu_req_alu_op1,\n    input wire [E203_XLEN-1:0] alu_req_alu_op2,\n    input wire bjp_req_alu,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    input wire agu_req_alu,\n    input wire [E203_XLEN-1:0] agu_req_alu_op1,\n    input wire [E203_XLEN-1:0] agu_req_alu_op2,\n    input wire muldiv_req_alu,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    input wire muldiv_req_alu_add,\n    input wire muldiv_req_alu_sub,\n    input wire muldiv_sbf_0_ena,\n    input wire [32:0] muldiv_sbf_0_nxt,\n    input wire muldiv_sbf_1_ena,\n    input wire [32:0] muldiv_sbf_1_nxt,\n    input wire clk,\n    input wire rst_n,\n    output wire [E203_XLEN-1:0] alu_req_alu_res,\n    output wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    output wire bjp_req_alu_cmp_res,\n    output wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output wire [32:0] muldiv_sbf_0_r,\n    output wire [32:0] muldiv_sbf_1_r\n);\n\n    // Internal signals for ALU operations\n    wire [E203_XLEN-1:0] add_res;\n    wire [E203_XLEN-1:0] sub_res;\n    wire [E203_XLEN-1:0] xor_res;\n    wire [E203_XLEN-1:0] sll_res;\n    wire [E203_XLEN-1:0] srl_res;\n    wire [E203_XLEN-1:0] sra_res;\n    wire [E203_XLEN-1:0] or_res;\n    wire [E203_XLEN-1:0] and_res;\n\n    // ALU operation implementations\n    assign add_res = alu_req_alu_op1 + alu_req_alu_op2;\n    assign sub_res = alu_req_alu_op1 - alu_req_alu_op2;\n    assign xor_res = alu_req_alu_op1 ^ alu_req_alu_op2;\n    assign sll_res = alu_req_alu_op1 << alu_req_alu_op2[E203_XLEN-1:0];\n    assign srl_res = alu_req_alu_op1 >> alu_req_alu_op2[E203_XLEN-1:0];\n    assign sra_res = $signed(alu_req_alu_op1) >>> alu_req_alu_op2[E203_XLEN-1:0];\n    assign or_res = alu_req_alu_op1 | alu_req_alu_op2;\n    assign and_res = alu_req_alu_op1 & alu_req_alu_op2;\n\n    // Result multiplexing based on operation type\n    assign alu_req_alu_res = ({E203_XLEN{alu_req_alu_add}} & add_res) |\n                             ({E203_XLEN{alu_req_alu_sub}} & sub_res) |\n                             ({E203_XLEN{alu_req_alu_xor}} & xor_res) |\n                             ({E203_XLEN{alu_req_alu_sll}} & sll_res) |\n                             ({E203_XLEN{alu_req_alu_srl}} & srl_res) |\n                             ({E203_XLEN{alu_req_alu_sra}} & sra_res) |\n                             ({E203_XLEN{alu_req_alu_or}} & or_res) |\n                             ({E203_XLEN{alu_req_alu_and}} & and_res);\n\n    // Shared buffer logic\n    sirv_gnrl_dffl #(33) sbf_0_dffl (\n        .lden(muldiv_sbf_0_ena),\n        .dnxt(muldiv_sbf_0_nxt),\n        .qout(muldiv_sbf_0_r),\n        .clk(clk)\n    );\n\n    sirv_gnrl_dffl #(33) sbf_1_dffl (\n        .lden(muldiv_sbf_1_ena),\n        .dnxt(muldiv_sbf_1_nxt),\n        .qout(muldiv_sbf_1_r),\n        .clk(clk)\n    );\n\n    // Additional logic for BJP, AGU, and MULDIV results can be implemented similarly\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 2, "code": "module itcm_controller #(\n    parameter ADDR_WIDTH = 32,\n    parameter DATA_WIDTH = 64,\n    parameter WMSK_WIDTH = DATA_WIDTH / 8,\n    parameter RAM_AW = 10,\n    parameter RAM_MW = DATA_WIDTH / 8,\n    parameter RAM_DW = DATA_WIDTH\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n\n    // IFU Interface\n    input wire ifu2itcm_icb_cmd_valid,\n    output wire ifu2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] ifu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] ifu2itcm_icb_cmd_wmask,\n    output wire ifu2itcm_icb_rsp_valid,\n    input wire ifu2itcm_icb_rsp_ready,\n    output wire ifu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n\n    // LSU Interface\n    input wire lsu2itcm_icb_cmd_valid,\n    output wire lsu2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] lsu2itcm_icb_cmd_addr,\n    input wire lsu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] lsu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] lsu2itcm_icb_cmd_wmask,\n    output wire lsu2itcm_icb_rsp_valid,\n    input wire lsu2itcm_icb_rsp_ready,\n    output wire lsu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] lsu2itcm_icb_rsp_rdata,\n\n    // RAM Interface\n    output wire itcm_ram_cs,\n    output wire itcm_ram_we,\n    output wire [RAM_AW-1:0] itcm_ram_addr,\n    output wire [RAM_MW-1:0] itcm_ram_wem,\n    output wire [RAM_DW-1:0] itcm_ram_din,\n    input wire [RAM_DW-1:0] itcm_ram_dout,\n    output wire clk_itcm_ram,\n\n    output wire itcm_active\n);\n\n    // Internal signals\n    reg [ADDR_WIDTH-1:0] addr_reg;\n    reg [DATA_WIDTH-1:0] data_reg;\n    reg [WMSK_WIDTH-1:0] wmask_reg;\n    reg we_reg;\n    reg cs_reg;\n\n    // Command arbitration logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            addr_reg <= 0;\n            data_reg <= 0;\n            wmask_reg <= 0;\n            we_reg <= 0;\n            cs_reg <= 0;\n        end else begin\n            if (ifu2itcm_icb_cmd_valid && ifu2itcm_icb_cmd_ready) begin\n                addr_reg <= ifu2itcm_icb_cmd_addr;\n                data_reg <= ifu2itcm_icb_cmd_wdata;\n                wmask_reg <= ifu2itcm_icb_cmd_wmask;\n                we_reg <= !ifu2itcm_icb_cmd_read;\n                cs_reg <= 1;\n            end else if (lsu2itcm_icb_cmd_valid && lsu2itcm_icb_cmd_ready) begin\n                addr_reg <= lsu2itcm_icb_cmd_addr;\n                data_reg <= lsu2itcm_icb_cmd_wdata;\n                wmask_reg <= lsu2itcm_icb_cmd_wmask;\n                we_reg <= !lsu2itcm_icb_cmd_read;\n                cs_reg <= 1;\n            end else begin\n                cs_reg <= 0;\n            end\n        end\n    end\n\n    // RAM interface logic\n    assign itcm_ram_cs = cs_reg;\n    assign itcm_ram_we = we_reg;\n    assign itcm_ram_addr = addr_reg[RAM_AW-1:0];\n    assign itcm_ram_wem = wmask_reg;\n    assign itcm_ram_din = data_reg;\n\n    // Response logic\n    assign ifu2itcm_icb_rsp_valid = cs_reg && ifu2itcm_icb_cmd_read;\n    assign ifu2itcm_icb_rsp_rdata = itcm_ram_dout;\n    assign ifu2itcm_icb_rsp_err = 0; // No error handling in this example\n\n    assign lsu2itcm_icb_rsp_valid = cs_reg && lsu2itcm_icb_cmd_read;\n    assign lsu2itcm_icb_rsp_rdata = itcm_ram_dout;\n    assign lsu2itcm_icb_rsp_err = 0; // No error handling in this example\n\n    // Clock and active status\n    assign clk_itcm_ram = clk;\n    assign itcm_active = cs_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 11, "code": "module e203_itcm_ram #(\n  parameter FORCE_X2ZERO = 0,\n  parameter DP = `E203_ITCM_RAM_DP,\n  parameter DW = `E203_ITCM_RAM_DW,\n  parameter MW = `E203_ITCM_RAM_MW,\n  parameter AW = `E203_ITCM_RAM_AW\n)(\n  input wire sd,\n  input wire ds,\n  input wire ls,\n  input wire cs,\n  input wire we,\n  input wire [AW-1:0] addr,\n  input wire [MW-1:0] wem,\n  input wire [DW-1:0] din,\n  input wire rst_n,\n  input wire clk,\n  output wire [DW-1:0] dout\n);\n\n  // Instantiate the generic RAM module\n  sirv_gnrl_ram #(\n    .FORCE_X2ZERO(FORCE_X2ZERO),\n    .DP(DP),\n    .DW(DW),\n    .MW(MW),\n    .AW(AW)\n  ) u_sirv_gnrl_ram (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 10, "code": "module e203_exu_longpwbck (\n    input wire lsu_wbck_i_valid,\n    output wire lsu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] lsu_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] lsu_wbck_i_itag,\n    input wire lsu_wbck_i_err,\n    input wire lsu_cmt_i_buserr,\n    input wire [E203_ADDR_SIZE-1:0] lsu_cmt_i_badaddr,\n    input wire lsu_cmt_i_ld,\n    input wire lsu_cmt_i_st,\n    output wire longp_wbck_o_valid,\n    input wire longp_wbck_o_ready,\n    output wire [E203_FLEN-1:0] longp_wbck_o_wdat,\n    output wire [4:0] longp_wbck_o_flags,\n    output wire [E203_RFIDX_WIDTH-1:0] longp_wbck_o_rdidx,\n    output wire longp_wbck_o_rdfpu,\n    output wire longp_excp_o_valid,\n    input wire longp_excp_o_ready,\n    output wire longp_excp_o_insterr,\n    output wire longp_excp_o_ld,\n    output wire longp_excp_o_st,\n    output wire longp_excp_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] longp_excp_o_badaddr,\n    output wire [E203_PC_SIZE-1:0] longp_excp_o_pc,\n    input wire oitf_empty,\n    input wire [E203_ITAG_WIDTH-1:0] oitf_ret_ptr,\n    input wire [E203_RFIDX_WIDTH-1:0] oitf_ret_rdidx,\n    input wire [E203_PC_SIZE-1:0] oitf_ret_pc,\n    input wire oitf_ret_rdwen,\n    input wire oitf_ret_rdfpu,\n    output wire oitf_ret_ena,\n    input wire clk,\n    input wire rst_n\n`ifdef E203_HAS_NICE\n    , input wire nice_longp_wbck_i_valid,\n    output wire nice_longp_wbck_i_ready,\n    input wire [E203_XLEN-1:0] nice_longp_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] nice_longp_wbck_i_itag,\n    input wire nice_longp_wbck_i_err\n`endif\n);\n\n    // Control logic to determine write-back and exception needs\n    wire wbck_need = (oitf_ret_rdwen && !lsu_wbck_i_err);\n    wire excp_need = (lsu_wbck_i_err || lsu_cmt_i_buserr);\n\n    // OITF control logic\n    assign lsu_wbck_i_ready = (wbck_need && longp_wbck_o_ready) && (excp_need && longp_excp_o_ready);\n    assign oitf_ret_ena = lsu_wbck_i_valid && (oitf_ret_ptr == lsu_wbck_i_itag) && !oitf_empty;\n\n    // Write-back arbitration logic\n    assign longp_wbck_o_valid = wbck_need && lsu_wbck_i_valid && !excp_need;\n    assign longp_wbck_o_wdat = lsu_wbck_i_wdat;\n    assign longp_wbck_o_rdidx = oitf_ret_rdidx;\n    assign longp_wbck_o_rdfpu = oitf_ret_rdfpu;\n    assign longp_wbck_o_flags = {lsu_cmt_i_ld, lsu_cmt_i_st, 3'b000}; // Example flags\n\n    // Exception handling\n    assign longp_excp_o_valid = excp_need && lsu_wbck_i_valid && !wbck_need;\n    assign longp_excp_o_insterr = lsu_wbck_i_err;\n    assign longp_excp_o_ld = lsu_cmt_i_ld;\n    assign longp_excp_o_st = lsu_cmt_i_st;\n    assign longp_excp_o_buserr = lsu_cmt_i_buserr;\n    assign longp_excp_o_badaddr = lsu_cmt_i_badaddr;\n    assign longp_excp_o_pc = oitf_ret_pc;\n\n`ifdef E203_HAS_NICE\n    // NICE write-back handling\n    assign nice_longp_wbck_i_ready = (oitf_ret_rdwen && !nice_longp_wbck_i_err);\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 7, "code": "module e203_exu_disp (\n    input wire wfi_halt_exu_req,\n    output wire wfi_halt_exu_ack,\n    input wire oitf_empty,\n    input wire amo_wait,\n    input wire disp_i_valid,\n    output wire disp_i_ready,\n    input wire disp_i_rs1x0,\n    input wire disp_i_rs2x0,\n    input wire disp_i_rs1en,\n    input wire disp_i_rs2en,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input wire [E203_XLEN-1:0] disp_i_rs1,\n    input wire [E203_XLEN-1:0] disp_i_rs2,\n    input wire disp_i_rdwen,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input wire [E203_DECINFO_WIDTH-1:0] disp_i_info,\n    input wire [E203_XLEN-1:0] disp_i_imm,\n    input wire [E203_PC_SIZE-1:0] disp_i_pc,\n    input wire disp_i_misalgn,\n    input wire disp_i_buserr,\n    input wire disp_i_ilegl,\n    output wire disp_o_alu_valid,\n    input wire disp_o_alu_ready,\n    input wire disp_o_alu_longpipe,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs1,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs2,\n    output wire disp_o_alu_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_o_alu_rdidx,\n    output wire [E203_DECINFO_WIDTH-1:0] disp_o_alu_info,\n    output wire [E203_XLEN-1:0] disp_o_alu_imm,\n    output wire [E203_PC_SIZE-1:0] disp_o_alu_pc,\n    output wire [E203_ITAG_WIDTH-1:0] disp_o_alu_itag,\n    output wire disp_o_alu_misalgn,\n    output wire disp_o_alu_buserr,\n    output wire disp_o_alu_ilegl,\n    input wire oitfrd_match_disprs1,\n    input wire oitfrd_match_disprs2,\n    input wire oitfrd_match_disprs3,\n    input wire oitfrd_match_disprd,\n    input wire [E203_ITAG_WIDTH-1:0] disp_oitf_ptr,\n    output wire disp_oitf_ena,\n    input wire disp_oitf_ready,\n    output wire disp_oitf_rs1fpu,\n    output wire disp_oitf_rs2fpu,\n    output wire disp_oitf_rs3fpu,\n    output wire disp_oitf_rdfpu,\n    output wire disp_oitf_rs1en,\n    output wire disp_oitf_rs2en,\n    output wire disp_oitf_rs3en,\n    output wire disp_oitf_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs2idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs3idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rdidx,\n    output wire [E203_PC_SIZE-1:0] disp_oitf_pc,\n    input wire clk,\n    input wire rst_n\n);\n\n// Implementation of the dispatch logic\n// This is a placeholder for the actual dispatch logic\n// which would include handling of various signals\n// and conditions described in the specification.\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 13, "code": "module e203_exu_alu_bjp (\n    input wire bjp_i_valid,\n    output wire bjp_i_ready,\n    input wire [E203_XLEN-1:0] bjp_i_rs1,\n    input wire [E203_XLEN-1:0] bjp_i_rs2,\n    input wire [E203_XLEN-1:0] bjp_i_imm,\n    input wire [E203_PC_SIZE-1:0] bjp_i_pc,\n    input wire [E203_DECINFO_BJP_WIDTH-1:0] bjp_i_info,\n    output wire bjp_o_valid,\n    input wire bjp_o_ready,\n    output wire [E203_XLEN-1:0] bjp_o_wbck_wdat,\n    output wire bjp_o_wbck_err,\n    output wire bjp_o_cmt_bjp,\n    output wire bjp_o_cmt_mret,\n    output wire bjp_o_cmt_dret,\n    output wire bjp_o_cmt_fencei,\n    output wire bjp_o_cmt_prdt,\n    output wire bjp_o_cmt_rslv,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    output wire bjp_req_alu_cmp_eq,\n    output wire bjp_req_alu_cmp_ne,\n    output wire bjp_req_alu_cmp_lt,\n    output wire bjp_req_alu_cmp_gt,\n    output wire bjp_req_alu_cmp_ltu,\n    output wire bjp_req_alu_cmp_gtu,\n    output wire bjp_req_alu_add,\n    input wire bjp_req_alu_cmp_res,\n    input wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Handshake signals\n    assign bjp_i_ready = bjp_o_ready;\n    assign bjp_o_valid = bjp_i_valid;\n\n    // Default assignments\n    assign bjp_o_wbck_err = 1'b0;\n    assign bjp_o_cmt_mret = 1'b0;\n    assign bjp_o_cmt_dret = 1'b0;\n    assign bjp_o_cmt_fencei = 1'b0;\n\n    // ALU operation requests\n    wire is_jump = bjp_i_info[E203_DECINFO_BJP_JUMP];\n    wire is_beq = bjp_i_info[E203_DECINFO_BJP_BEQ];\n    wire is_bne = bjp_i_info[E203_DECINFO_BJP_BNE];\n    wire is_blt = bjp_i_info[E203_DECINFO_BJP_BLT];\n    wire is_bgt = bjp_i_info[E203_DECINFO_BJP_BGT];\n    wire is_bltu = bjp_i_info[E203_DECINFO_BJP_BLTU];\n    wire is_bgtu = bjp_i_info[E203_DECINFO_BJP_BGTU];\n\n    assign bjp_req_alu_cmp_eq = is_beq;\n    assign bjp_req_alu_cmp_ne = is_bne;\n    assign bjp_req_alu_cmp_lt = is_blt;\n    assign bjp_req_alu_cmp_gt = is_bgt;\n    assign bjp_req_alu_cmp_ltu = is_bltu;\n    assign bjp_req_alu_cmp_gtu = is_bgtu;\n    assign bjp_req_alu_add = is_jump;\n\n    // Operand selection\n    assign bjp_req_alu_op1 = is_jump ? bjp_i_pc : bjp_i_rs1;\n    assign bjp_req_alu_op2 = is_jump ? bjp_i_imm : bjp_i_rs2;\n\n    // Commit signals\n    assign bjp_o_cmt_bjp = bjp_i_valid && (is_jump || is_beq || is_bne || is_blt || is_bgt || is_bltu || is_bgtu);\n    assign bjp_o_cmt_prdt = bjp_i_info[E203_DECINFO_BJP_BPRDT];\n    assign bjp_o_cmt_rslv = is_jump ? 1'b1 : bjp_req_alu_cmp_res;\n\n    // Write back data\n    assign bjp_o_wbck_wdat = bjp_req_alu_add_res;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 20, "code": "module e203_extend_csr (\n    input wire clk,\n    input wire rst_n,\n    input wire nice_csr_valid,\n    output wire nice_csr_ready,\n    input wire [31:0] nice_csr_addr,\n    input wire nice_csr_wr,\n    input wire [31:0] nice_csr_wdata,\n    output wire [31:0] nice_csr_rdata\n);\n\n`ifdef E203_HAS_CSR_NICE\n    // CSR access ready signal, always 1\n    assign nice_csr_ready = 1'b1;\n\n    // CSR read data, always 0\n    assign nice_csr_rdata = 32'b0;\n\n    // Unused inputs\n    wire unused = nice_csr_valid | nice_csr_wr | rst_n;\n    wire [31:0] unused_addr = nice_csr_addr;\n    wire [31:0] unused_wdata = nice_csr_wdata;\n`else\n    assign nice_csr_ready = 1'b0;\n    assign nice_csr_rdata = 32'b0;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 20, "code": "module e203_dtcm_ram #(\n  parameter E203_DTCM_RAM_DP = 256, // Depth of the RAM\n  parameter E203_DTCM_RAM_DW = 32,  // Data width\n  parameter E203_DTCM_RAM_MW = 4,   // Write mask width\n  parameter E203_DTCM_RAM_AW = 8    // Address width\n)(\n  input wire sd,\n  input wire ds,\n  input wire ls,\n  input wire cs,\n  input wire we,\n  input wire [E203_DTCM_RAM_AW-1:0] addr,\n  input wire [E203_DTCM_RAM_MW-1:0] wem,\n  input wire [E203_DTCM_RAM_DW-1:0] din,\n  input wire rst_n,\n  input wire clk,\n  output wire [E203_DTCM_RAM_DW-1:0] dout\n);\n\n  // Instantiate the generic RAM module\n  sirv_gnrl_ram #(\n    .DP(E203_DTCM_RAM_DP),\n    .DW(E203_DTCM_RAM_DW),\n    .MW(E203_DTCM_RAM_MW),\n    .AW(E203_DTCM_RAM_AW),\n    .FORCE_X2ZERO(1)\n  ) u_203_dtcm_gnrl_ram (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 12, "code": "module e203_exu_alu_csrctrl (\n    input wire csr_i_valid,\n    output reg csr_i_ready,\n    input wire [E203_XLEN-1:0] csr_i_rs1,\n    input wire [E203_DECINFO_CSR_WIDTH-1:0] csr_i_info,\n    input wire csr_i_rdwen,\n    output reg csr_ena,\n    output reg csr_wr_en,\n    output reg csr_rd_en,\n    output reg [11:0] csr_idx,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output reg [E203_XLEN-1:0] wbck_csr_dat,\n    output reg csr_o_valid,\n    input wire csr_o_ready,\n    output reg [E203_XLEN-1:0] csr_o_wbck_wdat,\n    output reg csr_o_wbck_err,\n    input wire clk,\n    input wire rst_n,\n    input wire nice_xs_off,\n    output reg csr_sel_nice,\n    output reg nice_csr_valid,\n    input wire nice_csr_ready,\n    output reg [31:0] nice_csr_addr,\n    output reg nice_csr_wr,\n    output reg [31:0] nice_csr_wdata,\n    input wire [31:0] nice_csr_rdata\n);\n\n    // Decode CSR instruction information\n    wire csrrw = csr_i_info[E203_DECINFO_CSR_CSRRW];\n    wire csrrs = csr_i_info[E203_DECINFO_CSR_CSRRS];\n    wire csrrc = csr_i_info[E203_DECINFO_CSR_CSRRC];\n    wire rs1imm = csr_i_info[E203_DECINFO_CSR_RS1IMM];\n    wire rs1is0 = csr_i_info[E203_DECINFO_CSR_RS1IS0];\n    wire [4:0] zimm = csr_i_info[E203_DECINFO_CSR_ZIMMM];\n    wire [11:0] csr_idx_info = csr_i_info[E203_DECINFO_CSR_CSRIDX];\n\n    // Prepare Operand 1\n    wire [E203_XLEN-1:0] csr_op1 = rs1imm ? {E203_XLEN-5{1'b0}, zimm} : csr_i_rs1;\n\n    // CSR Read and Write Enable Logic\n    always @(*) begin\n        csr_rd_en = csr_i_valid && ((csrrw && csr_i_rdwen) || csrrs || csrrc);\n        csr_wr_en = csr_i_valid && (csrrw || (csrrs && !rs1is0) || (csrrc && !rs1is0));\n        csr_idx = csr_idx_info;\n        csr_ena = csr_o_valid && csr_o_ready && !nice_xs_off;\n    end\n\n    // CSR Write-back Data Preparation\n    always @(*) begin\n        case ({csrrw, csrrs, csrrc})\n            3'b100: wbck_csr_dat = csr_op1;\n            3'b010: wbck_csr_dat = csr_op1 | read_csr_dat;\n            3'b001: wbck_csr_dat = ~csr_op1 & read_csr_dat;\n            default: wbck_csr_dat = {E203_XLEN{1'b0}};\n        endcase\n    end\n\n    // Error Handling\n    always @(*) begin\n        csr_o_wbck_wdat = read_csr_dat;\n        csr_o_wbck_err = csr_access_ilgl;\n    end\n\n    // NICE Interface Handling\n    always @(*) begin\n        csr_sel_nice = (csr_idx[11:8] == 4'hE);\n        nice_csr_valid = csr_i_valid && csr_o_ready;\n        nice_csr_addr = {20'h0, csr_idx};\n        nice_csr_wr = csr_wr_en;\n        nice_csr_wdata = wbck_csr_dat;\n    end\n\n    // Valid-Ready Handshake\n    always @(*) begin\n        csr_i_ready = csr_o_ready;\n        csr_o_valid = csr_i_valid && (nice_xs_off || nice_csr_ready);\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 15, "code": "module e203_reset_ctrl #(\n  parameter MASTER = 1,\n  parameter RST_SYNC_LEVEL = `E203_ASYNC_FF_LEVELS\n)(\n  input wire clk,\n  input wire rst_n,\n  input wire test_mode,\n  output wire rst_core,\n  output wire rst_itcm,\n  output wire rst_dtcm,\n  output wire rst_aon\n);\n\n  reg [RST_SYNC_LEVEL-1:0] rst_sync_reg;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      rst_sync_reg <= {RST_SYNC_LEVEL{1'b1}};\n    end else begin\n      rst_sync_reg <= {rst_sync_reg[RST_SYNC_LEVEL-2:0], 1'b0};\n    end\n  end\n\n  wire rst_sync = rst_sync_reg[RST_SYNC_LEVEL-1];\n\n  assign rst_core = (test_mode) ? rst_n : rst_sync;\n  assign rst_itcm = (test_mode) ? rst_n : rst_sync;\n  assign rst_dtcm = (test_mode) ? rst_n : rst_sync;\n  assign rst_aon = (test_mode) ? rst_n : rst_sync;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 11, "code": "module e203_exu_alu_muldiv(\n    input mdv_nob2b,\n    input muldiv_i_valid,\n    output muldiv_i_ready,\n    input [E203_XLEN-1:0] muldiv_i_rs1,\n    input [E203_XLEN-1:0] muldiv_i_rs2,\n    input [E203_XLEN-1:0] muldiv_i_imm,\n    input [E203_DECINFO_MULDIV_WIDTH-1:0] muldiv_i_info,\n    input [E203_ITAG_WIDTH-1:0] muldiv_i_itag,\n    output muldiv_i_longpipe,\n    input flush_pulse,\n    output muldiv_o_valid,\n    input muldiv_o_ready,\n    output [E203_XLEN-1:0] muldiv_o_wbck_wdat,\n    output muldiv_o_wbck_err,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    output muldiv_req_alu_add,\n    output muldiv_req_alu_sub,\n    input [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output muldiv_sbf_0_ena,\n    output [32:0] muldiv_sbf_0_nxt,\n    input [32:0] muldiv_sbf_0_r,\n    output muldiv_sbf_1_ena,\n    output [32:0] muldiv_sbf_1_nxt,\n    input [32:0] muldiv_sbf_1_r,\n    input clk,\n    input rst_n\n);\n    // Internal signals and registers\n    reg [4:0] state;\n    reg [4:0] next_state;\n    reg [E203_XLEN-1:0] rs1_reg, rs2_reg;\n    reg [E203_XLEN-1:0] product_reg;\n    reg [E203_XLEN-1:0] quotient_reg, remainder_reg;\n    reg muldiv_i_ready_reg;\n    reg muldiv_o_valid_reg;\n    reg [E203_XLEN-1:0] muldiv_o_wbck_wdat_reg;\n    reg muldiv_o_wbck_err_reg;\n\n    // State definitions\n    localparam MULDIV_STATE_IDLE = 5'd0;\n    localparam MULDIV_STATE_EXEC = 5'd1;\n    localparam MULDIV_STATE_REMD_CHCK = 5'd2;\n    localparam MULDIV_STATE_QUOT_CORR = 5'd3;\n    localparam MULDIV_STATE_REMD_CORR = 5'd4;\n\n    // FSM for multiplier and divider\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= MULDIV_STATE_IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            MULDIV_STATE_IDLE: begin\n                if (muldiv_i_valid && muldiv_i_ready) begin\n                    next_state = MULDIV_STATE_EXEC;\n                end else begin\n                    next_state = MULDIV_STATE_IDLE;\n                end\n            end\n            MULDIV_STATE_EXEC: begin\n                // Assuming 17 cycles for multiplication and 33 for division\n                if (/* condition to finish multiplication or division */) begin\n                    next_state = MULDIV_STATE_REMD_CHCK;\n                end else begin\n                    next_state = MULDIV_STATE_EXEC;\n                end\n            end\n            MULDIV_STATE_REMD_CHCK: begin\n                if (/* condition for remainder check */) begin\n                    next_state = MULDIV_STATE_QUOT_CORR;\n                end else begin\n                    next_state = MULDIV_STATE_IDLE;\n                end\n            end\n            MULDIV_STATE_QUOT_CORR: begin\n                next_state = MULDIV_STATE_REMD_CORR;\n            end\n            MULDIV_STATE_REMD_CORR: begin\n                next_state = MULDIV_STATE_IDLE;\n            end\n            default: begin\n                next_state = MULDIV_STATE_IDLE;\n            end\n        endcase\n    end\n\n    // Output assignments\n    assign muldiv_i_ready = muldiv_i_ready_reg;\n    assign muldiv_o_valid = muldiv_o_valid_reg;\n    assign muldiv_o_wbck_wdat = muldiv_o_wbck_wdat_reg;\n    assign muldiv_o_wbck_err = muldiv_o_wbck_err_reg;\n\n    // Logic for handling multiplication, division, and remainder calculations\n    // Add Booth encoding, partial product accumulation, and division correction logic here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 12, "code": "module e203_exu_branchslv (\n    input wire cmt_i_valid,\n    output wire cmt_i_ready,\n    input wire cmt_i_rv32,\n    input wire cmt_i_dret,\n    input wire cmt_i_mret,\n    input wire cmt_i_fencei,\n    input wire cmt_i_bjp,\n    input wire cmt_i_bjp_prdt,\n    input wire cmt_i_bjp_rslv,\n    input wire [E203_PC_SIZE-1:0] cmt_i_pc,\n    input wire [E203_XLEN-1:0] cmt_i_imm,\n    input wire [E203_PC_SIZE-1:0] csr_epc_r,\n    input wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    input wire nonalu_excpirq_flush_req_raw,\n    input wire brchmis_flush_ack,\n    output wire brchmis_flush_req,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op1,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op2,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_pc,\n    output wire cmt_mret_ena,\n    output wire cmt_dret_ena,\n    output wire cmt_fencei_ena,\n    input wire clk,\n    input wire rst_n\n);\n\n    wire flush_needed;\n    wire flush_target_mret;\n    wire flush_target_dret;\n    wire flush_target_fencei;\n    wire flush_target_bjp_mis;\n\n    assign flush_needed = (cmt_i_fencei | cmt_i_mret | cmt_i_dret | \n                           (cmt_i_bjp & (cmt_i_bjp_prdt != cmt_i_bjp_rslv)));\n\n    assign flush_target_mret = cmt_i_mret;\n    assign flush_target_dret = cmt_i_dret;\n    assign flush_target_fencei = cmt_i_fencei;\n    assign flush_target_bjp_mis = cmt_i_bjp & (cmt_i_bjp_prdt != cmt_i_bjp_rslv);\n\n    assign brchmis_flush_req = flush_needed & cmt_i_valid & ~nonalu_excpirq_flush_req_raw;\n    assign cmt_mret_ena = cmt_i_mret;\n    assign cmt_dret_ena = cmt_i_dret;\n    assign cmt_fencei_ena = cmt_i_fencei;\n\n    assign brchmis_flush_add_op1 = (flush_target_dret ? csr_dpc_r : \n                                   (flush_target_mret ? csr_epc_r : cmt_i_pc));\n    assign brchmis_flush_add_op2 = (flush_target_bjp_mis ? cmt_i_imm : 0);\n\n    assign brchmis_flush_pc = (flush_target_fencei | (cmt_i_bjp & cmt_i_bjp_prdt & ~cmt_i_bjp_rslv)) ? \n                              (cmt_i_rv32 ? cmt_i_pc + 4 : cmt_i_pc + 2) :\n                              ((cmt_i_bjp & ~cmt_i_bjp_prdt & cmt_i_bjp_rslv) ? \n                               (cmt_i_pc + cmt_i_imm) : \n                               (flush_target_dret ? csr_dpc_r : csr_epc_r));\n\n    assign cmt_i_ready = ~flush_needed & ~nonalu_excpirq_flush_req_raw & brchmis_flush_ack;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 3, "code": "module e203_lsu(\n    input wire commit_mret,\n    input wire commit_trap,\n    input wire excp_active,\n    output wire lsu_active,\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n    output wire [ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_buserr,\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [XLEN-1:0] agu_icb_rsp_rdata\n);\n    // LSU logic implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 10, "code": "module e203_ifu_minidec (\n    input wire [E203_INSTR_SIZE-1:0] instr,\n    output wire dec_rs1en,\n    output wire dec_rs2en,\n    output wire [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n    output wire dec_mulhsu,\n    output wire dec_mul,\n    output wire dec_div,\n    output wire dec_rem,\n    output wire dec_divu,\n    output wire dec_remu,\n    output wire dec_rv32,\n    output wire dec_bjp,\n    output wire dec_jal,\n    output wire dec_jalr,\n    output wire dec_bxx,\n    output wire [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    output wire [E203_XLEN-1:0] dec_bjp_imm\n);\n\n    // Internal signals for decoding\n    wire [6:0] opcode = instr[6:0];\n    wire [2:0] funct3 = instr[14:12];\n    wire [6:0] funct7 = instr[31:25];\n\n    // Decode logic for register file index extraction\n    assign dec_rs1idx = instr[19:15];\n    assign dec_rs2idx = instr[24:20];\n    assign dec_jalr_rs1idx = instr[19:15];\n\n    // Decode logic for control signals\n    assign dec_rs1en = (opcode == 7'b1100111 || opcode == 7'b1100011 || opcode == 7'b0100011 || opcode == 7'b0000011);\n    assign dec_rs2en = (opcode == 7'b1100011 || opcode == 7'b0100011);\n\n    // Decode logic for operation type\n    assign dec_mul = (opcode == 7'b0110011 && funct7 == 7'b0000001 && funct3 == 3'b000);\n    assign dec_mulhsu = (opcode == 7'b0110011 && funct7 == 7'b0000001 && funct3 == 3'b010);\n    assign dec_div = (opcode == 7'b0110011 && funct7 == 7'b0000001 && funct3 == 3'b100);\n    assign dec_divu = (opcode == 7'b0110011 && funct7 == 7'b0000001 && funct3 == 3'b101);\n    assign dec_rem = (opcode == 7'b0110011 && funct7 == 7'b0000001 && funct3 == 3'b110);\n    assign dec_remu = (opcode == 7'b0110011 && funct7 == 7'b0000001 && funct3 == 3'b111);\n\n    // Decode logic for branch and jump instructions\n    assign dec_bjp = (opcode == 7'b1101111 || opcode == 7'b1100111 || opcode == 7'b1100011);\n    assign dec_jal = (opcode == 7'b1101111);\n    assign dec_jalr = (opcode == 7'b1100111);\n    assign dec_bxx = (opcode == 7'b1100011);\n\n    // Immediate extraction for branch/jump instructions\n    assign dec_bjp_imm = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};\n\n    // RV32 instruction set flag (assuming all instructions are RV32)\n    assign dec_rv32 = 1'b1;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 4, "code": "module e203_lsu(\n    input wire commit_mret,\n    input wire commit_trap,\n    input wire excp_active,\n    output wire lsu_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n    output wire [ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_buserr,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [XLEN/8-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [XLEN-1:0] agu_icb_rsp_rdata\n);\n    // LSU logic implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 11, "code": "module e203_exu_alu_rglr(\n    input wire alu_i_valid,\n    output wire alu_i_ready,\n    input wire [E203_XLEN-1:0] alu_i_rs1,\n    input wire [E203_XLEN-1:0] alu_i_rs2,\n    input wire [E203_XLEN-1:0] alu_i_imm,\n    input wire [E203_PC_SIZE-1:0] alu_i_pc,\n    input wire [E203_DECINFO_ALU_WIDTH-1:0] alu_i_info,\n    output wire alu_o_valid,\n    input wire alu_o_ready,\n    output wire [E203_XLEN-1:0] alu_o_wbck_wdat,\n    output wire alu_o_wbck_err,\n    output wire alu_o_cmt_ecall,\n    output wire alu_o_cmt_ebreak,\n    output wire alu_o_cmt_wfi,\n    output wire alu_req_alu_add,\n    output wire alu_req_alu_sub,\n    output wire alu_req_alu_xor,\n    output wire alu_req_alu_sll,\n    output wire alu_req_alu_srl,\n    output wire alu_req_alu_sra,\n    output wire alu_req_alu_or,\n    output wire alu_req_alu_and,\n    output wire alu_req_alu_slt,\n    output wire alu_req_alu_sltu,\n    output wire alu_req_alu_lui,\n    output wire [E203_XLEN-1:0] alu_req_alu_op1,\n    output wire [E203_XLEN-1:0] alu_req_alu_op2,\n    output wire [E203_XLEN-1:0] alu_req_alu_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Handshake signals\n    assign alu_i_ready = alu_o_ready;\n    assign alu_o_valid = alu_i_valid;\n\n    // Decode ALU operations from the instruction info\n    assign alu_req_alu_add = alu_i_info[E203_DECINFO_ALU_ADD] & ~alu_i_info[E203_DECINFO_ALU_NOP];\n    assign alu_req_alu_sub = alu_i_info[E203_DECINFO_ALU_SUB];\n    assign alu_req_alu_xor = alu_i_info[E203_DECINFO_ALU_XOR];\n    assign alu_req_alu_sll = alu_i_info[E203_DECINFO_ALU_SLL];\n    assign alu_req_alu_srl = alu_i_info[E203_DECINFO_ALU_SRL];\n    assign alu_req_alu_sra = alu_i_info[E203_DECINFO_ALU_SRA];\n    assign alu_req_alu_or  = alu_i_info[E203_DECINFO_ALU_OR];\n    assign alu_req_alu_and = alu_i_info[E203_DECINFO_ALU_AND];\n    assign alu_req_alu_slt = alu_i_info[E203_DECINFO_ALU_SLT];\n    assign alu_req_alu_sltu = alu_i_info[E203_DECINFO_ALU_SLTU];\n    assign alu_req_alu_lui = alu_i_info[E203_DECINFO_ALU_LUI];\n\n    // Select operands\n    assign alu_req_alu_op1 = alu_i_info[E203_DECINFO_ALU_OP1PC] ? alu_i_pc : alu_i_rs1;\n    assign alu_req_alu_op2 = alu_i_info[E203_DECINFO_ALU_OP2IMM] ? alu_i_imm : alu_i_rs2;\n\n    // Perform ALU operation\n    reg [E203_XLEN-1:0] alu_result;\n    always @(*) begin\n        case (1'b1) // synthesis parallel_case\n            alu_req_alu_add: alu_result = alu_req_alu_op1 + alu_req_alu_op2;\n            alu_req_alu_sub: alu_result = alu_req_alu_op1 - alu_req_alu_op2;\n            alu_req_alu_xor: alu_result = alu_req_alu_op1 ^ alu_req_alu_op2;\n            alu_req_alu_sll: alu_result = alu_req_alu_op1 << alu_req_alu_op2;\n            alu_req_alu_srl: alu_result = alu_req_alu_op1 >> alu_req_alu_op2;\n            alu_req_alu_sra: alu_result = $signed(alu_req_alu_op1) >>> alu_req_alu_op2;\n            alu_req_alu_or:  alu_result = alu_req_alu_op1 | alu_req_alu_op2;\n            alu_req_alu_and: alu_result = alu_req_alu_op1 & alu_req_alu_op2;\n            alu_req_alu_slt: alu_result = $signed(alu_req_alu_op1) < $signed(alu_req_alu_op2);\n            alu_req_alu_sltu: alu_result = alu_req_alu_op1 < alu_req_alu_op2;\n            alu_req_alu_lui: alu_result = alu_req_alu_op2;\n            default: alu_result = {E203_XLEN{1'b0}};\n        endcase\n    end\n\n    assign alu_req_alu_res = alu_result;\n    assign alu_o_wbck_wdat = alu_result;\n\n    // Special instructions\n    assign alu_o_cmt_ecall = alu_i_info[E203_DECINFO_ALU_ECAL];\n    assign alu_o_cmt_ebreak = alu_i_info[E203_DECINFO_ALU_EBRK];\n    assign alu_o_cmt_wfi = alu_i_info[E203_DECINFO_ALU_WFI];\n\n    // Error handling\n    assign alu_o_wbck_err = alu_o_cmt_ecall | alu_o_cmt_ebreak | alu_o_cmt_wfi;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 9, "code": "module e203_exu_alu_lsuagu (\n    input wire agu_i_valid,\n    output wire agu_i_ready,\n    input wire [E203_XLEN-1:0] agu_i_rs1,\n    input wire [E203_XLEN-1:0] agu_i_rs2,\n    input wire [E203_XLEN-1:0] agu_i_imm,\n    input wire [E203_DECINFO_AGU_WIDTH-1:0] agu_i_info,\n    input wire [E203_ITAG_WIDTH-1:0] agu_i_itag,\n    output wire agu_i_longpipe,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire amo_wait,\n    input wire oitf_empty,\n    output wire agu_o_valid,\n    input wire agu_o_ready,\n    output wire [E203_XLEN-1:0] agu_o_wbck_wdat,\n    output wire agu_o_wbck_err,\n    output wire agu_o_cmt_misalgn,\n    output wire agu_o_cmt_ld,\n    output wire agu_o_cmt_stamo,\n    output wire agu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] agu_o_cmt_badaddr,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_cmd_usign,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire [E203_XLEN-1:0] agu_req_alu_op1,\n    output wire [E203_XLEN-1:0] agu_req_alu_op2,\n    output wire agu_req_alu_swap,\n    output wire agu_req_alu_add,\n    output wire agu_req_alu_and,\n    output wire agu_req_alu_or,\n    output wire agu_req_alu_xor,\n    output wire agu_req_alu_max,\n    output wire agu_req_alu_min,\n    output wire agu_req_alu_maxu,\n    output wire agu_req_alu_minu,\n    input wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire agu_sbf_0_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_0_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_0_r,\n    output wire agu_sbf_1_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_1_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_1_r,\n    input wire clk,\n    input wire rst_n\n);\n    // Implementation of the AGU logic goes here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 4, "code": "module e203_exu_excp(\n    output commit_trap,\n    output core_wfi,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input amo_wait,\n    input alu_excp_i_valid,\n    input alu_excp_i_ld,\n    input alu_excp_i_stamo,\n    input alu_excp_i_misalgn,\n    input alu_excp_i_buserr,\n    input alu_excp_i_ecall,\n    input alu_excp_i_ebreak,\n    input alu_excp_i_wfi,\n    input alu_excp_i_ifu_misalgn,\n    input alu_excp_i_ifu_buserr,\n    input alu_excp_i_ifu_ilegl,\n    input [E203_PC_SIZE-1:0] alu_excp_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_excp_i_instr,\n    input alu_excp_i_pc_vld,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input longp_excp_i_insterr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input excpirq_flush_ack,\n    output excpirq_flush_req,\n    output nonalu_excpirq_flush_req_raw,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op1,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op2,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input cmt_dret_ena,\n    input cmt_ena,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_badaddr_ena,\n    output cmt_epc_ena,\n    output cmt_cause_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output excp_active,\n    input clk,\n    input rst_n\n);\n    // Implementation of the exception handling logic\n    // This is a placeholder for the actual implementation\n    // which would include the logic described in the specification.\n\n    // Example of handling an ALU exception\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            commit_trap <= 1'b0;\n            core_wfi <= 1'b0;\n        end else begin\n            if (alu_excp_i_valid) begin\n                commit_trap <= 1'b1;\n                core_wfi <= 1'b0; // Clear WFI state on exception\n            end else if (alu_excp_i_wfi) begin\n                core_wfi <= 1'b1;\n            end else begin\n                commit_trap <= 1'b0;\n            end\n        end\n    end\n\n    // Example of setting flush request signals\n    assign excpirq_flush_req = alu_excp_i_valid || longp_excp_i_valid;\n    assign nonalu_excpirq_flush_req_raw = !alu_excp_i_valid && (longp_excp_i_valid || dbg_irq_r);\n\n    // Example of calculating flush address\n    assign excpirq_flush_add_op1 = (dbg_mode) ? 32'h800 : csr_mtvec_r;\n    assign excpirq_flush_add_op2 = 32'h0;\n\n    // Example of handling debug exceptions\n    always @(posedge clk) begin\n        if (dbg_irq_r && !dbg_mode) begin\n            cmt_dpc <= alu_excp_i_pc;\n            cmt_dcause <= 3'b001; // Example cause code for debug interrupt\n            cmt_dpc_ena <= 1'b1;\n        end else begin\n            cmt_dpc_ena <= 1'b0;\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 13, "code": "module e203_exu_alu_csrctrl (\n    input wire csr_i_valid,\n    output reg csr_i_ready,\n    input wire [E203_XLEN-1:0] csr_i_rs1,\n    input wire [E203_DECINFO_CSR_WIDTH-1:0] csr_i_info,\n    input wire csr_i_rdwen,\n    output reg csr_ena,\n    output reg csr_wr_en,\n    output reg csr_rd_en,\n    output reg [11:0] csr_idx,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output reg [E203_XLEN-1:0] wbck_csr_dat,\n    output reg csr_o_valid,\n    input wire csr_o_ready,\n    output reg [E203_XLEN-1:0] csr_o_wbck_wdat,\n    output reg csr_o_wbck_err,\n    input wire clk,\n    input wire rst_n,\n    input wire nice_xs_off,\n    output reg csr_sel_nice,\n    output reg nice_csr_valid,\n    input wire nice_csr_ready,\n    output reg [31:0] nice_csr_addr,\n    output reg nice_csr_wr,\n    output reg [31:0] nice_csr_wdata,\n    input wire [31:0] nice_csr_rdata\n);\n\n    // Decode CSR instruction info\n    wire csrrw = csr_i_info[E203_DECINFO_CSR_CSRRW];\n    wire csrrs = csr_i_info[E203_DECINFO_CSR_CSRRS];\n    wire csrrc = csr_i_info[E203_DECINFO_CSR_CSRRC];\n    wire rs1imm = csr_i_info[E203_DECINFO_CSR_RS1IMM];\n    wire rs1is0 = csr_i_info[E203_DECINFO_CSR_RS1IS0];\n    wire [4:0] zimm = csr_i_info[E203_DECINFO_CSR_ZIMMM];\n    wire [11:0] csr_idx_info = csr_i_info[E203_DECINFO_CSR_CSRIDX];\n\n    // CSR index and data preparation\n    always @(*) begin\n        csr_idx = csr_idx_info;\n        wbck_csr_dat = (csrrw ? csr_i_rs1 : \n                        csrrs ? (read_csr_dat | csr_i_rs1) : \n                        csrrc ? (read_csr_dat & ~csr_i_rs1) : 0);\n    end\n\n    // CSR control signals\n    always @(*) begin\n        csr_rd_en = (csr_i_valid && (csrrw || csrrs || csrrc));\n        csr_wr_en = (csr_i_valid && ((csrrw) || (csrrs && !rs1is0) || (csrrc && !rs1is0)));\n        csr_ena = csr_i_valid && csr_o_ready;\n        csr_i_ready = csr_o_ready;\n        csr_o_valid = csr_i_valid && csr_o_ready;\n        csr_o_wbck_wdat = read_csr_dat;\n        csr_o_wbck_err = csr_access_ilgl;\n    end\n\n    // NICE interface handling\n    always @(*) begin\n        csr_sel_nice = (csr_idx[11:8] == 4'hE) && !nice_xs_off;\n        nice_csr_valid = csr_i_valid && csr_o_ready && csr_sel_nice;\n        nice_csr_addr = {20'h0, csr_idx};\n        nice_csr_wr = csr_wr_en && csr_sel_nice;\n        nice_csr_wdata = wbck_csr_dat;\n        if (csr_sel_nice) begin\n            csr_o_wbck_wdat = nice_csr_rdata;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 12, "code": "module e203_exu_alu_rglr (\n    input wire alu_i_valid,\n    output reg alu_i_ready,\n    input wire [E203_XLEN-1:0] alu_i_rs1,\n    input wire [E203_XLEN-1:0] alu_i_rs2,\n    input wire [E203_XLEN-1:0] alu_i_imm,\n    input wire [E203_PC_SIZE-1:0] alu_i_pc,\n    input wire [E203_DECINFO_ALU_WIDTH-1:0] alu_i_info,\n    output reg alu_o_valid,\n    input wire alu_o_ready,\n    output reg [E203_XLEN-1:0] alu_o_wbck_wdat,\n    output reg alu_o_wbck_err,\n    output reg alu_o_cmt_ecall,\n    output reg alu_o_cmt_ebreak,\n    output reg alu_o_cmt_wfi,\n    output reg alu_req_alu_add,\n    output reg alu_req_alu_sub,\n    output reg alu_req_alu_xor,\n    output reg alu_req_alu_sll,\n    output reg alu_req_alu_srl,\n    output reg alu_req_alu_sra,\n    output reg alu_req_alu_or,\n    output reg alu_req_alu_and,\n    output reg alu_req_alu_slt,\n    output reg alu_req_alu_sltu,\n    output reg alu_req_alu_lui,\n    output reg [E203_XLEN-1:0] alu_req_alu_op1,\n    output reg [E203_XLEN-1:0] alu_req_alu_op2,\n    output reg [E203_XLEN-1:0] alu_req_alu_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Handshake mechanism\n    always @(*) begin\n        alu_i_ready = alu_o_ready;\n        alu_o_valid = alu_i_valid;\n    end\n\n    // Decode the ALU operation from the instruction info\n    always @(*) begin\n        alu_req_alu_add = alu_i_info[E203_DECINFO_ALU_ADD];\n        alu_req_alu_sub = alu_i_info[E203_DECINFO_ALU_SUB];\n        alu_req_alu_xor = alu_i_info[E203_DECINFO_ALU_XOR];\n        alu_req_alu_sll = alu_i_info[E203_DECINFO_ALU_SLL];\n        alu_req_alu_srl = alu_i_info[E203_DECINFO_ALU_SRL];\n        alu_req_alu_sra = alu_i_info[E203_DECINFO_ALU_SRA];\n        alu_req_alu_or = alu_i_info[E203_DECINFO_ALU_OR];\n        alu_req_alu_and = alu_i_info[E203_DECINFO_ALU_AND];\n        alu_req_alu_slt = alu_i_info[E203_DECINFO_ALU_SLT];\n        alu_req_alu_sltu = alu_i_info[E203_DECINFO_ALU_SLTU];\n        alu_req_alu_lui = alu_i_info[E203_DECINFO_ALU_LUI];\n    end\n\n    // Select the correct operands\n    always @(*) begin\n        alu_req_alu_op1 = (alu_i_info[E203_DECINFO_ALU_OP1PC]) ? alu_i_pc : alu_i_rs1;\n        alu_req_alu_op2 = (alu_i_info[E203_DECINFO_ALU_OP2IMM]) ? alu_i_imm : alu_i_rs2;\n    end\n\n    // Perform the ALU operation\n    always @(*) begin\n        case (1'b1) // synthesis parallel_case\n            alu_req_alu_add: alu_req_alu_res = alu_req_alu_op1 + alu_req_alu_op2;\n            alu_req_alu_sub: alu_req_alu_res = alu_req_alu_op1 - alu_req_alu_op2;\n            alu_req_alu_xor: alu_req_alu_res = alu_req_alu_op1 ^ alu_req_alu_op2;\n            alu_req_alu_sll: alu_req_alu_res = alu_req_alu_op1 << alu_req_alu_op2;\n            alu_req_alu_srl: alu_req_alu_res = alu_req_alu_op1 >> alu_req_alu_op2;\n            alu_req_alu_sra: alu_req_alu_res = $signed(alu_req_alu_op1) >>> alu_req_alu_op2;\n            alu_req_alu_or: alu_req_alu_res = alu_req_alu_op1 | alu_req_alu_op2;\n            alu_req_alu_and: alu_req_alu_res = alu_req_alu_op1 & alu_req_alu_op2;\n            alu_req_alu_slt: alu_req_alu_res = ($signed(alu_req_alu_op1) < $signed(alu_req_alu_op2)) ? 32'b1 : 32'b0;\n            alu_req_alu_sltu: alu_req_alu_res = (alu_req_alu_op1 < alu_req_alu_op2) ? 32'b1 : 32'b0;\n            alu_req_alu_lui: alu_req_alu_res = alu_req_alu_op2;\n            default: alu_req_alu_res = 32'b0;\n        endcase\n    end\n\n    // Write back and special instructions handling\n    always @(*) begin\n        alu_o_wbck_wdat = alu_req_alu_res;\n        alu_o_wbck_err = (alu_i_info[E203_DECINFO_ALU_ECAL] || alu_i_info[E203_DECINFO_ALU_EBRK] || alu_i_info[E203_DECINFO_ALU_WFI]);\n        alu_o_cmt_ecall = alu_i_info[E203_DECINFO_ALU_ECAL];\n        alu_o_cmt_ebreak = alu_i_info[E203_DECINFO_ALU_EBRK];\n        alu_o_cmt_wfi = alu_i_info[E203_DECINFO_ALU_WFI];\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 6, "code": "module e203_exu_commit(\n    input wire clk,\n    input wire rst_n,\n\n    // Inputs from ALU\n    input wire alu_cmt_i_valid,\n    output wire alu_cmt_i_ready,\n    input wire [E203_PC_SIZE-1:0] alu_cmt_i_pc,\n    input wire [E203_INSTR_SIZE-1:0] alu_cmt_i_instr,\n    input wire alu_cmt_i_pc_vld,\n    input wire [E203_XLEN-1:0] alu_cmt_i_imm,\n    input wire alu_cmt_i_rv32,\n    input wire alu_cmt_i_bjp,\n    input wire alu_cmt_i_wfi,\n    input wire alu_cmt_i_fencei,\n    input wire alu_cmt_i_mret,\n    input wire alu_cmt_i_dret,\n    input wire alu_cmt_i_ecall,\n    input wire alu_cmt_i_ebreak,\n    input wire alu_cmt_i_ifu_misalgn,\n    input wire alu_cmt_i_ifu_buserr,\n    input wire alu_cmt_i_ifu_ilegl,\n    input wire alu_cmt_i_bjp_prdt,\n    input wire alu_cmt_i_bjp_rslv,\n    input wire alu_cmt_i_misalgn,\n    input wire alu_cmt_i_ld,\n    input wire alu_cmt_i_stamo,\n    input wire alu_cmt_i_buserr,\n    input wire [E203_ADDR_SIZE-1:0] alu_cmt_i_badaddr,\n\n    // Outputs\n    output wire commit_mret,\n    output wire commit_trap,\n    output wire core_wfi,\n    output wire nonflush_cmt_ena,\n    output wire excp_active,\n    output wire wfi_halt_ifu_req,\n    output wire wfi_halt_exu_req,\n    output wire [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output wire cmt_badaddr_ena,\n    output wire [E203_PC_SIZE-1:0] cmt_epc,\n    output wire cmt_epc_ena,\n    output wire [E203_XLEN-1:0] cmt_cause,\n    output wire cmt_cause_ena,\n    output wire cmt_instret_ena,\n    output wire cmt_status_ena,\n    output wire [E203_PC_SIZE-1:0] cmt_dpc,\n    output wire cmt_dpc_ena,\n    output wire [2:0] cmt_dcause,\n    output wire cmt_dcause_ena,\n    output wire cmt_mret_ena,\n\n    // Inputs from CSR\n    input wire [E203_PC_SIZE-1:0] csr_epc_r,\n    input wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    input wire [E203_XLEN-1:0] csr_mtvec_r,\n\n    // Interrupt and debug inputs\n    input wire dbg_mode,\n    input wire dbg_halt_r,\n    input wire dbg_step_r,\n    input wire dbg_ebreakm_r,\n    input wire dbg_irq_r,\n    input wire [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input wire ext_irq_r,\n    input wire sft_irq_r,\n    input wire tmr_irq_r,\n    input wire status_mie_r,\n    input wire mtie_r,\n    input wire msie_r,\n    input wire meie_r,\n\n    // Long-pipe exception interface\n    input wire longp_excp_i_valid,\n    input wire longp_excp_i_ld,\n    input wire longp_excp_i_st,\n    input wire longp_excp_i_buserr,\n    input wire [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input wire longp_excp_i_insterr,\n    input wire [E203_PC_SIZE-1:0] longp_excp_i_pc,\n\n    // Outputs to IFU and EXU\n    output wire longp_excp_i_ready\n);\n\n    // Internal signals\n    wire flush;\n    wire [E203_PC_SIZE-1:0] new_pc;\n\n    // Commit logic\n    assign alu_cmt_i_ready = !flush;\n    assign commit_mret = alu_cmt_i_mret && alu_cmt_i_valid && alu_cmt_i_ready;\n    assign commit_trap = (alu_cmt_i_ecall || alu_cmt_i_ebreak || alu_cmt_i_misalgn || alu_cmt_i_ld || alu_cmt_i_stamo || alu_cmt_i_buserr) && alu_cmt_i_valid && alu_cmt_i_ready;\n    assign core_wfi = alu_cmt_i_wfi && alu_cmt_i_valid && alu_cmt_i_ready;\n    assign nonflush_cmt_ena = alu_cmt_i_valid && alu_cmt_i_ready && !flush;\n    assign excp_active = commit_trap;\n\n    // Exception handling\n    assign cmt_badaddr = alu_cmt_i_badaddr;\n    assign cmt_badaddr_ena = alu_cmt_i_valid && alu_cmt_i_ready && (alu_cmt_i_misalgn || alu_cmt_i_ld || alu_cmt_i_stamo || alu_cmt_i_buserr);\n    assign cmt_epc = alu_cmt_i_pc;\n    assign cmt_epc_ena = commit_trap;\n    assign cmt_cause = {E203_XLEN{1'b0}}; // Placeholder for actual cause calculation\n    assign cmt_cause_ena = commit_trap;\n    assign cmt_instret_ena = alu_cmt_i_valid && alu_cmt_i_ready && !flush;\n    assign cmt_status_ena = commit_trap || commit_mret;\n\n    // Debug handling\n    assign cmt_dpc = csr_dpc_r;\n    assign cmt_dpc_ena = dbg_mode && dbg_halt_r;\n    assign cmt_dcause = 3'b000; // Placeholder for actual debug cause\n    assign cmt_dcause_ena = dbg_mode && dbg_halt_r;\n    assign cmt_mret_ena = commit_mret;\n\n    // Flush logic\n    assign flush = commit_trap || dbg_halt_r || (dbg_mode && dbg_step_r);\n    assign new_pc = csr_mtvec_r; // Placeholder for actual new PC calculation\n\n    // Long-pipe exception ready signal\n    assign longp_excp_i_ready = !flush;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 13, "code": "module e203_exu_alu_rglr(\n    input wire alu_i_valid,\n    output reg alu_i_ready,\n    input wire [E203_XLEN-1:0] alu_i_rs1,\n    input wire [E203_XLEN-1:0] alu_i_rs2,\n    input wire [E203_XLEN-1:0] alu_i_imm,\n    input wire [E203_PC_SIZE-1:0] alu_i_pc,\n    input wire [E203_DECINFO_ALU_WIDTH-1:0] alu_i_info,\n    output reg alu_o_valid,\n    input wire alu_o_ready,\n    output reg [E203_XLEN-1:0] alu_o_wbck_wdat,\n    output reg alu_o_wbck_err,\n    output reg alu_o_cmt_ecall,\n    output reg alu_o_cmt_ebreak,\n    output reg alu_o_cmt_wfi,\n    output reg alu_req_alu_add,\n    output reg alu_req_alu_sub,\n    output reg alu_req_alu_xor,\n    output reg alu_req_alu_sll,\n    output reg alu_req_alu_srl,\n    output reg alu_req_alu_sra,\n    output reg alu_req_alu_or,\n    output reg alu_req_alu_and,\n    output reg alu_req_alu_slt,\n    output reg alu_req_alu_sltu,\n    output reg alu_req_alu_lui,\n    output reg [E203_XLEN-1:0] alu_req_alu_op1,\n    output reg [E203_XLEN-1:0] alu_req_alu_op2,\n    output reg [E203_XLEN-1:0] alu_req_alu_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    always @* begin\n        // Handshake signals\n        alu_i_ready = alu_o_ready;\n        alu_o_valid = alu_i_valid;\n\n        // Default outputs\n        alu_o_wbck_wdat = 0;\n        alu_o_wbck_err = 0;\n        alu_o_cmt_ecall = 0;\n        alu_o_cmt_ebreak = 0;\n        alu_o_cmt_wfi = 0;\n\n        alu_req_alu_add = 0;\n        alu_req_alu_sub = 0;\n        alu_req_alu_xor = 0;\n        alu_req_alu_sll = 0;\n        alu_req_alu_srl = 0;\n        alu_req_alu_sra = 0;\n        alu_req_alu_or = 0;\n        alu_req_alu_and = 0;\n        alu_req_alu_slt = 0;\n        alu_req_alu_sltu = 0;\n        alu_req_alu_lui = 0;\n\n        // Selecting operands\n        alu_req_alu_op1 = (alu_i_info[E203_DECINFO_ALU_OP1PC]) ? alu_i_pc : alu_i_rs1;\n        alu_req_alu_op2 = (alu_i_info[E203_DECINFO_ALU_OP2IMM]) ? alu_i_imm : alu_i_rs2;\n\n        // Operation decoding\n        if (alu_i_valid) begin\n            case (1'b1)\n                alu_i_info[E203_DECINFO_ALU_ADD]: alu_req_alu_add = 1;\n                alu_i_info[E203_DECINFO_ALU_SUB]: alu_req_alu_sub = 1;\n                alu_i_info[E203_DECINFO_ALU_XOR]: alu_req_alu_xor = 1;\n                alu_i_info[E203_DECINFO_ALU_SLL]: alu_req_alu_sll = 1;\n                alu_i_info[E203_DECINFO_ALU_SRL]: alu_req_alu_srl = 1;\n                alu_i_info[E203_DECINFO_ALU_SRA]: alu_req_alu_sra = 1;\n                alu_i_info[E203_DECINFO_ALU_OR]: alu_req_alu_or = 1;\n                alu_i_info[E203_DECINFO_ALU_AND]: alu_req_alu_and = 1;\n                alu_i_info[E203_DECINFO_ALU_SLT]: alu_req_alu_slt = 1;\n                alu_i_info[E203_DECINFO_ALU_SLTU]: alu_req_alu_sltu = 1;\n                alu_i_info[E203_DECINFO_ALU_LUI]: alu_req_alu_lui = 1;\n            endcase\n\n            // Special instructions\n            if (alu_i_info[E203_DECINFO_ALU_ECAL]) begin\n                alu_o_cmt_ecall = 1;\n                alu_o_wbck_err = 1;\n            end\n            if (alu_i_info[E203_DECINFO_ALU_EBRK]) begin\n                alu_o_cmt_ebreak = 1;\n                alu_o_wbck_err = 1;\n            end\n            if (alu_i_info[E203_DECINFO_ALU_WFI]) begin\n                alu_o_cmt_wfi = 1;\n                alu_o_wbck_err = 1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 12, "code": "module e203_exu_wbck (\n    input wire alu_wbck_i_valid,\n    output wire alu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] alu_wbck_i_wdat,\n    input wire [E203_RFIDX_WIDTH-1:0] alu_wbck_i_rdidx,\n    input wire longp_wbck_i_valid,\n    output wire longp_wbck_i_ready,\n    input wire [E203_FLEN-1:0] longp_wbck_i_wdat,\n    input wire [4:0] longp_wbck_i_flags,\n    input wire [E203_RFIDX_WIDTH-1:0] longp_wbck_i_rdidx,\n    input wire longp_wbck_i_rdfpu,\n    output wire rf_wbck_o_ena,\n    output wire [E203_XLEN-1:0] rf_wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] rf_wbck_o_rdidx,\n    input wire clk,\n    input wire rst_n\n);\n\n// Arbitration logic\nassign alu_wbck_i_ready = !longp_wbck_i_valid && alu_wbck_i_valid;\nassign longp_wbck_i_ready = longp_wbck_i_valid;\n\n// Write-back data selection\nwire [E203_XLEN-1:0] selected_wdat = longp_wbck_i_valid ? longp_wbck_i_wdat : alu_wbck_i_wdat;\nwire [E203_RFIDX_WIDTH-1:0] selected_rdidx = longp_wbck_i_valid ? longp_wbck_i_rdidx : alu_wbck_i_rdidx;\nwire selected_rdfpu = longp_wbck_i_valid ? longp_wbck_i_rdfpu : 1'b0;\n\n// Write-back enable\nassign rf_wbck_o_ena = (alu_wbck_i_valid || longp_wbck_i_valid) && !selected_rdfpu;\n\n// Output assignment\nassign rf_wbck_o_wdat = selected_wdat;\nassign rf_wbck_o_rdidx = selected_rdidx;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 13, "code": "module e203_exu_branchslv(\n    input wire cmt_i_valid,\n    output wire cmt_i_ready,\n    input wire cmt_i_rv32,\n    input wire cmt_i_dret,\n    input wire cmt_i_mret,\n    input wire cmt_i_fencei,\n    input wire cmt_i_bjp,\n    input wire cmt_i_bjp_prdt,\n    input wire cmt_i_bjp_rslv,\n    input wire [E203_PC_SIZE-1:0] cmt_i_pc,\n    input wire [E203_XLEN-1:0] cmt_i_imm,\n    input wire [E203_PC_SIZE-1:0] csr_epc_r,\n    input wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    input wire nonalu_excpirq_flush_req_raw,\n    input wire brchmis_flush_ack,\n    output wire brchmis_flush_req,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op1,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op2,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_pc,\n    output wire cmt_mret_ena,\n    output wire cmt_dret_ena,\n    output wire cmt_fencei_ena,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Flush need generation\n    wire flush_need_mret_dret = cmt_i_mret | cmt_i_dret;\n    wire flush_need_fencei = cmt_i_fencei;\n    wire flush_need_bjp = cmt_i_bjp & (cmt_i_bjp_prdt ^ cmt_i_bjp_rslv);\n    wire flush_need = (flush_need_mret_dret | flush_need_fencei | flush_need_bjp) & cmt_i_valid;\n\n    // Flush target calculation\n    wire [E203_PC_SIZE-1:0] flush_target_mret = csr_epc_r;\n    wire [E203_PC_SIZE-1:0] flush_target_dret = csr_dpc_r;\n    wire [E203_PC_SIZE-1:0] flush_target_fencei = cmt_i_pc + (cmt_i_rv32 ? 32'd4 : 32'd2);\n    wire [E203_PC_SIZE-1:0] flush_target_bjp_taken = cmt_i_pc + cmt_i_imm;\n    wire [E203_PC_SIZE-1:0] flush_target_bjp_not_taken = cmt_i_pc + (cmt_i_rv32 ? 32'd4 : 32'd2);\n\n    assign brchmis_flush_pc = (cmt_i_fencei | (cmt_i_bjp & cmt_i_bjp_prdt & ~cmt_i_bjp_rslv)) ? flush_target_fencei :\n                              (cmt_i_bjp & ~cmt_i_bjp_prdt & cmt_i_bjp_rslv) ? flush_target_bjp_taken :\n                              cmt_i_dret ? flush_target_dret :\n                              flush_target_mret;\n\n    // Pipeline flush control\n    assign brchmis_flush_req = flush_need & ~nonalu_excpirq_flush_req_raw;\n    assign brchmis_flush_add_op1 = cmt_i_pc;\n    assign brchmis_flush_add_op2 = cmt_i_imm;\n\n    // Special signal commit\n    assign cmt_mret_ena = cmt_i_mret & flush_need & brchmis_flush_ack;\n    assign cmt_dret_ena = cmt_i_dret & flush_need & brchmis_flush_ack;\n    assign cmt_fencei_ena = cmt_i_fencei & flush_need & brchmis_flush_ack;\n\n    // Controls the ready signal for the instruction\n    assign cmt_i_ready = ~cmt_i_bjp & ~cmt_i_fencei & ~cmt_i_mret & ~cmt_i_dret & ~nonalu_excpirq_flush_req_raw & ~flush_need;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 12, "code": "module e203_exu_alu_muldiv(\n    input mdv_nob2b,\n    input muldiv_i_valid,\n    output muldiv_i_ready,\n    input [E203_XLEN-1:0] muldiv_i_rs1,\n    input [E203_XLEN-1:0] muldiv_i_rs2,\n    input [E203_XLEN-1:0] muldiv_i_imm,\n    input [E203_DECINFO_MULDIV_WIDTH-1:0] muldiv_i_info,\n    input [E203_ITAG_WIDTH-1:0] muldiv_i_itag,\n    output muldiv_i_longpipe,\n    input flush_pulse,\n    output muldiv_o_valid,\n    input muldiv_o_ready,\n    output [E203_XLEN-1:0] muldiv_o_wbck_wdat,\n    output muldiv_o_wbck_err,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    output muldiv_req_alu_add,\n    output muldiv_req_alu_sub,\n    input [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output muldiv_sbf_0_ena,\n    output [32:0] muldiv_sbf_0_nxt,\n    input [32:0] muldiv_sbf_0_r,\n    output muldiv_sbf_1_ena,\n    output [32:0] muldiv_sbf_1_nxt,\n    input [32:0] muldiv_sbf_1_r,\n    input clk,\n    input rst_n\n);\n\n// Internal signals\nreg [4:0] state;\nreg [4:0] next_state;\nreg [E203_XLEN-1:0] operand1, operand2;\nreg [E203_XLEN-1:0] result;\nwire ready;\nwire valid;\nreg [32:0] buffer0, buffer1;\n\n// State definitions\nlocalparam MULDIV_STATE_IDLE = 5'b00001;\nlocalparam MULDIV_STATE_EXEC = 5'b00010;\nlocalparam MULDIV_STATE_REMD_CHCK = 5'b00100;\nlocalparam MULDIV_STATE_QUOT_CORR = 5'b01000;\nlocalparam MULDIV_STATE_REMD_CORR = 5'b10000;\n\n// FSM for handling multiplier and divider operations\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        state <= MULDIV_STATE_IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (state)\n        MULDIV_STATE_IDLE: begin\n            if (muldiv_i_valid && !flush_pulse)\n                next_state = MULDIV_STATE_EXEC;\n            else\n                next_state = MULDIV_STATE_IDLE;\n        end\n        MULDIV_STATE_EXEC: begin\n            if (flush_pulse)\n                next_state = MULDIV_STATE_IDLE;\n            else if (/* execution complete */)\n                next_state = MULDIV_STATE_REMD_CHCK;\n            else\n                next_state = MULDIV_STATE_EXEC;\n        end\n        MULDIV_STATE_REMD_CHCK: begin\n            if (flush_pulse)\n                next_state = MULDIV_STATE_IDLE;\n            else if (/* remainder check needed */)\n                next_state = MULDIV_STATE_QUOT_CORR;\n            else\n                next_state = MULDIV_STATE_IDLE;\n        end\n        MULDIV_STATE_QUOT_CORR: begin\n            next_state = MULDIV_STATE_REMD_CORR;\n        end\n        MULDIV_STATE_REMD_CORR: begin\n            if (flush_pulse)\n                next_state = MULDIV_STATE_IDLE;\n            else\n                next_state = MULDIV_STATE_IDLE;\n        end\n        default: next_state = MULDIV_STATE_IDLE;\n    endcase\nend\n\n// Output logic\nassign muldiv_i_ready = (state == MULDIV_STATE_IDLE);\nassign muldiv_o_valid = (state == MULDIV_STATE_REMD_CORR);\nassign muldiv_o_wbck_wdat = result;\nassign muldiv_o_wbck_err = 0;\n\n// Example operation (simple model)\nalways @(posedge clk) begin\n    if (state == MULDIV_STATE_EXEC) begin\n        result <= operand1 * operand2; // Simple multiplication example\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 14, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_branchslv(\n    input wire cmt_i_valid,\n    output wire cmt_i_ready,\n    input wire cmt_i_rv32,\n    input wire cmt_i_dret,\n    input wire cmt_i_mret,\n    input wire cmt_i_fencei,\n    input wire cmt_i_bjp,\n    input wire cmt_i_bjp_prdt,\n    input wire cmt_i_bjp_rslv,\n    input wire [E203_PC_SIZE-1:0] cmt_i_pc,\n    input wire [E203_XLEN-1:0] cmt_i_imm,\n    input wire [E203_PC_SIZE-1:0] csr_epc_r,\n    input wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    input wire nonalu_excpirq_flush_req_raw,\n    input wire brchmis_flush_ack,\n    output wire brchmis_flush_req,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op1,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op2,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_pc,\n    output wire cmt_mret_ena,\n    output wire cmt_dret_ena,\n    output wire cmt_fencei_ena,\n    input wire clk,\n    input wire rst_n\n);\n\n    wire flush_need;\n    wire branch_mispredict;\n    wire special_inst_flush;\n    wire flush_target_calc;\n\n    assign branch_mispredict = cmt_i_bjp & (cmt_i_bjp_prdt ^ cmt_i_bjp_rslv);\n    assign special_inst_flush = cmt_i_fencei | cmt_i_mret | cmt_i_dret;\n\n    assign flush_need = cmt_i_valid & (branch_mispredict | special_inst_flush) & ~nonalu_excpirq_flush_req_raw;\n\n    assign brchmis_flush_req = flush_need & ~brchmis_flush_ack;\n\n    assign cmt_i_ready = ~cmt_i_valid | ~flush_need | brchmis_flush_ack;\n\n    assign cmt_mret_ena = cmt_i_mret & flush_need & brchmis_flush_ack;\n    assign cmt_dret_ena = cmt_i_dret & flush_need & brchmis_flush_ack;\n    assign cmt_fencei_ena = cmt_i_fencei & flush_need & brchmis_flush_ack;\n\n    `ifdef E203_TIMING_BOOST\n        assign brchmis_flush_pc = (cmt_i_fencei | (cmt_i_bjp & cmt_i_bjp_prdt)) ? (cmt_i_pc + (cmt_i_rv32 ? 4 : 2)) :\n                                  (cmt_i_bjp & ~cmt_i_bjp_prdt) ? (cmt_i_pc + cmt_i_imm[E203_PC_SIZE-1:0]) :\n                                  cmt_i_dret ? csr_dpc_r :\n                                  csr_epc_r;\n    `else\n        assign brchmis_flush_add_op1 = cmt_i_pc;\n        assign brchmis_flush_add_op2 = cmt_i_imm;\n    `endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 10, "code": "module e203_exu_alu_lsuagu (\n    input wire agu_i_valid,\n    output wire agu_i_ready,\n    input wire [E203_XLEN-1:0] agu_i_rs1,\n    input wire [E203_XLEN-1:0] agu_i_rs2,\n    input wire [E203_XLEN-1:0] agu_i_imm,\n    input wire [E203_DECINFO_AGU_WIDTH-1:0] agu_i_info,\n    input wire [E203_ITAG_WIDTH-1:0] agu_i_itag,\n    output wire agu_i_longpipe,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire amo_wait,\n    input wire oitf_empty,\n    output wire agu_o_valid,\n    input wire agu_o_ready,\n    output wire [E203_XLEN-1:0] agu_o_wbck_wdat,\n    output wire agu_o_wbck_err,\n    output wire agu_o_cmt_misalgn,\n    output wire agu_o_cmt_ld,\n    output wire agu_o_cmt_stamo,\n    output wire agu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] agu_o_cmt_badaddr,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_cmd_usign,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire [E203_XLEN-1:0] agu_req_alu_op1,\n    output wire [E203_XLEN-1:0] agu_req_alu_op2,\n    output wire agu_req_alu_swap,\n    output wire agu_req_alu_add,\n    output wire agu_req_alu_and,\n    output wire agu_req_alu_or,\n    output wire agu_req_alu_xor,\n    output wire agu_req_alu_max,\n    output wire agu_req_alu_min,\n    output wire agu_req_alu_maxu,\n    output wire agu_req_alu_minu,\n    input wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire agu_sbf_0_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_0_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_0_r,\n    output wire agu_sbf_1_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_1_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_1_r,\n    input wire clk,\n    input wire rst_n\n);\n    // Module implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 5, "code": "module e203_exu_excp(\n    output commit_trap,\n    output core_wfi,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input amo_wait,\n    input alu_excp_i_valid,\n    input alu_excp_i_ld,\n    input alu_excp_i_stamo,\n    input alu_excp_i_misalgn,\n    input alu_excp_i_buserr,\n    input alu_excp_i_ecall,\n    input alu_excp_i_ebreak,\n    input alu_excp_i_wfi,\n    input alu_excp_i_ifu_misalgn,\n    input alu_excp_i_ifu_buserr,\n    input alu_excp_i_ifu_ilegl,\n    input [E203_PC_SIZE-1:0] alu_excp_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_excp_i_instr,\n    input alu_excp_i_pc_vld,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input longp_excp_i_insterr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input excpirq_flush_ack,\n    output excpirq_flush_req,\n    output nonalu_excpirq_flush_req_raw,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op1,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op2,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input cmt_dret_ena,\n    input cmt_ena,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_badaddr_ena,\n    output cmt_epc_ena,\n    output cmt_cause_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output excp_active,\n    input clk,\n    input rst_n\n);\n    // Internal signal declarations\n    reg core_wfi_reg;\n    reg wfi_halt_ifu_req_reg;\n    reg wfi_halt_exu_req_reg;\n    reg commit_trap_reg;\n    reg excp_active_reg;\n\n    // Exception handling logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            core_wfi_reg <= 1'b0;\n            wfi_halt_ifu_req_reg <= 1'b0;\n            wfi_halt_exu_req_reg <= 1'b0;\n            commit_trap_reg <= 1'b0;\n            excp_active_reg <= 1'b0;\n        end else begin\n            // Handle WFI state entry\n            if (alu_excp_i_wfi && cmt_ena && !dbg_mode) begin\n                core_wfi_reg <= 1'b1;\n                wfi_halt_ifu_req_reg <= 1'b1;\n                wfi_halt_exu_req_reg <= 1'b1;\n            end\n            // Handle WFI state exit\n            if ((wfi_halt_ifu_ack && wfi_halt_exu_ack) || dbg_irq_r) begin\n                core_wfi_reg <= 1'b0;\n                wfi_halt_ifu_req_reg <= 1'b0;\n                wfi_halt_exu_req_reg <= 1'b0;\n            end\n            // Handle exceptions\n            if (alu_excp_i_valid || longp_excp_i_valid) begin\n                commit_trap_reg <= 1'b1;\n                excp_active_reg <= 1'b1;\n            end else begin\n                commit_trap_reg <= 1'b0;\n                excp_active_reg <= 1'b0;\n            end\n        end\n    end\n\n    // Output assignments\n    assign core_wfi = core_wfi_reg;\n    assign wfi_halt_ifu_req = wfi_halt_ifu_req_reg;\n    assign wfi_halt_exu_req = wfi_halt_exu_req_reg;\n    assign commit_trap = commit_trap_reg;\n    assign excp_active = excp_active_reg;\n\n    // Additional logic for exception handling, pipeline flushing, etc.\n    // would be implemented here based on the full specification requirements.\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 12, "code": "module e203_exu_oitf #(\n  parameter E203_ITAG_WIDTH = 4,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_PC_SIZE = 32,\n  parameter E203_OITF_DEPTH = 16\n)(\n  input clk,\n  input rst_n,\n\n  // Dispatch interface\n  input dis_ena,\n  output reg dis_ready,\n  input [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n  input disp_i_rdwen,\n  input disp_i_rdfpu,\n  input [E203_PC_SIZE-1:0] disp_i_pc,\n\n  // Retirement interface\n  input ret_ena,\n  output reg [E203_RFIDX_WIDTH-1:0] ret_rdidx,\n  output reg ret_rdwen,\n  output reg ret_rdfpu,\n  output reg [E203_PC_SIZE-1:0] ret_pc,\n\n  // Dependency checking outputs\n  output reg oitfrd_match_disprs1,\n  output reg oitfrd_match_disprs2,\n  output reg oitfrd_match_disprs3,\n  output reg oitfrd_match_disprd,\n  output reg oitf_empty\n);\n\n  // Internal OITF storage\n  reg [E203_RFIDX_WIDTH-1:0] rdidx [0:E203_OITF_DEPTH-1];\n  reg [E203_PC_SIZE-1:0] pc [0:E203_OITF_DEPTH-1];\n  reg rdwen [0:E203_OITF_DEPTH-1];\n  reg rdfpu [0:E203_OITF_DEPTH-1];\n  reg [E203_ITAG_WIDTH-1:0] dis_ptr, ret_ptr;\n  reg full, empty;\n\n  // Initialize pointers and flags\n  initial begin\n    dis_ptr = 0;\n    ret_ptr = 0;\n    full = 0;\n    empty = 1;\n  end\n\n  // Dispatch logic\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      dis_ptr <= 0;\n      full <= 0;\n      empty <= 1;\n    end else if (dis_ena && dis_ready) begin\n      rdidx[dis_ptr] <= disp_i_rdidx;\n      pc[dis_ptr] <= disp_i_pc;\n      rdwen[dis_ptr] <= disp_i_rdwen;\n      rdfpu[dis_ptr] <= disp_i_rdfpu;\n      dis_ptr <= (dis_ptr + 1) % E203_OITF_DEPTH;\n      full <= (dis_ptr + 1) % E203_OITF_DEPTH == ret_ptr;\n      empty <= 0;\n    end\n  end\n\n  // Retirement logic\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      ret_ptr <= 0;\n      empty <= 1;\n    end else if (ret_ena && !empty) begin\n      ret_rdidx <= rdidx[ret_ptr];\n      ret_pc <= pc[ret_ptr];\n      ret_rdwen <= rdwen[ret_ptr];\n      ret_rdfpu <= rdfpu[ret_ptr];\n      ret_ptr <= (ret_ptr + 1) % E203_OITF_DEPTH;\n      empty <= ret_ptr + 1 == dis_ptr;\n      full <= 0;\n    end\n  end\n\n  // Dependency checking logic\n  integer i;\n  always @(*) begin\n    oitfrd_match_disprs1 = 0;\n    oitfrd_match_disprs2 = 0;\n    oitfrd_match_disprs3 = 0;\n    oitfrd_match_disprd = 0;\n    for (i = ret_ptr; i != dis_ptr; i = (i + 1) % E203_OITF_DEPTH) begin\n      if (rdwen[i]) begin\n        if (disp_i_rdidx == rdidx[i]) oitfrd_match_disprd = 1;\n      end\n    end\n  end\n\n  // Update dis_ready based on full flag\n  always @(*) begin\n    dis_ready = !full;\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 11, "code": "module e203_ifu_minidec (\n    input [E203_INSTR_SIZE-1:0] instr,\n    output reg dec_rs1en,\n    output reg dec_rs2en,\n    output reg [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n    output reg [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n    output reg dec_mulhsu,\n    output reg dec_mul,\n    output reg dec_div,\n    output reg dec_rem,\n    output reg dec_divu,\n    output reg dec_remu,\n    output reg dec_rv32,\n    output reg dec_bjp,\n    output reg dec_jal,\n    output reg dec_jalr,\n    output reg dec_bxx,\n    output reg [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    output reg [E203_XLEN-1:0] dec_bjp_imm\n);\n\n    // Internal signals for decoding\n    wire [6:0] opcode;\n    wire [2:0] funct3;\n    wire [6:0] funct7;\n\n    assign opcode = instr[6:0];\n    assign funct3 = instr[14:12];\n    assign funct7 = instr[31:25];\n\n    always @(*) begin\n        // Default assignments\n        dec_rs1en = 1'b0;\n        dec_rs2en = 1'b0;\n        dec_rs1idx = {E203_RFIDX_WIDTH{1'b0}};\n        dec_rs2idx = {E203_RFIDX_WIDTH{1'b0}};\n        dec_mulhsu = 1'b0;\n        dec_mul = 1'b0;\n        dec_div = 1'b0;\n        dec_rem = 1'b0;\n        dec_divu = 1'b0;\n        dec_remu = 1'b0;\n        dec_rv32 = 1'b1; // Assuming RV32\n        dec_bjp = 1'b0;\n        dec_jal = 1'b0;\n        dec_jalr = 1'b0;\n        dec_bxx = 1'b0;\n        dec_jalr_rs1idx = {E203_RFIDX_WIDTH{1'b0}};\n        dec_bjp_imm = {E203_XLEN{1'b0}};\n\n        case (opcode)\n            7'b0110011: begin // R-type\n                dec_rs1en = 1'b1;\n                dec_rs2en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_rs2idx = instr[24:20];\n                case (funct3)\n                    3'b000: begin\n                        if (funct7 == 7'b0000001) begin\n                            dec_mul = 1'b1;\n                        end\n                    end\n                    3'b001: begin\n                        if (funct7 == 7'b0000001) begin\n                            dec_mulhsu = 1'b1;\n                        end\n                    end\n                endcase\n            end\n            7'b1101111: begin // JAL\n                dec_jal = 1'b1;\n                dec_bjp = 1'b1;\n                dec_bjp_imm = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0};\n            end\n            7'b1100111: begin // JALR\n                dec_jalr = 1'b1;\n                dec_bjp = 1'b1;\n                dec_jalr_rs1idx = instr[19:15];\n                dec_bjp_imm = {{20{instr[31]}}, instr[31:20]};\n            end\n            7'b1100011: begin // Branches\n                dec_bxx = 1'b1;\n                dec_bjp = 1'b1;\n                dec_rs1en = 1'b1;\n                dec_rs2en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_rs2idx = instr[24:20];\n                dec_bjp_imm = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};\n            end\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 11, "code": "module e203_exu_alu_dpath(\n    input wire alu_req_alu,\n    input wire alu_req_alu_add,\n    input wire alu_req_alu_sub,\n    input wire alu_req_alu_xor,\n    input wire alu_req_alu_sll,\n    input wire alu_req_alu_srl,\n    input wire alu_req_alu_sra,\n    input wire alu_req_alu_or,\n    input wire alu_req_alu_and,\n    input wire [E203_XLEN-1:0] alu_req_alu_op1,\n    input wire [E203_XLEN-1:0] alu_req_alu_op2,\n    input wire bjp_req_alu,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    input wire agu_req_alu,\n    input wire [E203_XLEN-1:0] agu_req_alu_op1,\n    input wire [E203_XLEN-1:0] agu_req_alu_op2,\n    input wire muldiv_req_alu,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    input wire muldiv_req_alu_add,\n    input wire muldiv_req_alu_sub,\n    input wire muldiv_sbf_0_ena,\n    input wire [32:0] muldiv_sbf_0_nxt,\n    input wire muldiv_sbf_1_ena,\n    input wire [32:0] muldiv_sbf_1_nxt,\n    input wire clk,\n    input wire rst_n,\n    output wire [E203_XLEN-1:0] alu_req_alu_res,\n    output wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    output wire bjp_req_alu_cmp_res,\n    output wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output wire [32:0] muldiv_sbf_0_r,\n    output wire [32:0] muldiv_sbf_1_r\n);\n\n    // Internal signals for ALU operations\n    wire [E203_XLEN-1:0] add_result;\n    wire [E203_XLEN-1:0] sub_result;\n    wire [E203_XLEN-1:0] and_result;\n    wire [E203_XLEN-1:0] or_result;\n    wire [E203_XLEN-1:0] xor_result;\n    wire [E203_XLEN-1:0] sll_result;\n    wire [E203_XLEN-1:0] srl_result;\n    wire [E203_XLEN-1:0] sra_result;\n\n    // ALU operation implementations\n    assign add_result = alu_req_alu_op1 + alu_req_alu_op2;\n    assign sub_result = alu_req_alu_op1 - alu_req_alu_op2;\n    assign and_result = alu_req_alu_op1 & alu_req_alu_op2;\n    assign or_result = alu_req_alu_op1 | alu_req_alu_op2;\n    assign xor_result = alu_req_alu_op1 ^ alu_req_alu_op2;\n    assign sll_result = alu_req_alu_op1 << alu_req_alu_op2[E203_XLEN-1:0];\n    assign srl_result = alu_req_alu_op1 >> alu_req_alu_op2[E203_XLEN-1:0];\n    assign sra_result = $signed(alu_req_alu_op1) >>> alu_req_alu_op2[E203_XLEN-1:0];\n\n    // Result multiplexing\n    assign alu_req_alu_res = ({E203_XLEN{alu_req_alu_add}} & add_result) |\n                             ({E203_XLEN{alu_req_alu_sub}} & sub_result) |\n                             ({E203_XLEN{alu_req_alu_and}} & and_result) |\n                             ({E203_XLEN{alu_req_alu_or}} & or_result) |\n                             ({E203_XLEN{alu_req_alu_xor}} & xor_result) |\n                             ({E203_XLEN{alu_req_alu_sll}} & sll_result) |\n                             ({E203_XLEN{alu_req_alu_srl}} & srl_result) |\n                             ({E203_XLEN{alu_req_alu_sra}} & sra_result);\n\n    // BJP, AGU, and MULDIV results\n    assign bjp_req_alu_add_res = bjp_req_alu_op1 + bjp_req_alu_op2;\n    assign bjp_req_alu_cmp_res = (bjp_req_alu_op1 == bjp_req_alu_op2);\n    assign agu_req_alu_res = agu_req_alu_op1 + agu_req_alu_op2; // Example for AGU add operation\n    assign muldiv_req_alu_res = (muldiv_req_alu_add ? muldiv_req_alu_op1 + muldiv_req_alu_op2 :\n                                muldiv_req_alu_sub ? muldiv_req_alu_op1 - muldiv_req_alu_op2 : 0);\n\n    // Shared buffer management\n    sirv_gnrl_dffl #(.DW(33)) sbf_0_dffl (\n        .lden(muldiv_sbf_0_ena),\n        .dnxt(muldiv_sbf_0_nxt),\n        .qout(muldiv_sbf_0_r),\n        .clk(clk)\n    );\n\n    sirv_gnrl_dffl #(.DW(33)) sbf_1_dffl (\n        .lden(muldiv_sbf_1_ena),\n        .dnxt(muldiv_sbf_1_nxt),\n        .qout(muldiv_sbf_1_r),\n        .clk(clk)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 12, "code": "module e203_ifu_minidec #(\n  parameter E203_INSTR_SIZE = 32,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_XLEN = 32\n)(\n  input [E203_INSTR_SIZE-1:0] instr,\n  output dec_rs1en,\n  output dec_rs2en,\n  output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n  output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n  output dec_mulhsu,\n  output dec_mul,\n  output dec_div,\n  output dec_rem,\n  output dec_divu,\n  output dec_remu,\n  output dec_rv32,\n  output dec_bjp,\n  output dec_jal,\n  output dec_jalr,\n  output dec_bxx,\n  output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  output [E203_XLEN-1:0] dec_bjp_imm\n);\n\n  // Internal signals for decoding\n  wire [6:0] opcode = instr[6:0];\n  wire [2:0] funct3 = instr[14:12];\n  wire [6:0] funct7 = instr[31:25];\n\n  // Decode logic for register indices\n  assign dec_rs1idx = instr[19:15];\n  assign dec_rs2idx = instr[24:20];\n  assign dec_jalr_rs1idx = instr[19:15];\n\n  // Decode logic for register enable signals\n  assign dec_rs1en = (opcode == 7'b1100111 || opcode == 7'b0000011 || opcode == 7'b0100011);\n  assign dec_rs2en = (opcode == 7'b0100011);\n\n  // Decode logic for operation type flags\n  assign dec_mul = (opcode == 7'b0110011 && funct7 == 7'b0000001 && funct3 == 3'b000);\n  assign dec_mulhsu = (opcode == 7'b0110011 && funct7 == 7'b0000001 && funct3 == 3'b010);\n  assign dec_div = (opcode == 7'b0110011 && funct7 == 7'b0000001 && funct3 == 3'b100);\n  assign dec_divu = (opcode == 7'b0110011 && funct7 == 7'b0000001 && funct3 == 3'b101);\n  assign dec_rem = (opcode == 7'b0110011 && funct7 == 7'b0000001 && funct3 == 3'b110);\n  assign dec_remu = (opcode == 7'b0110011 && funct7 == 7'b0000001 && funct3 == 3'b111);\n\n  // Decode logic for branch and jump instructions\n  assign dec_bjp = (opcode == 7'b1100011 || opcode == 7'b1101111 || opcode == 7'b1100111);\n  assign dec_jal = (opcode == 7'b1101111);\n  assign dec_jalr = (opcode == 7'b1100111);\n  assign dec_bxx = (opcode == 7'b1100011);\n\n  // Immediate extraction for branch/jump instructions\n  assign dec_bjp_imm = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};\n\n  // RV32 instruction set flag\n  assign dec_rv32 = 1'b1; // Assuming only RV32 instructions are used\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 13, "code": "module e203_exu_wbck (\n    input wire alu_wbck_i_valid,\n    output reg alu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] alu_wbck_i_wdat,\n    input wire [E203_RFIDX_WIDTH-1:0] alu_wbck_i_rdidx,\n    input wire longp_wbck_i_valid,\n    output reg longp_wbck_i_ready,\n    input wire [E203_FLEN-1:0] longp_wbck_i_wdat,\n    input wire [4:0] longp_wbck_i_flags,\n    input wire [E203_RFIDX_WIDTH-1:0] longp_wbck_i_rdidx,\n    input wire longp_wbck_i_rdfpu,\n    output reg rf_wbck_o_ena,\n    output reg [E203_XLEN-1:0] rf_wbck_o_wdat,\n    output reg [E203_RFIDX_WIDTH-1:0] rf_wbck_o_rdidx,\n    input wire clk,\n    input wire rst_n\n);\n\n    always @(*) begin\n        // Default assignments\n        alu_wbck_i_ready = 1'b0;\n        longp_wbck_i_ready = 1'b0;\n        rf_wbck_o_ena = 1'b0;\n        rf_wbck_o_wdat = {E203_XLEN{1'b0}};\n        rf_wbck_o_rdidx = {E203_RFIDX_WIDTH{1'b0}};\n\n        // Long-pipeline write-back has higher priority\n        if (longp_wbck_i_valid) begin\n            longp_wbck_i_ready = 1'b1;\n            rf_wbck_o_ena = ~longp_wbck_i_rdfpu;\n            rf_wbck_o_wdat = longp_wbck_i_wdat[E203_XLEN-1:0]; // Assuming E203_FLEN >= E203_XLEN\n            rf_wbck_o_rdidx = longp_wbck_i_rdidx;\n        end else if (alu_wbck_i_valid) begin\n            alu_wbck_i_ready = 1'b1;\n            rf_wbck_o_ena = 1'b1;\n            rf_wbck_o_wdat = alu_wbck_i_wdat;\n            rf_wbck_o_rdidx = alu_wbck_i_rdidx;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 14, "code": "module e203_exu_alu_csrctrl (\n    input wire csr_i_valid,\n    output reg csr_i_ready,\n    input wire [E203_XLEN-1:0] csr_i_rs1,\n    input wire [E203_DECINFO_CSR_WIDTH-1:0] csr_i_info,\n    input wire csr_i_rdwen,\n    output reg csr_ena,\n    output reg csr_wr_en,\n    output reg csr_rd_en,\n    output reg [11:0] csr_idx,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output reg [E203_XLEN-1:0] wbck_csr_dat,\n    output reg csr_o_valid,\n    input wire csr_o_ready,\n    output reg [E203_XLEN-1:0] csr_o_wbck_wdat,\n    output reg csr_o_wbck_err,\n    input wire clk,\n    input wire rst_n\n);\n\n    wire csrrw = csr_i_info[E203_DECINFO_CSR_CSRRW];\n    wire csrrs = csr_i_info[E203_DECINFO_CSR_CSRRS];\n    wire csrrc = csr_i_info[E203_DECINFO_CSR_CSRRC];\n    wire rs1imm = csr_i_info[E203_DECINFO_CSR_RS1IMM];\n    wire rs1is0 = csr_i_info[E203_DECINFO_CSR_RS1IS0];\n    wire [11:0] csr_id = csr_i_info[E203_DECINFO_CSR_CSRIDX];\n\n    reg [E203_XLEN-1:0] csr_op1;\n\n    always @(*) begin\n        if (rs1imm) begin\n            csr_op1 = {E203_XLEN{1'b0}} | csr_id; // Immediate value from csr_id\n        end else begin\n            csr_op1 = csr_i_rs1; // Register value from csr_i_rs1\n        end\n    end\n\n    always @(*) begin\n        csr_idx = csr_id;\n        csr_rd_en = (csrrw & csr_i_rdwen) | csrrs | csrrc;\n        csr_wr_en = (csrrw | (csrrs & ~rs1is0) | (csrrc & ~rs1is0)) & csr_i_valid;\n        csr_ena = csr_i_valid & csr_o_ready & ~csr_access_ilgl;\n\n        csr_i_ready = csr_o_ready;\n        csr_o_valid = csr_i_valid & csr_o_ready;\n\n        if (csrrw) begin\n            wbck_csr_dat = csr_op1;\n        end else if (csrrs) begin\n            wbck_csr_dat = read_csr_dat | csr_op1;\n        end else if (csrrc) begin\n            wbck_csr_dat = read_csr_dat & ~csr_op1;\n        end else begin\n            wbck_csr_dat = {E203_XLEN{1'b0}};\n        end\n\n        csr_o_wbck_wdat = read_csr_dat;\n        csr_o_wbck_err = csr_access_ilgl;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 16, "code": "module e203_reset_ctrl #(\n    parameter MASTER = 1,\n    parameter RST_SYNC_LEVEL = `E203_ASYNC_FF_LEVELS\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    output reg rst_core,\n    `ifdef E203_HAS_ITCM\n    output reg rst_itcm,\n    `endif\n    `ifdef E203_HAS_DTCM\n    output reg rst_dtcm,\n    `endif\n    output reg rst_aon\n);\n\nreg [RST_SYNC_LEVEL-1:0] rst_sync;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        rst_sync <= {RST_SYNC_LEVEL{1'b1}};\n    end else if (test_mode) begin\n        rst_sync <= {RST_SYNC_LEVEL{rst_n}};\n    end else begin\n        rst_sync <= {rst_sync[RST_SYNC_LEVEL-2:0], 1'b1};\n    end\nend\n\nalways @(*) begin\n    if (test_mode) begin\n        rst_core = rst_n;\n        `ifdef E203_HAS_ITCM\n        rst_itcm = rst_n;\n        `endif\n        `ifdef E203_HAS_DTCM\n        rst_dtcm = rst_n;\n        `endif\n        rst_aon = rst_n;\n    end else if (MASTER == 1) begin\n        rst_core = rst_sync[RST_SYNC_LEVEL-1];\n        `ifdef E203_HAS_ITCM\n        rst_itcm = rst_sync[RST_SYNC_LEVEL-1];\n        `endif\n        `ifdef E203_HAS_DTCM\n        rst_dtcm = rst_sync[RST_SYNC_LEVEL-1];\n        `endif\n        rst_aon = rst_sync[RST_SYNC_LEVEL-1];\n    end else begin\n        rst_core = rst_n;\n        `ifdef E203_HAS_ITCM\n        rst_itcm = rst_n;\n        `endif\n        `ifdef E203_HAS_DTCM\n        rst_dtcm = rst_n;\n        `endif\n        rst_aon = rst_n;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 13, "code": "module e203_exu_oitf #(\n  parameter E203_ITAG_WIDTH = 4,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_PC_SIZE = 32,\n  parameter E203_OITF_DEPTH = 16\n)(\n  input clk,\n  input rst_n,\n  \n  output reg dis_ready,\n  input dis_ena,\n  input ret_ena,\n  \n  output [E203_ITAG_WIDTH-1:0] dis_ptr,\n  output [E203_ITAG_WIDTH-1:0] ret_ptr,\n  output [E203_RFIDX_WIDTH-1:0] ret_rdidx,\n  output ret_rdwen,\n  output ret_rdfpu,\n  output [E203_PC_SIZE-1:0] ret_pc,\n  \n  input disp_i_rs1en,\n  input disp_i_rs2en,\n  input disp_i_rs3en,\n  input disp_i_rdwen,\n  input disp_i_rs1fpu,\n  input disp_i_rs2fpu,\n  input disp_i_rs3fpu,\n  input disp_i_rdfpu,\n  input [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n  input [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n  input [E203_RFIDX_WIDTH-1:0] disp_i_rs3idx,\n  input [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n  input [E203_PC_SIZE-1:0] disp_i_pc,\n  \n  output oitfrd_match_disprs1,\n  output oitfrd_match_disprs2,\n  output oitfrd_match_disprs3,\n  output oitfrd_match_disprd,\n  output oitf_empty,\n  \n  input wire rst_n,\n  input wire clk\n);\n\n  reg [E203_RFIDX_WIDTH-1:0] rdidx [0:E203_OITF_DEPTH-1];\n  reg [E203_PC_SIZE-1:0] pc [0:E203_OITF_DEPTH-1];\n  reg [E203_OITF_DEPTH-1:0] rdwen;\n  reg [E203_OITF_DEPTH-1:0] rdfpu;\n  reg [E203_ITAG_WIDTH-1:0] head, tail;\n  reg full, empty;\n\n  wire wrap = (head == tail) && (full || empty);\n\n  assign dis_ready = !full;\n  assign oitf_empty = empty;\n  assign dis_ptr = tail;\n  assign ret_ptr = head;\n  assign ret_rdidx = rdidx[head];\n  assign ret_rdwen = rdwen[head];\n  assign ret_rdfpu = rdfpu[head];\n  assign ret_pc = pc[head];\n\n  integer i;\n  assign oitfrd_match_disprs1 = (disp_i_rs1en && |({E203_OITF_DEPTH{disp_i_rs1fpu}} & rdfpu & rdwen & (rdidx == {E203_OITF_DEPTH{disp_i_rs1idx}})));\n  assign oitfrd_match_disprs2 = (disp_i_rs2en && |({E203_OITF_DEPTH{disp_i_rs2fpu}} & rdfpu & rdwen & (rdidx == {E203_OITF_DEPTH{disp_i_rs2idx}})));\n  assign oitfrd_match_disprs3 = (disp_i_rs3en && |({E203_OITF_DEPTH{disp_i_rs3fpu}} & rdfpu & rdwen & (rdidx == {E203_OITF_DEPTH{disp_i_rs3idx}})));\n  assign oitfrd_match_disprd = (disp_i_rdwen && |(rdfpu & rdwen & (rdidx == {E203_OITF_DEPTH{disp_i_rdidx}})));\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      head <= 0;\n      tail <= 0;\n      full <= 0;\n      empty <= 1;\n      for (i = 0; i < E203_OITF_DEPTH; i = i + 1) begin\n        rdidx[i] <= 0;\n        pc[i] <= 0;\n        rdwen[i] <= 0;\n        rdfpu[i] <= 0;\n      end\n    end else begin\n      if (dis_ena && dis_ready) begin\n        rdidx[tail] <= disp_i_rdidx;\n        pc[tail] <= disp_i_pc;\n        rdwen[tail] <= disp_i_rdwen;\n        rdfpu[tail] <= disp_i_rdfpu;\n        tail <= tail + 1;\n        empty <= 0;\n        if (wrap) full <= 1;\n      end\n      if (ret_ena && !empty) begin\n        head <= head + 1;\n        full <= 0;\n        if (wrap) empty <= 1;\n      end\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 13, "code": "module e203_exu_alu_muldiv(\n    input mdv_nob2b,\n    input muldiv_i_valid,\n    output muldiv_i_ready,\n    input [E203_XLEN-1:0] muldiv_i_rs1,\n    input [E203_XLEN-1:0] muldiv_i_rs2,\n    input [E203_XLEN-1:0] muldiv_i_imm,\n    input [E203_DECINFO_MULDIV_WIDTH-1:0] muldiv_i_info,\n    input [E203_ITAG_WIDTH-1:0] muldiv_i_itag,\n    output muldiv_i_longpipe,\n    input flush_pulse,\n    output muldiv_o_valid,\n    input muldiv_o_ready,\n    output [E203_XLEN-1:0] muldiv_o_wbck_wdat,\n    output muldiv_o_wbck_err,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    output muldiv_req_alu_add,\n    output muldiv_req_alu_sub,\n    input [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output muldiv_sbf_0_ena,\n    output [32:0] muldiv_sbf_0_nxt,\n    input [32:0] muldiv_sbf_0_r,\n    output muldiv_sbf_1_ena,\n    output [32:0] muldiv_sbf_1_nxt,\n    input [32:0] muldiv_sbf_1_r,\n    input clk,\n    input rst_n\n);\n\n// Internal signals and registers\nreg [4:0] state;\nreg [4:0] next_state;\n\n// State definitions\nlocalparam MULDIV_STATE_0TH = 5'd0;\nlocalparam MULDIV_STATE_EXEC = 5'd1;\nlocalparam MULDIV_STATE_REMD_CHCK = 5'd2;\nlocalparam MULDIV_STATE_QUOT_CORR = 5'd3;\nlocalparam MULDIV_STATE_REMD_CORR = 5'd4;\n\n// FSM for managing multiplier and divider operations\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        state <= MULDIV_STATE_0TH;\n    end else if (flush_pulse) begin\n        state <= MULDIV_STATE_0TH;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (state)\n        MULDIV_STATE_0TH: begin\n            if (muldiv_i_valid && !flush_pulse)\n                next_state = MULDIV_STATE_EXEC;\n            else\n                next_state = MULDIV_STATE_0TH;\n        end\n        MULDIV_STATE_EXEC: begin\n            if (flush_pulse)\n                next_state = MULDIV_STATE_0TH;\n            else\n                next_state = MULDIV_STATE_REMD_CHCK;\n        end\n        MULDIV_STATE_REMD_CHCK: begin\n            if (flush_pulse)\n                next_state = MULDIV_STATE_0TH;\n            else\n                next_state = MULDIV_STATE_QUOT_CORR;\n        end\n        MULDIV_STATE_QUOT_CORR: begin\n            next_state = MULDIV_STATE_REMD_CORR;\n        end\n        MULDIV_STATE_REMD_CORR: begin\n            if (flush_pulse)\n                next_state = MULDIV_STATE_0TH;\n            else\n                next_state = MULDIV_STATE_0TH;\n        end\n        default: begin\n            next_state = MULDIV_STATE_0TH;\n        end\n    endcase\nend\n\n// Output logic and other processing logic\nassign muldiv_i_ready = (state == MULDIV_STATE_0TH);\nassign muldiv_o_valid = (state == MULDIV_STATE_REMD_CORR);\nassign muldiv_o_wbck_wdat = muldiv_req_alu_res; // Simplified example\nassign muldiv_o_wbck_err = 1'b0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 15, "code": "module e203_exu_branchslv(\n    input wire cmt_i_valid,\n    output wire cmt_i_ready,\n    input wire cmt_i_rv32,\n    input wire cmt_i_dret,\n    input wire cmt_i_mret,\n    input wire cmt_i_fencei,\n    input wire cmt_i_bjp,\n    input wire cmt_i_bjp_prdt,\n    input wire cmt_i_bjp_rslv,\n    input wire [E203_PC_SIZE-1:0] cmt_i_pc,\n    input wire [E203_XLEN-1:0] cmt_i_imm,\n    input wire [E203_PC_SIZE-1:0] csr_epc_r,\n    input wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    input wire nonalu_excpirq_flush_req_raw,\n    input wire brchmis_flush_ack,\n    output wire brchmis_flush_req,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op1,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op2,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_pc,\n    output wire cmt_mret_ena,\n    output wire cmt_dret_ena,\n    output wire cmt_fencei_ena,\n    input wire clk,\n    input wire rst_n\n);\n\n    wire flush_need;\n    wire flush_target_mret;\n    wire flush_target_dret;\n    wire flush_target_fencei;\n    wire flush_target_bjp_mis;\n\n    assign flush_need = (cmt_i_fencei | cmt_i_mret | cmt_i_dret |\n                         (cmt_i_bjp & (cmt_i_bjp_prdt ^ cmt_i_bjp_rslv)));\n\n    assign flush_target_mret = cmt_i_mret;\n    assign flush_target_dret = cmt_i_dret;\n    assign flush_target_fencei = cmt_i_fencei;\n    assign flush_target_bjp_mis = cmt_i_bjp & (cmt_i_bjp_prdt ^ cmt_i_bjp_rslv);\n\n    assign brchmis_flush_req = flush_need & cmt_i_valid & ~nonalu_excpirq_flush_req_raw;\n\n    assign cmt_i_ready = ~flush_need & ~nonalu_excpirq_flush_req_raw | brchmis_flush_ack;\n\n    assign cmt_mret_ena = cmt_i_mret;\n    assign cmt_dret_ena = cmt_i_dret;\n    assign cmt_fencei_ena = cmt_i_fencei;\n\n    // Calculate flush target address\n    always @(*) begin\n        if (flush_target_dret) begin\n            brchmis_flush_pc = csr_dpc_r;\n        end else if (flush_target_mret) begin\n            brchmis_flush_pc = csr_epc_r;\n        end else if (flush_target_fencei || (flush_target_bjp_mis && cmt_i_bjp_prdt && !cmt_i_bjp_rslv)) begin\n            brchmis_flush_pc = cmt_i_pc + (cmt_i_rv32 ? 4 : 2);\n        end else if (flush_target_bjp_mis && !cmt_i_bjp_prdt && cmt_i_bjp_rslv) begin\n            brchmis_flush_pc = cmt_i_pc + cmt_i_imm[E203_PC_SIZE-1:0];\n        end else begin\n            brchmis_flush_pc = csr_epc_r;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 12, "code": "module e203_irq_sync (\n    input wire clk,\n    input wire rst_n,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire dbg_irq_a,\n    output wire ext_irq_r,\n    output wire sft_irq_r,\n    output wire tmr_irq_r,\n    output wire dbg_irq_r\n);\n\n    // Synchronization instances for each interrupt type\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) ext_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(ext_irq_a),\n        .dout(ext_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) sft_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(sft_irq_a),\n        .dout(sft_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) tmr_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(tmr_irq_a),\n        .dout(tmr_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) dbg_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(dbg_irq_a),\n        .dout(dbg_irq_r)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 15, "code": "module e203_exu_alu_csrctrl (\n    input wire csr_i_valid,\n    output reg csr_i_ready,\n    input wire [E203_XLEN-1:0] csr_i_rs1,\n    input wire [E203_DECINFO_CSR_WIDTH-1:0] csr_i_info,\n    input wire csr_i_rdwen,\n    output reg csr_ena,\n    output reg csr_wr_en,\n    output reg csr_rd_en,\n    output reg [11:0] csr_idx,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output reg [E203_XLEN-1:0] wbck_csr_dat,\n    output reg csr_o_valid,\n    input wire csr_o_ready,\n    output reg [E203_XLEN-1:0] csr_o_wbck_wdat,\n    output reg csr_o_wbck_err,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Decode CSR instruction information\n    wire csrrw = csr_i_info[E203_DECINFO_CSR_CSRRW];\n    wire csrrs = csr_i_info[E203_DECINFO_CSR_CSRRS];\n    wire csrrc = csr_i_info[E203_DECINFO_CSR_CSRRC];\n    wire rs1imm = csr_i_info[E203_DECINFO_CSR_RS1IMM];\n    wire rs1is0 = csr_i_info[E203_DECINFO_CSR_RS1IS0];\n    wire [4:0] zimm = csr_i_info[E203_DECINFO_CSR_ZIMMM];\n    wire [11:0] csr_idx_info = csr_i_info[E203_DECINFO_CSR_CSRIDX];\n\n    // Prepare operand 1\n    wire [E203_XLEN-1:0] csr_op1 = rs1imm ? {E203_XLEN-5{1'b0}, zimm} : csr_i_rs1;\n\n    // Control signal logic\n    always @(*) begin\n        csr_i_ready = csr_o_ready;\n        csr_o_valid = csr_i_valid && csr_o_ready;\n        csr_idx = csr_idx_info;\n        csr_ena = csr_i_valid && csr_o_ready && !csr_access_ilgl;\n\n        // Read enable logic\n        csr_rd_en = csr_i_valid && ((csrrw && csr_i_rdwen) || csrrs || csrrc);\n\n        // Write enable logic\n        csr_wr_en = csr_i_valid && (csrrw || (csrrs && !rs1is0) || (csrrc && !rs1is0));\n\n        // Write-back data logic\n        wbck_csr_dat = (csrrw ? csr_op1 :\n                        csrrs ? (read_csr_dat | csr_op1) :\n                        csrrc ? (read_csr_dat & ~csr_op1) : read_csr_dat);\n\n        // Error handling\n        csr_o_wbck_err = csr_access_ilgl;\n        csr_o_wbck_wdat = read_csr_dat;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 16, "code": "module e203_exu_alu_csrctrl(\n    input wire csr_i_valid,\n    output reg csr_i_ready,\n    input wire [E203_XLEN-1:0] csr_i_rs1,\n    input wire [E203_DECINFO_CSR_WIDTH-1:0] csr_i_info,\n    input wire csr_i_rdwen,\n    output reg csr_ena,\n    output reg csr_wr_en,\n    output reg csr_rd_en,\n    output reg [11:0] csr_idx,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output reg [E203_XLEN-1:0] wbck_csr_dat,\n    output reg csr_o_valid,\n    input wire csr_o_ready,\n    output reg [E203_XLEN-1:0] csr_o_wbck_wdat,\n    output reg csr_o_wbck_err,\n    input wire clk,\n    input wire rst_n,\n    input wire nice_xs_off,\n    output reg csr_sel_nice,\n    output reg nice_csr_valid,\n    input wire nice_csr_ready,\n    output reg [31:0] nice_csr_addr,\n    output reg nice_csr_wr,\n    output reg [31:0] nice_csr_wdata,\n    input wire [31:0] nice_csr_rdata\n);\n\n    // Decode CSR instruction information\n    wire csrrw = csr_i_info[E203_DECINFO_CSR_CSRRW];\n    wire csrrs = csr_i_info[E203_DECINFO_CSR_CSRRS];\n    wire csrrc = csr_i_info[E203_DECINFO_CSR_CSRRC];\n    wire rs1imm = csr_i_info[E203_DECINFO_CSR_RS1IMM];\n    wire rs1is0 = csr_i_info[E203_DECINFO_CSR_RS1IS0];\n    wire [4:0] zimm = csr_i_info[E203_DECINFO_CSR_ZIMMM];\n    wire [11:0] csr_idx_info = csr_i_info[E203_DECINFO_CSR_CSRIDX];\n\n    // CSR index and data preparation\n    always @(*) begin\n        csr_idx = csr_idx_info;\n        wbck_csr_dat = (csrrw ? csr_i_rs1 : \n                        (csrrs ? (read_csr_dat | csr_i_rs1) : \n                        (csrrc ? (read_csr_dat & ~csr_i_rs1) : read_csr_dat)));\n    end\n\n    // Control signal generation\n    always @(*) begin\n        csr_rd_en = (csr_i_valid && ((csrrw && csr_i_rdwen) || csrrs || csrrc));\n        csr_wr_en = (csr_i_valid && ((csrrw || (csrrs && !rs1is0) || (csrrc && !rs1is0))));\n        csr_ena = csr_i_valid && csr_o_ready && !csr_access_ilgl;\n        csr_i_ready = csr_o_ready;\n        csr_o_valid = csr_i_valid && csr_o_ready;\n        csr_o_wbck_wdat = read_csr_dat;\n        csr_o_wbck_err = csr_access_ilgl;\n    end\n\n    // NICE interface handling\n    always @(*) begin\n        csr_sel_nice = (csr_idx[11:8] == 4'hE) && !nice_xs_off;\n        nice_csr_valid = csr_i_valid && csr_o_ready && csr_sel_nice;\n        nice_csr_addr = {20'h0, csr_idx};\n        nice_csr_wr = csr_wr_en && csr_sel_nice;\n        nice_csr_wdata = wbck_csr_dat;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 11, "code": "module e203_exu_longpwbck (\n    input wire lsu_wbck_i_valid,\n    output wire lsu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] lsu_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] lsu_wbck_i_itag,\n    input wire lsu_wbck_i_err,\n    input wire lsu_cmt_i_buserr,\n    input wire [E203_ADDR_SIZE-1:0] lsu_cmt_i_badaddr,\n    input wire lsu_cmt_i_ld,\n    input wire lsu_cmt_i_st,\n    output wire longp_wbck_o_valid,\n    input wire longp_wbck_o_ready,\n    output wire [E203_FLEN-1:0] longp_wbck_o_wdat,\n    output wire [4:0] longp_wbck_o_flags,\n    output wire [E203_RFIDX_WIDTH-1:0] longp_wbck_o_rdidx,\n    output wire longp_wbck_o_rdfpu,\n    output wire longp_excp_o_valid,\n    input wire longp_excp_o_ready,\n    output wire longp_excp_o_insterr,\n    output wire longp_excp_o_ld,\n    output wire longp_excp_o_st,\n    output wire longp_excp_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] longp_excp_o_badaddr,\n    output wire [E203_PC_SIZE-1:0] longp_excp_o_pc,\n    input wire oitf_empty,\n    input wire [E203_ITAG_WIDTH-1:0] oitf_ret_ptr,\n    input wire [E203_RFIDX_WIDTH-1:0] oitf_ret_rdidx,\n    input wire [E203_PC_SIZE-1:0] oitf_ret_pc,\n    input wire oitf_ret_rdwen,\n    input wire oitf_ret_rdfpu,\n    output wire oitf_ret_ena,\n    input wire clk,\n    input wire rst_n\n`ifdef E203_HAS_NICE\n    , input wire nice_longp_wbck_i_valid,\n    output wire nice_longp_wbck_i_ready,\n    input wire [E203_XLEN-1:0] nice_longp_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] nice_longp_wbck_i_itag,\n    input wire nice_longp_wbck_i_err\n`endif\n);\n\n    // Write-back arbitration logic\n    wire wbck_need = (oitf_ret_rdwen && !lsu_wbck_i_err);\n    wire excp_need = (lsu_wbck_i_err || lsu_cmt_i_buserr);\n\n    assign lsu_wbck_i_ready = (wbck_need && longp_wbck_o_ready) && (excp_need && longp_excp_o_ready);\n    assign longp_wbck_o_valid = wbck_need && lsu_wbck_i_valid && !excp_need;\n    assign longp_wbck_o_wdat = lsu_wbck_i_wdat;\n    assign longp_wbck_o_rdidx = oitf_ret_rdidx;\n    assign longp_wbck_o_rdfpu = oitf_ret_rdfpu;\n\n    // Exception handling logic\n    assign longp_excp_o_valid = excp_need && lsu_wbck_i_valid && !wbck_need;\n    assign longp_excp_o_insterr = lsu_wbck_i_err;\n    assign longp_excp_o_ld = lsu_cmt_i_ld;\n    assign longp_excp_o_st = lsu_cmt_i_st;\n    assign longp_excp_o_buserr = lsu_cmt_i_buserr;\n    assign longp_excp_o_badaddr = lsu_cmt_i_badaddr;\n    assign longp_excp_o_pc = oitf_ret_pc;\n\n    // OITF control logic\n    assign oitf_ret_ena = lsu_wbck_i_ready && lsu_wbck_i_valid;\n\n`ifdef E203_HAS_NICE\n    // NICE write-back handling\n    assign nice_longp_wbck_i_ready = (wbck_need && longp_wbck_o_ready) && (excp_need && longp_excp_o_ready);\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 16, "code": "module e203_exu_branchslv(\n    input wire cmt_i_valid,\n    output wire cmt_i_ready,\n    input wire cmt_i_rv32,\n    input wire cmt_i_dret,\n    input wire cmt_i_mret,\n    input wire cmt_i_fencei,\n    input wire cmt_i_bjp,\n    input wire cmt_i_bjp_prdt,\n    input wire cmt_i_bjp_rslv,\n    input wire [E203_PC_SIZE-1:0] cmt_i_pc,\n    input wire [E203_XLEN-1:0] cmt_i_imm,\n    input wire [E203_PC_SIZE-1:0] csr_epc_r,\n    input wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    input wire nonalu_excpirq_flush_req_raw,\n    input wire brchmis_flush_ack,\n    output wire brchmis_flush_req,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op1,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op2,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_pc,\n    output wire cmt_mret_ena,\n    output wire cmt_dret_ena,\n    output wire cmt_fencei_ena,\n    input wire clk,\n    input wire rst_n\n);\n\n    wire flush_need;\n    wire [E203_PC_SIZE-1:0] flush_target;\n    wire flush_ready;\n    wire flush_ack;\n\n    assign flush_need = (cmt_i_bjp & (cmt_i_bjp_prdt != cmt_i_bjp_rslv)) | cmt_i_fencei | cmt_i_mret | cmt_i_dret;\n    assign flush_target = cmt_i_dret ? csr_dpc_r :\n                          cmt_i_mret ? csr_epc_r :\n                          (cmt_i_fencei | (cmt_i_bjp & cmt_i_bjp_prdt & ~cmt_i_bjp_rslv)) ? (cmt_i_rv32 ? cmt_i_pc + 4 : cmt_i_pc + 2) :\n                          (cmt_i_bjp & ~cmt_i_bjp_prdt & cmt_i_bjp_rslv) ? (cmt_i_pc + cmt_i_imm) :\n                          csr_epc_r;\n\n    assign brchmis_flush_req = flush_need & cmt_i_valid & ~nonalu_excpirq_flush_req_raw;\n    assign brchmis_flush_add_op1 = cmt_i_pc;\n    assign brchmis_flush_add_op2 = cmt_i_imm;\n    assign brchmis_flush_pc = flush_target;\n\n    assign cmt_i_ready = ~flush_need | (flush_ack & ~nonalu_excpirq_flush_req_raw);\n    assign cmt_mret_ena = cmt_i_mret & flush_ready & flush_ack;\n    assign cmt_dret_ena = cmt_i_dret & flush_ready & flush_ack;\n    assign cmt_fencei_ena = cmt_i_fencei & flush_ready & flush_ack;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 14, "code": "module e203_exu_alu_muldiv(\n    input mdv_nob2b,\n    input muldiv_i_valid,\n    output muldiv_i_ready,\n    input [E203_XLEN-1:0] muldiv_i_rs1,\n    input [E203_XLEN-1:0] muldiv_i_rs2,\n    input [E203_XLEN-1:0] muldiv_i_imm,\n    input [E203_DECINFO_MULDIV_WIDTH-1:0] muldiv_i_info,\n    input [E203_ITAG_WIDTH-1:0] muldiv_i_itag,\n    output muldiv_i_longpipe,\n    input flush_pulse,\n    output muldiv_o_valid,\n    input muldiv_o_ready,\n    output [E203_XLEN-1:0] muldiv_o_wbck_wdat,\n    output muldiv_o_wbck_err,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    output muldiv_req_alu_add,\n    output muldiv_req_alu_sub,\n    input [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output muldiv_sbf_0_ena,\n    output [32:0] muldiv_sbf_0_nxt,\n    input [32:0] muldiv_sbf_0_r,\n    output muldiv_sbf_1_ena,\n    output [32:0] muldiv_sbf_1_nxt,\n    input [32:0] muldiv_sbf_1_r,\n    input clk,\n    input rst_n\n);\n\n// Internal signals and registers\nreg [4:0] state;\nreg [4:0] next_state;\nreg [E203_XLEN-1:0] operand1, operand2;\nreg [E203_XLEN*2-1:0] product;\nreg [E203_XLEN-1:0] quotient, remainder;\nreg [E203_XLEN-1:0] divisor, dividend;\nreg muldiv_i_ready_reg, muldiv_o_valid_reg;\nreg [E203_XLEN-1:0] muldiv_o_wbck_wdat_reg;\nwire muldiv_active;\n\n// State definitions\nlocalparam MULDIV_STATE_IDLE = 5'd0,\n           MULDIV_STATE_EXEC = 5'd1,\n           MULDIV_STATE_REMD_CHCK = 5'd2,\n           MULDIV_STATE_QUOT_CORR = 5'd3,\n           MULDIV_STATE_REMD_CORR = 5'd4;\n\n// FSM for handling multiplier and divider operations\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        state <= MULDIV_STATE_IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (state)\n        MULDIV_STATE_IDLE: begin\n            if (muldiv_i_valid && muldiv_i_ready)\n                next_state = MULDIV_STATE_EXEC;\n            else\n                next_state = MULDIV_STATE_IDLE;\n        end\n        MULDIV_STATE_EXEC: begin\n            if (flush_pulse)\n                next_state = MULDIV_STATE_IDLE;\n            else if (/* execution complete */)\n                next_state = MULDIV_STATE_REMD_CHCK;\n            else\n                next_state = MULDIV_STATE_EXEC;\n        end\n        MULDIV_STATE_REMD_CHCK: begin\n            if (flush_pulse)\n                next_state = MULDIV_STATE_IDLE;\n            else if (/* remainder check */)\n                next_state = MULDIV_STATE_QUOT_CORR;\n            else\n                next_state = MULDIV_STATE_IDLE;\n        end\n        MULDIV_STATE_QUOT_CORR: begin\n            if (flush_pulse)\n                next_state = MULDIV_STATE_IDLE;\n            else\n                next_state = MULDIV_STATE_REMD_CORR;\n        end\n        MULDIV_STATE_REMD_CORR: begin\n            if (flush_pulse)\n                next_state = MULDIV_STATE_IDLE;\n            else\n                next_state = MULDIV_STATE_IDLE;\n        end\n        default: begin\n            next_state = MULDIV_STATE_IDLE;\n        end\n    endcase\nend\n\n// Output assignments\nassign muldiv_i_ready = muldiv_i_ready_reg;\nassign muldiv_o_valid = muldiv_o_valid_reg;\nassign muldiv_o_wbck_wdat = muldiv_o_wbck_wdat_reg;\nassign muldiv_o_wbck_err = 0; // No error handling in this example\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 17, "code": "module e203_reset_ctrl #(\n    parameter MASTER = 1,\n    parameter RST_SYNC_LEVEL = `E203_ASYNC_FF_LEVELS\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    output wire rst_core,\n    output wire rst_itcm,\n    output wire rst_dtcm,\n    output wire rst_aon\n);\n\nreg [RST_SYNC_LEVEL-1:0] rst_sync_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        rst_sync_reg <= {RST_SYNC_LEVEL{1'b1}};\n    end else if (test_mode) begin\n        rst_sync_reg <= {RST_SYNC_LEVEL{rst_n}};\n    end else begin\n        rst_sync_reg <= {rst_sync_reg[RST_SYNC_LEVEL-2:0], 1'b1};\n    end\nend\n\nassign rst_core = (MASTER == 1) ? rst_sync_reg[RST_SYNC_LEVEL-1] : rst_n;\nassign rst_itcm = (MASTER == 1) ? rst_sync_reg[RST_SYNC_LEVEL-1] : rst_n;\nassign rst_dtcm = (MASTER == 1) ? rst_sync_reg[RST_SYNC_LEVEL-1] : rst_n;\nassign rst_aon  = (MASTER == 1) ? rst_sync_reg[RST_SYNC_LEVEL-1] : rst_n;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 17, "code": "module e203_exu_branchslv(\n    input wire cmt_i_valid,\n    output wire cmt_i_ready,\n    input wire cmt_i_rv32,\n    input wire cmt_i_dret,\n    input wire cmt_i_mret,\n    input wire cmt_i_fencei,\n    input wire cmt_i_bjp,\n    input wire cmt_i_bjp_prdt,\n    input wire cmt_i_bjp_rslv,\n    input wire [E203_PC_SIZE-1:0] cmt_i_pc,\n    input wire [E203_XLEN-1:0] cmt_i_imm,\n    input wire [E203_PC_SIZE-1:0] csr_epc_r,\n    input wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    input wire nonalu_excpirq_flush_req_raw,\n    input wire brchmis_flush_ack,\n    output wire brchmis_flush_req,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op1,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op2,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_pc,\n    output wire cmt_mret_ena,\n    output wire cmt_dret_ena,\n    output wire cmt_fencei_ena,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Flush need generation\n    wire flush_need = (cmt_i_bjp & (cmt_i_bjp_prdt != cmt_i_bjp_rslv)) | cmt_i_fencei | cmt_i_mret | cmt_i_dret;\n\n    // Flush target calculation\n    wire [E203_PC_SIZE-1:0] next_pc = cmt_i_rv32 ? (cmt_i_pc + 4) : (cmt_i_pc + 2);\n    wire [E203_PC_SIZE-1:0] branch_target = cmt_i_pc + cmt_i_imm;\n\n    assign brchmis_flush_add_op1 = cmt_i_pc;\n    assign brchmis_flush_add_op2 = cmt_i_imm;\n\n    // Selecting flush target address\n    always @(*) begin\n        if (cmt_i_fencei | (cmt_i_bjp & cmt_i_bjp_prdt & ~cmt_i_bjp_rslv)) begin\n            brchmis_flush_pc = next_pc;\n        end else if (cmt_i_bjp & ~cmt_i_bjp_prdt & cmt_i_bjp_rslv) begin\n            brchmis_flush_pc = branch_target;\n        end else if (cmt_i_dret) begin\n            brchmis_flush_pc = csr_dpc_r;\n        end else begin\n            brchmis_flush_pc = csr_epc_r;\n        end\n    end\n\n    // Pipeline flush control\n    assign brchmis_flush_req = flush_need & cmt_i_valid & ~nonalu_excpirq_flush_req_raw;\n\n    // Special signal commit\n    assign cmt_mret_ena = cmt_i_mret & flush_need & brchmis_flush_ack;\n    assign cmt_dret_ena = cmt_i_dret & flush_need & brchmis_flush_ack;\n    assign cmt_fencei_ena = cmt_i_fencei & flush_need & brchmis_flush_ack;\n\n    // Ready signal control\n    assign cmt_i_ready = ~flush_need & ~nonalu_excpirq_flush_req_raw | (flush_need & brchmis_flush_ack);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 15, "code": "module e203_exu_alu_muldiv(\n    input mdv_nob2b,\n    input muldiv_i_valid,\n    output muldiv_i_ready,\n    input [E203_XLEN-1:0] muldiv_i_rs1,\n    input [E203_XLEN-1:0] muldiv_i_rs2,\n    input [E203_XLEN-1:0] muldiv_i_imm,\n    input [E203_DECINFO_MULDIV_WIDTH-1:0] muldiv_i_info,\n    input [E203_ITAG_WIDTH-1:0] muldiv_i_itag,\n    output muldiv_i_longpipe,\n    input flush_pulse,\n    output muldiv_o_valid,\n    input muldiv_o_ready,\n    output [E203_XLEN-1:0] muldiv_o_wbck_wdat,\n    output muldiv_o_wbck_err,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    output muldiv_req_alu_add,\n    output muldiv_req_alu_sub,\n    input [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output muldiv_sbf_0_ena,\n    output [32:0] muldiv_sbf_0_nxt,\n    input [32:0] muldiv_sbf_0_r,\n    output muldiv_sbf_1_ena,\n    output [32:0] muldiv_sbf_1_nxt,\n    input [32:0] muldiv_sbf_1_r,\n    input clk,\n    input rst_n\n);\n\n    // Internal signals\n    wire [E203_XLEN-1:0] rs1 = muldiv_i_rs1;\n    wire [E203_XLEN-1:0] rs2 = muldiv_i_rs2;\n    wire [E203_XLEN-1:0] imm = muldiv_i_imm;\n    wire [E203_DECINFO_MULDIV_WIDTH-1:0] info = muldiv_i_info;\n    wire [E203_ITAG_WIDTH-1:0] itag = muldiv_i_itag;\n    wire valid = muldiv_i_valid;\n    wire ready = muldiv_i_ready;\n    wire longpipe = muldiv_i_longpipe;\n    wire flush = flush_pulse;\n    wire o_valid = muldiv_o_valid;\n    wire o_ready = muldiv_o_ready;\n    wire [E203_XLEN-1:0] wbck_wdat = muldiv_o_wbck_wdat;\n    wire wbck_err = muldiv_o_wbck_err;\n    wire [E203_MULDIV_ADDER_WIDTH-1:0] op1 = muldiv_req_alu_op1;\n    wire [E203_MULDIV_ADDER_WIDTH-1:0] op2 = muldiv_req_alu_op2;\n    wire add = muldiv_req_alu_add;\n    wire sub = muldiv_req_alu_sub;\n    wire [E203_MULDIV_ADDER_WIDTH-1:0] res = muldiv_req_alu_res;\n    wire sbf_0_ena = muldiv_sbf_0_ena;\n    wire [32:0] sbf_0_nxt = muldiv_sbf_0_nxt;\n    wire [32:0] sbf_0_r = muldiv_sbf_0_r;\n    wire sbf_1_ena = muldiv_sbf_1_ena;\n    wire [32:0] sbf_1_nxt = muldiv_sbf_1_nxt;\n    wire [32:0] sbf_1_r = muldiv_sbf_1_r;\n\n    // FSM and control logic\n    // Placeholder for FSM and control logic implementation\n\n    // Output assignments\n    assign muldiv_i_ready = 1'b1; // Always ready for simplification\n    assign muldiv_o_valid = 1'b0; // No valid output by default\n    assign muldiv_o_wbck_wdat = 32'b0; // Default output data\n    assign muldiv_o_wbck_err = 1'b0; // No error by default\n\n    // Placeholder for actual multiplier and divider logic\n    // Placeholder for Booth encoding and non-restoring division algorithm\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 13, "code": "module e203_ifu_minidec #(\n  parameter E203_INSTR_SIZE = 32,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_XLEN = 32\n)(\n  input [E203_INSTR_SIZE-1:0] instr,\n  output reg dec_rs1en,\n  output reg dec_rs2en,\n  output reg [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n  output reg [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n  output reg dec_mulhsu,\n  output reg dec_mul,\n  output reg dec_div,\n  output reg dec_rem,\n  output reg dec_divu,\n  output reg dec_remu,\n  output reg dec_rv32,\n  output reg dec_bjp,\n  output reg dec_jal,\n  output reg dec_jalr,\n  output reg dec_bxx,\n  output reg [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  output reg [E203_XLEN-1:0] dec_bjp_imm\n);\n\n  // Internal signals\n  wire [6:0] opcode;\n  wire [2:0] funct3;\n  wire [6:0] funct7;\n\n  assign opcode = instr[6:0];\n  assign funct3 = instr[14:12];\n  assign funct7 = instr[31:25];\n\n  always @(*) begin\n    // Default assignments\n    dec_rs1en = 1'b0;\n    dec_rs2en = 1'b0;\n    dec_rs1idx = instr[19:15];\n    dec_rs2idx = instr[24:20];\n    dec_mulhsu = 1'b0;\n    dec_mul = 1'b0;\n    dec_div = 1'b0;\n    dec_rem = 1'b0;\n    dec_divu = 1'b0;\n    dec_remu = 1'b0;\n    dec_rv32 = 1'b1; // Assuming RV32\n    dec_bjp = 1'b0;\n    dec_jal = 1'b0;\n    dec_jalr = 1'b0;\n    dec_bxx = 1'b0;\n    dec_jalr_rs1idx = instr[19:15];\n    dec_bjp_imm = {E203_XLEN{1'b0}};\n\n    case (opcode)\n      7'b0110011: begin // R-type\n        dec_rs1en = 1'b1;\n        dec_rs2en = 1'b1;\n        case (funct3)\n          3'b000: begin\n            if (funct7 == 7'b0000001) begin\n              dec_mul = 1'b1; // MUL\n            end\n          end\n          3'b001: begin\n            if (funct7 == 7'b0000001) begin\n              dec_mulhsu = 1'b1; // MULHSU\n            end\n          end\n          3'b100: begin\n            if (funct7 == 7'b0000001) begin\n              dec_div = 1'b1; // DIV\n            end\n          end\n          3'b110: begin\n            if (funct7 == 7'b0000001) begin\n              dec_divu = 1'b1; // DIVU\n            end\n          end\n          3'b101: begin\n            if (funct7 == 7'b0000001) begin\n              dec_rem = 1'b1; // REM\n            end\n          end\n          3'b111: begin\n            if (funct7 == 7'b0000001) begin\n              dec_remu = 1'b1; // REMU\n            end\n          end\n        endcase\n      end\n      7'b1101111: begin // JAL\n        dec_jal = 1'b1;\n        dec_bjp = 1'b1;\n        dec_bjp_imm = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0};\n      end\n      7'b1100111: begin // JALR\n        dec_jalr = 1'b1;\n        dec_bjp = 1'b1;\n        dec_bjp_imm = {{20{instr[31]}}, instr[31:20]};\n      end\n      7'b1100011: begin // Branches\n        dec_bxx = 1'b1;\n        dec_bjp = 1'b1;\n        dec_bjp_imm = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};\n      end\n    endcase\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 3, "code": "module e203_ifu_litebpu #(\n    parameter E203_PC_SIZE = 32,\n    parameter E203_XLEN = 32,\n    parameter E203_RFIDX_WIDTH = 5\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc,\n    input wire dec_jal,\n    input wire dec_jalr,\n    input wire dec_bxx,\n    input wire [E203_XLEN-1:0] dec_bjp_imm,\n    input wire [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    input wire oitf_empty,\n    input wire ir_empty,\n    input wire ir_rs1en,\n    input wire jalr_rs1idx_cam_irrdidx,\n    input wire dec_i_valid,\n    input wire ir_valid_clr,\n    input wire [E203_XLEN-1:0] rf2bpu_x1,\n    input wire [E203_XLEN-1:0] rf2bpu_rs1,\n    output reg prdt_taken,\n    output reg [E203_PC_SIZE-1:0] prdt_pc_add_op1,\n    output reg [E203_PC_SIZE-1:0] prdt_pc_add_op2,\n    output reg bpu_wait,\n    output reg bpu2rf_rs1_ena\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            prdt_taken <= 1'b0;\n            prdt_pc_add_op1 <= {E203_PC_SIZE{1'b0}};\n            prdt_pc_add_op2 <= {E203_PC_SIZE{1'b0}};\n            bpu_wait <= 1'b0;\n            bpu2rf_rs1_ena <= 1'b0;\n        end else begin\n            if (dec_i_valid) begin\n                if (dec_jal) begin\n                    prdt_taken <= 1'b1;\n                    prdt_pc_add_op1 <= pc;\n                    prdt_pc_add_op2 <= dec_bjp_imm;\n                end else if (dec_jalr) begin\n                    prdt_taken <= 1'b1;\n                    if (dec_jalr_rs1idx == 0) begin\n                        prdt_pc_add_op1 <= 0;\n                    end else if (dec_jalr_rs1idx == 1) begin\n                        prdt_pc_add_op1 <= rf2bpu_x1;\n                        bpu_wait <= !oitf_empty;\n                    end else begin\n                        prdt_pc_add_op1 <= rf2bpu_rs1;\n                        bpu_wait <= !oitf_empty || !ir_empty;\n                    end\n                    prdt_pc_add_op2 <= dec_bjp_imm;\n                end else if (dec_bxx) begin\n                    prdt_taken <= dec_bjp_imm[E203_XLEN-1];\n                    prdt_pc_add_op1 <= pc;\n                    prdt_pc_add_op2 <= dec_bjp_imm;\n                end else begin\n                    prdt_taken <= 1'b0;\n                    prdt_pc_add_op1 <= pc;\n                    prdt_pc_add_op2 <= dec_bjp_imm;\n                end\n            end else begin\n                prdt_taken <= 1'b0;\n                prdt_pc_add_op1 <= {E203_PC_SIZE{1'b0}};\n                prdt_pc_add_op2 <= {E203_PC_SIZE{1'b0}};\n                bpu_wait <= 1'b0;\n                bpu2rf_rs1_ena <= 1'b0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 14, "code": "module e203_srams #(\n  parameter E203_ITCM_RAM_AW = 10, // Address width for ITCM\n  parameter E203_ITCM_RAM_MW = 4,  // Write mask width for ITCM\n  parameter E203_ITCM_RAM_DW = 32, // Data width for ITCM\n  parameter E203_DTCM_RAM_AW = 10, // Address width for DTCM\n  parameter E203_DTCM_RAM_MW = 4,  // Write mask width for DTCM\n  parameter E203_DTCM_RAM_DW = 32  // Data width for DTCM\n)(\n  input  wire                     clk_itcm_ram,\n  input  wire                     rst_itcm,\n  input  wire                     itcm_ram_sd,\n  input  wire                     itcm_ram_ds,\n  input  wire                     itcm_ram_ls,\n  input  wire                     itcm_ram_cs,\n  input  wire                     itcm_ram_we,\n  input  wire [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n  input  wire [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n  input  wire [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n  output wire [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n\n  input  wire                     clk_dtcm_ram,\n  input  wire                     rst_dtcm,\n  input  wire                     dtcm_ram_sd,\n  input  wire                     dtcm_ram_ds,\n  input  wire                     dtcm_ram_ls,\n  input  wire                     dtcm_ram_cs,\n  input  wire                     dtcm_ram_we,\n  input  wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n  input  wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n  input  wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n  output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout\n);\n\n`ifdef E203_HAS_ITCM\n  // ITCM Memory instantiation\n  ram #(\n    .ADDR_WIDTH(E203_ITCM_RAM_AW),\n    .DATA_WIDTH(E203_ITCM_RAM_DW),\n    .MASK_WIDTH(E203_ITCM_RAM_MW)\n  ) itcm_ram (\n    .clk(clk_itcm_ram),\n    .rst(rst_itcm),\n    .cs(itcm_ram_cs),\n    .we(itcm_ram_we),\n    .addr(itcm_ram_addr),\n    .wem(itcm_ram_wem),\n    .din(itcm_ram_din),\n    .dout(itcm_ram_dout)\n  );\n`endif\n\n`ifdef E203_HAS_DTCM\n  // DTCM Memory instantiation\n  ram #(\n    .ADDR_WIDTH(E203_DTCM_RAM_AW),\n    .DATA_WIDTH(E203_DTCM_RAM_DW),\n    .MASK_WIDTH(E203_DTCM_RAM_MW)\n  ) dtcm_ram (\n    .clk(clk_dtcm_ram),\n    .rst(rst_dtcm),\n    .cs(dtcm_ram_cs),\n    .we(dtcm_ram_we),\n    .addr(dtcm_ram_addr),\n    .wem(dtcm_ram_wem),\n    .din(dtcm_ram_din),\n    .dout(dtcm_ram_dout)\n  );\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 14, "code": "module e203_exu_alu_rglr(\n    input wire alu_i_valid,\n    output reg alu_i_ready,\n    input wire [E203_XLEN-1:0] alu_i_rs1,\n    input wire [E203_XLEN-1:0] alu_i_rs2,\n    input wire [E203_XLEN-1:0] alu_i_imm,\n    input wire [E203_PC_SIZE-1:0] alu_i_pc,\n    input wire [E203_DECINFO_ALU_WIDTH-1:0] alu_i_info,\n    output reg alu_o_valid,\n    input wire alu_o_ready,\n    output reg [E203_XLEN-1:0] alu_o_wbck_wdat,\n    output reg alu_o_wbck_err,\n    output reg alu_o_cmt_ecall,\n    output reg alu_o_cmt_ebreak,\n    output reg alu_o_cmt_wfi,\n    output reg alu_req_alu_add,\n    output reg alu_req_alu_sub,\n    output reg alu_req_alu_xor,\n    output reg alu_req_alu_sll,\n    output reg alu_req_alu_srl,\n    output reg alu_req_alu_sra,\n    output reg alu_req_alu_or,\n    output reg alu_req_alu_and,\n    output reg alu_req_alu_slt,\n    output reg alu_req_alu_sltu,\n    output reg alu_req_alu_lui,\n    output reg [E203_XLEN-1:0] alu_req_alu_op1,\n    output reg [E203_XLEN-1:0] alu_req_alu_op2,\n    output reg [E203_XLEN-1:0] alu_req_alu_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    always @(*) begin\n        alu_i_ready = alu_o_ready;\n        alu_o_valid = alu_i_valid;\n\n        // Default values\n        alu_o_wbck_wdat = 0;\n        alu_o_wbck_err = 0;\n        alu_o_cmt_ecall = 0;\n        alu_o_cmt_ebreak = 0;\n        alu_o_cmt_wfi = 0;\n\n        alu_req_alu_add = 0;\n        alu_req_alu_sub = 0;\n        alu_req_alu_xor = 0;\n        alu_req_alu_sll = 0;\n        alu_req_alu_srl = 0;\n        alu_req_alu_sra = 0;\n        alu_req_alu_or = 0;\n        alu_req_alu_and = 0;\n        alu_req_alu_slt = 0;\n        alu_req_alu_sltu = 0;\n        alu_req_alu_lui = 0;\n\n        alu_req_alu_op1 = alu_i_info[E203_DECINFO_ALU_OP1PC] ? alu_i_pc : alu_i_rs1;\n        alu_req_alu_op2 = alu_i_info[E203_DECINFO_ALU_OP2IMM] ? alu_i_imm : alu_i_rs2;\n\n        if (alu_i_valid && alu_o_ready) begin\n            case (1'b1) // synthesis parallel_case\n                alu_i_info[E203_DECINFO_ALU_ADD]: alu_req_alu_add = 1;\n                alu_i_info[E203_DECINFO_ALU_SUB]: alu_req_alu_sub = 1;\n                alu_i_info[E203_DECINFO_ALU_XOR]: alu_req_alu_xor = 1;\n                alu_i_info[E203_DECINFO_ALU_SLL]: alu_req_alu_sll = 1;\n                alu_i_info[E203_DECINFO_ALU_SRL]: alu_req_alu_srl = 1;\n                alu_i_info[E203_DECINFO_ALU_SRA]: alu_req_alu_sra = 1;\n                alu_i_info[E203_DECINFO_ALU_OR]: alu_req_alu_or = 1;\n                alu_i_info[E203_DECINFO_ALU_AND]: alu_req_alu_and = 1;\n                alu_i_info[E203_DECINFO_ALU_SLT]: alu_req_alu_slt = 1;\n                alu_i_info[E203_DECINFO_ALU_SLTU]: alu_req_alu_sltu = 1;\n                alu_i_info[E203_DECINFO_ALU_LUI]: alu_req_alu_lui = 1;\n            endcase\n\n            if (alu_i_info[E203_DECINFO_ALU_ECAL]) begin\n                alu_o_cmt_ecall = 1;\n                alu_o_wbck_err = 1;\n            end\n            if (alu_i_info[E203_DECINFO_ALU_EBRK]) begin\n                alu_o_cmt_ebreak = 1;\n                alu_o_wbck_err = 1;\n            end\n            if (alu_i_info[E203_DECINFO_ALU_WFI]) begin\n                alu_o_cmt_wfi = 1;\n                alu_o_wbck_err = 1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 6, "code": "module e203_ifu_ift2icb (\n    input wire itcm_nohold,\n    input wire ifu_req_valid,\n    input wire [PC_SIZE-1:0] ifu_req_pc,\n    input wire ifu_req_seq,\n    input wire ifu_req_seq_rv32,\n    input wire [PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_ready,\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_ready,\n    output wire ifu_rsp_valid,\n    output wire ifu_rsp_err,\n    output wire [31:0] ifu_rsp_instr,\n    output wire ifu2itcm_icb_cmd_valid,\n    input wire ifu2itcm_icb_cmd_ready,\n    output wire [ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_rsp_valid,\n    output wire ifu2itcm_icb_rsp_ready,\n    input wire ifu2itcm_icb_rsp_err,\n    input wire [ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    output wire ifu2biu_icb_cmd_valid,\n    input wire ifu2biu_icb_cmd_ready,\n    output wire [ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input wire ifu2biu_icb_rsp_valid,\n    output wire ifu2biu_icb_rsp_ready,\n    input wire ifu2biu_icb_rsp_err,\n    input wire [SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata\n);\n\n    // State Definitions\n    localparam ICB_STATE_IDLE = 2'b00;\n    localparam ICB_STATE_1ST = 2'b01;\n    localparam ICB_STATE_WAIT2ND = 2'b10;\n    localparam ICB_STATE_2ND = 2'b11;\n\n    // State Variables\n    reg [1:0] icb_state;\n    reg [1:0] icb_state_nxt;\n\n    // Handshake signals\n    wire ifu_req_hsked = ifu_req_valid & ifu_req_ready;\n    wire ifu_icb_cmd_hsked = ifu2itcm_icb_cmd_valid & ifu2itcm_icb_cmd_ready;\n    wire ifu_icb_rsp_hsked = ifu2itcm_icb_rsp_valid & ifu2itcm_icb_rsp_ready;\n    wire i_ifu_rsp_hsked = ifu_rsp_valid & ifu_rsp_ready;\n\n    // State Transition Logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            icb_state <= ICB_STATE_IDLE;\n        end else begin\n            icb_state <= icb_state_nxt;\n        end\n    end\n\n    // Next State Logic\n    always @(*) begin\n        case (icb_state)\n            ICB_STATE_IDLE: begin\n                if (ifu_req_hsked)\n                    icb_state_nxt = ICB_STATE_1ST;\n                else\n                    icb_state_nxt = ICB_STATE_IDLE;\n            end\n            ICB_STATE_1ST: begin\n                if (ifu_icb_rsp_hsked)\n                    icb_state_nxt = ICB_STATE_IDLE;\n                else\n                    icb_state_nxt = ICB_STATE_1ST;\n            end\n            ICB_STATE_WAIT2ND: begin\n                if (ifu_icb_cmd_ready)\n                    icb_state_nxt = ICB_STATE_2ND;\n                else\n                    icb_state_nxt = ICB_STATE_WAIT2ND;\n            end\n            ICB_STATE_2ND: begin\n                if (i_ifu_rsp_hsked)\n                    icb_state_nxt = ICB_STATE_IDLE;\n                else\n                    icb_state_nxt = ICB_STATE_2ND;\n            end\n            default: icb_state_nxt = ICB_STATE_IDLE;\n        endcase\n    end\n\n    // Output Logic\n    assign ifu_req_ready = (icb_state == ICB_STATE_IDLE);\n    assign ifu_rsp_valid = (icb_state == ICB_STATE_1ST) & ifu2itcm_icb_rsp_valid;\n    assign ifu_rsp_err = ifu2itcm_icb_rsp_err;\n    assign ifu_rsp_instr = ifu2itcm_icb_rsp_rdata[31:0];\n\n    // ICB Command Logic\n    assign ifu2itcm_icb_cmd_valid = (icb_state == ICB_STATE_IDLE) & ifu_req_valid;\n    assign ifu2itcm_icb_cmd_addr = ifu_req_pc[ITCM_ADDR_WIDTH-1:0];\n\n    // ICB Response Logic\n    assign ifu2itcm_icb_rsp_ready = (icb_state == ICB_STATE_1ST);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 4, "code": "module e203_ifu (\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire itcm_nohold,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire ifu_active,\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    input wire pipe_flush_req,\n    output wire pipe_flush_ack,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input wire ifu_halt_req,\n    output wire ifu_halt_ack,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu\n);\n\n    // Internal signals\n    wire [E203_PC_SIZE-1:0] next_pc;\n    wire [E203_INSTR_SIZE-1:0] fetched_instr;\n    wire fetch_valid;\n    wire fetch_ready;\n    wire [E203_PC_SIZE-1:0] current_pc;\n    wire [E203_ADDR_SIZE-1:0] fetch_addr;\n    wire fetch_error;\n    wire misaligned;\n\n    // Instantiate IFU Fetch module\n    e203_ifu_ifetch ifetch (\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ifu_o_ready(ifu_o_ready),\n        .pipe_flush_req(pipe_flush_req),\n        .pipe_flush_add_op1(pipe_flush_add_op1),\n        .pipe_flush_add_op2(pipe_flush_add_op2),\n        .ifu_halt_req(ifu_halt_req),\n        .oitf_empty(oitf_empty),\n        .rf2ifu_x1(rf2ifu_x1),\n        .rf2ifu_rs1(rf2ifu_rs1),\n        .dec2ifu_rden(dec2ifu_rden),\n        .dec2ifu_rs1en(dec2ifu_rs1en),\n        .dec2ifu_rdidx(dec2ifu_rdidx),\n        .dec2ifu_mulhsu(dec2ifu_mulhsu),\n        .dec2ifu_div(dec2ifu_div),\n        .dec2ifu_rem(dec2ifu_rem),\n        .dec2ifu_divu(dec2ifu_divu),\n        .dec2ifu_remu(dec2ifu_remu),\n        .inspect_pc(inspect_pc),\n        .ifu_req_valid(fetch_valid),\n        .ifu_req_pc(fetch_addr),\n        .ifu_req_seq(fetch_ready),\n        .ifu_req_last_pc(current_pc),\n        .pipe_flush_ack(pipe_flush_ack),\n        .ifu_halt_ack(ifu_halt_ack),\n        .ifu_o_ir(fetched_instr),\n        .ifu_o_pc(next_pc),\n        .ifu_o_pc_vld(ifu_o_pc_vld),\n        .ifu_o_misalgn(misaligned),\n        .ifu_o_buserr(fetch_error),\n        .ifu_o_rs1idx(ifu_o_rs1idx),\n        .ifu_o_rs2idx(ifu_o_rs2idx),\n        .ifu_o_prdt_taken(ifu_o_prdt_taken),\n        .ifu_o_muldiv_b2b(ifu_o_muldiv_b2b),\n        .ifu_o_valid(ifu_o_valid)\n    );\n\n    // Logic to handle instruction fetch, alignment, and error processing\n    assign ifu_active = fetch_valid && fetch_ready;\n    assign ifu_o_ir = fetched_instr;\n    assign ifu_o_pc = next_pc;\n    assign ifu_o_misalgn = misaligned;\n    assign ifu_o_buserr = fetch_error;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 16, "code": "module e203_exu_alu_muldiv(\n    input mdv_nob2b,\n    input muldiv_i_valid,\n    output muldiv_i_ready,\n    input [E203_XLEN-1:0] muldiv_i_rs1,\n    input [E203_XLEN-1:0] muldiv_i_rs2,\n    input [E203_XLEN-1:0] muldiv_i_imm,\n    input [E203_DECINFO_MULDIV_WIDTH-1:0] muldiv_i_info,\n    input [E203_ITAG_WIDTH-1:0] muldiv_i_itag,\n    output muldiv_i_longpipe,\n    input flush_pulse,\n    output muldiv_o_valid,\n    input muldiv_o_ready,\n    output [E203_XLEN-1:0] muldiv_o_wbck_wdat,\n    output muldiv_o_wbck_err,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    output muldiv_req_alu_add,\n    output muldiv_req_alu_sub,\n    input [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output muldiv_sbf_0_ena,\n    output [32:0] muldiv_sbf_0_nxt,\n    input [32:0] muldiv_sbf_0_r,\n    output muldiv_sbf_1_ena,\n    output [32:0] muldiv_sbf_1_nxt,\n    input [32:0] muldiv_sbf_1_r,\n    input clk,\n    input rst_n\n);\n\n// Internal signals and registers\nreg [4:0] state;\nreg [4:0] next_state;\nreg [E203_XLEN-1:0] operand1;\nreg [E203_XLEN-1:0] operand2;\nreg [E203_XLEN-1:0] result;\nwire valid_operation;\nwire ready_for_next;\nwire operation_complete;\n\n// State definitions\nlocalparam MULDIV_STATE_IDLE = 5'd0;\nlocalparam MULDIV_STATE_EXEC = 5'd1;\nlocalparam MULDIV_STATE_REMD_CHCK = 5'd2;\nlocalparam MULDIV_STATE_QUOT_CORR = 5'd3;\nlocalparam MULDIV_STATE_REMD_CORR = 5'd4;\n\n// FSM for handling multiplier and divider operations\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        state <= MULDIV_STATE_IDLE;\n    else\n        state <= next_state;\nend\n\n// Next state logic\nalways @(*) begin\n    case (state)\n        MULDIV_STATE_IDLE: begin\n            if (muldiv_i_valid && !flush_pulse)\n                next_state = MULDIV_STATE_EXEC;\n            else\n                next_state = MULDIV_STATE_IDLE;\n        end\n        MULDIV_STATE_EXEC: begin\n            if (operation_complete)\n                next_state = MULDIV_STATE_REMD_CHCK;\n            else\n                next_state = MULDIV_STATE_EXEC;\n        end\n        MULDIV_STATE_REMD_CHCK: begin\n            if (need_correction)\n                next_state = MULDIV_STATE_QUOT_CORR;\n            else\n                next_state = MULDIV_STATE_IDLE;\n        end\n        MULDIV_STATE_QUOT_CORR: begin\n            next_state = MULDIV_STATE_REMD_CORR;\n        end\n        MULDIV_STATE_REMD_CORR: begin\n            next_state = MULDIV_STATE_IDLE;\n        end\n        default: begin\n            next_state = MULDIV_STATE_IDLE;\n        end\n    endcase\nend\n\n// Output logic\nassign muldiv_i_ready = (state == MULDIV_STATE_IDLE);\nassign muldiv_o_valid = (state == MULDIV_STATE_REMD_CORR) && operation_complete;\nassign muldiv_o_wbck_wdat = result;\nassign muldiv_o_wbck_err = 0;\n\n// Operation logic\nalways @(posedge clk) begin\n    if (state == MULDIV_STATE_EXEC) begin\n        // Perform multiplication or division based on muldiv_i_info\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 13, "code": "module e203_exu_nice (\n    input wire nice_i_xs_off,\n    input wire nice_i_valid,\n    output wire nice_i_ready,\n    input wire [E203_XLEN-1:0] nice_i_instr,\n    input wire [E203_XLEN-1:0] nice_i_rs1,\n    input wire [E203_XLEN-1:0] nice_i_rs2,\n    input wire [E203_ITAG_WIDTH-1:0] nice_i_itag,\n    output wire nice_o_longpipe,\n    output wire nice_o_valid,\n    input wire nice_o_ready,\n    output wire nice_o_itag_valid,\n    input wire nice_o_itag_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire clk,\n    input wire rst_n\n);\n\n// Internal signals\nwire fifo_push, fifo_pop;\nwire [E203_ITAG_WIDTH-1:0] fifo_data_in, fifo_data_out;\nwire fifo_full, fifo_empty;\n\n// Control signals\nassign fifo_push = nice_i_valid && nice_i_ready && !nice_i_xs_off;\nassign fifo_pop = nice_rsp_multicyc_valid && nice_rsp_multicyc_ready;\n\n// FIFO instantiation for instruction tags\nsirv_gnrl_fifo #(\n    .CUT_READY(1),\n    .MSKO(0),\n    .DP(4),\n    .DW(E203_ITAG_WIDTH)\n) itag_fifo (\n    .i_vld(fifo_push),\n    .i_rdy(nice_i_ready),\n    .i_dat(nice_i_itag),\n    .o_vld(nice_o_itag_valid),\n    .o_rdy(nice_o_itag_ready),\n    .o_dat(nice_o_itag),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// Handling requests to the accelerator\nassign nice_req_valid = nice_i_valid && !nice_i_xs_off && nice_req_ready;\nassign nice_req_instr = nice_i_instr;\nassign nice_req_rs1 = nice_i_rs1;\nassign nice_req_rs2 = nice_i_rs2;\n\n// Handling responses from the accelerator\nassign nice_rsp_multicyc_ready = !fifo_full;\nassign nice_o_valid = nice_i_valid && nice_o_ready && !nice_i_xs_off;\n\n// Long pipeline handling\nassign nice_o_longpipe = !nice_i_xs_off;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 17, "code": "module e203_exu_alu_csrctrl (\n    input wire csr_i_valid,\n    output reg csr_i_ready,\n    input wire [E203_XLEN-1:0] csr_i_rs1,\n    input wire [E203_DECINFO_CSR_WIDTH-1:0] csr_i_info,\n    input wire csr_i_rdwen,\n    output reg csr_ena,\n    output reg csr_wr_en,\n    output reg csr_rd_en,\n    output reg [11:0] csr_idx,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output reg [E203_XLEN-1:0] wbck_csr_dat,\n    output reg csr_o_valid,\n    input wire csr_o_ready,\n    output reg [E203_XLEN-1:0] csr_o_wbck_wdat,\n    output reg csr_o_wbck_err,\n    input wire clk,\n    input wire rst_n,\n    input wire nice_xs_off,\n    output reg csr_sel_nice,\n    output reg nice_csr_valid,\n    input wire nice_csr_ready,\n    output reg [31:0] nice_csr_addr,\n    output reg nice_csr_wr,\n    output reg [31:0] nice_csr_wdata,\n    input wire [31:0] nice_csr_rdata\n);\n\n    always @(*) begin\n        csr_i_ready = csr_o_ready;\n        csr_o_valid = csr_i_valid && csr_o_ready;\n        csr_ena = csr_i_valid && csr_o_ready && !nice_xs_off;\n\n        csr_idx = csr_i_info[E203_DECINFO_CSR_CSRIDX];\n        csr_sel_nice = (csr_idx[11:8] == 4'hE) && !nice_xs_off;\n\n        csr_rd_en = csr_i_valid && ((csr_i_info[E203_DECINFO_CSR_CSRRW] && csr_i_rdwen) ||\n                                    csr_i_info[E203_DECINFO_CSR_CSRRS] ||\n                                    csr_i_info[E203_DECINFO_CSR_CSRRC]);\n\n        csr_wr_en = csr_i_valid && (csr_i_info[E203_DECINFO_CSR_CSRRW] ||\n                                    (csr_i_info[E203_DECINFO_CSR_CSRRS] && !csr_i_info[E203_DECINFO_CSR_RS1IS0]) ||\n                                    (csr_i_info[E203_DECINFO_CSR_CSRRC] && !csr_i_info[E203_DECINFO_CSR_RS1IS0]));\n\n        wbck_csr_dat = (csr_i_info[E203_DECINFO_CSR_CSRRW] ? csr_i_rs1 :\n                        csr_i_info[E203_DECINFO_CSR_CSRRS] ? (read_csr_dat | csr_i_rs1) :\n                        csr_i_info[E203_DECINFO_CSR_CSRRC] ? (read_csr_dat & ~csr_i_rs1) : 0);\n\n        csr_o_wbck_wdat = read_csr_dat;\n        csr_o_wbck_err = csr_access_ilgl;\n\n        if (csr_sel_nice) begin\n            nice_csr_valid = csr_i_valid && csr_o_ready;\n            nice_csr_addr = {20'h0, csr_idx};\n            nice_csr_wr = csr_wr_en;\n            nice_csr_wdata = wbck_csr_dat;\n            csr_o_wbck_wdat = nice_csr_rdata;\n        end else begin\n            nice_csr_valid = 1'b0;\n            nice_csr_addr = 32'h0;\n            nice_csr_wr = 1'b0;\n            nice_csr_wdata = 32'h0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 8, "code": "module e203_exu_disp (\n    input wire wfi_halt_exu_req,\n    output wire wfi_halt_exu_ack,\n    input wire oitf_empty,\n    input wire amo_wait,\n    input wire disp_i_valid,\n    output wire disp_i_ready,\n    input wire disp_i_rs1x0,\n    input wire disp_i_rs2x0,\n    input wire disp_i_rs1en,\n    input wire disp_i_rs2en,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input wire [E203_XLEN-1:0] disp_i_rs1,\n    input wire [E203_XLEN-1:0] disp_i_rs2,\n    input wire disp_i_rdwen,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input wire [E203_DECINFO_WIDTH-1:0] disp_i_info,\n    input wire [E203_XLEN-1:0] disp_i_imm,\n    input wire [E203_PC_SIZE-1:0] disp_i_pc,\n    input wire disp_i_misalgn,\n    input wire disp_i_buserr,\n    input wire disp_i_ilegl,\n    output wire disp_o_alu_valid,\n    input wire disp_o_alu_ready,\n    input wire disp_o_alu_longpipe,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs1,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs2,\n    output wire disp_o_alu_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_o_alu_rdidx,\n    output wire [E203_DECINFO_WIDTH-1:0] disp_o_alu_info,\n    output wire [E203_XLEN-1:0] disp_o_alu_imm,\n    output wire [E203_PC_SIZE-1:0] disp_o_alu_pc,\n    output wire [E203_ITAG_WIDTH-1:0] disp_o_alu_itag,\n    output wire disp_o_alu_misalgn,\n    output wire disp_o_alu_buserr,\n    output wire disp_o_alu_ilegl,\n    input wire oitfrd_match_disprs1,\n    input wire oitfrd_match_disprs2,\n    input wire oitfrd_match_disprs3,\n    input wire oitfrd_match_disprd,\n    input wire [E203_ITAG_WIDTH-1:0] disp_oitf_ptr,\n    output wire disp_oitf_ena,\n    input wire disp_oitf_ready,\n    output wire disp_oitf_rs1fpu,\n    output wire disp_oitf_rs2fpu,\n    output wire disp_oitf_rs3fpu,\n    output wire disp_oitf_rdfpu,\n    output wire disp_oitf_rs1en,\n    output wire disp_oitf_rs2en,\n    output wire disp_oitf_rs3en,\n    output wire disp_oitf_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs2idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs3idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rdidx,\n    output wire [E203_PC_SIZE-1:0] disp_oitf_pc,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Implementation of dispatch logic\n    // This is a simplified example. Actual implementation will depend on the specific requirements and architecture.\n\n    assign disp_i_ready = !amo_wait && disp_o_alu_ready && !wfi_halt_exu_req;\n\n    assign disp_o_alu_valid = disp_i_valid && disp_i_ready;\n    assign disp_o_alu_rs1 = disp_i_rs1;\n    assign disp_o_alu_rs2 = disp_i_rs2;\n    assign disp_o_alu_rdwen = disp_i_rdwen;\n    assign disp_o_alu_rdidx = disp_i_rdidx;\n    assign disp_o_alu_info = disp_i_info;\n    assign disp_o_alu_imm = disp_i_imm;\n    assign disp_o_alu_pc = disp_i_pc;\n    assign disp_o_alu_itag = disp_oitf_ptr;\n    assign disp_o_alu_misalgn = disp_i_misalgn;\n    assign disp_o_alu_buserr = disp_i_buserr;\n    assign disp_o_alu_ilegl = disp_i_ilegl;\n\n    assign disp_oitf_ena = disp_o_alu_valid && disp_o_alu_longpipe && disp_oitf_ready;\n    assign disp_oitf_rs1fpu = 0; // Assuming no FPU in this example\n    assign disp_oitf_rs2fpu = 0;\n    assign disp_oitf_rs3fpu = 0;\n    assign disp_oitf_rdfpu = 0;\n    assign disp_oitf_rs1en = disp_i_rs1en;\n    assign disp_oitf_rs2en = disp_i_rs2en;\n    assign disp_oitf_rs3en = 0; // Assuming no third operand\n    assign disp_oitf_rdwen = disp_i_rdwen;\n    assign disp_oitf_rs1idx = disp_i_rs1idx;\n    assign disp_oitf_rs2idx = disp_i_rs2idx;\n    assign disp_oitf_rs3idx = 0; // Assuming no third operand\n    assign disp_oitf_rdidx = disp_i_rdidx;\n    assign disp_oitf_pc = disp_i_pc;\n\n    assign wfi_halt_exu_ack = wfi_halt_exu_req && oitf_empty;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 12, "code": "module e203_exu_alu_dpath (\n    input wire alu_req_alu,\n    input wire alu_req_alu_add,\n    input wire alu_req_alu_sub,\n    input wire alu_req_alu_xor,\n    input wire alu_req_alu_sll,\n    input wire alu_req_alu_srl,\n    input wire alu_req_alu_sra,\n    input wire alu_req_alu_or,\n    input wire alu_req_alu_and,\n    input wire [E203_XLEN-1:0] alu_req_alu_op1,\n    input wire [E203_XLEN-1:0] alu_req_alu_op2,\n    input wire bjp_req_alu,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    input wire agu_req_alu,\n    input wire [E203_XLEN-1:0] agu_req_alu_op1,\n    input wire [E203_XLEN-1:0] agu_req_alu_op2,\n    input wire muldiv_req_alu,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    input wire muldiv_req_alu_add,\n    input wire muldiv_req_alu_sub,\n    input wire muldiv_sbf_0_ena,\n    input wire [32:0] muldiv_sbf_0_nxt,\n    input wire muldiv_sbf_1_ena,\n    input wire [32:0] muldiv_sbf_1_nxt,\n    input wire clk,\n    input wire rst_n,\n    output wire [E203_XLEN-1:0] alu_req_alu_res,\n    output wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    output wire bjp_req_alu_cmp_res,\n    output wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output wire [32:0] muldiv_sbf_0_r,\n    output wire [32:0] muldiv_sbf_1_r\n);\n\n    // Internal signals for ALU operations\n    wire [E203_XLEN-1:0] add_res;\n    wire [E203_XLEN-1:0] sub_res;\n    wire [E203_XLEN-1:0] and_res;\n    wire [E203_XLEN-1:0] or_res;\n    wire [E203_XLEN-1:0] xor_res;\n    wire [E203_XLEN-1:0] sll_res;\n    wire [E203_XLEN-1:0] srl_res;\n    wire [E203_XLEN-1:0] sra_res;\n\n    // ALU operation implementations\n    assign add_res = alu_req_alu_op1 + alu_req_alu_op2;\n    assign sub_res = alu_req_alu_op1 - alu_req_alu_op2;\n    assign and_res = alu_req_alu_op1 & alu_req_alu_op2;\n    assign or_res  = alu_req_alu_op1 | alu_req_alu_op2;\n    assign xor_res = alu_req_alu_op1 ^ alu_req_alu_op2;\n    assign sll_res = alu_req_alu_op1 << alu_req_alu_op2[E203_XLEN-1:0];\n    assign srl_res = alu_req_alu_op1 >> alu_req_alu_op2[E203_XLEN-1:0];\n    assign sra_res = $signed(alu_req_alu_op1) >>> alu_req_alu_op2[E203_XLEN-1:0];\n\n    // Result multiplexing based on operation type\n    assign alu_req_alu_res = ({E203_XLEN{alu_req_alu_add}} & add_res) |\n                             ({E203_XLEN{alu_req_alu_sub}} & sub_res) |\n                             ({E203_XLEN{alu_req_alu_and}} & and_res) |\n                             ({E203_XLEN{alu_req_alu_or}} & or_res) |\n                             ({E203_XLEN{alu_req_alu_xor}} & xor_res) |\n                             ({E203_XLEN{alu_req_alu_sll}} & sll_res) |\n                             ({E203_XLEN{alu_req_alu_srl}} & srl_res) |\n                             ({E203_XLEN{alu_req_alu_sra}} & sra_res);\n\n    // Shared buffers\n    sirv_gnrl_dffl #(.DW(33)) sbf_0_dffl (\n        .lden(muldiv_sbf_0_ena),\n        .dnxt(muldiv_sbf_0_nxt),\n        .qout(muldiv_sbf_0_r),\n        .clk(clk)\n    );\n\n    sirv_gnrl_dffl #(.DW(33)) sbf_1_dffl (\n        .lden(muldiv_sbf_1_ena),\n        .dnxt(muldiv_sbf_1_nxt),\n        .qout(muldiv_sbf_1_r),\n        .clk(clk)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 15, "code": "module e203_srams #(\n  parameter E203_ITCM_RAM_AW = 12,\n  parameter E203_ITCM_RAM_MW = 4,\n  parameter E203_ITCM_RAM_DW = 32,\n  parameter E203_DTCM_RAM_AW = 12,\n  parameter E203_DTCM_RAM_MW = 4,\n  parameter E203_DTCM_RAM_DW = 32\n)(\n  input wire itcm_ram_sd,\n  input wire itcm_ram_ds,\n  input wire itcm_ram_ls,\n  input wire itcm_ram_cs,\n  input wire itcm_ram_we,\n  input wire [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n  input wire [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n  input wire [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n  output wire [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n  input wire clk_itcm_ram,\n  input wire rst_itcm,\n\n  input wire dtcm_ram_sd,\n  input wire dtcm_ram_ds,\n  input wire dtcm_ram_ls,\n  input wire dtcm_ram_cs,\n  input wire dtcm_ram_we,\n  input wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n  input wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n  input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n  output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n  input wire clk_dtcm_ram,\n  input wire rst_dtcm\n);\n\n`ifdef E203_HAS_ITCM\n  e203_itcm_ram #(\n    .AW(E203_ITCM_RAM_AW),\n    .MW(E203_ITCM_RAM_MW),\n    .DW(E203_ITCM_RAM_DW)\n  ) u_e203_itcm_ram (\n    .sd(itcm_ram_sd),\n    .ds(itcm_ram_ds),\n    .ls(itcm_ram_ls),\n    .cs(itcm_ram_cs),\n    .we(itcm_ram_we),\n    .addr(itcm_ram_addr),\n    .wem(itcm_ram_wem),\n    .din(itcm_ram_din),\n    .dout(itcm_ram_dout),\n    .clk(clk_itcm_ram),\n    .rst_n(rst_itcm)\n  );\n`endif\n\n`ifdef E203_HAS_DTCM\n  e203_dtcm_ram #(\n    .AW(E203_DTCM_RAM_AW),\n    .MW(E203_DTCM_RAM_MW),\n    .DW(E203_DTCM_RAM_DW)\n  ) u_e203_dtcm_ram (\n    .sd(dtcm_ram_sd),\n    .ds(dtcm_ram_ds),\n    .ls(dtcm_ram_ls),\n    .cs(dtcm_ram_cs),\n    .we(dtcm_ram_we),\n    .addr(dtcm_ram_addr),\n    .wem(dtcm_ram_wem),\n    .din(dtcm_ram_din),\n    .dout(dtcm_ram_dout),\n    .clk(clk_dtcm_ram),\n    .rst_n(rst_dtcm)\n  );\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 7, "code": "module e203_ifu_ift2icb (\n    input wire itcm_nohold,\n    input wire ifu_req_valid,\n    input wire [PC_SIZE-1:0] ifu_req_pc,\n    input wire ifu_req_seq,\n    input wire ifu_req_seq_rv32,\n    input wire [PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_ready,\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_ready,\n    output wire ifu_rsp_valid,\n    output wire ifu_rsp_err,\n    output wire [31:0] ifu_rsp_instr,\n    output wire ifu2itcm_icb_cmd_valid,\n    input wire ifu2itcm_icb_cmd_ready,\n    output wire [ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_rsp_valid,\n    output wire ifu2itcm_icb_rsp_ready,\n    input wire ifu2itcm_icb_rsp_err,\n    input wire [ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    output wire ifu2biu_icb_cmd_valid,\n    input wire ifu2biu_icb_cmd_ready,\n    output wire [ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input wire ifu2biu_icb_rsp_valid,\n    output wire ifu2biu_icb_rsp_ready,\n    input wire ifu2biu_icb_rsp_err,\n    input wire [SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata\n);\n\n    // State machine definition\n    localparam ICB_STATE_IDLE = 2'b00;\n    localparam ICB_STATE_1ST = 2'b01;\n    localparam ICB_STATE_WAIT2ND = 2'b10;\n    localparam ICB_STATE_2ND = 2'b11;\n\n    reg [1:0] icb_state;\n    reg [1:0] icb_state_nxt;\n\n    // State transition logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            icb_state <= ICB_STATE_IDLE;\n        end else begin\n            icb_state <= icb_state_nxt;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (icb_state)\n            ICB_STATE_IDLE: begin\n                if (ifu_req_valid && ifu_req_ready)\n                    icb_state_nxt = ICB_STATE_1ST;\n                else\n                    icb_state_nxt = ICB_STATE_IDLE;\n            end\n            ICB_STATE_1ST: begin\n                if (ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid)\n                    icb_state_nxt = ifu_req_valid ? ICB_STATE_1ST : ICB_STATE_IDLE;\n                else\n                    icb_state_nxt = ICB_STATE_WAIT2ND;\n            end\n            ICB_STATE_WAIT2ND: begin\n                if (ifu2itcm_icb_cmd_ready || ifu2biu_icb_cmd_ready)\n                    icb_state_nxt = ICB_STATE_2ND;\n                else\n                    icb_state_nxt = ICB_STATE_WAIT2ND;\n            end\n            ICB_STATE_2ND: begin\n                if (ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid)\n                    icb_state_nxt = ifu_req_valid ? ICB_STATE_1ST : ICB_STATE_IDLE;\n                else\n                    icb_state_nxt = ICB_STATE_2ND;\n            end\n            default: icb_state_nxt = ICB_STATE_IDLE;\n        endcase\n    end\n\n    // Output logic\n    assign ifu_req_ready = (icb_state == ICB_STATE_IDLE);\n    assign ifu_rsp_valid = (icb_state == ICB_STATE_1ST) && (ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid);\n    assign ifu_rsp_err = (icb_state == ICB_STATE_1ST) && (ifu2itcm_icb_rsp_err || ifu2biu_icb_rsp_err);\n    assign ifu_rsp_instr = (icb_state == ICB_STATE_1ST) ? ifu2itcm_icb_rsp_rdata : ifu2biu_icb_rsp_rdata;\n\n    // Command generation logic\n    assign ifu2itcm_icb_cmd_valid = (icb_state == ICB_STATE_IDLE) && ifu_req_valid;\n    assign ifu2itcm_icb_cmd_addr = ifu_req_pc[ITCM_ADDR_WIDTH-1:0];\n    assign ifu2itcm_icb_rsp_ready = (icb_state == ICB_STATE_1ST);\n\n    assign ifu2biu_icb_cmd_valid = (icb_state == ICB_STATE_IDLE) && ifu_req_valid;\n    assign ifu2biu_icb_cmd_addr = ifu_req_pc[ADDR_SIZE-1:0];\n    assign ifu2biu_icb_rsp_ready = (icb_state == ICB_STATE_1ST);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 4, "code": "module e203_exu_decode (\n    input [E203_INSTR_SIZE-1:0] i_instr,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_prdt_taken,\n    input i_misalgn,\n    input i_buserr,\n    input i_muldiv_b2b,\n    input dbg_mode,\n    output dec_rs1x0,\n    output dec_rs2x0,\n    output dec_rs1en,\n    output dec_rs2en,\n    output dec_rdwen,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rdidx,\n    output [E203_DECINFO_WIDTH-1:0] dec_info,\n    output [E203_XLEN-1:0] dec_imm,\n    output [E203_PC_SIZE-1:0] dec_pc,\n    output dec_misalgn,\n    output dec_buserr,\n    output dec_ilegl,\n    output dec_mulhsu,\n    output dec_mul,\n    output dec_div,\n    output dec_rem,\n    output dec_divu,\n    output dec_remu,\n    output dec_rv32,\n    output dec_bjp,\n    output dec_jal,\n    output dec_jalr,\n    output dec_bxx,\n    output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    output [E203_XLEN-1:0] dec_bjp_imm,\n    `ifdef E203_HAS_NICE\n    input nice_xs_off,\n    output dec_nice,\n    output nice_cmt_off_ilgl_o,\n    `endif\n);\n\n    // Instruction decoding logic here\n    // This is a placeholder for the actual decoding logic\n    // The outputs should be assigned based on the decoded instruction fields\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 12, "code": "`include \"e203_defines.v\"\n\nmodule e203_itcm_ram #(\n  parameter FORCE_X2ZERO = 0,\n  parameter DP = `E203_ITCM_RAM_DP,\n  parameter DW = `E203_ITCM_RAM_DW,\n  parameter MW = `E203_ITCM_RAM_MW,\n  parameter AW = `E203_ITCM_RAM_AW\n)(\n  input wire sd,\n  input wire ds,\n  input wire ls,\n  input wire cs,\n  input wire we,\n  input wire [AW-1:0] addr,\n  input wire [MW-1:0] wem,\n  input wire [DW-1:0] din,\n  input wire rst_n,\n  input wire clk,\n  output wire [DW-1:0] dout\n);\n\n  sirv_gnrl_ram #(\n    .FORCE_X2ZERO(FORCE_X2ZERO),\n    .DP(DP),\n    .DW(DW),\n    .MW(MW),\n    .AW(AW)\n  ) itcm_ram_inst (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 4, "code": "module e203_ifu_litebpu #(\n  parameter E203_PC_SIZE = 32,\n  parameter E203_XLEN = 32,\n  parameter E203_RFIDX_WIDTH = 5\n)(\n  input clk,\n  input rst_n,\n  input [E203_PC_SIZE-1:0] pc,\n  input dec_jal,\n  input dec_jalr,\n  input dec_bxx,\n  input [E203_XLEN-1:0] dec_bjp_imm,\n  input [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  input oitf_empty,\n  input ir_empty,\n  input ir_rs1en,\n  input jalr_rs1idx_cam_irrdidx,\n  input dec_i_valid,\n  input ir_valid_clr,\n  input [E203_XLEN-1:0] rf2bpu_x1,\n  input [E203_XLEN-1:0] rf2bpu_rs1,\n  output reg prdt_taken,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op1,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op2,\n  output reg bpu_wait,\n  output reg bpu2rf_rs1_ena\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      prdt_taken <= 1'b0;\n      prdt_pc_add_op1 <= {E203_PC_SIZE{1'b0}};\n      prdt_pc_add_op2 <= {E203_PC_SIZE{1'b0}};\n      bpu_wait <= 1'b0;\n      bpu2rf_rs1_ena <= 1'b0;\n    end else begin\n      // Prediction logic for JAL instruction\n      if (dec_jal) begin\n        prdt_taken <= 1'b1;\n        prdt_pc_add_op1 <= pc;\n        prdt_pc_add_op2 <= dec_bjp_imm;\n      end\n      // Prediction logic for JALR instruction\n      else if (dec_jalr) begin\n        prdt_taken <= 1'b1;\n        if (dec_jalr_rs1idx == 0) begin\n          prdt_pc_add_op1 <= 0;\n        end else if (dec_jalr_rs1idx == 1) begin\n          prdt_pc_add_op1 <= rf2bpu_x1;\n          bpu_wait <= !oitf_empty; // Wait if OITF is not empty\n        end else begin\n          prdt_pc_add_op1 <= rf2bpu_rs1;\n          bpu_wait <= !ir_empty && ir_rs1en && jalr_rs1idx_cam_irrdidx;\n        end\n        prdt_pc_add_op2 <= dec_bjp_imm;\n      end\n      // Prediction logic for conditional branches\n      else if (dec_bxx) begin\n        prdt_taken <= dec_bjp_imm[E203_XLEN-1];\n        prdt_pc_add_op1 <= pc;\n        prdt_pc_add_op2 <= dec_bjp_imm;\n      end\n      // Default case to handle unexpected scenarios\n      else begin\n        prdt_taken <= 1'b0;\n        prdt_pc_add_op1 <= pc;\n        prdt_pc_add_op2 <= 0;\n        bpu_wait <= 1'b0;\n      end\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 11, "code": "module e203_exu_alu_lsuagu (\n    input wire agu_i_valid,\n    output wire agu_i_ready,\n    input wire [E203_XLEN-1:0] agu_i_rs1,\n    input wire [E203_XLEN-1:0] agu_i_rs2,\n    input wire [E203_XLEN-1:0] agu_i_imm,\n    input wire [E203_DECINFO_AGU_WIDTH-1:0] agu_i_info,\n    input wire [E203_ITAG_WIDTH-1:0] agu_i_itag,\n    output wire agu_i_longpipe,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire amo_wait,\n    input wire oitf_empty,\n    output wire agu_o_valid,\n    input wire agu_o_ready,\n    output wire [E203_XLEN-1:0] agu_o_wbck_wdat,\n    output wire agu_o_wbck_err,\n    output wire agu_o_cmt_misalgn,\n    output wire agu_o_cmt_ld,\n    output wire agu_o_cmt_stamo,\n    output wire agu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] agu_o_cmt_badaddr,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_cmd_usign,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire [E203_XLEN-1:0] agu_req_alu_op1,\n    output wire [E203_XLEN-1:0] agu_req_alu_op2,\n    output wire agu_req_alu_swap,\n    output wire agu_req_alu_add,\n    output wire agu_req_alu_and,\n    output wire agu_req_alu_or,\n    output wire agu_req_alu_xor,\n    output wire agu_req_alu_max,\n    output wire agu_req_alu_min,\n    output wire agu_req_alu_maxu,\n    output wire agu_req_alu_minu,\n    input wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire agu_sbf_0_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_0_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_0_r,\n    output wire agu_sbf_1_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_1_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_1_r,\n    input wire clk,\n    input wire rst_n\n);\n    // Implementation of AGU logic goes here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 5, "code": "module e203_ifu_litebpu #(\n  parameter E203_PC_SIZE = 32,\n  parameter E203_XLEN = 32,\n  parameter E203_RFIDX_WIDTH = 5\n)(\n  input clk,\n  input rst_n,\n  input [E203_PC_SIZE-1:0] pc,\n  input dec_jal,\n  input dec_jalr,\n  input dec_bxx,\n  input [E203_XLEN-1:0] dec_bjp_imm,\n  input [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  input oitf_empty,\n  input ir_empty,\n  input ir_rs1en,\n  input jalr_rs1idx_cam_irrdidx,\n  input dec_i_valid,\n  input ir_valid_clr,\n  input [E203_XLEN-1:0] rf2bpu_x1,\n  input [E203_XLEN-1:0] rf2bpu_rs1,\n  output reg prdt_taken,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op1,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op2,\n  output reg bpu_wait,\n  output reg bpu2rf_rs1_ena\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      prdt_taken <= 1'b0;\n      prdt_pc_add_op1 <= {E203_PC_SIZE{1'b0}};\n      prdt_pc_add_op2 <= {E203_PC_SIZE{1'b0}};\n      bpu_wait <= 1'b0;\n      bpu2rf_rs1_ena <= 1'b0;\n    end else begin\n      // Default values\n      prdt_taken <= 1'b0;\n      prdt_pc_add_op1 <= pc;\n      prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n      bpu_wait <= 1'b0;\n      bpu2rf_rs1_ena <= 1'b0;\n\n      if (dec_i_valid) begin\n        if (dec_jal) begin\n          prdt_taken <= 1'b1;\n        end else if (dec_jalr) begin\n          prdt_taken <= 1'b1;\n          if (dec_jalr_rs1idx == 0) begin\n            prdt_pc_add_op1 <= 0;\n          end else if (dec_jalr_rs1idx == 1) begin\n            prdt_pc_add_op1 <= rf2bpu_x1;\n            if (!oitf_empty || jalr_rs1idx_cam_irrdidx) begin\n              bpu_wait <= 1'b1;\n            end\n          end else begin\n            prdt_pc_add_op1 <= rf2bpu_rs1;\n            if (!ir_empty && ir_rs1en) begin\n              bpu_wait <= 1'b1;\n            end\n          end\n        end else if (dec_bxx) begin\n          if (dec_bjp_imm[E203_XLEN-1]) begin // Negative offset implies backward jump\n            prdt_taken <= 1'b1;\n          end\n        end\n      end\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 7, "code": "module e203_exu_csr (\n    input wire nonflush_cmt_ena,\n    input wire csr_ena,\n    input wire csr_wr_en,\n    input wire csr_rd_en,\n    input wire [11:0] csr_idx,\n    output wire csr_access_ilgl,\n    output wire tm_stop,\n    output wire core_cgstop,\n    output wire tcm_cgstop,\n    output wire itcm_nohold,\n    output wire mdv_nob2b,\n    output wire [E203_XLEN-1:0] read_csr_dat,\n    input wire [E203_XLEN-1:0] wbck_csr_dat,\n    input wire [E203_HART_ID_W-1:0] core_mhartid,\n    input wire ext_irq_r,\n    input wire sft_irq_r,\n    input wire tmr_irq_r,\n    output wire status_mie_r,\n    output wire mtie_r,\n    output wire msie_r,\n    output wire meie_r,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    input wire [E203_XLEN-1:0] dcsr_r,\n    input wire [E203_PC_SIZE-1:0] dpc_r,\n    input wire [E203_XLEN-1:0] dscratch_r,\n    output wire u_mode,\n    output wire s_mode,\n    output wire h_mode,\n    output wire m_mode,\n    input wire [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    input wire cmt_badaddr_ena,\n    input wire [E203_PC_SIZE-1:0] cmt_epc,\n    input wire cmt_epc_ena,\n    input wire [E203_XLEN-1:0] cmt_cause,\n    input wire cmt_cause_ena,\n    input wire cmt_status_ena,\n    input wire cmt_instret_ena,\n    input wire cmt_mret_ena,\n    output wire [E203_PC_SIZE-1:0] csr_epc_r,\n    output wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    output wire [E203_XLEN-1:0] csr_mtvec_r,\n    input wire clk_aon,\n    input wire clk,\n    input wire rst_n\n);\n\n// Optional Interface\n`ifdef E203_HAS_NICE\n    output wire nice_xs_off;\n`endif\n\n// CSR Logic Implementation\nassign csr_access_ilgl = 0; // Assuming no illegal access in this design\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        // Reset logic\n    end else if (csr_ena) begin\n        if (csr_wr_en) begin\n            // Write logic\n        end\n        if (csr_rd_en) begin\n            // Read logic\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 12, "code": "module e203_exu_longpwbck (\n    input wire lsu_wbck_i_valid,\n    output wire lsu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] lsu_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] lsu_wbck_i_itag,\n    input wire lsu_wbck_i_err,\n    input wire lsu_cmt_i_buserr,\n    input wire [E203_ADDR_SIZE-1:0] lsu_cmt_i_badaddr,\n    input wire lsu_cmt_i_ld,\n    input wire lsu_cmt_i_st,\n    output wire longp_wbck_o_valid,\n    input wire longp_wbck_o_ready,\n    output wire [E203_FLEN-1:0] longp_wbck_o_wdat,\n    output wire [4:0] longp_wbck_o_flags,\n    output wire [E203_RFIDX_WIDTH-1:0] longp_wbck_o_rdidx,\n    output wire longp_wbck_o_rdfpu,\n    output wire longp_excp_o_valid,\n    input wire longp_excp_o_ready,\n    output wire longp_excp_o_insterr,\n    output wire longp_excp_o_ld,\n    output wire longp_excp_o_st,\n    output wire longp_excp_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] longp_excp_o_badaddr,\n    output wire [E203_PC_SIZE-1:0] longp_excp_o_pc,\n    input wire oitf_empty,\n    input wire [E203_ITAG_WIDTH-1:0] oitf_ret_ptr,\n    input wire [E203_RFIDX_WIDTH-1:0] oitf_ret_rdidx,\n    input wire [E203_PC_SIZE-1:0] oitf_ret_pc,\n    input wire oitf_ret_rdwen,\n    input wire oitf_ret_rdfpu,\n    output wire oitf_ret_ena,\n    input wire clk,\n    input wire rst_n\n`ifdef E203_HAS_NICE\n    , input wire nice_longp_wbck_i_valid,\n    output wire nice_longp_wbck_i_ready,\n    input wire [E203_XLEN-1:0] nice_longp_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] nice_longp_wbck_i_itag,\n    input wire nice_longp_wbck_i_err\n`endif\n);\n\n    // Internal signals\n    wire wbck_need, excp_need;\n    wire lsu_match, nice_match;\n    wire wbck_ready, excp_ready;\n    wire wbck_valid, excp_valid;\n\n    assign wbck_need = (oitf_ret_rdwen && !lsu_wbck_i_err);\n    assign excp_need = (lsu_wbck_i_err || lsu_cmt_i_buserr);\n\n    assign lsu_match = (lsu_wbck_i_valid && (lsu_wbck_i_itag == oitf_ret_ptr) && !oitf_empty);\n`ifdef E203_HAS_NICE\n    assign nice_match = (nice_longp_wbck_i_valid && (nice_longp_wbck_i_itag == oitf_ret_ptr) && !oitf_empty);\n`else\n    assign nice_match = 1'b0;\n`endif\n\n    assign wbck_ready = longp_wbck_o_ready || !wbck_need;\n    assign excp_ready = longp_excp_o_ready || !excp_need;\n\n    assign wbck_valid = (lsu_match || nice_match) && wbck_need && wbck_ready;\n    assign excp_valid = (lsu_match || nice_match) && excp_need && excp_ready;\n\n    assign longp_wbck_o_valid = wbck_valid;\n    assign longp_excp_o_valid = excp_valid;\n\n    assign lsu_wbck_i_ready = wbck_ready && excp_ready;\n`ifdef E203_HAS_NICE\n    assign nice_longp_wbck_i_ready = wbck_ready && excp_ready;\n`endif\n\n    assign longp_wbck_o_wdat = lsu_match ? lsu_wbck_i_wdat : nice_longp_wbck_i_wdat;\n    assign longp_wbck_o_rdidx = oitf_ret_rdidx;\n    assign longp_wbck_o_rdfpu = oitf_ret_rdfpu;\n    assign longp_wbck_o_flags = {lsu_cmt_i_ld, lsu_cmt_i_st, lsu_wbck_i_err, lsu_cmt_i_buserr, 1'b0};\n\n    assign longp_excp_o_insterr = lsu_wbck_i_err;\n    assign longp_excp_o_ld = lsu_cmt_i_ld;\n    assign longp_excp_o_st = lsu_cmt_i_st;\n    assign longp_excp_o_buserr = lsu_cmt_i_buserr;\n    assign longp_excp_o_badaddr = lsu_cmt_i_badaddr;\n    assign longp_excp_o_pc = oitf_ret_pc;\n\n    assign oitf_ret_ena = (wbck_valid || excp_valid) && (lsu_match || nice_match);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 17, "code": "module e203_dtcm_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n    output wire dtcm_active,\n\n    // LSU ICB Interface\n    input wire lsu2dtcm_icb_cmd_valid,\n    output wire lsu2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] lsu2dtcm_icb_cmd_addr,\n    input wire lsu2dtcm_icb_cmd_read,\n    input wire [31:0] lsu2dtcm_icb_cmd_wdata,\n    input wire [3:0] lsu2dtcm_icb_cmd_wmask,\n    output wire lsu2dtcm_icb_rsp_valid,\n    input wire lsu2dtcm_icb_rsp_ready,\n    output wire lsu2dtcm_icb_rsp_err,\n    output wire [31:0] lsu2dtcm_icb_rsp_rdata,\n\n    // External ICB Interface (Optional)\n    `ifdef E203_HAS_DTCM_EXTITF\n    input wire ext2dtcm_icb_cmd_valid,\n    output wire ext2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] ext2dtcm_icb_cmd_addr,\n    input wire ext2dtcm_icb_cmd_read,\n    input wire [31:0] ext2dtcm_icb_cmd_wdata,\n    input wire [3:0] ext2dtcm_icb_cmd_wmask,\n    output wire ext2dtcm_icb_rsp_valid,\n    input wire ext2dtcm_icb_rsp_ready,\n    output wire ext2dtcm_icb_rsp_err,\n    output wire [31:0] ext2dtcm_icb_rsp_rdata,\n    `endif\n\n    // DTCM RAM Interface\n    output wire dtcm_ram_cs,\n    output wire dtcm_ram_we,\n    output wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    output wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    output wire clk_dtcm_ram\n);\n\n    // Internal signals\n    wire arb_cmd_valid;\n    wire arb_cmd_ready;\n    wire [E203_DTCM_ADDR_WIDTH-1:0] arb_cmd_addr;\n    wire arb_cmd_read;\n    wire [31:0] arb_cmd_wdata;\n    wire [3:0] arb_cmd_wmask;\n    wire arb_rsp_valid;\n    wire arb_rsp_ready;\n    wire arb_rsp_err;\n    wire [31:0] arb_rsp_rdata;\n\n    // Instantiate the bus arbiter\n    sirv_gnrl_icb_arbt #(\n        .ARBT_SCHEME(0),\n        .ALLOW_0CYCL_RSP(0),\n        .FIFO_OUTS_NUM(E203_DTCM_OUTS_NUM),\n        .FIFO_CUT_READY(0),\n        .USR_W(1),\n        .ARBT_NUM(DTCM_ARBT_I_NUM),\n        .AW(E203_DTCM_ADDR_WIDTH),\n        .DW(32),\n        .ARBT_PTR_W(DTCM_ARBT_I_PTR_W)\n    ) u_dtcm_arbiter (\n        .o_icb_cmd_valid(arb_cmd_valid),\n        .o_icb_cmd_ready(arb_cmd_ready),\n        .o_icb_cmd_addr(arb_cmd_addr),\n        .o_icb_cmd_read(arb_cmd_read),\n        .o_icb_cmd_wdata(arb_cmd_wdata),\n        .o_icb_cmd_wmask(arb_cmd_wmask),\n        .o_icb_rsp_valid(arb_rsp_valid),\n        .o_icb_rsp_ready(arb_rsp_ready),\n        .o_icb_rsp_err(arb_rsp_err),\n        .o_icb_rsp_rdata(arb_rsp_rdata),\n        .i_bus_icb_cmd_ready({lsu2dtcm_icb_cmd_ready, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_cmd_ready `endif}),\n        .i_bus_icb_cmd_valid({lsu2dtcm_icb_cmd_valid, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_cmd_valid `endif}),\n        .i_bus_icb_cmd_read({lsu2dtcm_icb_cmd_read, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_cmd_read `endif}),\n        .i_bus_icb_cmd_addr({lsu2dtcm_icb_cmd_addr, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_cmd_addr `endif}),\n        .i_bus_icb_cmd_wdata({lsu2dtcm_icb_cmd_wdata, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_cmd_wdata `endif}),\n        .i_bus_icb_cmd_wmask({lsu2dtcm_icb_cmd_wmask, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_cmd_wmask `endif}),\n        .i_bus_icb_rsp_valid({lsu2dtcm_icb_rsp_valid, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_rsp_valid `endif}),\n        .i_bus_icb_rsp_ready({lsu2dtcm_icb_rsp_ready, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_rsp_ready `endif}),\n        .i_bus_icb_rsp_err({lsu2dtcm_icb_rsp_err, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_rsp_err `endif}),\n        .i_bus_icb_rsp_rdata({lsu2dtcm_icb_rsp_rdata, `ifdef E203_HAS_DTCM_EXTITF ext2dtcm_icb_rsp_rdata `endif}),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\n    // SRAM controller\n    sirv_sram_icb_ctrl #(\n        .DW(E203_DTCM_DATA_WIDTH),\n        .AW(E203_DTCM_ADDR_WIDTH),\n        .MW(E203_DTCM_WMSK_WIDTH),\n        .AW_LSB(2),\n        .USR_W(1)\n    ) u_dtcm_sram_ctrl (\n        .sram_ctrl_active(dtcm_active),\n        .tcm_cgstop(tcm_cgstop),\n        .i_icb_cmd_valid(arb_cmd_valid),\n        .i_icb_cmd_ready(arb_cmd_ready),\n        .i_icb_cmd_read(arb_cmd_read),\n        .i_icb_cmd_addr(arb_cmd_addr),\n        .i_icb_cmd_wdata(arb_cmd_wdata),\n        .i_icb_cmd_wmask(arb_cmd_wmask),\n        .i_icb_rsp_valid(arb_rsp_valid),\n        .i_icb_rsp_ready(arb_rsp_ready),\n        .i_icb_rsp_rdata(arb_rsp_rdata),\n        .ram_cs(dtcm_ram_cs),\n        .ram_we(dtcm_ram_we),\n        .ram_addr(dtcm_ram_addr),\n        .ram_wem(dtcm_ram_wem),\n        .ram_din(dtcm_ram_din),\n        .ram_dout(dtcm_ram_dout),\n        .clk_ram(clk_dtcm_ram),\n        .test_mode(test_mode),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 7, "code": "module e203_exu_commit(\n    output commit_mret,\n    output commit_trap,\n    output core_wfi,\n    output nonflush_cmt_ena,\n    output excp_active,\n    input amo_wait,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input alu_cmt_i_valid,\n    output alu_cmt_i_ready,\n    input [E203_PC_SIZE-1:0] alu_cmt_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_cmt_i_instr,\n    input alu_cmt_i_pc_vld,\n    input [E203_XLEN-1:0] alu_cmt_i_imm,\n    input alu_cmt_i_rv32,\n    input alu_cmt_i_bjp,\n    input alu_cmt_i_wfi,\n    input alu_cmt_i_fencei,\n    input alu_cmt_i_mret,\n    input alu_cmt_i_dret,\n    input alu_cmt_i_ecall,\n    input alu_cmt_i_ebreak,\n    input alu_cmt_i_ifu_misalgn,\n    input alu_cmt_i_ifu_buserr,\n    input alu_cmt_i_ifu_ilegl,\n    input alu_cmt_i_bjp_prdt,\n    input alu_cmt_i_bjp_rslv,\n    input alu_cmt_i_misalgn,\n    input alu_cmt_i_ld,\n    input alu_cmt_i_stamo,\n    input alu_cmt_i_buserr,\n    input [E203_ADDR_SIZE-1:0] alu_cmt_i_badaddr,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output cmt_badaddr_ena,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output cmt_epc_ena,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_cause_ena,\n    output cmt_instret_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output cmt_mret_ena,\n    input [E203_PC_SIZE-1:0] csr_epc_r,\n    input [E203_PC_SIZE-1:0] csr_dpc_r,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output longp_excp_i_ready,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input longp_excp_i_insterr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc\n);\n    // Implementation of commit logic, exception handling, and flush logic goes here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 6, "code": "module e203_ifu_litebpu #(\n  parameter E203_PC_SIZE = 32,\n  parameter E203_XLEN = 32,\n  parameter E203_RFIDX_WIDTH = 5\n)(\n  input wire clk,\n  input wire rst_n,\n  input wire [E203_PC_SIZE-1:0] pc,\n  input wire dec_jal,\n  input wire dec_jalr,\n  input wire dec_bxx,\n  input wire [E203_XLEN-1:0] dec_bjp_imm,\n  input wire [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  input wire oitf_empty,\n  input wire ir_empty,\n  input wire ir_rs1en,\n  input wire jalr_rs1idx_cam_irrdidx,\n  input wire dec_i_valid,\n  input wire ir_valid_clr,\n  input wire [E203_XLEN-1:0] rf2bpu_x1,\n  input wire [E203_XLEN-1:0] rf2bpu_rs1,\n  output reg prdt_taken,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op1,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op2,\n  output reg bpu_wait,\n  output reg bpu2rf_rs1_ena\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      prdt_taken <= 1'b0;\n      prdt_pc_add_op1 <= {E203_PC_SIZE{1'b0}};\n      prdt_pc_add_op2 <= {E203_PC_SIZE{1'b0}};\n      bpu_wait <= 1'b0;\n      bpu2rf_rs1_ena <= 1'b0;\n    end else begin\n      // Default values\n      prdt_taken <= 1'b0;\n      prdt_pc_add_op1 <= pc;\n      prdt_pc_add_op2 <= dec_bjp_imm;\n      bpu_wait <= 1'b0;\n      bpu2rf_rs1_ena <= 1'b0;\n\n      if (dec_i_valid) begin\n        if (dec_jal) begin\n          prdt_taken <= 1'b1;\n        end else if (dec_jalr) begin\n          prdt_taken <= 1'b1;\n          if (dec_jalr_rs1idx == 0) begin\n            prdt_pc_add_op1 <= 0;\n          end else if (dec_jalr_rs1idx == 1) begin\n            prdt_pc_add_op1 <= rf2bpu_x1;\n            if (!oitf_empty || jalr_rs1idx_cam_irrdidx) begin\n              bpu_wait <= 1'b1;\n            end\n          end else begin\n            prdt_pc_add_op1 <= rf2bpu_rs1;\n            if (!oitf_empty || (ir_rs1en && !ir_empty)) begin\n              bpu_wait <= 1'b1;\n            end\n          end\n        end else if (dec_bxx) begin\n          if (dec_bjp_imm[E203_XLEN-1]) begin\n            prdt_taken <= 1'b1;\n          end\n        end\n      end\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 12, "code": "module e203_exu_regfile (\n    input  wire                     clk,\n    input  wire                     rst_n,\n    input  wire [E203_RFIDX_WIDTH-1:0] read_src1_idx,\n    input  wire [E203_RFIDX_WIDTH-1:0] read_src2_idx,\n    output wire [E203_XLEN-1:0]      read_src1_dat,\n    output wire [E203_XLEN-1:0]      read_src2_dat,\n    input  wire                     wbck_dest_wen,\n    input  wire [E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n    input  wire [E203_XLEN-1:0]      wbck_dest_dat,\n    output wire [E203_XLEN-1:0]      x1_r,\n    input  wire                     test_mode\n);\n\n`include \"e203_defines.v\"\n\n// Register file storage\nreg [E203_XLEN-1:0] regfile [0:E203_RFREG_NUM-1];\n\n// Read logic\nassign read_src1_dat = (read_src1_idx == 0) ? 0 : regfile[read_src1_idx];\nassign read_src2_dat = (read_src2_idx == 0) ? 0 : regfile[read_src2_idx];\n\n// Write logic\nalways @(posedge clk) begin\n    if (wbck_dest_wen && wbck_dest_idx != 0) begin\n        regfile[wbck_dest_idx] <= wbck_dest_dat;\n    end\nend\n\n// Output for register x1\nassign x1_r = regfile[1];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 16, "code": "module e203_srams (\n    input wire itcm_ram_sd,\n    input wire itcm_ram_ds,\n    input wire itcm_ram_ls,\n    input wire itcm_ram_cs,\n    input wire itcm_ram_we,\n    input wire [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n    input wire [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n    input wire [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n    output wire [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n    input wire clk_itcm_ram,\n    input wire rst_itcm,\n\n    input wire dtcm_ram_sd,\n    input wire dtcm_ram_ds,\n    input wire dtcm_ram_ls,\n    input wire dtcm_ram_cs,\n    input wire dtcm_ram_we,\n    input wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    input wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    input wire clk_dtcm_ram,\n    input wire rst_dtcm\n);\n\n`ifdef E203_HAS_ITCM\n    // ITCM instantiation\n    ram #(\n        .ADDR_WIDTH(E203_ITCM_RAM_AW),\n        .DATA_WIDTH(E203_ITCM_RAM_DW),\n        .MASK_WIDTH(E203_ITCM_RAM_MW)\n    ) itcm_ram (\n        .clk(clk_itcm_ram),\n        .rst(rst_itcm),\n        .cs(itcm_ram_cs),\n        .we(itcm_ram_we),\n        .addr(itcm_ram_addr),\n        .wem(itcm_ram_wem),\n        .din(itcm_ram_din),\n        .dout(itcm_ram_dout),\n        .sd(itcm_ram_sd),\n        .ds(itcm_ram_ds),\n        .ls(itcm_ram_ls)\n    );\n`endif\n\n`ifdef E203_HAS_DTCM\n    // DTCM instantiation\n    ram #(\n        .ADDR_WIDTH(E203_DTCM_RAM_AW),\n        .DATA_WIDTH(E203_DTCM_RAM_DW),\n        .MASK_WIDTH(E203_DTCM_RAM_MW)\n    ) dtcm_ram (\n        .clk(clk_dtcm_ram),\n        .rst(rst_dtcm),\n        .cs(dtcm_ram_cs),\n        .we(dtcm_ram_we),\n        .addr(dtcm_ram_addr),\n        .wem(dtcm_ram_wem),\n        .din(dtcm_ram_din),\n        .dout(dtcm_ram_dout),\n        .sd(dtcm_ram_sd),\n        .ds(dtcm_ram_ds),\n        .ls(dtcm_ram_ls)\n    );\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 8, "code": "module e203_exu_csr (\n    input wire nonflush_cmt_ena,\n    input wire csr_ena,\n    input wire csr_wr_en,\n    input wire csr_rd_en,\n    input wire [11:0] csr_idx,\n    output reg csr_access_ilgl,\n    output reg tm_stop,\n    output reg core_cgstop,\n    output reg tcm_cgstop,\n    output reg itcm_nohold,\n    output reg mdv_nob2b,\n    output reg [E203_XLEN-1:0] read_csr_dat,\n    input wire [E203_XLEN-1:0] wbck_csr_dat,\n    input wire [E203_HART_ID_W-1:0] core_mhartid,\n    input wire ext_irq_r,\n    input wire sft_irq_r,\n    input wire tmr_irq_r,\n    output reg status_mie_r,\n    output reg mtie_r,\n    output reg msie_r,\n    output reg meie_r,\n    output reg wr_dcsr_ena,\n    output reg wr_dpc_ena,\n    output reg wr_dscratch_ena,\n    input wire [E203_XLEN-1:0] dcsr_r,\n    input wire [E203_PC_SIZE-1:0] dpc_r,\n    input wire [E203_XLEN-1:0] dscratch_r,\n    output reg u_mode,\n    output reg s_mode,\n    output reg h_mode,\n    output reg m_mode,\n    input wire [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    input wire cmt_badaddr_ena,\n    input wire [E203_PC_SIZE-1:0] cmt_epc,\n    input wire cmt_epc_ena,\n    input wire [E203_XLEN-1:0] cmt_cause,\n    input wire cmt_cause_ena,\n    input wire cmt_status_ena,\n    input wire cmt_instret_ena,\n    input wire cmt_mret_ena,\n    output reg [E203_PC_SIZE-1:0] csr_epc_r,\n    output reg [E203_PC_SIZE-1:0] csr_dpc_r,\n    output reg [E203_XLEN-1:0] csr_mtvec_r,\n    input wire clk_aon,\n    input wire clk,\n    input wire rst_n\n);\n\n    // CSR Access Control Logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            csr_access_ilgl <= 1'b0;\n            tm_stop <= 1'b0;\n            core_cgstop <= 1'b0;\n            tcm_cgstop <= 1'b0;\n            itcm_nohold <= 1'b0;\n            mdv_nob2b <= 1'b0;\n            read_csr_dat <= {E203_XLEN{1'b0}};\n            status_mie_r <= 1'b0;\n            mtie_r <= 1'b0;\n            msie_r <= 1'b0;\n            meie_r <= 1'b0;\n            wr_dcsr_ena <= 1'b0;\n            wr_dpc_ena <= 1'b0;\n            wr_dscratch_ena <= 1'b0;\n            u_mode <= 1'b0;\n            s_mode <= 1'b0;\n            h_mode <= 1'b0;\n            m_mode <= 1'b1;\n            csr_epc_r <= {E203_PC_SIZE{1'b0}};\n            csr_dpc_r <= {E203_PC_SIZE{1'b0}};\n            csr_mtvec_r <= {E203_XLEN{1'b0}};\n        end else if (csr_ena) begin\n            if (csr_wr_en && !csr_access_ilgl) begin\n                case (csr_idx)\n                    12'h300: begin // mstatus\n                        // Update mstatus register\n                    end\n                    12'h304: begin // mie\n                        // Update mie register\n                    end\n                    12'h305: begin // mtvec\n                        // Update mtvec register\n                    end\n                    12'h341: begin // mepc\n                        // Update mepc register\n                    end\n                    // Add more CSR indices as needed\n                    default: begin\n                        csr_access_ilgl <= 1'b1;\n                    end\n                endcase\n            end\n            if (csr_rd_en && !csr_access_ilgl) begin\n                case (csr_idx)\n                    12'h300: read_csr_dat <= {E203_XLEN{1'b0}}; // mstatus\n                    12'h304: read_csr_dat <= {E203_XLEN{1'b0}}; // mie\n                    12'h305: read_csr_dat <= {E203_XLEN{1'b0}}; // mtvec\n                    12'h341: read_csr_dat <= {E203_XLEN{1'b0}}; // mepc\n                    // Add more CSR indices as needed\n                    default: begin\n                        csr_access_ilgl <= 1'b1;\n                    end\n                endcase\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 9, "code": "module e203_exu_disp (\n    input wire wfi_halt_exu_req,\n    output wire wfi_halt_exu_ack,\n    input wire oitf_empty,\n    input wire amo_wait,\n    input wire disp_i_valid,\n    output wire disp_i_ready,\n    input wire disp_i_rs1x0,\n    input wire disp_i_rs2x0,\n    input wire disp_i_rs1en,\n    input wire disp_i_rs2en,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input wire [E203_XLEN-1:0] disp_i_rs1,\n    input wire [E203_XLEN-1:0] disp_i_rs2,\n    input wire disp_i_rdwen,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input wire [E203_DECINFO_WIDTH-1:0] disp_i_info,\n    input wire [E203_XLEN-1:0] disp_i_imm,\n    input wire [E203_PC_SIZE-1:0] disp_i_pc,\n    input wire disp_i_misalgn,\n    input wire disp_i_buserr,\n    input wire disp_i_ilegl,\n    output wire disp_o_alu_valid,\n    input wire disp_o_alu_ready,\n    input wire disp_o_alu_longpipe,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs1,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs2,\n    output wire disp_o_alu_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_o_alu_rdidx,\n    output wire [E203_DECINFO_WIDTH-1:0] disp_o_alu_info,\n    output wire [E203_XLEN-1:0] disp_o_alu_imm,\n    output wire [E203_PC_SIZE-1:0] disp_o_alu_pc,\n    output wire [E203_ITAG_WIDTH-1:0] disp_o_alu_itag,\n    output wire disp_o_alu_misalgn,\n    output wire disp_o_alu_buserr,\n    output wire disp_o_alu_ilegl,\n    input wire oitfrd_match_disprs1,\n    input wire oitfrd_match_disprs2,\n    input wire oitfrd_match_disprs3,\n    input wire oitfrd_match_disprd,\n    input wire [E203_ITAG_WIDTH-1:0] disp_oitf_ptr,\n    output wire disp_oitf_ena,\n    input wire disp_oitf_ready,\n    output wire disp_oitf_rs1fpu,\n    output wire disp_oitf_rs2fpu,\n    output wire disp_oitf_rs3fpu,\n    output wire disp_oitf_rdfpu,\n    output wire disp_oitf_rs1en,\n    output wire disp_oitf_rs2en,\n    output wire disp_oitf_rs3en,\n    output wire disp_oitf_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs2idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs3idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rdidx,\n    output wire [E203_PC_SIZE-1:0] disp_oitf_pc,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Implementation of dispatch logic, dependency checks, and WFI handling\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 12, "code": "module e203_exu_alu_lsuagu (\n    input wire agu_i_valid,\n    output wire agu_i_ready,\n    input wire [E203_XLEN-1:0] agu_i_rs1,\n    input wire [E203_XLEN-1:0] agu_i_rs2,\n    input wire [E203_XLEN-1:0] agu_i_imm,\n    input wire [E203_DECINFO_AGU_WIDTH-1:0] agu_i_info,\n    input wire [E203_ITAG_WIDTH-1:0] agu_i_itag,\n    output wire agu_i_longpipe,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire amo_wait,\n    input wire oitf_empty,\n    output wire agu_o_valid,\n    input wire agu_o_ready,\n    output wire [E203_XLEN-1:0] agu_o_wbck_wdat,\n    output wire agu_o_wbck_err,\n    output wire agu_o_cmt_misalgn,\n    output wire agu_o_cmt_ld,\n    output wire agu_o_cmt_stamo,\n    output wire agu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] agu_o_cmt_badaddr,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_cmd_usign,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire [E203_XLEN-1:0] agu_req_alu_op1,\n    output wire [E203_XLEN-1:0] agu_req_alu_op2,\n    output wire agu_req_alu_swap,\n    output wire agu_req_alu_add,\n    output wire agu_req_alu_and,\n    output wire agu_req_alu_or,\n    output wire agu_req_alu_xor,\n    output wire agu_req_alu_max,\n    output wire agu_req_alu_min,\n    output wire agu_req_alu_maxu,\n    output wire agu_req_alu_minu,\n    input wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire agu_sbf_0_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_0_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_0_r,\n    output wire agu_sbf_1_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_1_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_1_r,\n    input wire clk,\n    input wire rst_n\n);\n    // Implementation of the AGU logic goes here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 5, "code": "module e203_ifu(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire itcm_nohold,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire ifu_active,\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    input wire pipe_flush_req,\n    output wire pipe_flush_ack,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input wire ifu_halt_req,\n    output wire ifu_halt_ack,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu\n);\n\n    // Internal signals\n    wire ifu_req_valid;\n    wire [E203_PC_SIZE-1:0] ifu_req_pc;\n    wire ifu_req_seq;\n    wire ifu_req_seq_rv32;\n    wire [E203_PC_SIZE-1:0] ifu_req_last_pc;\n    wire ifu_rsp_valid;\n    wire ifu_rsp_err;\n    wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr;\n\n    // Instantiate the instruction fetch module\n    e203_ifu_ifetch ifetch (\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ifu_o_ready(ifu_o_ready),\n        .pipe_flush_req(pipe_flush_req),\n        .pipe_flush_add_op1(pipe_flush_add_op1),\n        .pipe_flush_add_op2(pipe_flush_add_op2),\n        .ifu_halt_req(ifu_halt_req),\n        .oitf_empty(oitf_empty),\n        .rf2ifu_x1(rf2ifu_x1),\n        .rf2ifu_rs1(rf2ifu_rs1),\n        .dec2ifu_rden(dec2ifu_rden),\n        .dec2ifu_rs1en(dec2ifu_rs1en),\n        .dec2ifu_rdidx(dec2ifu_rdidx),\n        .dec2ifu_mulhsu(dec2ifu_mulhsu),\n        .dec2ifu_div(dec2ifu_div),\n        .dec2ifu_rem(dec2ifu_rem),\n        .dec2ifu_divu(dec2ifu_divu),\n        .dec2ifu_remu(dec2ifu_remu),\n        .inspect_pc(inspect_pc),\n        .ifu_req_valid(ifu_req_valid),\n        .ifu_req_pc(ifu_req_pc),\n        .ifu_req_seq(ifu_req_seq),\n        .ifu_req_seq_rv32(ifu_req_seq_rv32),\n        .ifu_req_last_pc(ifu_req_last_pc),\n        .pipe_flush_ack(pipe_flush_ack),\n        .ifu_halt_ack(ifu_halt_ack),\n        .ifu_o_ir(ifu_o_ir),\n        .ifu_o_pc(ifu_o_pc),\n        .ifu_o_pc_vld(ifu_o_pc_vld),\n        .ifu_o_misalgn(ifu_o_misalgn),\n        .ifu_o_buserr(ifu_o_buserr),\n        .ifu_o_rs1idx(ifu_o_rs1idx),\n        .ifu_o_rs2idx(ifu_o_rs2idx),\n        .ifu_o_prdt_taken(ifu_o_prdt_taken),\n        .ifu_o_muldiv_b2b(ifu_o_muldiv_b2b),\n        .ifu_o_valid(ifu_o_valid)\n    );\n\n    // Instantiate the bus interface unit\n    e203_ifu_ift2icb ift2icb (\n        .clk(clk),\n        .rst_n(rst_n),\n        .ifu_req_valid(ifu_req_valid),\n        .ifu_req_pc(ifu_req_pc),\n        .ifu_req_seq(ifu_req_seq),\n        .ifu_req_seq_rv32(ifu_req_seq_rv32),\n        .ifu_req_last_pc(ifu_req_last_pc),\n        .ifu_rsp_ready(ifu_o_ready),\n        .itcm_nohold(itcm_nohold),\n        .ifu_rsp_valid(ifu_rsp_valid),\n        .ifu_rsp_err(ifu_rsp_err),\n        .ifu_rsp_instr(ifu_rsp_instr)\n    );\n\n    // Logic to handle instruction fetch activity\n    assign ifu_active = ifu_req_valid || ifu_rsp_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 8, "code": "module e203_ifu_ift2icb (\n    input wire itcm_nohold,\n    input wire ifu_req_valid,\n    input wire [PC_SIZE-1:0] ifu_req_pc,\n    input wire ifu_req_seq,\n    input wire ifu_req_seq_rv32,\n    input wire [PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_ready,\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_ready,\n    output wire ifu_rsp_valid,\n    output wire ifu_rsp_err,\n    output wire [31:0] ifu_rsp_instr,\n    output wire ifu2itcm_icb_cmd_valid,\n    input wire ifu2itcm_icb_cmd_ready,\n    output wire [ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_rsp_valid,\n    output wire ifu2itcm_icb_rsp_ready,\n    input wire ifu2itcm_icb_rsp_err,\n    input wire [ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    output wire ifu2biu_icb_cmd_valid,\n    input wire ifu2biu_icb_cmd_ready,\n    output wire [ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input wire ifu2biu_icb_rsp_valid,\n    output wire ifu2biu_icb_rsp_ready,\n    input wire ifu2biu_icb_rsp_err,\n    input wire [SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata\n);\n\n    // State definitions\n    localparam ICB_STATE_IDLE = 2'b00;\n    localparam ICB_STATE_1ST = 2'b01;\n    localparam ICB_STATE_WAIT2ND = 2'b10;\n    localparam ICB_STATE_2ND = 2'b11;\n\n    // State registers\n    reg [1:0] icb_state;\n    reg [1:0] icb_state_nxt;\n\n    // State transition logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            icb_state <= ICB_STATE_IDLE;\n        end else begin\n            icb_state <= icb_state_nxt;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (icb_state)\n            ICB_STATE_IDLE: begin\n                if (ifu_req_valid && ifu_req_ready)\n                    icb_state_nxt = ICB_STATE_1ST;\n                else\n                    icb_state_nxt = ICB_STATE_IDLE;\n            end\n            ICB_STATE_1ST: begin\n                if (ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid)\n                    icb_state_nxt = ICB_STATE_WAIT2ND;\n                else\n                    icb_state_nxt = ICB_STATE_1ST;\n            end\n            ICB_STATE_WAIT2ND: begin\n                if (ifu2itcm_icb_cmd_ready || ifu2biu_icb_cmd_ready)\n                    icb_state_nxt = ICB_STATE_2ND;\n                else\n                    icb_state_nxt = ICB_STATE_WAIT2ND;\n            end\n            ICB_STATE_2ND: begin\n                if (ifu_rsp_ready)\n                    icb_state_nxt = ICB_STATE_IDLE;\n                else\n                    icb_state_nxt = ICB_STATE_2ND;\n            end\n            default: icb_state_nxt = ICB_STATE_IDLE;\n        endcase\n    end\n\n    // Output logic\n    assign ifu_req_ready = (icb_state == ICB_STATE_IDLE);\n    assign ifu_rsp_valid = (icb_state == ICB_STATE_2ND) && (ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid);\n    assign ifu_rsp_err = (icb_state == ICB_STATE_2ND) && (ifu2itcm_icb_rsp_err || ifu2biu_icb_rsp_err);\n    assign ifu_rsp_instr = (icb_state == ICB_STATE_2ND) ? (ifu2itcm_icb_rsp_rdata[31:0] : ifu2biu_icb_rsp_rdata[31:0]);\n\n    // ICB command signals\n    assign ifu2itcm_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && (ifu_req_pc < `ITCM_ADDR_BASE);\n    assign ifu2itcm_icb_cmd_addr = ifu_req_pc[ITCM_ADDR_WIDTH-1:0];\n    assign ifu2itcm_icb_rsp_ready = (icb_state == ICB_STATE_1ST) || (icb_state == ICB_STATE_2ND);\n\n    assign ifu2biu_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && (ifu_req_pc >= `ITCM_ADDR_BASE);\n    assign ifu2biu_icb_cmd_addr = ifu_req_pc[ADDR_SIZE-1:0];\n    assign ifu2biu_icb_rsp_ready = (icb_state == ICB_STATE_1ST) || (icb_state == ICB_STATE_2ND);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 13, "code": "module e203_exu_alu_lsuagu (\n    input wire agu_i_valid,\n    output wire agu_i_ready,\n    input wire [E203_XLEN-1:0] agu_i_rs1,\n    input wire [E203_XLEN-1:0] agu_i_rs2,\n    input wire [E203_XLEN-1:0] agu_i_imm,\n    input wire [E203_DECINFO_AGU_WIDTH-1:0] agu_i_info,\n    input wire [E203_ITAG_WIDTH-1:0] agu_i_itag,\n    output wire agu_i_longpipe,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire amo_wait,\n    input wire oitf_empty,\n    output wire agu_o_valid,\n    input wire agu_o_ready,\n    output wire [E203_XLEN-1:0] agu_o_wbck_wdat,\n    output wire agu_o_wbck_err,\n    output wire agu_o_cmt_misalgn,\n    output wire agu_o_cmt_ld,\n    output wire agu_o_cmt_stamo,\n    output wire agu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] agu_o_cmt_badaddr,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_cmd_usign,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire [E203_XLEN-1:0] agu_req_alu_op1,\n    output wire [E203_XLEN-1:0] agu_req_alu_op2,\n    output wire agu_req_alu_swap,\n    output wire agu_req_alu_add,\n    output wire agu_req_alu_and,\n    output wire agu_req_alu_or,\n    output wire agu_req_alu_xor,\n    output wire agu_req_alu_max,\n    output wire agu_req_alu_min,\n    output wire agu_req_alu_maxu,\n    output wire agu_req_alu_minu,\n    input wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire agu_sbf_0_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_0_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_0_r,\n    output wire agu_sbf_1_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_1_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_1_r,\n    input wire clk,\n    input wire rst_n\n);\n    // Implementation of AGU logic here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 13, "code": "module e203_itcm_ram #(\n  parameter FORCE_X2ZERO = 0,\n  parameter DP = `E203_ITCM_RAM_DP,\n  parameter DW = `E203_ITCM_RAM_DW,\n  parameter MW = `E203_ITCM_RAM_MW,\n  parameter AW = `E203_ITCM_RAM_AW\n)(\n  input wire sd,\n  input wire ds,\n  input wire ls,\n  input wire cs,\n  input wire we,\n  input wire [AW-1:0] addr,\n  input wire [MW-1:0] wem,\n  input wire [DW-1:0] din,\n  input wire rst_n,\n  input wire clk,\n  output wire [DW-1:0] dout\n);\n\n  // Instantiate the generic RAM module\n  sirv_gnrl_ram #(\n    .FORCE_X2ZERO(FORCE_X2ZERO),\n    .DP(DP),\n    .DW(DW),\n    .MW(MW),\n    .AW(AW)\n  ) u_sirv_gnrl_ram (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 13, "code": "module e203_exu_alu_dpath(\n    input wire alu_req_alu,\n    input wire alu_req_alu_add,\n    input wire alu_req_alu_sub,\n    input wire alu_req_alu_xor,\n    input wire alu_req_alu_sll,\n    input wire alu_req_alu_srl,\n    input wire alu_req_alu_sra,\n    input wire alu_req_alu_or,\n    input wire alu_req_alu_and,\n    input wire [E203_XLEN-1:0] alu_req_alu_op1,\n    input wire [E203_XLEN-1:0] alu_req_alu_op2,\n    input wire bjp_req_alu,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    input wire agu_req_alu,\n    input wire [E203_XLEN-1:0] agu_req_alu_op1,\n    input wire [E203_XLEN-1:0] agu_req_alu_op2,\n    input wire muldiv_req_alu,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    input wire muldiv_req_alu_add,\n    input wire muldiv_req_alu_sub,\n    input wire muldiv_sbf_0_ena,\n    input wire [32:0] muldiv_sbf_0_nxt,\n    input wire muldiv_sbf_1_ena,\n    input wire [32:0] muldiv_sbf_1_nxt,\n    input wire clk,\n    input wire rst_n,\n    output wire [E203_XLEN-1:0] alu_req_alu_res,\n    output wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    output wire bjp_req_alu_cmp_res,\n    output wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output wire [32:0] muldiv_sbf_0_r,\n    output wire [32:0] muldiv_sbf_1_r\n);\n\n    // Internal signals for ALU operations\n    wire [E203_XLEN-1:0] add_result;\n    wire [E203_XLEN-1:0] sub_result;\n    wire [E203_XLEN-1:0] and_result;\n    wire [E203_XLEN-1:0] or_result;\n    wire [E203_XLEN-1:0] xor_result;\n    wire [E203_XLEN-1:0] sll_result;\n    wire [E203_XLEN-1:0] srl_result;\n    wire [E203_XLEN-1:0] sra_result;\n\n    // ALU operations\n    assign add_result = alu_req_alu_op1 + alu_req_alu_op2;\n    assign sub_result = alu_req_alu_op1 - alu_req_alu_op2;\n    assign and_result = alu_req_alu_op1 & alu_req_alu_op2;\n    assign or_result = alu_req_alu_op1 | alu_req_alu_op2;\n    assign xor_result = alu_req_alu_op1 ^ alu_req_alu_op2;\n    assign sll_result = alu_req_alu_op1 << alu_req_alu_op2;\n    assign srl_result = alu_req_alu_op1 >> alu_req_alu_op2;\n    assign sra_result = $signed(alu_req_alu_op1) >>> alu_req_alu_op2;\n\n    // Multiplexer for ALU result output\n    assign alu_req_alu_res = (alu_req_alu_add) ? add_result :\n                             (alu_req_alu_sub) ? sub_result :\n                             (alu_req_alu_and) ? and_result :\n                             (alu_req_alu_or)  ? or_result :\n                             (alu_req_alu_xor) ? xor_result :\n                             (alu_req_alu_sll) ? sll_result :\n                             (alu_req_alu_srl) ? srl_result :\n                             (alu_req_alu_sra) ? sra_result : \n                             {E203_XLEN{1'b0}};\n\n    // BJP and AGU operations\n    assign bjp_req_alu_add_res = bjp_req_alu_op1 + bjp_req_alu_op2;\n    assign bjp_req_alu_cmp_res = (bjp_req_alu_op1 == bjp_req_alu_op2);\n    assign agu_req_alu_res = (agu_req_alu) ? (agu_req_alu_op1 + agu_req_alu_op2) : {E203_XLEN{1'b0}};\n\n    // MULDIV operations\n    assign muldiv_req_alu_res = (muldiv_req_alu_add) ? (muldiv_req_alu_op1 + muldiv_req_alu_op2) :\n                                (muldiv_req_alu_sub) ? (muldiv_req_alu_op1 - muldiv_req_alu_op2) :\n                                {E203_ALU_ADDER_WIDTH{1'b0}};\n\n    // Shared buffers\n    sirv_gnrl_dffl #(33) sbf_0_dffl (\n        .lden(muldiv_sbf_0_ena),\n        .dnxt(muldiv_sbf_0_nxt),\n        .qout(muldiv_sbf_0_r),\n        .clk(clk)\n    );\n\n    sirv_gnrl_dffl #(33) sbf_1_dffl (\n        .lden(muldiv_sbf_1_ena),\n        .dnxt(muldiv_sbf_1_nxt),\n        .qout(muldiv_sbf_1_r),\n        .clk(clk)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 14, "code": "module e203_exu_wbck (\n    input wire alu_wbck_i_valid,\n    output reg alu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] alu_wbck_i_wdat,\n    input wire [E203_RFIDX_WIDTH-1:0] alu_wbck_i_rdidx,\n    input wire longp_wbck_i_valid,\n    output reg longp_wbck_i_ready,\n    input wire [E203_FLEN-1:0] longp_wbck_i_wdat,\n    input wire [4:0] longp_wbck_i_flags,\n    input wire [E203_RFIDX_WIDTH-1:0] longp_wbck_i_rdidx,\n    input wire longp_wbck_i_rdfpu,\n    output reg rf_wbck_o_ena,\n    output reg [E203_XLEN-1:0] rf_wbck_o_wdat,\n    output reg [E203_RFIDX_WIDTH-1:0] rf_wbck_o_rdidx,\n    input wire clk,\n    input wire rst_n\n);\n\n    always @(*) begin\n        // Default assignments\n        alu_wbck_i_ready = 1'b0;\n        longp_wbck_i_ready = 1'b0;\n        rf_wbck_o_ena = 1'b0;\n        rf_wbck_o_wdat = {E203_XLEN{1'b0}};\n        rf_wbck_o_rdidx = {E203_RFIDX_WIDTH{1'b0}};\n\n        // Arbitration logic\n        if (longp_wbck_i_valid) begin\n            longp_wbck_i_ready = 1'b1;\n            rf_wbck_o_ena = ~longp_wbck_i_rdfpu;\n            rf_wbck_o_wdat = longp_wbck_i_wdat;\n            rf_wbck_o_rdidx = longp_wbck_i_rdidx;\n        end else if (alu_wbck_i_valid) begin\n            alu_wbck_i_ready = 1'b1;\n            rf_wbck_o_ena = 1'b1;\n            rf_wbck_o_wdat = alu_wbck_i_wdat;\n            rf_wbck_o_rdidx = alu_wbck_i_rdidx;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 18, "code": "module e203_exu_alu_csrctrl (\n    input wire csr_i_valid,\n    output reg csr_i_ready,\n    input wire [E203_XLEN-1:0] csr_i_rs1,\n    input wire [E203_DECINFO_CSR_WIDTH-1:0] csr_i_info,\n    input wire csr_i_rdwen,\n    output reg csr_ena,\n    output reg csr_wr_en,\n    output reg csr_rd_en,\n    output reg [11:0] csr_idx,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output reg [E203_XLEN-1:0] wbck_csr_dat,\n    output reg csr_o_valid,\n    input wire csr_o_ready,\n    output reg [E203_XLEN-1:0] csr_o_wbck_wdat,\n    output reg csr_o_wbck_err,\n    input wire clk,\n    input wire rst_n,\n\n    // NICE interface signals\n    input wire nice_xs_off,\n    output reg csr_sel_nice,\n    output reg nice_csr_valid,\n    input wire nice_csr_ready,\n    output reg [31:0] nice_csr_addr,\n    output reg nice_csr_wr,\n    output reg [31:0] nice_csr_wdata,\n    input wire [31:0] nice_csr_rdata\n);\n\n    // Decode CSR instruction information\n    wire csrrw = csr_i_info[E203_DECINFO_CSR_CSRRW];\n    wire csrrs = csr_i_info[E203_DECINFO_CSR_CSRRS];\n    wire csrrc = csr_i_info[E203_DECINFO_CSR_CSRRC];\n    wire rs1imm = csr_i_info[E203_DECINFO_CSR_RS1IMM];\n    wire rs1is0 = csr_i_info[E203_DECINFO_CSR_RS1IS0];\n    wire [4:0] zimm = csr_i_info[E203_DECINFO_CSR_ZIMMM];\n    wire [11:0] csr_idx_info = csr_i_info[E203_DECINFO_CSR_CSRIDX];\n\n    // CSR index and data preparation\n    always @(*) begin\n        csr_idx = csr_idx_info;\n        wbck_csr_dat = (csrrw ? csr_i_rs1 : \n                        (csrrs ? (read_csr_dat | csr_i_rs1) : \n                        (csrrc ? (read_csr_dat & ~csr_i_rs1) : read_csr_dat)));\n    end\n\n    // Control signal generation\n    always @(*) begin\n        csr_rd_en = (csr_i_valid && ((csrrw && csr_i_rdwen) || csrrs || csrrc));\n        csr_wr_en = (csr_i_valid && ((csrrw || (csrrs && !rs1is0) || (csrrc && !rs1is0))));\n        csr_ena = csr_i_valid && csr_o_ready && !nice_xs_off;\n        csr_i_ready = csr_o_ready;\n        csr_o_valid = csr_i_valid && csr_o_ready;\n        csr_o_wbck_wdat = read_csr_dat;\n        csr_o_wbck_err = csr_access_ilgl;\n\n        // NICE interface handling\n        csr_sel_nice = (csr_idx[11:8] == 4'hE) && !nice_xs_off;\n        nice_csr_valid = csr_i_valid && csr_o_ready && csr_sel_nice;\n        nice_csr_addr = {20'h0, csr_idx};\n        nice_csr_wr = csr_wr_en && csr_sel_nice;\n        nice_csr_wdata = wbck_csr_dat;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 17, "code": "module e203_srams (\n    input wire itcm_ram_sd,\n    input wire itcm_ram_ds,\n    input wire itcm_ram_ls,\n    input wire itcm_ram_cs,\n    input wire itcm_ram_we,\n    input wire [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n    input wire [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n    input wire [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n    output wire [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n    input wire clk_itcm_ram,\n    input wire rst_itcm,\n\n    input wire dtcm_ram_sd,\n    input wire dtcm_ram_ds,\n    input wire dtcm_ram_ls,\n    input wire dtcm_ram_cs,\n    input wire dtcm_ram_we,\n    input wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    input wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    input wire clk_dtcm_ram,\n    input wire rst_dtcm\n);\n\n`ifdef E203_HAS_ITCM\n    e203_itcm_ram #(\n        .AW(E203_ITCM_RAM_AW),\n        .MW(E203_ITCM_RAM_MW),\n        .DW(E203_ITCM_RAM_DW)\n    ) itcm_ram_inst (\n        .sd(itcm_ram_sd),\n        .ds(itcm_ram_ds),\n        .ls(itcm_ram_ls),\n        .cs(itcm_ram_cs),\n        .we(itcm_ram_we),\n        .addr(itcm_ram_addr),\n        .wem(itcm_ram_wem),\n        .din(itcm_ram_din),\n        .dout(itcm_ram_dout),\n        .clk(clk_itcm_ram),\n        .rst_n(rst_itcm)\n    );\n`endif\n\n`ifdef E203_HAS_DTCM\n    e203_dtcm_ram #(\n        .AW(E203_DTCM_RAM_AW),\n        .MW(E203_DTCM_RAM_MW),\n        .DW(E203_DTCM_RAM_DW)\n    ) dtcm_ram_inst (\n        .sd(dtcm_ram_sd),\n        .ds(dtcm_ram_ds),\n        .ls(dtcm_ram_ls),\n        .cs(dtcm_ram_cs),\n        .we(dtcm_ram_we),\n        .addr(dtcm_ram_addr),\n        .wem(dtcm_ram_wem),\n        .din(dtcm_ram_din),\n        .dout(dtcm_ram_dout),\n        .clk(clk_dtcm_ram),\n        .rst_n(rst_dtcm)\n    );\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 5, "code": "module e203_lsu(\n    input wire commit_mret,\n    input wire commit_trap,\n    input wire excp_active,\n    output wire lsu_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n    output wire [ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_buserr,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [XLEN-1:0] agu_icb_rsp_rdata,\n\n    input wire nice_mem_holdup,\n    input wire itcm_region_indic,\n    input wire dtcm_region_indic\n);\n    // LSU logic implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 9, "code": "module e203_exu_csr(\n    input wire nonflush_cmt_ena,\n    input wire csr_ena,\n    input wire csr_wr_en,\n    input wire csr_rd_en,\n    input wire [11:0] csr_idx,\n    output wire csr_access_ilgl,\n    output wire tm_stop,\n    output wire core_cgstop,\n    output wire tcm_cgstop,\n    output wire itcm_nohold,\n    output wire mdv_nob2b,\n    output wire [E203_XLEN-1:0] read_csr_dat,\n    input wire [E203_XLEN-1:0] wbck_csr_dat,\n    input wire [E203_HART_ID_W-1:0] core_mhartid,\n    input wire ext_irq_r,\n    input wire sft_irq_r,\n    input wire tmr_irq_r,\n    output wire status_mie_r,\n    output wire mtie_r,\n    output wire msie_r,\n    output wire meie_r,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    input wire [E203_XLEN-1:0] dcsr_r,\n    input wire [E203_PC_SIZE-1:0] dpc_r,\n    input wire [E203_XLEN-1:0] dscratch_r,\n    output wire u_mode,\n    output wire s_mode,\n    output wire h_mode,\n    output wire m_mode,\n    input wire [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    input wire cmt_badaddr_ena,\n    input wire [E203_PC_SIZE-1:0] cmt_epc,\n    input wire cmt_epc_ena,\n    input wire [E203_XLEN-1:0] cmt_cause,\n    input wire cmt_cause_ena,\n    input wire cmt_status_ena,\n    input wire cmt_instret_ena,\n    input wire cmt_mret_ena,\n    output wire [E203_PC_SIZE-1:0] csr_epc_r,\n    output wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    output wire [E203_XLEN-1:0] csr_mtvec_r,\n    input wire clk_aon,\n    input wire clk,\n    input wire rst_n\n    `ifdef E203_HAS_NICE\n    , output wire nice_xs_off\n    `endif\n);\n\n    // Implementation of CSR logic here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 14, "code": "module e203_exu_oitf #(\n  parameter E203_ITAG_WIDTH = 4,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_PC_SIZE = 32,\n  parameter E203_OITF_DEPTH = 16\n)(\n  input  wire                     clk,\n  input  wire                     rst_n,\n  \n  output wire                     dis_ready,\n  input  wire                     dis_ena,\n  input  wire                     ret_ena,\n  \n  output wire [E203_ITAG_WIDTH-1:0] dis_ptr,\n  output wire [E203_ITAG_WIDTH-1:0] ret_ptr,\n  output wire [E203_RFIDX_WIDTH-1:0] ret_rdidx,\n  output wire                     ret_rdwen,\n  output wire                     ret_rdfpu,\n  output wire [E203_PC_SIZE-1:0]  ret_pc,\n  \n  input  wire                     disp_i_rs1en,\n  input  wire                     disp_i_rs2en,\n  input  wire                     disp_i_rs3en,\n  input  wire                     disp_i_rdwen,\n  input  wire                     disp_i_rs1fpu,\n  input  wire                     disp_i_rs2fpu,\n  input  wire                     disp_i_rs3fpu,\n  input  wire                     disp_i_rdfpu,\n  input  wire [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n  input  wire [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n  input  wire [E203_RFIDX_WIDTH-1:0] disp_i_rs3idx,\n  input  wire [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n  input  wire [E203_PC_SIZE-1:0]  disp_i_pc,\n  \n  output wire                     oitfrd_match_disprs1,\n  output wire                     oitfrd_match_disprs2,\n  output wire                     oitfrd_match_disprs3,\n  output wire                     oitfrd_match_disprd,\n  output wire                     oitf_empty\n);\n\n  reg [E203_RFIDX_WIDTH-1:0] rdidx [0:E203_OITF_DEPTH-1];\n  reg [E203_PC_SIZE-1:0]     pc [0:E203_OITF_DEPTH-1];\n  reg                        rdwen [0:E203_OITF_DEPTH-1];\n  reg                        rdfpu [0:E203_OITF_DEPTH-1];\n  reg [E203_ITAG_WIDTH-1:0]  head, tail;\n  wire                       full, empty;\n  \n  assign full = ((head == tail) && (rdwen[head] != 1'b0));\n  assign empty = ((head == tail) && (rdwen[head] == 1'b0));\n  assign oitf_empty = empty;\n  assign dis_ready = !full;\n  \n  integer i;\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      for (i = 0; i < E203_OITF_DEPTH; i = i + 1) begin\n        rdidx[i] <= {E203_RFIDX_WIDTH{1'b0}};\n        pc[i]    <= {E203_PC_SIZE{1'b0}};\n        rdwen[i] <= 1'b0;\n        rdfpu[i] <= 1'b0;\n      end\n      head <= 0;\n      tail <= 0;\n    end else begin\n      if (dis_ena && dis_ready) begin\n        rdidx[tail] <= disp_i_rdidx;\n        pc[tail]    <= disp_i_pc;\n        rdwen[tail] <= disp_i_rdwen;\n        rdfpu[tail] <= disp_i_rdfpu;\n        tail <= tail + 1;\n      end\n      if (ret_ena && !empty) begin\n        rdwen[head] <= 1'b0;\n        head <= head + 1;\n      end\n    end\n  end\n  \n  assign dis_ptr = tail;\n  assign ret_ptr = head;\n  assign ret_rdidx = rdidx[head];\n  assign ret_rdwen = rdwen[head];\n  assign ret_rdfpu = rdfpu[head];\n  assign ret_pc = pc[head];\n  \n  wire [E203_OITF_DEPTH-1:0] match_rs1, match_rs2, match_rs3, match_rd;\n  generate\n    genvar idx;\n    for (idx = 0; idx < E203_OITF_DEPTH; idx = idx + 1) begin\n      assign match_rs1[idx] = (disp_i_rs1idx == rdidx[idx]) && rdwen[idx] && (disp_i_rs1fpu == rdfpu[idx]);\n      assign match_rs2[idx] = (disp_i_rs2idx == rdidx[idx]) && rdwen[idx] && (disp_i_rs2fpu == rdfpu[idx]);\n      assign match_rs3[idx] = (disp_i_rs3idx == rdidx[idx]) && rdwen[idx] && (disp_i_rs3fpu == rdfpu[idx]);\n      assign match_rd[idx]  = (disp_i_rdidx == rdidx[idx]) && rdwen[idx] && (disp_i_rdfpu == rdfpu[idx]);\n    end\n  endgenerate\n  \n  assign oitfrd_match_disprs1 = |match_rs1;\n  assign oitfrd_match_disprs2 = |match_rs2;\n  assign oitfrd_match_disprs3 = |match_rs3;\n  assign oitfrd_match_disprd = |match_rd;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 13, "code": "module e203_irq_sync (\n    input wire clk,\n    input wire rst_n,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire dbg_irq_a,\n    output wire ext_irq_r,\n    output wire sft_irq_r,\n    output wire tmr_irq_r,\n    output wire dbg_irq_r\n);\n\n    // Synchronization module for external interrupt\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) u_ext_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(ext_irq_a),\n        .dout(ext_irq_r)\n    );\n\n    // Synchronization module for software interrupt\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) u_sft_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(sft_irq_a),\n        .dout(sft_irq_r)\n    );\n\n    // Synchronization module for timer interrupt\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) u_tmr_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(tmr_irq_a),\n        .dout(tmr_irq_r)\n    );\n\n    // Synchronization module for debug interrupt\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) u_dbg_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(dbg_irq_a),\n        .dout(dbg_irq_r)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 15, "code": "module e203_exu_alu_rglr (\n    input wire alu_i_valid,\n    output reg alu_i_ready,\n    input wire [E203_XLEN-1:0] alu_i_rs1,\n    input wire [E203_XLEN-1:0] alu_i_rs2,\n    input wire [E203_XLEN-1:0] alu_i_imm,\n    input wire [E203_PC_SIZE-1:0] alu_i_pc,\n    input wire [E203_DECINFO_ALU_WIDTH-1:0] alu_i_info,\n    output reg alu_o_valid,\n    input wire alu_o_ready,\n    output reg [E203_XLEN-1:0] alu_o_wbck_wdat,\n    output reg alu_o_wbck_err,\n    output reg alu_o_cmt_ecall,\n    output reg alu_o_cmt_ebreak,\n    output reg alu_o_cmt_wfi,\n    output reg alu_req_alu_add,\n    output reg alu_req_alu_sub,\n    output reg alu_req_alu_xor,\n    output reg alu_req_alu_sll,\n    output reg alu_req_alu_srl,\n    output reg alu_req_alu_sra,\n    output reg alu_req_alu_or,\n    output reg alu_req_alu_and,\n    output reg alu_req_alu_slt,\n    output reg alu_req_alu_sltu,\n    output reg alu_req_alu_lui,\n    output reg [E203_XLEN-1:0] alu_req_alu_op1,\n    output reg [E203_XLEN-1:0] alu_req_alu_op2,\n    output reg [E203_XLEN-1:0] alu_req_alu_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Handshake mechanism\n    always @(*) begin\n        alu_i_ready = alu_o_ready;\n        alu_o_valid = alu_i_valid;\n    end\n\n    // Decode the ALU operation\n    always @(*) begin\n        alu_req_alu_add = alu_i_info[E203_DECINFO_ALU_ADD];\n        alu_req_alu_sub = alu_i_info[E203_DECINFO_ALU_SUB];\n        alu_req_alu_xor = alu_i_info[E203_DECINFO_ALU_XOR];\n        alu_req_alu_sll = alu_i_info[E203_DECINFO_ALU_SLL];\n        alu_req_alu_srl = alu_i_info[E203_DECINFO_ALU_SRL];\n        alu_req_alu_sra = alu_i_info[E203_DECINFO_ALU_SRA];\n        alu_req_alu_or  = alu_i_info[E203_DECINFO_ALU_OR];\n        alu_req_alu_and = alu_i_info[E203_DECINFO_ALU_AND];\n        alu_req_alu_slt = alu_i_info[E203_DECINFO_ALU_SLT];\n        alu_req_alu_sltu = alu_i_info[E203_DECINFO_ALU_SLTU];\n        alu_req_alu_lui = alu_i_info[E203_DECINFO_ALU_LUI];\n    end\n\n    // Select the correct operands\n    always @(*) begin\n        alu_req_alu_op1 = (alu_i_info[E203_DECINFO_ALU_OP1PC]) ? alu_i_pc : alu_i_rs1;\n        alu_req_alu_op2 = (alu_i_info[E203_DECINFO_ALU_OP2IMM]) ? alu_i_imm : alu_i_rs2;\n    end\n\n    // Compute the result\n    always @(*) begin\n        case (1'b1) // synthesis parallel_case\n            alu_req_alu_add: alu_req_alu_res = alu_req_alu_op1 + alu_req_alu_op2;\n            alu_req_alu_sub: alu_req_alu_res = alu_req_alu_op1 - alu_req_alu_op2;\n            alu_req_alu_xor: alu_req_alu_res = alu_req_alu_op1 ^ alu_req_alu_op2;\n            alu_req_alu_sll: alu_req_alu_res = alu_req_alu_op1 << alu_req_alu_op2;\n            alu_req_alu_srl: alu_req_alu_res = alu_req_alu_op1 >> alu_req_alu_op2;\n            alu_req_alu_sra: alu_req_alu_res = $signed(alu_req_alu_op1) >>> alu_req_alu_op2;\n            alu_req_alu_or:  alu_req_alu_res = alu_req_alu_op1 | alu_req_alu_op2;\n            alu_req_alu_and: alu_req_alu_res = alu_req_alu_op1 & alu_req_alu_op2;\n            alu_req_alu_slt: alu_req_alu_res = ($signed(alu_req_alu_op1) < $signed(alu_req_alu_op2)) ? 1 : 0;\n            alu_req_alu_sltu: alu_req_alu_res = (alu_req_alu_op1 < alu_req_alu_op2) ? 1 : 0;\n            alu_req_alu_lui: alu_req_alu_res = alu_req_alu_op2;\n            default: alu_req_alu_res = 0;\n        endcase\n    end\n\n    // Write back and special instructions\n    always @(*) begin\n        alu_o_wbck_wdat = alu_req_alu_res;\n        alu_o_wbck_err = alu_i_info[E203_DECINFO_ALU_ECAL] | alu_i_info[E203_DECINFO_ALU_EBRK] | alu_i_info[E203_DECINFO_ALU_WFI];\n        alu_o_cmt_ecall = alu_i_info[E203_DECINFO_ALU_ECAL];\n        alu_o_cmt_ebreak = alu_i_info[E203_DECINFO_ALU_EBRK];\n        alu_o_cmt_wfi = alu_i_info[E203_DECINFO_ALU_WFI];\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 14, "code": "module e203_exu_alu_dpath(\n    input wire alu_req_alu,\n    input wire alu_req_alu_add,\n    input wire alu_req_alu_sub,\n    input wire alu_req_alu_xor,\n    input wire alu_req_alu_sll,\n    input wire alu_req_alu_srl,\n    input wire alu_req_alu_sra,\n    input wire alu_req_alu_or,\n    input wire alu_req_alu_and,\n    input wire [E203_XLEN-1:0] alu_req_alu_op1,\n    input wire [E203_XLEN-1:0] alu_req_alu_op2,\n    input wire bjp_req_alu,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    input wire agu_req_alu,\n    input wire [E203_XLEN-1:0] agu_req_alu_op1,\n    input wire [E203_XLEN-1:0] agu_req_alu_op2,\n    input wire muldiv_req_alu,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    input wire muldiv_req_alu_add,\n    input wire muldiv_req_alu_sub,\n    input wire muldiv_sbf_0_ena,\n    input wire [32:0] muldiv_sbf_0_nxt,\n    input wire muldiv_sbf_1_ena,\n    input wire [32:0] muldiv_sbf_1_nxt,\n    input wire clk,\n    input wire rst_n,\n    output wire [E203_XLEN-1:0] alu_req_alu_res,\n    output wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    output wire bjp_req_alu_cmp_res,\n    output wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output wire [32:0] muldiv_sbf_0_r,\n    output wire [32:0] muldiv_sbf_1_r\n);\n\n    // Internal signals for ALU operations\n    wire [E203_XLEN-1:0] add_res;\n    wire [E203_XLEN-1:0] sub_res;\n    wire [E203_XLEN-1:0] xor_res;\n    wire [E203_XLEN-1:0] or_res;\n    wire [E203_XLEN-1:0] and_res;\n    wire [E203_XLEN-1:0] sll_res;\n    wire [E203_XLEN-1:0] srl_res;\n    wire [E203_XLEN-1:0] sra_res;\n\n    // ALU Operations\n    assign add_res = alu_req_alu_op1 + alu_req_alu_op2;\n    assign sub_res = alu_req_alu_op1 - alu_req_alu_op2;\n    assign xor_res = alu_req_alu_op1 ^ alu_req_alu_op2;\n    assign or_res = alu_req_alu_op1 | alu_req_alu_op2;\n    assign and_res = alu_req_alu_op1 & alu_req_alu_op2;\n    assign sll_res = alu_req_alu_op1 << alu_req_alu_op2[E203_XLEN-1:0];\n    assign srl_res = alu_req_alu_op1 >> alu_req_alu_op2[E203_XLEN-1:0];\n    assign sra_res = $signed(alu_req_alu_op1) >>> alu_req_alu_op2[E203_XLEN-1:0];\n\n    // Result multiplexing\n    assign alu_req_alu_res = ({E203_XLEN{alu_req_alu_add}} & add_res) |\n                             ({E203_XLEN{alu_req_alu_sub}} & sub_res) |\n                             ({E203_XLEN{alu_req_alu_xor}} & xor_res) |\n                             ({E203_XLEN{alu_req_alu_or}} & or_res) |\n                             ({E203_XLEN{alu_req_alu_and}} & and_res) |\n                             ({E203_XLEN{alu_req_alu_sll}} & sll_res) |\n                             ({E203_XLEN{alu_req_alu_srl}} & srl_res) |\n                             ({E203_XLEN{alu_req_alu_sra}} & sra_res);\n\n    // BJP, AGU, MULDIV results are not implemented in this example for brevity\n    assign bjp_req_alu_add_res = 0;\n    assign bjp_req_alu_cmp_res = 0;\n    assign agu_req_alu_res = 0;\n    assign muldiv_req_alu_res = 0;\n\n    // Shared buffers\n    sirv_gnrl_dffl #(.DW(33)) sbf_0_dffl (\n        .lden(muldiv_sbf_0_ena),\n        .dnxt(muldiv_sbf_0_nxt),\n        .qout(muldiv_sbf_0_r),\n        .clk(clk)\n    );\n\n    sirv_gnrl_dffl #(.DW(33)) sbf_1_dffl (\n        .lden(muldiv_sbf_1_ena),\n        .dnxt(muldiv_sbf_1_nxt),\n        .qout(muldiv_sbf_1_r),\n        .clk(clk)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 13, "code": "module e203_exu_regfile #(\n  parameter E203_RFIDX_WIDTH = 5, // Width of the register index\n  parameter E203_XLEN = 32        // Width of the register data\n)(\n  input  wire                     clk,\n  input  wire                     rst_n,\n  input  wire [E203_RFIDX_WIDTH-1:0] read_src1_idx,\n  input  wire [E203_RFIDX_WIDTH-1:0] read_src2_idx,\n  output wire [E203_XLEN-1:0]     read_src1_dat,\n  output wire [E203_XLEN-1:0]     read_src2_dat,\n  input  wire                     wbck_dest_wen,\n  input  wire [E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n  input  wire [E203_XLEN-1:0]     wbck_dest_dat,\n  output wire [E203_XLEN-1:0]     x1_r,\n  input  wire                     test_mode\n);\n\n  // Local parameters for register file size\n  `ifdef E203_CFG_REGNUM_IS_32\n    localparam NUM_REGS = 32;\n  `elsif E203_CFG_REGNUM_IS_16\n    localparam NUM_REGS = 16;\n  `else\n    localparam NUM_REGS = 32; // Default size\n  `endif\n\n  // Register array\n  reg [E203_XLEN-1:0] regs [0:NUM_REGS-1];\n\n  // Read logic\n  assign read_src1_dat = (read_src1_idx == 0) ? 0 : regs[read_src1_idx];\n  assign read_src2_dat = (read_src2_idx == 0) ? 0 : regs[read_src2_idx];\n\n  // Write logic\n  always @(posedge clk) begin\n    if (wbck_dest_wen && (wbck_dest_idx != 0)) begin\n      regs[wbck_dest_idx] <= wbck_dest_dat;\n    end\n  end\n\n  // Special register x1 output\n  assign x1_r = regs[1];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 14, "code": "module e203_exu_alu_lsuagu (\n    input wire agu_i_valid,\n    output wire agu_i_ready,\n    input wire [E203_XLEN-1:0] agu_i_rs1,\n    input wire [E203_XLEN-1:0] agu_i_rs2,\n    input wire [E203_XLEN-1:0] agu_i_imm,\n    input wire [E203_DECINFO_AGU_WIDTH-1:0] agu_i_info,\n    input wire [E203_ITAG_WIDTH-1:0] agu_i_itag,\n    output wire agu_i_longpipe,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire amo_wait,\n    input wire oitf_empty,\n    output wire agu_o_valid,\n    input wire agu_o_ready,\n    output wire [E203_XLEN-1:0] agu_o_wbck_wdat,\n    output wire agu_o_wbck_err,\n    output wire agu_o_cmt_misalgn,\n    output wire agu_o_cmt_ld,\n    output wire agu_o_cmt_stamo,\n    output wire agu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] agu_o_cmt_badaddr,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_cmd_usign,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire [E203_XLEN-1:0] agu_req_alu_op1,\n    output wire [E203_XLEN-1:0] agu_req_alu_op2,\n    output wire agu_req_alu_swap,\n    output wire agu_req_alu_add,\n    output wire agu_req_alu_and,\n    output wire agu_req_alu_or,\n    output wire agu_req_alu_xor,\n    output wire agu_req_alu_max,\n    output wire agu_req_alu_min,\n    output wire agu_req_alu_maxu,\n    output wire agu_req_alu_minu,\n    input wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire agu_sbf_0_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_0_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_0_r,\n    output wire agu_sbf_1_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_1_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_1_r,\n    input wire clk,\n    input wire rst_n\n);\n    // Implementation of the AGU logic goes here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 14, "code": "module e203_irq_sync (\n    input wire clk,\n    input wire rst_n,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire dbg_irq_a,\n    output wire ext_irq_r,\n    output wire sft_irq_r,\n    output wire tmr_irq_r,\n    output wire dbg_irq_r\n);\n\n// Synchronization instances for each interrupt type\nsirv_gnrl_sync #(\n    .DP(2),\n    .DW(1)\n) u_ext_sync (\n    .clk(clk),\n    .rst_n(rst_n),\n    .din_a(ext_irq_a),\n    .dout(ext_irq_r)\n);\n\nsirv_gnrl_sync #(\n    .DP(2),\n    .DW(1)\n) u_sft_sync (\n    .clk(clk),\n    .rst_n(rst_n),\n    .din_a(sft_irq_a),\n    .dout(sft_irq_r)\n);\n\nsirv_gnrl_sync #(\n    .DP(2),\n    .DW(1)\n) u_tmr_sync (\n    .clk(clk),\n    .rst_n(rst_n),\n    .din_a(tmr_irq_a),\n    .dout(tmr_irq_r)\n);\n\nsirv_gnrl_sync #(\n    .DP(2),\n    .DW(1)\n) u_dbg_sync (\n    .clk(clk),\n    .rst_n(rst_n),\n    .din_a(dbg_irq_a),\n    .dout(dbg_irq_r)\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 15, "code": "module e203_exu_wbck (\n    input wire alu_wbck_i_valid,\n    output wire alu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] alu_wbck_i_wdat,\n    input wire [E203_RFIDX_WIDTH-1:0] alu_wbck_i_rdidx,\n    input wire longp_wbck_i_valid,\n    output wire longp_wbck_i_ready,\n    input wire [E203_FLEN-1:0] longp_wbck_i_wdat,\n    input wire [4:0] longp_wbck_i_flags,\n    input wire [E203_RFIDX_WIDTH-1:0] longp_wbck_i_rdidx,\n    input wire longp_wbck_i_rdfpu,\n    output wire rf_wbck_o_ena,\n    output wire [E203_XLEN-1:0] rf_wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] rf_wbck_o_rdidx,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Arbitration logic\n    assign longp_wbck_i_ready = longp_wbck_i_valid;\n    assign alu_wbck_i_ready = !longp_wbck_i_valid && alu_wbck_i_valid;\n\n    // Write-back data selection\n    wire [E203_XLEN-1:0] selected_wdat = longp_wbck_i_valid ? longp_wbck_i_wdat : alu_wbck_i_wdat;\n    wire [E203_RFIDX_WIDTH-1:0] selected_rdidx = longp_wbck_i_valid ? longp_wbck_i_rdidx : alu_wbck_i_rdidx;\n    wire selected_rdfpu = longp_wbck_i_valid ? longp_wbck_i_rdfpu : 1'b0;\n\n    // Write-back enable\n    assign rf_wbck_o_ena = (alu_wbck_i_valid || longp_wbck_i_valid) && !selected_rdfpu;\n\n    // Write-back data and register index output\n    assign rf_wbck_o_wdat = selected_wdat;\n    assign rf_wbck_o_rdidx = selected_rdidx;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 14, "code": "module e203_exu_alu_bjp (\n    input wire bjp_i_valid,\n    output wire bjp_i_ready,\n    input wire [E203_XLEN-1:0] bjp_i_rs1,\n    input wire [E203_XLEN-1:0] bjp_i_rs2,\n    input wire [E203_XLEN-1:0] bjp_i_imm,\n    input wire [E203_PC_SIZE-1:0] bjp_i_pc,\n    input wire [E203_DECINFO_BJP_WIDTH-1:0] bjp_i_info,\n    output wire bjp_o_valid,\n    input wire bjp_o_ready,\n    output wire [E203_XLEN-1:0] bjp_o_wbck_wdat,\n    output wire bjp_o_wbck_err,\n    output wire bjp_o_cmt_bjp,\n    output wire bjp_o_cmt_mret,\n    output wire bjp_o_cmt_dret,\n    output wire bjp_o_cmt_fencei,\n    output wire bjp_o_cmt_prdt,\n    output wire bjp_o_cmt_rslv,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    output wire bjp_req_alu_cmp_eq,\n    output wire bjp_req_alu_cmp_ne,\n    output wire bjp_req_alu_cmp_lt,\n    output wire bjp_req_alu_cmp_gt,\n    output wire bjp_req_alu_cmp_ltu,\n    output wire bjp_req_alu_cmp_gtu,\n    output wire bjp_req_alu_add,\n    input wire bjp_req_alu_cmp_res,\n    input wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Handshake mechanism\n    assign bjp_i_ready = bjp_o_ready;\n    assign bjp_o_valid = bjp_i_valid;\n\n    // Default outputs\n    assign bjp_o_wbck_err = 1'b0;\n\n    // Operand selection\n    assign bjp_req_alu_op1 = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? bjp_i_pc : bjp_i_rs1;\n    assign bjp_req_alu_op2 = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? (E203_XLEN == 32 ? 32'd4 : 64'd2) : bjp_i_rs2;\n\n    // ALU operation request signals\n    assign bjp_req_alu_cmp_eq  = bjp_i_info[E203_DECINFO_BJP_BEQ];\n    assign bjp_req_alu_cmp_ne  = bjp_i_info[E203_DECINFO_BJP_BNE];\n    assign bjp_req_alu_cmp_lt  = bjp_i_info[E203_DECINFO_BJP_BLT];\n    assign bjp_req_alu_cmp_gt  = bjp_i_info[E203_DECINFO_BJP_BGT];\n    assign bjp_req_alu_cmp_ltu = bjp_i_info[E203_DECINFO_BJP_BLTU];\n    assign bjp_req_alu_cmp_gtu = bjp_i_info[E203_DECINFO_BJP_BGTU];\n    assign bjp_req_alu_add     = bjp_i_info[E203_DECINFO_BJP_JUMP];\n\n    // Commit signals\n    assign bjp_o_cmt_bjp       = bjp_i_info[E203_DECINFO_BJP_BXX] | bjp_i_info[E203_DECINFO_BJP_JUMP];\n    assign bjp_o_cmt_mret      = bjp_i_info[E203_DECINFO_BJP_MRET];\n    assign bjp_o_cmt_dret      = bjp_i_info[E203_DECINFO_BJP_DRET];\n    assign bjp_o_cmt_fencei    = bjp_i_info[E203_DECINFO_BJP_FENCEI];\n\n    // Predicted and resolved branch results\n    assign bjp_o_cmt_prdt      = bjp_i_info[E203_DECINFO_BJP_BPRDT];\n    assign bjp_o_cmt_rslv      = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? 1'b1 : bjp_req_alu_cmp_res;\n\n    // Write back data\n    assign bjp_o_wbck_wdat     = bjp_req_alu_add_res;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 16, "code": "module e203_exu_alu_rglr(\n    input wire alu_i_valid,\n    output reg alu_i_ready,\n    input wire [E203_XLEN-1:0] alu_i_rs1,\n    input wire [E203_XLEN-1:0] alu_i_rs2,\n    input wire [E203_XLEN-1:0] alu_i_imm,\n    input wire [E203_PC_SIZE-1:0] alu_i_pc,\n    input wire [E203_DECINFO_ALU_WIDTH-1:0] alu_i_info,\n    output reg alu_o_valid,\n    input wire alu_o_ready,\n    output reg [E203_XLEN-1:0] alu_o_wbck_wdat,\n    output reg alu_o_wbck_err,\n    output reg alu_o_cmt_ecall,\n    output reg alu_o_cmt_ebreak,\n    output reg alu_o_cmt_wfi,\n    output reg alu_req_alu_add,\n    output reg alu_req_alu_sub,\n    output reg alu_req_alu_xor,\n    output reg alu_req_alu_sll,\n    output reg alu_req_alu_srl,\n    output reg alu_req_alu_sra,\n    output reg alu_req_alu_or,\n    output reg alu_req_alu_and,\n    output reg alu_req_alu_slt,\n    output reg alu_req_alu_sltu,\n    output reg alu_req_alu_lui,\n    output reg [E203_XLEN-1:0] alu_req_alu_op1,\n    output reg [E203_XLEN-1:0] alu_req_alu_op2,\n    output reg [E203_XLEN-1:0] alu_req_alu_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    always @(*) begin\n        // Default assignments\n        alu_i_ready = alu_o_ready;\n        alu_o_valid = alu_i_valid;\n        alu_o_wbck_err = 0;\n        alu_o_cmt_ecall = 0;\n        alu_o_cmt_ebreak = 0;\n        alu_o_cmt_wfi = 0;\n\n        // Default operation requests\n        alu_req_alu_add = 0;\n        alu_req_alu_sub = 0;\n        alu_req_alu_xor = 0;\n        alu_req_alu_sll = 0;\n        alu_req_alu_srl = 0;\n        alu_req_alu_sra = 0;\n        alu_req_alu_or = 0;\n        alu_req_alu_and = 0;\n        alu_req_alu_slt = 0;\n        alu_req_alu_sltu = 0;\n        alu_req_alu_lui = 0;\n\n        // Selecting operands\n        alu_req_alu_op1 = (alu_i_info[E203_DECINFO_ALU_OP1PC]) ? alu_i_pc : alu_i_rs1;\n        alu_req_alu_op2 = (alu_i_info[E203_DECINFO_ALU_OP2IMM]) ? alu_i_imm : alu_i_rs2;\n\n        // Decoding ALU operations\n        if (alu_i_info[E203_DECINFO_ALU_ADD]) alu_req_alu_add = 1;\n        if (alu_i_info[E203_DECINFO_ALU_SUB]) alu_req_alu_sub = 1;\n        if (alu_i_info[E203_DECINFO_ALU_XOR]) alu_req_alu_xor = 1;\n        if (alu_i_info[E203_DECINFO_ALU_SLL]) alu_req_alu_sll = 1;\n        if (alu_i_info[E203_DECINFO_ALU_SRL]) alu_req_alu_srl = 1;\n        if (alu_i_info[E203_DECINFO_ALU_SRA]) alu_req_alu_sra = 1;\n        if (alu_i_info[E203_DECINFO_ALU_OR]) alu_req_alu_or = 1;\n        if (alu_i_info[E203_DECINFO_ALU_AND]) alu_req_alu_and = 1;\n        if (alu_i_info[E203_DECINFO_ALU_SLT]) alu_req_alu_slt = 1;\n        if (alu_i_info[E203_DECINFO_ALU_SLTU]) alu_req_alu_sltu = 1;\n        if (alu_i_info[E203_DECINFO_ALU_LUI]) alu_req_alu_lui = 1;\n\n        // Handling special instructions\n        if (alu_i_info[E203_DECINFO_ALU_ECAL]) begin\n            alu_o_cmt_ecall = 1;\n            alu_o_wbck_err = 1;\n        end\n        if (alu_i_info[E203_DECINFO_ALU_EBRK]) begin\n            alu_o_cmt_ebreak = 1;\n            alu_o_wbck_err = 1;\n        end\n        if (alu_i_info[E203_DECINFO_ALU_WFI]) begin\n            alu_o_cmt_wfi = 1;\n            alu_o_wbck_err = 1;\n        end\n\n        // Compute result\n        alu_req_alu_res = 0; // Placeholder for actual ALU result computation\n        alu_o_wbck_wdat = alu_req_alu_res;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 6, "code": "module e203_ifu(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire itcm_nohold,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire ifu_active,\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    input wire pipe_flush_req,\n    output wire pipe_flush_ack,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input wire ifu_halt_req,\n    output wire ifu_halt_ack,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu\n);\n\n    // Internal signals\n    wire ifetch_req_valid;\n    wire ifetch_req_ready;\n    wire [E203_PC_SIZE-1:0] ifetch_req_pc;\n    wire ifetch_rsp_valid;\n    wire ifetch_rsp_ready;\n    wire [E203_INSTR_SIZE-1:0] ifetch_rsp_instr;\n    wire ifetch_rsp_err;\n\n    // Instantiate the instruction fetch module\n    e203_ifu_ifetch ifetch (\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ifu_o_ready(ifu_o_ready),\n        .pipe_flush_req(pipe_flush_req),\n        .pipe_flush_add_op1(pipe_flush_add_op1),\n        .pipe_flush_add_op2(pipe_flush_add_op2),\n        .ifu_halt_req(ifu_halt_req),\n        .oitf_empty(oitf_empty),\n        .rf2ifu_x1(rf2ifu_x1),\n        .rf2ifu_rs1(rf2ifu_rs1),\n        .dec2ifu_rden(dec2ifu_rden),\n        .dec2ifu_rs1en(dec2ifu_rs1en),\n        .dec2ifu_rdidx(dec2ifu_rdidx),\n        .dec2ifu_mulhsu(dec2ifu_mulhsu),\n        .dec2ifu_div(dec2ifu_div),\n        .dec2ifu_rem(dec2ifu_rem),\n        .dec2ifu_divu(dec2ifu_divu),\n        .dec2ifu_remu(dec2ifu_remu),\n        .inspect_pc(inspect_pc),\n        .ifu_req_valid(ifetch_req_valid),\n        .ifu_req_pc(ifetch_req_pc),\n        .ifu_req_ready(ifetch_req_ready),\n        .pipe_flush_ack(pipe_flush_ack),\n        .ifu_halt_ack(ifu_halt_ack),\n        .ifu_o_ir(ifu_o_ir),\n        .ifu_o_pc(ifu_o_pc),\n        .ifu_o_pc_vld(ifu_o_pc_vld),\n        .ifu_o_misalgn(ifu_o_misalgn),\n        .ifu_o_buserr(ifu_o_buserr),\n        .ifu_o_rs1idx(ifu_o_rs1idx),\n        .ifu_o_rs2idx(ifu_o_rs2idx),\n        .ifu_o_prdt_taken(ifu_o_prdt_taken),\n        .ifu_o_muldiv_b2b(ifu_o_muldiv_b2b),\n        .ifu_o_valid(ifu_o_valid)\n    );\n\n    // Instantiate the IFT2ICB interface converter\n    e203_ifu_ift2icb ift2icb (\n        .clk(clk),\n        .rst_n(rst_n),\n        .ifu_req_valid(ifetch_req_valid),\n        .ifu_req_pc(ifetch_req_pc),\n        .ifu_req_ready(ifetch_req_ready),\n        .ifu_rsp_valid(ifetch_rsp_valid),\n        .ifu_rsp_ready(ifetch_rsp_ready),\n        .ifu_rsp_instr(ifetch_rsp_instr),\n        .ifu_rsp_err(ifetch_rsp_err),\n        .itcm_nohold(itcm_nohold)\n    );\n\n    // IFU activity indicator logic\n    assign ifu_active = ifetch_req_valid || ifetch_rsp_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 19, "code": "module e203_exu_alu_csrctrl (\n    input wire csr_i_valid,\n    output reg csr_i_ready,\n    input wire [E203_XLEN-1:0] csr_i_rs1,\n    input wire [E203_DECINFO_CSR_WIDTH-1:0] csr_i_info,\n    input wire csr_i_rdwen,\n    output reg csr_ena,\n    output reg csr_wr_en,\n    output reg csr_rd_en,\n    output reg [11:0] csr_idx,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output reg [E203_XLEN-1:0] wbck_csr_dat,\n    output reg csr_o_valid,\n    input wire csr_o_ready,\n    output reg [E203_XLEN-1:0] csr_o_wbck_wdat,\n    output reg csr_o_wbck_err,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Handshake mechanism\n    always @(*) begin\n        csr_i_ready = csr_o_ready;\n        csr_o_valid = csr_i_valid;\n    end\n\n    // CSR operation decoding\n    always @(*) begin\n        csr_idx = csr_i_info[E203_DECINFO_CSR_CSRIDX +: 12];\n        csr_ena = csr_i_valid && csr_o_ready;\n        csr_rd_en = csr_i_valid && (csr_i_info[E203_DECINFO_CSR_CSRRW] || csr_i_info[E203_DECINFO_CSR_CSRRS] || csr_i_info[E203_DECINFO_CSR_CSRRC]);\n        csr_wr_en = csr_i_valid && ((csr_i_info[E203_DECINFO_CSR_CSRRW]) || (csr_i_info[E203_DECINFO_CSR_CSRRS] && !csr_i_info[E203_DECINFO_CSR_RS1IS0]) || (csr_i_info[E203_DECINFO_CSR_CSRRC] && !csr_i_info[E203_DECINFO_CSR_RS1IS0]));\n    end\n\n    // Data preparation for CSR write operations\n    always @(*) begin\n        case (1'b1)\n            csr_i_info[E203_DECINFO_CSR_CSRRW]: wbck_csr_dat = csr_i_rs1;\n            csr_i_info[E203_DECINFO_CSR_CSRRS]: wbck_csr_dat = csr_i_rs1 | read_csr_dat;\n            csr_i_info[E203_DECINFO_CSR_CSRRC]: wbck_csr_dat = ~csr_i_rs1 & read_csr_dat;\n            default: wbck_csr_dat = {E203_XLEN{1'b0}};\n        endcase\n    end\n\n    // Error handling\n    always @(*) begin\n        csr_o_wbck_wdat = read_csr_dat;\n        csr_o_wbck_err = csr_access_ilgl;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 13, "code": "module e203_exu_longpwbck (\n    input wire lsu_wbck_i_valid,\n    output wire lsu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] lsu_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] lsu_wbck_i_itag,\n    input wire lsu_wbck_i_err,\n    input wire lsu_cmt_i_buserr,\n    input wire [E203_ADDR_SIZE-1:0] lsu_cmt_i_badaddr,\n    input wire lsu_cmt_i_ld,\n    input wire lsu_cmt_i_st,\n    output wire longp_wbck_o_valid,\n    input wire longp_wbck_o_ready,\n    output wire [E203_FLEN-1:0] longp_wbck_o_wdat,\n    output wire [4:0] longp_wbck_o_flags,\n    output wire [E203_RFIDX_WIDTH-1:0] longp_wbck_o_rdidx,\n    output wire longp_wbck_o_rdfpu,\n    output wire longp_excp_o_valid,\n    input wire longp_excp_o_ready,\n    output wire longp_excp_o_insterr,\n    output wire longp_excp_o_ld,\n    output wire longp_excp_o_st,\n    output wire longp_excp_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] longp_excp_o_badaddr,\n    output wire [E203_PC_SIZE-1:0] longp_excp_o_pc,\n    input wire oitf_empty,\n    input wire [E203_ITAG_WIDTH-1:0] oitf_ret_ptr,\n    input wire [E203_RFIDX_WIDTH-1:0] oitf_ret_rdidx,\n    input wire [E203_PC_SIZE-1:0] oitf_ret_pc,\n    input wire oitf_ret_rdwen,\n    input wire oitf_ret_rdfpu,\n    output wire oitf_ret_ena,\n    input wire clk,\n    input wire rst_n\n    `ifdef E203_HAS_NICE\n    , input wire nice_longp_wbck_i_valid,\n    output wire nice_longp_wbck_i_ready,\n    input wire [E203_XLEN-1:0] nice_longp_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] nice_longp_wbck_i_itag,\n    input wire nice_longp_wbck_i_err\n    `endif\n);\n\n    // Internal signals\n    wire wbck_i_valid;\n    wire wbck_i_ready;\n    wire [E203_XLEN-1:0] wbck_i_wdat;\n    wire [E203_ITAG_WIDTH-1:0] wbck_i_itag;\n    wire wbck_i_err;\n\n    // Arbitration logic\n    assign wbck_i_valid = lsu_wbck_i_valid `ifdef E203_HAS_NICE || nice_longp_wbck_i_valid `endif;\n    assign wbck_i_wdat = lsu_wbck_i_valid ? lsu_wbck_i_wdat : `ifdef E203_HAS_NICE nice_longp_wbck_i_wdat `endif;\n    assign wbck_i_itag = lsu_wbck_i_valid ? lsu_wbck_i_itag : `ifdef E203_HAS_NICE nice_longp_wbck_i_itag `endif;\n    assign wbck_i_err = lsu_wbck_i_valid ? lsu_wbck_i_err : `ifdef E203_HAS_NICE nice_longp_wbck_i_err `endif;\n\n    // Control logic for write-back and exceptions\n    assign wbck_i_ready = (wbck_i_valid && longp_wbck_o_ready && longp_excp_o_ready);\n    assign longp_wbck_o_valid = wbck_i_valid && !wbck_i_err && longp_wbck_o_ready;\n    assign longp_excp_o_valid = wbck_i_err && longp_excp_o_ready;\n\n    // Output assignments\n    assign longp_wbck_o_wdat = wbck_i_wdat;\n    assign longp_wbck_o_rdidx = oitf_ret_rdidx;\n    assign longp_wbck_o_rdfpu = oitf_ret_rdfpu;\n    assign longp_excp_o_insterr = wbck_i_err;\n    assign longp_excp_o_ld = lsu_cmt_i_ld;\n    assign longp_excp_o_st = lsu_cmt_i_st;\n    assign longp_excp_o_buserr = lsu_cmt_i_buserr;\n    assign longp_excp_o_badaddr = lsu_cmt_i_badaddr;\n    assign longp_excp_o_pc = oitf_ret_pc;\n\n    // OITF control\n    assign oitf_ret_ena = wbck_i_ready && wbck_i_valid;\n\n    // Ready signals\n    assign lsu_wbck_i_ready = wbck_i_ready;\n    `ifdef E203_HAS_NICE\n    assign nice_longp_wbck_i_ready = wbck_i_ready;\n    `endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 15, "code": "module e203_exu_oitf #(\n  parameter E203_ITAG_WIDTH = 4,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_PC_SIZE = 32,\n  parameter E203_OITF_DEPTH = 16\n)(\n  input clk,\n  input rst_n,\n\n  // Dispatch interface\n  input dis_ena,\n  output reg dis_ready,\n  input [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n  input disp_i_rdwen,\n  input disp_i_rdfpu,\n  input [E203_PC_SIZE-1:0] disp_i_pc,\n\n  // Retirement interface\n  input ret_ena,\n  output reg [E203_RFIDX_WIDTH-1:0] ret_rdidx,\n  output reg ret_rdwen,\n  output reg ret_rdfpu,\n  output reg [E203_PC_SIZE-1:0] ret_pc,\n\n  // Dependency checking outputs\n  output reg oitfrd_match_disprs1,\n  output reg oitfrd_match_disprs2,\n  output reg oitfrd_match_disprs3,\n  output reg oitfrd_match_disprd,\n  output reg oitf_empty\n);\n\n  // Internal OITF storage\n  reg [E203_RFIDX_WIDTH-1:0] rdidx [0:E203_OITF_DEPTH-1];\n  reg [E203_PC_SIZE-1:0] pc [0:E203_OITF_DEPTH-1];\n  reg rdwen [0:E203_OITF_DEPTH-1];\n  reg rdfpu [0:E203_OITF_DEPTH-1];\n  reg [E203_ITAG_WIDTH-1:0] dis_ptr, ret_ptr;\n  reg dis_ptr_wrap, ret_ptr_wrap;\n\n  // Initialize pointers\n  initial begin\n    dis_ptr = 0;\n    ret_ptr = 0;\n    dis_ptr_wrap = 0;\n    ret_ptr_wrap = 0;\n  end\n\n  // Check if OITF is empty or full\n  wire oitf_full = (dis_ptr == ret_ptr) && (dis_ptr_wrap != ret_ptr_wrap);\n  assign oitf_empty = (dis_ptr == ret_ptr) && (dis_ptr_wrap == ret_ptr_wrap);\n\n  // Dispatch logic\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      dis_ptr <= 0;\n      dis_ptr_wrap <= 0;\n      dis_ready <= 1;\n    end else if (dis_ena && dis_ready) begin\n      rdidx[dis_ptr] <= disp_i_rdidx;\n      pc[dis_ptr] <= disp_i_pc;\n      rdwen[dis_ptr] <= disp_i_rdwen;\n      rdfpu[dis_ptr] <= disp_i_rdfpu;\n      dis_ptr <= dis_ptr + 1;\n      if (dis_ptr == E203_OITF_DEPTH-1) begin\n        dis_ptr <= 0;\n        dis_ptr_wrap <= ~dis_ptr_wrap;\n      end\n      dis_ready <= !oitf_full;\n    end\n  end\n\n  // Retirement logic\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      ret_ptr <= 0;\n      ret_ptr_wrap <= 0;\n    end else if (ret_ena && !oitf_empty) begin\n      ret_rdidx <= rdidx[ret_ptr];\n      ret_pc <= pc[ret_ptr];\n      ret_rdwen <= rdwen[ret_ptr];\n      ret_rdfpu <= rdfpu[ret_ptr];\n      ret_ptr <= ret_ptr + 1;\n      if (ret_ptr == E203_OITF_DEPTH-1) begin\n        ret_ptr <= 0;\n        ret_ptr_wrap <= ~ret_ptr_wrap;\n      end\n    end\n  end\n\n  // Dependency checking logic\n  integer i;\n  always @(*) begin\n    oitfrd_match_disprs1 = 0;\n    oitfrd_match_disprs2 = 0;\n    oitfrd_match_disprs3 = 0;\n    oitfrd_match_disprd = 0;\n    for (i = 0; i < E203_OITF_DEPTH; i = i + 1) begin\n      if (rdwen[i]) begin\n        if (disp_i_rdidx == rdidx[i]) begin\n          oitfrd_match_disprd = 1;\n        end\n      end\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 17, "code": "module e203_exu_alu_rglr (\n    input wire alu_i_valid,\n    output reg alu_i_ready,\n    input wire [E203_XLEN-1:0] alu_i_rs1,\n    input wire [E203_XLEN-1:0] alu_i_rs2,\n    input wire [E203_XLEN-1:0] alu_i_imm,\n    input wire [E203_PC_SIZE-1:0] alu_i_pc,\n    input wire [E203_DECINFO_ALU_WIDTH-1:0] alu_i_info,\n    output reg alu_o_valid,\n    input wire alu_o_ready,\n    output reg [E203_XLEN-1:0] alu_o_wbck_wdat,\n    output reg alu_o_wbck_err,\n    output reg alu_o_cmt_ecall,\n    output reg alu_o_cmt_ebreak,\n    output reg alu_o_cmt_wfi,\n    output reg alu_req_alu_add,\n    output reg alu_req_alu_sub,\n    output reg alu_req_alu_xor,\n    output reg alu_req_alu_sll,\n    output reg alu_req_alu_srl,\n    output reg alu_req_alu_sra,\n    output reg alu_req_alu_or,\n    output reg alu_req_alu_and,\n    output reg alu_req_alu_slt,\n    output reg alu_req_alu_sltu,\n    output reg alu_req_alu_lui,\n    output reg [E203_XLEN-1:0] alu_req_alu_op1,\n    output reg [E203_XLEN-1:0] alu_req_alu_op2,\n    output reg [E203_XLEN-1:0] alu_req_alu_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    always @(*) begin\n        // Default assignments\n        alu_i_ready = alu_o_ready;\n        alu_o_valid = alu_i_valid;\n        alu_o_wbck_err = 0;\n        alu_o_cmt_ecall = 0;\n        alu_o_cmt_ebreak = 0;\n        alu_o_cmt_wfi = 0;\n\n        // Default operation requests\n        alu_req_alu_add = 0;\n        alu_req_alu_sub = 0;\n        alu_req_alu_xor = 0;\n        alu_req_alu_sll = 0;\n        alu_req_alu_srl = 0;\n        alu_req_alu_sra = 0;\n        alu_req_alu_or = 0;\n        alu_req_alu_and = 0;\n        alu_req_alu_slt = 0;\n        alu_req_alu_sltu = 0;\n        alu_req_alu_lui = 0;\n\n        // Select operands\n        alu_req_alu_op1 = alu_i_info[E203_DECINFO_ALU_OP1PC] ? alu_i_pc : alu_i_rs1;\n        alu_req_alu_op2 = alu_i_info[E203_DECINFO_ALU_OP2IMM] ? alu_i_imm : alu_i_rs2;\n\n        // Determine operation based on instruction info\n        if (alu_i_info[E203_DECINFO_ALU_ADD]) alu_req_alu_add = 1;\n        if (alu_i_info[E203_DECINFO_ALU_SUB]) alu_req_alu_sub = 1;\n        if (alu_i_info[E203_DECINFO_ALU_XOR]) alu_req_alu_xor = 1;\n        if (alu_i_info[E203_DECINFO_ALU_SLL]) alu_req_alu_sll = 1;\n        if (alu_i_info[E203_DECINFO_ALU_SRL]) alu_req_alu_srl = 1;\n        if (alu_i_info[E203_DECINFO_ALU_SRA]) alu_req_alu_sra = 1;\n        if (alu_i_info[E203_DECINFO_ALU_OR]) alu_req_alu_or = 1;\n        if (alu_i_info[E203_DECINFO_ALU_AND]) alu_req_alu_and = 1;\n        if (alu_i_info[E203_DECINFO_ALU_SLT]) alu_req_alu_slt = 1;\n        if (alu_i_info[E203_DECINFO_ALU_SLTU]) alu_req_alu_sltu = 1;\n        if (alu_i_info[E203_DECINFO_ALU_LUI]) alu_req_alu_lui = 1;\n\n        // Special instructions\n        if (alu_i_info[E203_DECINFO_ALU_ECAL]) begin\n            alu_o_cmt_ecall = 1;\n            alu_o_wbck_err = 1;\n        end\n        if (alu_i_info[E203_DECINFO_ALU_EBRK]) begin\n            alu_o_cmt_ebreak = 1;\n            alu_o_wbck_err = 1;\n        end\n        if (alu_i_info[E203_DECINFO_ALU_WFI]) begin\n            alu_o_cmt_wfi = 1;\n            alu_o_wbck_err = 1;\n        end\n\n        // Compute result\n        alu_req_alu_res = 0; // Placeholder for ALU result computation\n        alu_o_wbck_wdat = alu_req_alu_res;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 2, "code": "module e203_lsu_ctrl(\n    input wire commit_mret,\n    input wire commit_trap,\n    output wire lsu_ctrl_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    input wire nice_mem_holdup,\n    input wire nice_icb_cmd_valid,\n    output wire nice_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] nice_icb_cmd_addr,\n    input wire nice_icb_cmd_read,\n    input wire [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] nice_icb_cmd_wmask,\n    output wire nice_icb_rsp_valid,\n    input wire nice_icb_rsp_ready,\n    output wire nice_icb_rsp_err,\n    output wire [E203_XLEN-1:0] nice_icb_rsp_rdata,\n\n    output wire dcache_icb_cmd_valid,\n    input wire dcache_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] dcache_icb_cmd_addr,\n    output wire dcache_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dcache_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dcache_icb_cmd_wmask,\n    output wire dcache_icb_cmd_lock,\n    output wire dcache_icb_cmd_excl,\n    output wire [1:0] dcache_icb_cmd_size,\n    input wire dcache_icb_rsp_valid,\n    output wire dcache_icb_rsp_ready,\n    input wire dcache_icb_rsp_err,\n    input wire dcache_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dcache_icb_rsp_rdata,\n\n    output wire dtcm_icb_cmd_valid,\n    input wire dtcm_icb_cmd_ready,\n    output wire [E203_DTCM_ADDR_WIDTH-1:0] dtcm_icb_cmd_addr,\n    output wire dtcm_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dtcm_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dtcm_icb_cmd_wmask,\n    output wire dtcm_icb_cmd_lock,\n    output wire dtcm_icb_cmd_excl,\n    output wire [1:0] dtcm_icb_cmd_size,\n    input wire dtcm_icb_rsp_valid,\n    output wire dtcm_icb_rsp_ready,\n    input wire dtcm_icb_rsp_err,\n    input wire dtcm_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dtcm_icb_rsp_rdata,\n    input wire [E203_ADDR_SIZE-1:0] dtcm_region_indic,\n\n    output wire biu_icb_cmd_valid,\n    input wire biu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,\n    output wire biu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] biu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] biu_icb_cmd_wmask,\n    output wire biu_icb_cmd_lock,\n    output wire biu_icb_cmd_excl,\n    output wire [1:0] biu_icb_cmd_size,\n    input wire biu_icb_rsp_valid,\n    output wire biu_icb_rsp_ready,\n    input wire biu_icb_rsp_err,\n    input wire biu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] biu_icb_rsp_rdata,\n\n    input wire clk,\n    input wire rst_n\n);\n    // LSU Control Logic Implementation Here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 7, "code": "module e203_ifu_litebpu #(\n  parameter E203_PC_SIZE = 32,\n  parameter E203_XLEN = 32,\n  parameter E203_RFIDX_WIDTH = 5\n)(\n  input clk,\n  input rst_n,\n  input [E203_PC_SIZE-1:0] pc,\n  input dec_jal,\n  input dec_jalr,\n  input dec_bxx,\n  input [E203_XLEN-1:0] dec_bjp_imm,\n  input [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  input oitf_empty,\n  input ir_empty,\n  input ir_rs1en,\n  input jalr_rs1idx_cam_irrdidx,\n  input dec_i_valid,\n  input ir_valid_clr,\n  input [E203_XLEN-1:0] rf2bpu_x1,\n  input [E203_XLEN-1:0] rf2bpu_rs1,\n  output reg prdt_taken,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op1,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op2,\n  output reg bpu_wait,\n  output reg bpu2rf_rs1_ena\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      prdt_taken <= 1'b0;\n      prdt_pc_add_op1 <= {E203_PC_SIZE{1'b0}};\n      prdt_pc_add_op2 <= {E203_PC_SIZE{1'b0}};\n      bpu_wait <= 1'b0;\n      bpu2rf_rs1_ena <= 1'b0;\n    end else begin\n      // Default assignments\n      prdt_taken <= 1'b0;\n      prdt_pc_add_op1 <= pc;\n      prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n      bpu_wait <= 1'b0;\n      bpu2rf_rs1_ena <= 1'b0;\n\n      // Prediction logic\n      if (dec_i_valid) begin\n        if (dec_jal) begin\n          prdt_taken <= 1'b1;\n          prdt_pc_add_op1 <= pc;\n          prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n        end else if (dec_jalr) begin\n          prdt_taken <= 1'b1;\n          if (dec_jalr_rs1idx == 0) begin\n            prdt_pc_add_op1 <= 0;\n          end else if (dec_jalr_rs1idx == 1) begin\n            prdt_pc_add_op1 <= rf2bpu_x1;\n            if (!oitf_empty || jalr_rs1idx_cam_irrdidx) begin\n              bpu_wait <= 1'b1;\n            end\n          end else begin\n            prdt_pc_add_op1 <= rf2bpu_rs1;\n            if (!ir_empty && ir_rs1en) begin\n              bpu_wait <= 1'b1;\n            end\n          end\n          prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n        end else if (dec_bxx) begin\n          if (dec_bjp_imm[E203_XLEN-1] == 1'b1) begin // Negative offset\n            prdt_taken <= 1'b1;\n          end\n          prdt_pc_add_op1 <= pc;\n          prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n        end\n      end\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 15, "code": "module e203_exu_alu_lsuagu (\n    input wire agu_i_valid,\n    output wire agu_i_ready,\n    input wire [E203_XLEN-1:0] agu_i_rs1,\n    input wire [E203_XLEN-1:0] agu_i_rs2,\n    input wire [E203_XLEN-1:0] agu_i_imm,\n    input wire [E203_DECINFO_AGU_WIDTH-1:0] agu_i_info,\n    input wire [E203_ITAG_WIDTH-1:0] agu_i_itag,\n    output wire agu_i_longpipe,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire amo_wait,\n    input wire oitf_empty,\n    output wire agu_o_valid,\n    input wire agu_o_ready,\n    output wire [E203_XLEN-1:0] agu_o_wbck_wdat,\n    output wire agu_o_wbck_err,\n    output wire agu_o_cmt_misalgn,\n    output wire agu_o_cmt_ld,\n    output wire agu_o_cmt_stamo,\n    output wire agu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] agu_o_cmt_badaddr,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_cmd_usign,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire [E203_XLEN-1:0] agu_req_alu_op1,\n    output wire [E203_XLEN-1:0] agu_req_alu_op2,\n    output wire agu_req_alu_swap,\n    output wire agu_req_alu_add,\n    output wire agu_req_alu_and,\n    output wire agu_req_alu_or,\n    output wire agu_req_alu_xor,\n    output wire agu_req_alu_max,\n    output wire agu_req_alu_min,\n    output wire agu_req_alu_maxu,\n    output wire agu_req_alu_minu,\n    input wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire agu_sbf_0_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_0_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_0_r,\n    output wire agu_sbf_1_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_1_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_1_r,\n    input wire clk,\n    input wire rst_n\n);\n    // Internal signals and registers\n    reg [3:0] state;\n    wire state_idle_exit_ena;\n    wire state_1st_exit_ena;\n    wire state_amoalu_exit_ena;\n    wire state_amordy_exit_ena;\n    wire state_wait2nd_exit_ena;\n    wire state_2nd_exit_ena;\n    wire state_wbck_exit_ena;\n\n    // State machine logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= `ICB_STATE_IDLE;\n        end else begin\n            case (state)\n                `ICB_STATE_IDLE: begin\n                    if (state_idle_exit_ena) state <= `ICB_STATE_1ST;\n                end\n                `ICB_STATE_1ST: begin\n                    if (state_1st_exit_ena) state <= `ICB_STATE_AMOALU;\n                end\n                `ICB_STATE_AMOALU: begin\n                    if (state_amoalu_exit_ena) state <= `ICB_STATE_AMORDY;\n                end\n                `ICB_STATE_AMORDY: begin\n                    if (state_amordy_exit_ena) state <= `ICB_STATE_WAIT2ND;\n                end\n                `ICB_STATE_WAIT2ND: begin\n                    if (state_wait2nd_exit_ena) state <= `ICB_STATE_2ND;\n                end\n                `ICB_STATE_2ND: begin\n                    if (state_2nd_exit_ena) state <= `ICB_STATE_WBCK;\n                end\n                `ICB_STATE_WBCK: begin\n                    if (state_wbck_exit_ena) state <= `ICB_STATE_IDLE;\n                end\n            endcase\n        end\n    end\n\n    // Output assignments and additional logic\n    assign agu_i_ready = (state == `ICB_STATE_IDLE);\n    assign agu_o_valid = (state == `ICB_STATE_WBCK);\n    assign agu_icb_cmd_valid = (state == `ICB_STATE_1ST) || (state == `ICB_STATE_2ND);\n    assign agu_icb_rsp_ready = (state == `ICB_STATE_1ST) || (state == `ICB_STATE_2ND);\n    assign amo_wait = (state == `ICB_STATE_AMOALU) || (state == `ICB_STATE_AMORDY) || (state == `ICB_STATE_WAIT2ND);\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 10, "code": "module e203_exu_csr(\n    input nonflush_cmt_ena,\n    input csr_ena,\n    input csr_wr_en,\n    input csr_rd_en,\n    input [11:0] csr_idx,\n    output csr_access_ilgl,\n    output tm_stop,\n    output core_cgstop,\n    output tcm_cgstop,\n    output itcm_nohold,\n    output mdv_nob2b,\n    output [E203_XLEN-1:0] read_csr_dat,\n    input [E203_XLEN-1:0] wbck_csr_dat,\n    input [E203_HART_ID_W-1:0] core_mhartid,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    output status_mie_r,\n    output mtie_r,\n    output msie_r,\n    output meie_r,\n    output wr_dcsr_ena,\n    output wr_dpc_ena,\n    output wr_dscratch_ena,\n    input [E203_XLEN-1:0] dcsr_r,\n    input [E203_PC_SIZE-1:0] dpc_r,\n    input [E203_XLEN-1:0] dscratch_r,\n    output u_mode,\n    output s_mode,\n    output h_mode,\n    output m_mode,\n    input [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    input cmt_badaddr_ena,\n    input [E203_PC_SIZE-1:0] cmt_epc,\n    input cmt_epc_ena,\n    input [E203_XLEN-1:0] cmt_cause,\n    input cmt_cause_ena,\n    input cmt_status_ena,\n    input cmt_instret_ena,\n    input cmt_mret_ena,\n    output [E203_PC_SIZE-1:0] csr_epc_r,\n    output [E203_PC_SIZE-1:0] csr_dpc_r,\n    output [E203_XLEN-1:0] csr_mtvec_r,\n    input clk_aon,\n    input clk,\n    input rst_n\n    `ifdef E203_HAS_NICE\n    , output nice_xs_off\n    `endif\n);\n\n    // CSR logic implementation\n    // Note: This is a simplified example and does not include actual CSR logic.\n    assign csr_access_ilgl = 0; // Assume no illegal access in this example\n    assign tm_stop = 0; // Time counter not stopped\n    assign core_cgstop = 0; // No core clock gating\n    assign tcm_cgstop = 0; // No TCM clock gating\n    assign itcm_nohold = 0; // No ITCM hold-up\n    assign mdv_nob2b = 0; // No mul/div back-to-back disable\n    assign read_csr_dat = 0; // Default read data\n    assign status_mie_r = 0; // Machine interrupt enable status\n    assign mtie_r = 0; // Machine timer interrupt enable status\n    assign msie_r = 0; // Machine software interrupt enable status\n    assign meie_r = 0; // Machine external interrupt enable status\n    assign wr_dcsr_ena = 0; // No write to dcsr\n    assign wr_dpc_ena = 0; // No write to dpc\n    assign wr_dscratch_ena = 0; // No write to dscratch\n    assign u_mode = 0; // User mode not supported\n    assign s_mode = 0; // Supervisor mode not supported\n    assign h_mode = 0; // Hypervisor mode not supported\n    assign m_mode = 1; // Machine mode always on\n    assign csr_epc_r = 0; // Default EPC\n    assign csr_dpc_r = 0; // Default DPC\n    assign csr_mtvec_r = 0; // Default MTVEC\n\n    `ifdef E203_HAS_NICE\n    assign nice_xs_off = 1; // NICE is closed\n    `endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 15, "code": "module e203_exu_alu_bjp (\n    input wire bjp_i_valid,\n    output wire bjp_i_ready,\n    input wire [E203_XLEN-1:0] bjp_i_rs1,\n    input wire [E203_XLEN-1:0] bjp_i_rs2,\n    input wire [E203_XLEN-1:0] bjp_i_imm,\n    input wire [E203_PC_SIZE-1:0] bjp_i_pc,\n    input wire [E203_DECINFO_BJP_WIDTH-1:0] bjp_i_info,\n    output wire bjp_o_valid,\n    input wire bjp_o_ready,\n    output wire [E203_XLEN-1:0] bjp_o_wbck_wdat,\n    output wire bjp_o_wbck_err,\n    output wire bjp_o_cmt_bjp,\n    output wire bjp_o_cmt_mret,\n    output wire bjp_o_cmt_dret,\n    output wire bjp_o_cmt_fencei,\n    output wire bjp_o_cmt_prdt,\n    output wire bjp_o_cmt_rslv,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    output wire bjp_req_alu_cmp_eq,\n    output wire bjp_req_alu_cmp_ne,\n    output wire bjp_req_alu_cmp_lt,\n    output wire bjp_req_alu_cmp_gt,\n    output wire bjp_req_alu_cmp_ltu,\n    output wire bjp_req_alu_cmp_gtu,\n    output wire bjp_req_alu_add,\n    input wire bjp_req_alu_cmp_res,\n    input wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Handshake mechanism\n    assign bjp_i_ready = bjp_o_ready;\n    assign bjp_o_valid = bjp_i_valid;\n\n    // Operand selection\n    assign bjp_req_alu_op1 = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? bjp_i_pc : bjp_i_rs1;\n    assign bjp_req_alu_op2 = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? (E203_XLEN == 32 ? 32'd4 : 32'd2) : bjp_i_rs2;\n\n    // ALU operation requests\n    assign bjp_req_alu_cmp_eq = bjp_i_info[E203_DECINFO_BJP_BEQ];\n    assign bjp_req_alu_cmp_ne = bjp_i_info[E203_DECINFO_BJP_BNE];\n    assign bjp_req_alu_cmp_lt = bjp_i_info[E203_DECINFO_BJP_BLT];\n    assign bjp_req_alu_cmp_gt = bjp_i_info[E203_DECINFO_BJP_BGT];\n    assign bjp_req_alu_cmp_ltu = bjp_i_info[E203_DECINFO_BJP_BLTU];\n    assign bjp_req_alu_cmp_gtu = bjp_i_info[E203_DECINFO_BJP_BGTU];\n    assign bjp_req_alu_add = bjp_i_info[E203_DECINFO_BJP_JUMP];\n\n    // Commit signals\n    assign bjp_o_cmt_bjp = bjp_i_valid && (bjp_i_info[E203_DECINFO_BJP_BXX] || bjp_i_info[E203_DECINFO_BJP_JUMP]);\n    assign bjp_o_cmt_mret = bjp_i_info[E203_DECINFO_BJP_MRET];\n    assign bjp_o_cmt_dret = bjp_i_info[E203_DECINFO_BJP_DRET];\n    assign bjp_o_cmt_fencei = bjp_i_info[E203_DECINFO_BJP_FENCEI];\n    assign bjp_o_cmt_prdt = bjp_i_info[E203_DECINFO_BJP_BPRDT];\n    assign bjp_o_cmt_rslv = bjp_i_info[E203_DECINFO_BJP_JUMP] ? 1'b1 : bjp_req_alu_cmp_res;\n\n    // Write-back data and error generation\n    assign bjp_o_wbck_wdat = bjp_req_alu_add_res;\n    assign bjp_o_wbck_err = 1'b0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 14, "code": "module e203_itcm_ram #(\n  parameter FORCE_X2ZERO = 0,\n  parameter DP = `E203_ITCM_RAM_DP,\n  parameter DW = `E203_ITCM_RAM_DW,\n  parameter MW = `E203_ITCM_RAM_MW,\n  parameter AW = `E203_ITCM_RAM_AW\n)(\n  input sd,\n  input ds,\n  input ls,\n  input cs,\n  input we,\n  input [AW-1:0] addr,\n  input [MW-1:0] wem,\n  input [DW-1:0] din,\n  input rst_n,\n  input clk,\n  output [DW-1:0] dout\n);\n\n  // Instantiate the generic RAM module\n  sirv_gnrl_ram #(\n    .FORCE_X2ZERO(FORCE_X2ZERO),\n    .DP(DP),\n    .DW(DW),\n    .MW(MW),\n    .AW(AW)\n  ) u_sirv_gnrl_ram (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .clk(clk),\n    .rst_n(rst_n),\n    .dout(dout)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 7, "code": "module e203_ifu (\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire itcm_nohold,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input wire pipe_flush_req,\n    input wire ifu_halt_req,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rden,\n    input wire dec2ifu_rs1en,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire ifu_active,\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    output wire pipe_flush_ack,\n    input wire `ifdef E203_TIMING_BOOST pipe_flush_pc, `endif\n    input wire `ifdef E203_HAS_ITCM ifu2itcm_holdup, `endif\n    input wire `ifdef E203_HAS_ITCM [E203_ADDR_SIZE-1:0] itcm_region_indic, `endif\n    output wire `ifdef E203_HAS_ITCM ifu2itcm_icb_cmd_valid, `endif\n    input wire `ifdef E203_HAS_ITCM ifu2itcm_icb_cmd_ready, `endif\n    output wire `ifdef E203_HAS_ITCM [E203_ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr, `endif\n    input wire `ifdef E203_HAS_ITCM ifu2itcm_icb_rsp_valid, `endif\n    output wire `ifdef E203_HAS_ITCM ifu2itcm_icb_rsp_ready, `endif\n    input wire `ifdef E203_HAS_ITCM ifu2itcm_icb_rsp_err, `endif\n    input wire `ifdef E203_HAS_ITCM [E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata, `endif\n    output wire `ifdef E203_HAS_MEM_ITF ifu2biu_icb_cmd_valid, `endif\n    input wire `ifdef E203_HAS_MEM_ITF ifu2biu_icb_cmd_ready, `endif\n    output wire `ifdef E203_HAS_MEM_ITF [E203_ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr, `endif\n    input wire `ifdef E203_HAS_MEM_ITF ifu2biu_icb_rsp_valid, `endif\n    output wire `ifdef E203_HAS_MEM_ITF ifu2biu_icb_rsp_ready, `endif\n    input wire `ifdef E203_HAS_MEM_ITF ifu2biu_icb_rsp_err, `endif\n    input wire `ifdef E203_HAS_MEM_ITF [E203_SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata, `endif\n    output wire ifu_halt_ack\n);\n\n    // Module implementation here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 6, "code": "module e203_lsu(\n    input wire commit_mret,\n    input wire commit_trap,\n    input wire excp_active,\n    output wire lsu_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n    output wire [ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_buserr,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [XLEN-1:0] agu_icb_rsp_rdata\n);\n    // LSU logic implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 8, "code": "module e203_ifu_litebpu #(\n  parameter E203_PC_SIZE = 32,\n  parameter E203_XLEN = 32,\n  parameter E203_RFIDX_WIDTH = 5\n)(\n  input clk,\n  input rst_n,\n  input [E203_PC_SIZE-1:0] pc,\n  input dec_jal,\n  input dec_jalr,\n  input dec_bxx,\n  input [E203_XLEN-1:0] dec_bjp_imm,\n  input [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  input oitf_empty,\n  input ir_empty,\n  input ir_rs1en,\n  input jalr_rs1idx_cam_irrdidx,\n  input dec_i_valid,\n  input ir_valid_clr,\n  input [E203_XLEN-1:0] rf2bpu_x1,\n  input [E203_XLEN-1:0] rf2bpu_rs1,\n  output reg prdt_taken,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op1,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op2,\n  output reg bpu_wait,\n  output reg bpu2rf_rs1_ena\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      prdt_taken <= 1'b0;\n      prdt_pc_add_op1 <= {E203_PC_SIZE{1'b0}};\n      prdt_pc_add_op2 <= {E203_PC_SIZE{1'b0}};\n      bpu_wait <= 1'b0;\n      bpu2rf_rs1_ena <= 1'b0;\n    end else begin\n      // Default values\n      prdt_taken <= 1'b0;\n      prdt_pc_add_op1 <= pc;\n      prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n      bpu_wait <= 1'b0;\n      bpu2rf_rs1_ena <= 1'b0;\n\n      // Prediction logic\n      if (dec_jal) begin\n        prdt_taken <= 1'b1;\n        prdt_pc_add_op1 <= pc;\n        prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n      end else if (dec_jalr) begin\n        prdt_taken <= 1'b1;\n        if (dec_jalr_rs1idx == 0) begin\n          prdt_pc_add_op1 <= 0;\n        end else if (dec_jalr_rs1idx == 1) begin\n          prdt_pc_add_op1 <= rf2bpu_x1;\n          bpu_wait <= !oitf_empty;\n          bpu2rf_rs1_ena <= 1'b1;\n        end else begin\n          prdt_pc_add_op1 <= rf2bpu_rs1;\n          bpu_wait <= !oitf_empty || !ir_empty;\n          bpu2rf_rs1_ena <= 1'b1;\n        end\n        prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n      end else if (dec_bxx) begin\n        prdt_taken <= dec_bjp_imm[E203_XLEN-1];\n      end\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 15, "code": "module e203_irq_sync (\n    input wire clk,\n    input wire rst_n,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire dbg_irq_a,\n    output wire ext_irq_r,\n    output wire sft_irq_r,\n    output wire tmr_irq_r,\n    output wire dbg_irq_r\n);\n\n    // Synchronization instances for each interrupt type\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) ext_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(ext_irq_a),\n        .dout(ext_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) sft_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(sft_irq_a),\n        .dout(sft_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) tmr_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(tmr_irq_a),\n        .dout(tmr_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) dbg_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(dbg_irq_a),\n        .dout(dbg_irq_r)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 14, "code": "module e203_exu_regfile (\n    input  wire                    clk,\n    input  wire                    rst_n,\n    input  wire [E203_RFIDX_WIDTH-1:0] read_src1_idx,\n    input  wire [E203_RFIDX_WIDTH-1:0] read_src2_idx,\n    output wire [E203_XLEN-1:0]    read_src1_dat,\n    output wire [E203_XLEN-1:0]    read_src2_dat,\n    input  wire                    wbck_dest_wen,\n    input  wire [E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n    input  wire [E203_XLEN-1:0]    wbck_dest_dat,\n    output wire [E203_XLEN-1:0]    x1_r,\n    input  wire                    test_mode\n);\n\n// Register file storage\nreg [E203_XLEN-1:0] regfile [0:E203_RFREG_NUM-1];\n\n// Read logic\nassign read_src1_dat = (read_src1_idx == 0) ? 0 : regfile[read_src1_idx];\nassign read_src2_dat = (read_src2_idx == 0) ? 0 : regfile[read_src2_idx];\n\n// Write logic\nalways @(posedge clk) begin\n    if (wbck_dest_wen && wbck_dest_idx != 0) begin\n        regfile[wbck_dest_idx] <= wbck_dest_dat;\n    end\nend\n\n// Special register x1 output\nassign x1_r = regfile[1];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 14, "code": "module e203_exu_nice(\n    input wire nice_i_xs_off,\n    input wire nice_i_valid,\n    output wire nice_i_ready,\n    input wire [E203_XLEN-1:0] nice_i_instr,\n    input wire [E203_XLEN-1:0] nice_i_rs1,\n    input wire [E203_XLEN-1:0] nice_i_rs2,\n    input wire [E203_ITAG_WIDTH-1:0] nice_i_itag,\n    output wire nice_o_longpipe,\n    output wire nice_o_valid,\n    input wire nice_o_ready,\n    output wire nice_o_itag_valid,\n    input wire nice_o_itag_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire clk,\n    input wire rst_n\n);\n\n// Internal signals\nwire fifo_full, fifo_empty;\nwire [E203_ITAG_WIDTH-1:0] fifo_data_out;\nwire fifo_push, fifo_pop;\n\n// FIFO control logic\nassign fifo_push = nice_i_valid && nice_i_ready && !nice_i_xs_off;\nassign fifo_pop = nice_rsp_multicyc_valid && nice_rsp_multicyc_ready && !fifo_empty;\n\nsirv_gnrl_fifo #(\n    .CUT_READY(1),\n    .DP(4),\n    .DW(E203_ITAG_WIDTH)\n) itag_fifo (\n    .i_vld(fifo_push),\n    .i_rdy(nice_i_ready),\n    .i_dat(nice_i_itag),\n    .o_vld(nice_o_itag_valid),\n    .o_rdy(nice_o_itag_ready),\n    .o_dat(fifo_data_out),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// Output assignments\nassign nice_o_longpipe = !nice_i_xs_off;\nassign nice_o_valid = nice_i_valid && nice_o_ready && !nice_i_xs_off;\nassign nice_o_itag = fifo_data_out;\nassign nice_req_valid = nice_i_valid && nice_req_ready && !nice_i_xs_off;\nassign nice_req_instr = nice_i_instr;\nassign nice_req_rs1 = nice_i_rs1;\nassign nice_req_rs2 = nice_i_rs2;\nassign nice_rsp_multicyc_ready = !fifo_full;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 15, "code": "module e203_exu_regfile (\n    input [E203_RFIDX_WIDTH-1:0] read_src1_idx,\n    input [E203_RFIDX_WIDTH-1:0] read_src2_idx,\n    output [E203_XLEN-1:0] read_src1_dat,\n    output [E203_XLEN-1:0] read_src2_dat,\n    input wbck_dest_wen,\n    input [E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n    input [E203_XLEN-1:0] wbck_dest_dat,\n    output [E203_XLEN-1:0] x1_r,\n    input test_mode,\n    input clk,\n    input rst_n\n);\n\n// Register file storage\nreg [E203_XLEN-1:0] regfile [0:E203_RFREG_NUM-1];\n\n// Read logic\nassign read_src1_dat = (read_src1_idx == 0) ? 0 : regfile[read_src1_idx];\nassign read_src2_dat = (read_src2_idx == 0) ? 0 : regfile[read_src2_idx];\n\n// Write logic\nalways @(posedge clk) begin\n    if (wbck_dest_wen && wbck_dest_idx != 0) begin\n        regfile[wbck_dest_idx] <= wbck_dest_dat;\n    end\nend\n\n// Output register x1\nassign x1_r = regfile[1];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 14, "code": "module e203_ifu_minidec #(\n  parameter E203_INSTR_SIZE = 32,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_XLEN = 32\n)(\n  input [E203_INSTR_SIZE-1:0] instr,\n  output dec_rs1en,\n  output dec_rs2en,\n  output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n  output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n  output dec_mulhsu,\n  output dec_mul,\n  output dec_div,\n  output dec_rem,\n  output dec_divu,\n  output dec_remu,\n  output dec_rv32,\n  output dec_bjp,\n  output dec_jal,\n  output dec_jalr,\n  output dec_bxx,\n  output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  output [E203_XLEN-1:0] dec_bjp_imm\n);\n\n  // Internal signals for decoding logic\n  wire [6:0] opcode = instr[6:0];\n  wire [2:0] funct3 = instr[14:12];\n  wire [6:0] funct7 = instr[31:25];\n\n  // Register enable signals\n  assign dec_rs1en = (opcode != 7'b0110111) && (opcode != 7'b0010111);\n  assign dec_rs2en = (opcode == 7'b0110011) || (opcode == 7'b0100011) || (opcode == 7'b1100011);\n\n  // Register index fields\n  assign dec_rs1idx = instr[19:15];\n  assign dec_rs2idx = instr[24:20];\n\n  // Decode multiplication and division instructions\n  assign dec_mul    = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b000);\n  assign dec_mulhsu = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b010);\n  assign dec_div    = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b100);\n  assign dec_divu   = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b101);\n  assign dec_rem    = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b110);\n  assign dec_remu   = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b111);\n\n  // Decode branch and jump instructions\n  assign dec_bjp    = (opcode == 7'b1100011) || (opcode == 7'b1101111) || (opcode == 7'b1100111);\n  assign dec_jal    = (opcode == 7'b1101111);\n  assign dec_jalr   = (opcode == 7'b1100111);\n  assign dec_bxx    = (opcode == 7'b1100011);\n\n  // Immediate for branch/jump instructions\n  assign dec_bjp_imm = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};\n\n  // RV32 instruction set flag\n  assign dec_rv32 = 1'b1;\n\n  // RS1 index for JALR instruction\n  assign dec_jalr_rs1idx = (dec_jalr) ? instr[19:15] : {E203_RFIDX_WIDTH{1'b0}};\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 7, "code": "module e203_lsu(\n    input wire commit_mret,\n    input wire commit_trap,\n    input wire excp_active,\n    output wire lsu_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n    output wire [ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_buserr,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [XLEN-1:0] agu_icb_rsp_rdata,\n\n    input wire nice_mem_holdup,\n    input wire itcm_region_indic,\n    input wire dtcm_region_indic\n);\n    // LSU logic implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 15, "code": "module e203_exu_alu_dpath(\n    input wire alu_req_alu,\n    input wire alu_req_alu_add,\n    input wire alu_req_alu_sub,\n    input wire alu_req_alu_xor,\n    input wire alu_req_alu_sll,\n    input wire alu_req_alu_srl,\n    input wire alu_req_alu_sra,\n    input wire alu_req_alu_or,\n    input wire alu_req_alu_and,\n    input wire [E203_XLEN-1:0] alu_req_alu_op1,\n    input wire [E203_XLEN-1:0] alu_req_alu_op2,\n    input wire bjp_req_alu,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    input wire agu_req_alu,\n    input wire [E203_XLEN-1:0] agu_req_alu_op1,\n    input wire [E203_XLEN-1:0] agu_req_alu_op2,\n    input wire muldiv_req_alu,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    input wire muldiv_req_alu_add,\n    input wire muldiv_req_alu_sub,\n    input wire muldiv_sbf_0_ena,\n    input wire [32:0] muldiv_sbf_0_nxt,\n    input wire muldiv_sbf_1_ena,\n    input wire [32:0] muldiv_sbf_1_nxt,\n    input wire clk,\n    input wire rst_n,\n    output wire [E203_XLEN-1:0] alu_req_alu_res,\n    output wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    output wire bjp_req_alu_cmp_res,\n    output wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output wire [32:0] muldiv_sbf_0_r,\n    output wire [32:0] muldiv_sbf_1_r\n);\n\n    // Internal signals for ALU operations\n    wire [E203_XLEN-1:0] add_result;\n    wire [E203_XLEN-1:0] sub_result;\n    wire [E203_XLEN-1:0] xor_result;\n    wire [E203_XLEN-1:0] sll_result;\n    wire [E203_XLEN-1:0] srl_result;\n    wire [E203_XLEN-1:0] sra_result;\n    wire [E203_XLEN-1:0] or_result;\n    wire [E203_XLEN-1:0] and_result;\n\n    // ALU operations\n    assign add_result = alu_req_alu_op1 + alu_req_alu_op2;\n    assign sub_result = alu_req_alu_op1 - alu_req_alu_op2;\n    assign xor_result = alu_req_alu_op1 ^ alu_req_alu_op2;\n    assign sll_result = alu_req_alu_op1 << alu_req_alu_op2;\n    assign srl_result = alu_req_alu_op1 >> alu_req_alu_op2;\n    assign sra_result = $signed(alu_req_alu_op1) >>> alu_req_alu_op2;\n    assign or_result = alu_req_alu_op1 | alu_req_alu_op2;\n    assign and_result = alu_req_alu_op1 & alu_req_alu_op2;\n\n    // Result multiplexing based on operation type\n    assign alu_req_alu_res = ({E203_XLEN{alu_req_alu_add}} & add_result) |\n                             ({E203_XLEN{alu_req_alu_sub}} & sub_result) |\n                             ({E203_XLEN{alu_req_alu_xor}} & xor_result) |\n                             ({E203_XLEN{alu_req_alu_sll}} & sll_result) |\n                             ({E203_XLEN{alu_req_alu_srl}} & srl_result) |\n                             ({E203_XLEN{alu_req_alu_sra}} & sra_result) |\n                             ({E203_XLEN{alu_req_alu_or}} & or_result) |\n                             ({E203_XLEN{alu_req_alu_and}} & and_result);\n\n    // BJP and AGU operation results\n    assign bjp_req_alu_add_res = bjp_req_alu_op1 + bjp_req_alu_op2;\n    assign bjp_req_alu_cmp_res = (bjp_req_alu_op1 == bjp_req_alu_op2);\n    assign agu_req_alu_res = (agu_req_alu_op1 + agu_req_alu_op2); // Example for AGU add operation\n\n    // MULDIV operation results\n    wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_add_result = muldiv_req_alu_op1 + muldiv_req_alu_op2;\n    wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_sub_result = muldiv_req_alu_op1 - muldiv_req_alu_op2;\n    assign muldiv_req_alu_res = (muldiv_req_alu_add ? muldiv_add_result : muldiv_sub_result);\n\n    // Shared buffer handling\n    sirv_gnrl_dffl #(.DW(33)) sbf_0_dffl (\n        .lden(muldiv_sbf_0_ena),\n        .dnxt(muldiv_sbf_0_nxt),\n        .qout(muldiv_sbf_0_r),\n        .clk(clk)\n    );\n\n    sirv_gnrl_dffl #(.DW(33)) sbf_1_dffl (\n        .lden(muldiv_sbf_1_ena),\n        .dnxt(muldiv_sbf_1_nxt),\n        .qout(muldiv_sbf_1_r),\n        .clk(clk)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 16, "code": "module e203_exu_regfile #(\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_XLEN = 32\n)(\n  input  wire [E203_RFIDX_WIDTH-1:0] read_src1_idx,\n  input  wire [E203_RFIDX_WIDTH-1:0] read_src2_idx,\n  output wire [E203_XLEN-1:0] read_src1_dat,\n  output wire [E203_XLEN-1:0] read_src2_dat,\n  input  wire wbck_dest_wen,\n  input  wire [E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n  input  wire [E203_XLEN-1:0] wbck_dest_dat,\n  output wire [E203_XLEN-1:0] x1_r,\n  input  wire test_mode,\n  input  wire clk,\n  input  wire rst_n\n);\n\n`include \"e203_defines.v\"\n\nlocalparam REGFILE_DEPTH = `E203_CFG_REGNUM_IS_32 ? 32 : 16;\n\nreg [E203_XLEN-1:0] regfile [0:REGFILE_DEPTH-1];\n\nassign read_src1_dat = (read_src1_idx == 0) ? 0 : regfile[read_src1_idx];\nassign read_src2_dat = (read_src2_idx == 0) ? 0 : regfile[read_src2_idx];\nassign x1_r = regfile[1];\n\nalways @(posedge clk) begin\n  if (wbck_dest_wen && wbck_dest_idx != 0) begin\n    regfile[wbck_dest_idx] <= wbck_dest_dat;\n  end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 15, "code": "module e203_itcm_ram #(\n  parameter FORCE_X2ZERO = 0,\n  parameter DP = `E203_ITCM_RAM_DP,\n  parameter DW = `E203_ITCM_RAM_DW,\n  parameter MW = `E203_ITCM_RAM_MW,\n  parameter AW = `E203_ITCM_RAM_AW\n)(\n  input wire sd,\n  input wire ds,\n  input wire ls,\n  input wire cs,\n  input wire we,\n  input wire [AW-1:0] addr,\n  input wire [MW-1:0] wem,\n  input wire [DW-1:0] din,\n  input wire rst_n,\n  input wire clk,\n  output wire [DW-1:0] dout\n);\n\n  // Instantiate the generic RAM module\n  sirv_gnrl_ram #(\n    .FORCE_X2ZERO(FORCE_X2ZERO),\n    .DP(DP),\n    .DW(DW),\n    .MW(MW),\n    .AW(AW)\n  ) u_sirv_gnrl_ram (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 16, "code": "module e203_exu_alu_bjp (\n    input wire bjp_i_valid,\n    output wire bjp_i_ready,\n    input wire [E203_XLEN-1:0] bjp_i_rs1,\n    input wire [E203_XLEN-1:0] bjp_i_rs2,\n    input wire [E203_XLEN-1:0] bjp_i_imm,\n    input wire [E203_PC_SIZE-1:0] bjp_i_pc,\n    input wire [E203_DECINFO_BJP_WIDTH-1:0] bjp_i_info,\n    output wire bjp_o_valid,\n    input wire bjp_o_ready,\n    output wire [E203_XLEN-1:0] bjp_o_wbck_wdat,\n    output wire bjp_o_wbck_err,\n    output wire bjp_o_cmt_bjp,\n    output wire bjp_o_cmt_mret,\n    output wire bjp_o_cmt_dret,\n    output wire bjp_o_cmt_fencei,\n    output wire bjp_o_cmt_prdt,\n    output wire bjp_o_cmt_rslv,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    output wire bjp_req_alu_cmp_eq,\n    output wire bjp_req_alu_cmp_ne,\n    output wire bjp_req_alu_cmp_lt,\n    output wire bjp_req_alu_cmp_gt,\n    output wire bjp_req_alu_cmp_ltu,\n    output wire bjp_req_alu_cmp_gtu,\n    output wire bjp_req_alu_add,\n    input wire bjp_req_alu_cmp_res,\n    input wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Handshake mechanism\n    assign bjp_i_ready = bjp_o_ready;\n    assign bjp_o_valid = bjp_i_valid;\n\n    // Default assignments\n    assign bjp_o_wbck_err = 1'b0;\n    assign bjp_o_cmt_mret = 1'b0;\n    assign bjp_o_cmt_dret = 1'b0;\n    assign bjp_o_cmt_fencei = 1'b0;\n\n    // ALU operation requests\n    wire is_jump = bjp_i_info[E203_DECINFO_BJP_JUMP];\n    wire is_beq = bjp_i_info[E203_DECINFO_BJP_BEQ];\n    wire is_bne = bjp_i_info[E203_DECINFO_BJP_BNE];\n    wire is_blt = bjp_i_info[E203_DECINFO_BJP_BLT];\n    wire is_bgt = bjp_i_info[E203_DECINFO_BJP_BGT];\n    wire is_bltu = bjp_i_info[E203_DECINFO_BJP_BLTU];\n    wire is_bgtu = bjp_i_info[E203_DECINFO_BJP_BGTU];\n\n    assign bjp_req_alu_cmp_eq = is_beq;\n    assign bjp_req_alu_cmp_ne = is_bne;\n    assign bjp_req_alu_cmp_lt = is_blt;\n    assign bjp_req_alu_cmp_gt = is_bgt;\n    assign bjp_req_alu_cmp_ltu = is_bltu;\n    assign bjp_req_alu_cmp_gtu = is_bgtu;\n    assign bjp_req_alu_add = is_jump;\n\n    // Operand selection\n    assign bjp_req_alu_op1 = is_jump ? bjp_i_pc : bjp_i_rs1;\n    assign bjp_req_alu_op2 = is_jump ? bjp_i_imm : bjp_i_rs2;\n\n    // Write back data and commit signals\n    assign bjp_o_wbck_wdat = bjp_req_alu_add_res;\n    assign bjp_o_cmt_bjp = bjp_i_valid & (is_jump | is_beq | is_bne | is_blt | is_bgt | is_bltu | is_bgtu);\n    assign bjp_o_cmt_prdt = bjp_i_info[E203_DECINFO_BJP_BPRDT];\n    assign bjp_o_cmt_rslv = is_jump ? 1'b1 : bjp_req_alu_cmp_res;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 18, "code": "module e203_exu_branchslv (\n    input wire cmt_i_valid,\n    output wire cmt_i_ready,\n    input wire cmt_i_rv32,\n    input wire cmt_i_dret,\n    input wire cmt_i_mret,\n    input wire cmt_i_fencei,\n    input wire cmt_i_bjp,\n    input wire cmt_i_bjp_prdt,\n    input wire cmt_i_bjp_rslv,\n    input wire [E203_PC_SIZE-1:0] cmt_i_pc,\n    input wire [E203_XLEN-1:0] cmt_i_imm,\n    input wire [E203_PC_SIZE-1:0] csr_epc_r,\n    input wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    input wire nonalu_excpirq_flush_req_raw,\n    input wire brchmis_flush_ack,\n    output wire brchmis_flush_req,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op1,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op2,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_pc,\n    output wire cmt_mret_ena,\n    output wire cmt_dret_ena,\n    output wire cmt_fencei_ena,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Flush need generation logic\n    wire flush_need_mret_dret = cmt_i_mret | cmt_i_dret;\n    wire flush_need_fencei = cmt_i_fencei;\n    wire flush_need_bjp = cmt_i_bjp & (cmt_i_bjp_prdt ^ cmt_i_bjp_rslv);\n    wire flush_need = (flush_need_mret_dret | flush_need_fencei | flush_need_bjp) & cmt_i_valid;\n\n    // Flush target calculation\n    wire [E203_PC_SIZE-1:0] flush_target_mret = csr_epc_r;\n    wire [E203_PC_SIZE-1:0] flush_target_dret = csr_dpc_r;\n    wire [E203_PC_SIZE-1:0] flush_target_fencei = cmt_i_pc + (cmt_i_rv32 ? 32'd4 : 32'd2);\n    wire [E203_PC_SIZE-1:0] flush_target_bjp_taken = cmt_i_pc + cmt_i_imm;\n    wire [E203_PC_SIZE-1:0] flush_target_bjp_not_taken = cmt_i_pc + (cmt_i_rv32 ? 32'd4 : 32'd2);\n\n    assign brchmis_flush_pc = (cmt_i_dret) ? flush_target_dret :\n                              (cmt_i_mret) ? flush_target_mret :\n                              (cmt_i_fencei) ? flush_target_fencei :\n                              (cmt_i_bjp & cmt_i_bjp_prdt & ~cmt_i_bjp_rslv) ? flush_target_bjp_not_taken :\n                              (cmt_i_bjp & ~cmt_i_bjp_prdt & cmt_i_bjp_rslv) ? flush_target_bjp_taken :\n                              csr_epc_r;\n\n    // Pipeline flush control\n    assign brchmis_flush_req = flush_need & ~nonalu_excpirq_flush_req_raw;\n    assign brchmis_flush_add_op1 = cmt_i_pc;\n    assign brchmis_flush_add_op2 = cmt_i_imm;\n\n    // Special signal commit\n    assign cmt_mret_ena = cmt_i_mret & flush_need & brchmis_flush_ack;\n    assign cmt_dret_ena = cmt_i_dret & flush_need & brchmis_flush_ack;\n    assign cmt_fencei_ena = cmt_i_fencei & flush_need & brchmis_flush_ack;\n\n    // Ready signal logic\n    assign cmt_i_ready = ~flush_need & ~nonalu_excpirq_flush_req_raw | brchmis_flush_ack;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 17, "code": "module e203_exu_alu_bjp (\n    input wire bjp_i_valid,\n    output wire bjp_i_ready,\n    input wire [E203_XLEN-1:0] bjp_i_rs1,\n    input wire [E203_XLEN-1:0] bjp_i_rs2,\n    input wire [E203_XLEN-1:0] bjp_i_imm,\n    input wire [E203_PC_SIZE-1:0] bjp_i_pc,\n    input wire [E203_DECINFO_BJP_WIDTH-1:0] bjp_i_info,\n    output wire bjp_o_valid,\n    input wire bjp_o_ready,\n    output wire [E203_XLEN-1:0] bjp_o_wbck_wdat,\n    output wire bjp_o_wbck_err,\n    output wire bjp_o_cmt_bjp,\n    output wire bjp_o_cmt_mret,\n    output wire bjp_o_cmt_dret,\n    output wire bjp_o_cmt_fencei,\n    output wire bjp_o_cmt_prdt,\n    output wire bjp_o_cmt_rslv,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    output wire bjp_req_alu_cmp_eq,\n    output wire bjp_req_alu_cmp_ne,\n    output wire bjp_req_alu_cmp_lt,\n    output wire bjp_req_alu_cmp_gt,\n    output wire bjp_req_alu_cmp_ltu,\n    output wire bjp_req_alu_cmp_gtu,\n    output wire bjp_req_alu_add,\n    input wire bjp_req_alu_cmp_res,\n    input wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    assign bjp_i_ready = bjp_o_ready;\n    assign bjp_o_valid = bjp_i_valid;\n\n    wire is_beq = bjp_i_info[E203_DECINFO_BJP_BEQ];\n    wire is_bne = bjp_i_info[E203_DECINFO_BJP_BNE];\n    wire is_blt = bjp_i_info[E203_DECINFO_BJP_BLT];\n    wire is_bgt = bjp_i_info[E203_DECINFO_BJP_BGT];\n    wire is_bltu = bjp_i_info[E203_DECINFO_BJP_BLTU];\n    wire is_bgtu = bjp_i_info[E203_DECINFO_BJP_BGTU];\n    wire is_jump = bjp_i_info[E203_DECINFO_BJP_JUMP];\n    wire is_mret = bjp_i_info[E203_DECINFO_BJP_MRET];\n    wire is_dret = bjp_i_info[E203_DECINFO_BJP_DRET];\n    wire is_fencei = bjp_i_info[E203_DECINFO_BJP_FENCEI];\n\n    assign bjp_req_alu_cmp_eq = is_beq;\n    assign bjp_req_alu_cmp_ne = is_bne;\n    assign bjp_req_alu_cmp_lt = is_blt;\n    assign bjp_req_alu_cmp_gt = is_bgt;\n    assign bjp_req_alu_cmp_ltu = is_bltu;\n    assign bjp_req_alu_cmp_gtu = is_bgtu;\n    assign bjp_req_alu_add = is_jump;\n\n    assign bjp_o_wbck_err = 1'b0;\n\n    assign bjp_o_cmt_bjp = bjp_i_valid && (is_beq || is_bne || is_blt || is_bgt || is_bltu || is_bgtu || is_jump);\n    assign bjp_o_cmt_mret = is_mret;\n    assign bjp_o_cmt_dret = is_dret;\n    assign bjp_o_cmt_fencei = is_fencei;\n\n    assign bjp_o_cmt_prdt = bjp_i_info[E203_DECINFO_BJP_BPRDT];\n    assign bjp_o_cmt_rslv = is_jump ? 1'b1 : bjp_req_alu_cmp_res;\n\n    assign bjp_req_alu_op1 = is_jump ? bjp_i_pc : bjp_i_rs1;\n    assign bjp_req_alu_op2 = is_jump ? (E203_XLEN == 32 ? 32'd4 : 64'd2) : bjp_i_rs2;\n\n    assign bjp_o_wbck_wdat = bjp_req_alu_add_res;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 18, "code": "module e203_exu_alu_rglr (\n    input wire alu_i_valid,\n    output wire alu_i_ready,\n    input wire [E203_XLEN-1:0] alu_i_rs1,\n    input wire [E203_XLEN-1:0] alu_i_rs2,\n    input wire [E203_XLEN-1:0] alu_i_imm,\n    input wire [E203_PC_SIZE-1:0] alu_i_pc,\n    input wire [E203_DECINFO_ALU_WIDTH-1:0] alu_i_info,\n    output wire alu_o_valid,\n    input wire alu_o_ready,\n    output wire [E203_XLEN-1:0] alu_o_wbck_wdat,\n    output wire alu_o_wbck_err,\n    output wire alu_o_cmt_ecall,\n    output wire alu_o_cmt_ebreak,\n    output wire alu_o_cmt_wfi,\n    output wire alu_req_alu_add,\n    output wire alu_req_alu_sub,\n    output wire alu_req_alu_xor,\n    output wire alu_req_alu_sll,\n    output wire alu_req_alu_srl,\n    output wire alu_req_alu_sra,\n    output wire alu_req_alu_or,\n    output wire alu_req_alu_and,\n    output wire alu_req_alu_slt,\n    output wire alu_req_alu_sltu,\n    output wire alu_req_alu_lui,\n    output wire [E203_XLEN-1:0] alu_req_alu_op1,\n    output wire [E203_XLEN-1:0] alu_req_alu_op2,\n    output wire [E203_XLEN-1:0] alu_req_alu_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Handshake signals\n    assign alu_i_ready = alu_o_ready;\n    assign alu_o_valid = alu_i_valid;\n\n    // Operation decoding\n    assign alu_req_alu_add = alu_i_info[E203_DECINFO_ALU_ADD] & ~alu_i_info[E203_DECINFO_ALU_NOP];\n    assign alu_req_alu_sub = alu_i_info[E203_DECINFO_ALU_SUB];\n    assign alu_req_alu_xor = alu_i_info[E203_DECINFO_ALU_XOR];\n    assign alu_req_alu_sll = alu_i_info[E203_DECINFO_ALU_SLL];\n    assign alu_req_alu_srl = alu_i_info[E203_DECINFO_ALU_SRL];\n    assign alu_req_alu_sra = alu_i_info[E203_DECINFO_ALU_SRA];\n    assign alu_req_alu_or = alu_i_info[E203_DECINFO_ALU_OR];\n    assign alu_req_alu_and = alu_i_info[E203_DECINFO_ALU_AND];\n    assign alu_req_alu_slt = alu_i_info[E203_DECINFO_ALU_SLT];\n    assign alu_req_alu_sltu = alu_i_info[E203_DECINFO_ALU_SLTU];\n    assign alu_req_alu_lui = alu_i_info[E203_DECINFO_ALU_LUI];\n\n    // Operand selection\n    assign alu_req_alu_op1 = alu_i_info[E203_DECINFO_ALU_OP1PC] ? alu_i_pc : alu_i_rs1;\n    assign alu_req_alu_op2 = alu_i_info[E203_DECINFO_ALU_OP2IMM] ? alu_i_imm : alu_i_rs2;\n\n    // Result forwarding\n    assign alu_o_wbck_wdat = alu_req_alu_res;\n\n    // Error and special instruction handling\n    wire special_instr = alu_i_info[E203_DECINFO_ALU_ECAL] | alu_i_info[E203_DECINFO_ALU_EBRK] | alu_i_info[E203_DECINFO_ALU_WFI];\n    assign alu_o_wbck_err = special_instr;\n    assign alu_o_cmt_ecall = alu_i_info[E203_DECINFO_ALU_ECAL];\n    assign alu_o_cmt_ebreak = alu_i_info[E203_DECINFO_ALU_EBRK];\n    assign alu_o_cmt_wfi = alu_i_info[E203_DECINFO_ALU_WFI];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 8, "code": "module e203_lsu(\n    input wire commit_mret,\n    input wire commit_trap,\n    input wire excp_active,\n    output wire lsu_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n    output wire [ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_buserr,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [XLEN/8-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [XLEN-1:0] agu_icb_rsp_rdata,\n\n    input wire nice_mem_holdup,\n    input wire itcm_region_indic,\n    input wire dtcm_region_indic\n);\n    // LSU logic implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 18, "code": "module e203_reset_ctrl #(\n    parameter MASTER = 1,\n    parameter RST_SYNC_LEVEL = `E203_ASYNC_FF_LEVELS\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    output wire rst_core,\n    output wire rst_itcm,\n    output wire rst_dtcm,\n    output wire rst_aon\n);\n\nreg [RST_SYNC_LEVEL-1:0] rst_sync_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        rst_sync_reg <= {RST_SYNC_LEVEL{1'b1}};\n    end else if (test_mode) begin\n        rst_sync_reg <= {RST_SYNC_LEVEL{rst_n}};\n    end else begin\n        rst_sync_reg <= {rst_sync_reg[RST_SYNC_LEVEL-2:0], 1'b1};\n    end\nend\n\nassign rst_core = (MASTER == 1) ? rst_sync_reg[RST_SYNC_LEVEL-1] : rst_n;\nassign rst_itcm = (MASTER == 1) ? rst_sync_reg[RST_SYNC_LEVEL-1] : rst_n;\nassign rst_dtcm = (MASTER == 1) ? rst_sync_reg[RST_SYNC_LEVEL-1] : rst_n;\nassign rst_aon = (MASTER == 1) ? rst_sync_reg[RST_SYNC_LEVEL-1] : rst_n;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 16, "code": "module e203_exu_alu_lsuagu (\n    input wire agu_i_valid,\n    output wire agu_i_ready,\n    input wire [E203_XLEN-1:0] agu_i_rs1,\n    input wire [E203_XLEN-1:0] agu_i_rs2,\n    input wire [E203_XLEN-1:0] agu_i_imm,\n    input wire [E203_DECINFO_AGU_WIDTH-1:0] agu_i_info,\n    input wire [E203_ITAG_WIDTH-1:0] agu_i_itag,\n    output wire agu_i_longpipe,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire amo_wait,\n    input wire oitf_empty,\n    output wire agu_o_valid,\n    input wire agu_o_ready,\n    output wire [E203_XLEN-1:0] agu_o_wbck_wdat,\n    output wire agu_o_wbck_err,\n    output wire agu_o_cmt_misalgn,\n    output wire agu_o_cmt_ld,\n    output wire agu_o_cmt_stamo,\n    output wire agu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] agu_o_cmt_badaddr,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_cmd_usign,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire [E203_XLEN-1:0] agu_req_alu_op1,\n    output wire [E203_XLEN-1:0] agu_req_alu_op2,\n    output wire agu_req_alu_swap,\n    output wire agu_req_alu_add,\n    output wire agu_req_alu_and,\n    output wire agu_req_alu_or,\n    output wire agu_req_alu_xor,\n    output wire agu_req_alu_max,\n    output wire agu_req_alu_min,\n    output wire agu_req_alu_maxu,\n    output wire agu_req_alu_minu,\n    input wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire agu_sbf_0_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_0_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_0_r,\n    output wire agu_sbf_1_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_1_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_1_r,\n    input wire clk,\n    input wire rst_n\n);\n    // Module implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 14, "code": "module e203_exu_longpwbck (\n    input wire lsu_wbck_i_valid,\n    output wire lsu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] lsu_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] lsu_wbck_i_itag,\n    input wire lsu_wbck_i_err,\n    input wire lsu_cmt_i_buserr,\n    input wire [E203_ADDR_SIZE-1:0] lsu_cmt_i_badaddr,\n    input wire lsu_cmt_i_ld,\n    input wire lsu_cmt_i_st,\n    output wire longp_wbck_o_valid,\n    input wire longp_wbck_o_ready,\n    output wire [E203_FLEN-1:0] longp_wbck_o_wdat,\n    output wire [4:0] longp_wbck_o_flags,\n    output wire [E203_RFIDX_WIDTH-1:0] longp_wbck_o_rdidx,\n    output wire longp_wbck_o_rdfpu,\n    output wire longp_excp_o_valid,\n    input wire longp_excp_o_ready,\n    output wire longp_excp_o_insterr,\n    output wire longp_excp_o_ld,\n    output wire longp_excp_o_st,\n    output wire longp_excp_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] longp_excp_o_badaddr,\n    output wire [E203_PC_SIZE-1:0] longp_excp_o_pc,\n    input wire oitf_empty,\n    input wire [E203_ITAG_WIDTH-1:0] oitf_ret_ptr,\n    input wire [E203_RFIDX_WIDTH-1:0] oitf_ret_rdidx,\n    input wire [E203_PC_SIZE-1:0] oitf_ret_pc,\n    input wire oitf_ret_rdwen,\n    input wire oitf_ret_rdfpu,\n    output wire oitf_ret_ena,\n    input wire clk,\n    input wire rst_n\n`ifdef E203_HAS_NICE\n    , input wire nice_longp_wbck_i_valid,\n    output wire nice_longp_wbck_i_ready,\n    input wire [E203_XLEN-1:0] nice_longp_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] nice_longp_wbck_i_itag,\n    input wire nice_longp_wbck_i_err\n`endif\n);\n\n    // Write-back arbitration logic\n    wire wbck_i_valid = lsu_wbck_i_valid `ifdef E203_HAS_NICE || nice_longp_wbck_i_valid `endif;\n    wire [E203_XLEN-1:0] wbck_i_wdat = lsu_wbck_i_valid ? lsu_wbck_i_wdat : `ifdef E203_HAS_NICE nice_longp_wbck_i_wdat `endif;\n    wire wbck_i_err = lsu_wbck_i_valid ? lsu_wbck_i_err : `ifdef E203_HAS_NICE nice_longp_wbck_i_err `endif;\n    wire wbck_i_ready = longp_wbck_o_ready && longp_excp_o_ready;\n\n    assign lsu_wbck_i_ready = wbck_i_ready;\n    `ifdef E203_HAS_NICE\n    assign nice_longp_wbck_i_ready = wbck_i_ready;\n    `endif\n\n    // Exception handling logic\n    wire excp_need = wbck_i_err;\n    wire wbck_need = wbck_i_valid && !wbck_i_err;\n\n    assign longp_excp_o_valid = excp_need && wbck_i_valid && !wbck_need;\n    assign longp_excp_o_insterr = wbck_i_err;\n    assign longp_excp_o_ld = lsu_cmt_i_ld;\n    assign longp_excp_o_st = lsu_cmt_i_st;\n    assign longp_excp_o_buserr = lsu_cmt_i_buserr;\n    assign longp_excp_o_badaddr = lsu_cmt_i_badaddr;\n    assign longp_excp_o_pc = oitf_ret_pc;\n\n    // Write-back logic\n    assign longp_wbck_o_valid = wbck_need && wbck_i_valid && !excp_need;\n    assign longp_wbck_o_wdat = wbck_i_wdat;\n    assign longp_wbck_o_flags = {4'b0, wbck_i_err};\n    assign longp_wbck_o_rdidx = oitf_ret_rdidx;\n    assign longp_wbck_o_rdfpu = oitf_ret_rdfpu;\n\n    // OITF control logic\n    assign oitf_ret_ena = wbck_i_ready && wbck_i_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 17, "code": "module e203_exu_alu_lsuagu (\n    input wire agu_i_valid,\n    output wire agu_i_ready,\n    input wire [E203_XLEN-1:0] agu_i_rs1,\n    input wire [E203_XLEN-1:0] agu_i_rs2,\n    input wire [E203_XLEN-1:0] agu_i_imm,\n    input wire [E203_DECINFO_AGU_WIDTH-1:0] agu_i_info,\n    input wire [E203_ITAG_WIDTH-1:0] agu_i_itag,\n    output wire agu_i_longpipe,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire amo_wait,\n    input wire oitf_empty,\n    output wire agu_o_valid,\n    input wire agu_o_ready,\n    output wire [E203_XLEN-1:0] agu_o_wbck_wdat,\n    output wire agu_o_wbck_err,\n    output wire agu_o_cmt_misalgn,\n    output wire agu_o_cmt_ld,\n    output wire agu_o_cmt_stamo,\n    output wire agu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] agu_o_cmt_badaddr,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_cmd_usign,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire [E203_XLEN-1:0] agu_req_alu_op1,\n    output wire [E203_XLEN-1:0] agu_req_alu_op2,\n    output wire agu_req_alu_swap,\n    output wire agu_req_alu_add,\n    output wire agu_req_alu_and,\n    output wire agu_req_alu_or,\n    output wire agu_req_alu_xor,\n    output wire agu_req_alu_max,\n    output wire agu_req_alu_min,\n    output wire agu_req_alu_maxu,\n    output wire agu_req_alu_minu,\n    input wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire agu_sbf_0_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_0_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_0_r,\n    output wire agu_sbf_1_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_1_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_1_r,\n    input wire clk,\n    input wire rst_n\n);\n    // Module implementation goes here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 15, "code": "module e203_exu_longpwbck (\n    input wire lsu_wbck_i_valid,\n    output wire lsu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] lsu_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] lsu_wbck_i_itag,\n    input wire lsu_wbck_i_err,\n    input wire lsu_cmt_i_buserr,\n    input wire [E203_ADDR_SIZE-1:0] lsu_cmt_i_badaddr,\n    input wire lsu_cmt_i_ld,\n    input wire lsu_cmt_i_st,\n    output wire longp_wbck_o_valid,\n    input wire longp_wbck_o_ready,\n    output wire [E203_FLEN-1:0] longp_wbck_o_wdat,\n    output wire [4:0] longp_wbck_o_flags,\n    output wire [E203_RFIDX_WIDTH-1:0] longp_wbck_o_rdidx,\n    output wire longp_wbck_o_rdfpu,\n    output wire longp_excp_o_valid,\n    input wire longp_excp_o_ready,\n    output wire longp_excp_o_insterr,\n    output wire longp_excp_o_ld,\n    output wire longp_excp_o_st,\n    output wire longp_excp_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] longp_excp_o_badaddr,\n    output wire [E203_PC_SIZE-1:0] longp_excp_o_pc,\n    input wire oitf_empty,\n    input wire [E203_ITAG_WIDTH-1:0] oitf_ret_ptr,\n    input wire [E203_RFIDX_WIDTH-1:0] oitf_ret_rdidx,\n    input wire [E203_PC_SIZE-1:0] oitf_ret_pc,\n    input wire oitf_ret_rdwen,\n    input wire oitf_ret_rdfpu,\n    output wire oitf_ret_ena,\n    input wire clk,\n    input wire rst_n\n    `ifdef E203_HAS_NICE\n    , input wire nice_longp_wbck_i_valid,\n    output wire nice_longp_wbck_i_ready,\n    input wire [E203_XLEN-1:0] nice_longp_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] nice_longp_wbck_i_itag,\n    input wire nice_longp_wbck_i_err\n    `endif\n);\n\n    // Write-Back Arbitration Logic\n    wire wbck_need = (oitf_ret_rdwen && !lsu_wbck_i_err);\n    wire excp_need = (lsu_wbck_i_err || lsu_cmt_i_buserr);\n\n    assign lsu_wbck_i_ready = (wbck_need && longp_wbck_o_ready) && (excp_need && longp_excp_o_ready);\n    assign longp_wbck_o_valid = wbck_need && lsu_wbck_i_valid && !excp_need;\n    assign longp_wbck_o_wdat = lsu_wbck_i_wdat;\n    assign longp_wbck_o_rdidx = oitf_ret_rdidx;\n    assign longp_wbck_o_rdfpu = oitf_ret_rdfpu;\n\n    // Exception Handling\n    assign longp_excp_o_valid = excp_need && lsu_wbck_i_valid && !wbck_need;\n    assign longp_excp_o_insterr = lsu_wbck_i_err;\n    assign longp_excp_o_ld = lsu_cmt_i_ld;\n    assign longp_excp_o_st = lsu_cmt_i_st;\n    assign longp_excp_o_buserr = lsu_cmt_i_buserr;\n    assign longp_excp_o_badaddr = lsu_cmt_i_badaddr;\n    assign longp_excp_o_pc = oitf_ret_pc;\n\n    // OITF Control\n    assign oitf_ret_ena = lsu_wbck_i_ready && lsu_wbck_i_valid;\n\n    `ifdef E203_HAS_NICE\n    // NICE Write-Back Arbitration\n    assign nice_longp_wbck_i_ready = (wbck_need && longp_wbck_o_ready) && (excp_need && longp_excp_o_ready);\n    `endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 3, "code": "module e203_ifu_ifetch(\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_valid,\n    input wire ifu_req_ready,\n    output wire [E203_PC_SIZE-1:0] ifu_req_pc,\n    output wire ifu_req_seq,\n    output wire ifu_req_seq_rv32,\n    output wire [E203_PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_valid,\n    output wire ifu_rsp_ready,\n    input wire ifu_rsp_err,\n    input wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr,\n    input wire pipe_flush_req,\n    output wire pipe_flush_ack,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    `ifdef E203_TIMING_BOOST\n    input wire [E203_PC_SIZE-1:0] pipe_flush_pc,\n    `endif\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    input wire ifu_halt_req,\n    output wire ifu_halt_ack,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu\n);\n    // Internal signal declarations\n    wire reset_flag_r;\n    wire reset_req_r;\n    wire halt_ack_r;\n    wire dly_flush_r;\n    wire ir_valid_r;\n    wire ir_pc_vld_r;\n    wire ifu_err_r;\n    wire ifu_prdt_taken_r;\n    wire [E203_INSTR_SIZE-1:0] ifu_ir_r;\n    wire [E203_RFIDX_WIDTH-1:0] ir_rs1idx_r;\n    wire [E203_RFIDX_WIDTH-1:0] ir_rs2idx_r;\n    wire [E203_PC_SIZE-1:0] ifu_pc_r;\n    wire [E203_PC_SIZE-1:0] pc_r;\n    wire out_flag_r;\n    wire pc_newpend_r;\n\n    // Implementation of the e203_ifu_ifetch logic\n    // This is a placeholder for the actual implementation\n    // Please replace with the actual logic based on the design specifications\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 6, "code": "module e203_exu_excp (\n    output commit_trap,\n    output core_wfi,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input amo_wait,\n    input alu_excp_i_valid,\n    input alu_excp_i_ld,\n    input alu_excp_i_stamo,\n    input alu_excp_i_misalgn,\n    input alu_excp_i_buserr,\n    input alu_excp_i_ecall,\n    input alu_excp_i_ebreak,\n    input alu_excp_i_wfi,\n    input alu_excp_i_ifu_misalgn,\n    input alu_excp_i_ifu_buserr,\n    input alu_excp_i_ifu_ilegl,\n    input [E203_PC_SIZE-1:0] alu_excp_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_excp_i_instr,\n    input alu_excp_i_pc_vld,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input longp_excp_i_insterr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input excpirq_flush_ack,\n    output excpirq_flush_req,\n    output nonalu_excpirq_flush_req_raw,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op1,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op2,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input cmt_dret_ena,\n    input cmt_ena,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_badaddr_ena,\n    output cmt_epc_ena,\n    output cmt_cause_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output excp_active,\n    input clk,\n    input rst_n\n);\n\n// Implementation of the exception handling logic\n// This is a placeholder for the actual logic which would handle the exceptions\n// based on the inputs and control the outputs accordingly.\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 3, "code": "module itcm_controller (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n    output wire itcm_active,\n\n    // IFU Interface\n    input wire ifu2itcm_icb_cmd_valid,\n    output wire ifu2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] ifu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] ifu2itcm_icb_cmd_wmask,\n    output wire ifu2itcm_icb_rsp_valid,\n    input wire ifu2itcm_icb_rsp_ready,\n    output wire ifu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n\n    // LSU Interface\n    input wire lsu2itcm_icb_cmd_valid,\n    output wire lsu2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] lsu2itcm_icb_cmd_addr,\n    input wire lsu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] lsu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] lsu2itcm_icb_cmd_wmask,\n    output wire lsu2itcm_icb_rsp_valid,\n    input wire lsu2itcm_icb_rsp_ready,\n    output wire lsu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] lsu2itcm_icb_rsp_rdata,\n\n    // External Interface\n    `ifdef E203_HAS_ITCM_EXTITF\n    input wire ext2itcm_icb_cmd_valid,\n    output wire ext2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input wire ext2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] ext2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] ext2itcm_icb_cmd_wmask,\n    output wire ext2itcm_icb_rsp_valid,\n    input wire ext2itcm_icb_rsp_ready,\n    output wire ext2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] ext2itcm_icb_rsp_rdata,\n    `endif\n\n    // RAM Interface\n    output wire itcm_ram_cs,\n    output wire itcm_ram_we,\n    output wire [RAM_AW-1:0] itcm_ram_addr,\n    output wire [RAM_MW-1:0] itcm_ram_wem,\n    output wire [RAM_DW-1:0] itcm_ram_din,\n    input wire [RAM_DW-1:0] itcm_ram_dout,\n    output wire clk_itcm_ram\n);\n\n    // Internal signals\n    wire [ADDR_WIDTH-1:0] selected_addr;\n    wire [DATA_WIDTH-1:0] selected_wdata;\n    wire [WMSK_WIDTH-1:0] selected_wmask;\n    wire selected_read;\n    wire selected_valid;\n    wire selected_ready;\n\n    // Arbitration logic\n    always @(*) begin\n        if (lsu2itcm_icb_cmd_valid) begin\n            selected_addr = lsu2itcm_icb_cmd_addr;\n            selected_wdata = lsu2itcm_icb_cmd_wdata;\n            selected_wmask = lsu2itcm_icb_cmd_wmask;\n            selected_read = lsu2itcm_icb_cmd_read;\n            selected_valid = lsu2itcm_icb_cmd_valid;\n            lsu2itcm_icb_cmd_ready = selected_ready;\n        end else if (ifu2itcm_icb_cmd_valid) begin\n            selected_addr = ifu2itcm_icb_cmd_addr;\n            selected_wdata = ifu2itcm_icb_cmd_wdata;\n            selected_wmask = ifu2itcm_icb_cmd_wmask;\n            selected_read = ifu2itcm_icb_cmd_read;\n            selected_valid = ifu2itcm_icb_cmd_valid;\n            ifu2itcm_icb_cmd_ready = selected_ready;\n        end `ifdef E203_HAS_ITCM_EXTITF\n        else if (ext2itcm_icb_cmd_valid) begin\n            selected_addr = ext2itcm_icb_cmd_addr;\n            selected_wdata = ext2itcm_icb_cmd_wdata;\n            selected_wmask = ext2itcm_icb_cmd_wmask;\n            selected_read = ext2itcm_icb_cmd_read;\n            selected_valid = ext2itcm_icb_cmd_valid;\n            ext2itcm_icb_cmd_ready = selected_ready;\n        end\n        `endif\n        else begin\n            selected_valid = 1'b0;\n        end\n    end\n\n    // RAM access logic\n    assign itcm_ram_cs = selected_valid && selected_ready;\n    assign itcm_ram_we = !selected_read;\n    assign itcm_ram_addr = selected_addr[RAM_AW-1:0];\n    assign itcm_ram_wem = selected_wmask;\n    assign itcm_ram_din = selected_wdata;\n    assign clk_itcm_ram = clk;\n\n    // Response logic\n    assign ifu2itcm_icb_rsp_valid = itcm_ram_cs && ifu2itcm_icb_cmd_valid;\n    assign ifu2itcm_icb_rsp_rdata = itcm_ram_dout;\n    assign ifu2itcm_icb_rsp_err = 1'b0; // Assuming no error handling for simplicity\n\n    assign lsu2itcm_icb_rsp_valid = itcm_ram_cs && lsu2itcm_icb_cmd_valid;\n    assign lsu2itcm_icb_rsp_rdata = itcm_ram_dout;\n    assign lsu2itcm_icb_rsp_err = 1'b0; // Assuming no error handling for simplicity\n\n    `ifdef E203_HAS_ITCM_EXTITF\n    assign ext2itcm_icb_rsp_valid = itcm_ram_cs && ext2itcm_icb_cmd_valid;\n    assign ext2itcm_icb_rsp_rdata = itcm_ram_dout;\n    assign ext2itcm_icb_rsp_err = 1'b0; // Assuming no error handling for simplicity\n    `endif\n\n    // Active status\n    assign itcm_active = itcm_ram_cs;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 9, "code": "module e203_lsu(\n    input wire commit_mret,\n    input wire commit_trap,\n    input wire excp_active,\n    output wire lsu_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n    output wire [ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_buserr,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [XLEN-1:0] agu_icb_rsp_rdata,\n\n    input wire nice_mem_holdup,\n    input wire itcm_region_indic,\n    input wire dtcm_region_indic\n);\n    // LSU logic implementation here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 16, "code": "module e203_exu_alu_dpath(\n    input wire alu_req_alu,\n    input wire alu_req_alu_add,\n    input wire alu_req_alu_sub,\n    input wire alu_req_alu_xor,\n    input wire alu_req_alu_sll,\n    input wire alu_req_alu_srl,\n    input wire alu_req_alu_sra,\n    input wire alu_req_alu_or,\n    input wire alu_req_alu_and,\n    input wire [E203_XLEN-1:0] alu_req_alu_op1,\n    input wire [E203_XLEN-1:0] alu_req_alu_op2,\n    input wire bjp_req_alu,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    input wire agu_req_alu,\n    input wire [E203_XLEN-1:0] agu_req_alu_op1,\n    input wire [E203_XLEN-1:0] agu_req_alu_op2,\n    input wire muldiv_req_alu,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    input wire muldiv_req_alu_add,\n    input wire muldiv_req_alu_sub,\n    input wire muldiv_sbf_0_ena,\n    input wire [32:0] muldiv_sbf_0_nxt,\n    input wire muldiv_sbf_1_ena,\n    input wire [32:0] muldiv_sbf_1_nxt,\n    input wire clk,\n    input wire rst_n,\n    output wire [E203_XLEN-1:0] alu_req_alu_res,\n    output wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    output wire bjp_req_alu_cmp_res,\n    output wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output wire [32:0] muldiv_sbf_0_r,\n    output wire [32:0] muldiv_sbf_1_r\n);\n\n    // Internal signals for ALU operations\n    wire [E203_XLEN-1:0] add_res;\n    wire [E203_XLEN-1:0] sub_res;\n    wire [E203_XLEN-1:0] xor_res;\n    wire [E203_XLEN-1:0] sll_res;\n    wire [E203_XLEN-1:0] srl_res;\n    wire [E203_XLEN-1:0] sra_res;\n    wire [E203_XLEN-1:0] or_res;\n    wire [E203_XLEN-1:0] and_res;\n\n    // ALU operations\n    assign add_res = alu_req_alu_op1 + alu_req_alu_op2;\n    assign sub_res = alu_req_alu_op1 - alu_req_alu_op2;\n    assign xor_res = alu_req_alu_op1 ^ alu_req_alu_op2;\n    assign sll_res = alu_req_alu_op1 << alu_req_alu_op2;\n    assign srl_res = alu_req_alu_op1 >> alu_req_alu_op2;\n    assign sra_res = $signed(alu_req_alu_op1) >>> alu_req_alu_op2;\n    assign or_res = alu_req_alu_op1 | alu_req_alu_op2;\n    assign and_res = alu_req_alu_op1 & alu_req_alu_op2;\n\n    // ALU result multiplexer\n    assign alu_req_alu_res = (alu_req_alu_add ? add_res :\n                             (alu_req_alu_sub ? sub_res :\n                             (alu_req_alu_xor ? xor_res :\n                             (alu_req_alu_sll ? sll_res :\n                             (alu_req_alu_srl ? srl_res :\n                             (alu_req_alu_sra ? sra_res :\n                             (alu_req_alu_or  ? or_res  :\n                             (alu_req_alu_and ? and_res : 0))))))));\n\n    // BJP and AGU results\n    assign bjp_req_alu_add_res = bjp_req_alu_op1 + bjp_req_alu_op2;\n    assign bjp_req_alu_cmp_res = (bjp_req_alu_op1 == bjp_req_alu_op2);\n    assign agu_req_alu_res = agu_req_alu_op1 + agu_req_alu_op2;\n\n    // MULDIV results\n    assign muldiv_req_alu_res = (muldiv_req_alu_add ? muldiv_req_alu_op1 + muldiv_req_alu_op2 :\n                                (muldiv_req_alu_sub ? muldiv_req_alu_op1 - muldiv_req_alu_op2 : 0));\n\n    // Shared buffer logic\n    sirv_gnrl_dffl #(33) sbf_0_dffl (\n        .lden(muldiv_sbf_0_ena),\n        .dnxt(muldiv_sbf_0_nxt),\n        .qout(muldiv_sbf_0_r),\n        .clk(clk)\n    );\n\n    sirv_gnrl_dffl #(33) sbf_1_dffl (\n        .lden(muldiv_sbf_1_ena),\n        .dnxt(muldiv_sbf_1_nxt),\n        .qout(muldiv_sbf_1_r),\n        .clk(clk)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 3, "code": "module e203_lsu_ctrl(\n    input wire commit_mret,\n    input wire commit_trap,\n    output wire lsu_ctrl_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    input wire nice_mem_holdup,\n    input wire nice_icb_cmd_valid,\n    output wire nice_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] nice_icb_cmd_addr,\n    input wire nice_icb_cmd_read,\n    input wire [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input wire [E203_XLEN/8-1:0] nice_icb_cmd_wmask,\n    output wire nice_icb_rsp_valid,\n    input wire nice_icb_rsp_ready,\n    output wire nice_icb_rsp_err,\n    output wire [E203_XLEN-1:0] nice_icb_rsp_rdata,\n\n    output wire dcache_icb_cmd_valid,\n    input wire dcache_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] dcache_icb_cmd_addr,\n    output wire dcache_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dcache_icb_cmd_wdata,\n    output wire [E203_XLEN/8-1:0] dcache_icb_cmd_wmask,\n    output wire dcache_icb_cmd_lock,\n    output wire dcache_icb_cmd_excl,\n    output wire [1:0] dcache_icb_cmd_size,\n    input wire dcache_icb_rsp_valid,\n    output wire dcache_icb_rsp_ready,\n    input wire dcache_icb_rsp_err,\n    input wire dcache_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dcache_icb_rsp_rdata,\n\n    output wire dtcm_icb_cmd_valid,\n    input wire dtcm_icb_cmd_ready,\n    output wire [E203_DTCM_ADDR_WIDTH-1:0] dtcm_icb_cmd_addr,\n    output wire dtcm_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dtcm_icb_cmd_wdata,\n    output wire [E203_XLEN/8-1:0] dtcm_icb_cmd_wmask,\n    output wire dtcm_icb_cmd_lock,\n    output wire dtcm_icb_cmd_excl,\n    output wire [1:0] dtcm_icb_cmd_size,\n    input wire dtcm_icb_rsp_valid,\n    output wire dtcm_icb_rsp_ready,\n    input wire dtcm_icb_rsp_err,\n    input wire dtcm_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dtcm_icb_rsp_rdata,\n    input wire [E203_ADDR_SIZE-1:0] dtcm_region_indic,\n\n    output wire biu_icb_cmd_valid,\n    input wire biu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,\n    output wire biu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] biu_icb_cmd_wdata,\n    output wire [E203_XLEN/8-1:0] biu_icb_cmd_wmask,\n    output wire biu_icb_cmd_lock,\n    output wire biu_icb_cmd_excl,\n    output wire [1:0] biu_icb_cmd_size,\n    input wire biu_icb_rsp_valid,\n    output wire biu_icb_rsp_ready,\n    input wire biu_icb_rsp_err,\n    input wire biu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] biu_icb_rsp_rdata,\n\n    input wire clk,\n    input wire rst_n\n);\n    // Implementation of LSU control logic here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 17, "code": "module e203_exu_alu_muldiv(\n    input mdv_nob2b,\n    input muldiv_i_valid,\n    output muldiv_i_ready,\n    input [E203_XLEN-1:0] muldiv_i_rs1,\n    input [E203_XLEN-1:0] muldiv_i_rs2,\n    input [E203_XLEN-1:0] muldiv_i_imm,\n    input [E203_DECINFO_MULDIV_WIDTH-1:0] muldiv_i_info,\n    input [E203_ITAG_WIDTH-1:0] muldiv_i_itag,\n    output muldiv_i_longpipe,\n    input flush_pulse,\n    output muldiv_o_valid,\n    input muldiv_o_ready,\n    output [E203_XLEN-1:0] muldiv_o_wbck_wdat,\n    output muldiv_o_wbck_err,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    output muldiv_req_alu_add,\n    output muldiv_req_alu_sub,\n    input [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output muldiv_sbf_0_ena,\n    output [32:0] muldiv_sbf_0_nxt,\n    input [32:0] muldiv_sbf_0_r,\n    output muldiv_sbf_1_ena,\n    output [32:0] muldiv_sbf_1_nxt,\n    input [32:0] muldiv_sbf_1_r,\n    input clk,\n    input rst_n\n);\n\n// Internal signals and registers\nreg [4:0] state;\nreg [4:0] next_state;\n\n// State definitions\nlocalparam MULDIV_STATE_0TH = 5'd0;\nlocalparam MULDIV_STATE_EXEC = 5'd1;\nlocalparam MULDIV_STATE_REMD_CHCK = 5'd2;\nlocalparam MULDIV_STATE_QUOT_CORR = 5'd3;\nlocalparam MULDIV_STATE_REMD_CORR = 5'd4;\n\n// FSM for managing multiplier and divider operations\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        state <= MULDIV_STATE_0TH;\n    end else if (flush_pulse) begin\n        state <= MULDIV_STATE_0TH;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (state)\n        MULDIV_STATE_0TH: begin\n            if (muldiv_i_valid && !flush_pulse)\n                next_state = MULDIV_STATE_EXEC;\n            else\n                next_state = MULDIV_STATE_0TH;\n        end\n        MULDIV_STATE_EXEC: begin\n            if (flush_pulse)\n                next_state = MULDIV_STATE_0TH;\n            else if (/* condition for completing execution */)\n                next_state = MULDIV_STATE_REMD_CHCK;\n            else\n                next_state = MULDIV_STATE_EXEC;\n        end\n        MULDIV_STATE_REMD_CHCK: begin\n            if (flush_pulse)\n                next_state = MULDIV_STATE_0TH;\n            else if (/* condition for needing correction */)\n                next_state = MULDIV_STATE_QUOT_CORR;\n            else\n                next_state = MULDIV_STATE_0TH;\n        end\n        MULDIV_STATE_QUOT_CORR: begin\n            next_state = MULDIV_STATE_REMD_CORR;\n        end\n        MULDIV_STATE_REMD_CORR: begin\n            if (flush_pulse)\n                next_state = MULDIV_STATE_0TH;\n            else\n                next_state = MULDIV_STATE_0TH;\n        end\n        default: begin\n            next_state = MULDIV_STATE_0TH;\n        end\n    endcase\nend\n\n// Output logic and other processing logic here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 8, "code": "module e203_ifu(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire itcm_nohold,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input wire pipe_flush_req,\n    input wire ifu_halt_req,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire ifu_active,\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    output wire pipe_flush_ack,\n    output wire ifu_halt_ack\n);\n\n    // Internal signals for submodule connections\n    wire ifu_req_valid;\n    wire [E203_PC_SIZE-1:0] ifu_req_pc;\n    wire ifu_req_seq;\n    wire ifu_req_seq_rv32;\n    wire [E203_PC_SIZE-1:0] ifu_req_last_pc;\n    wire ifu_req_ready;\n    wire ifu_rsp_valid;\n    wire ifu_rsp_err;\n    wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr;\n\n    // Instantiate the IFU fetch module\n    e203_ifu_ifetch ifetch (\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ifu_o_ready(ifu_o_ready),\n        .pipe_flush_req(pipe_flush_req),\n        .pipe_flush_add_op1(pipe_flush_add_op1),\n        .pipe_flush_add_op2(pipe_flush_add_op2),\n        .ifu_halt_req(ifu_halt_req),\n        .oitf_empty(oitf_empty),\n        .rf2ifu_x1(rf2ifu_x1),\n        .rf2ifu_rs1(rf2ifu_rs1),\n        .dec2ifu_rden(dec2ifu_rden),\n        .dec2ifu_rs1en(dec2ifu_rs1en),\n        .dec2ifu_rdidx(dec2ifu_rdidx),\n        .dec2ifu_mulhsu(dec2ifu_mulhsu),\n        .dec2ifu_div(dec2ifu_div),\n        .dec2ifu_rem(dec2ifu_rem),\n        .dec2ifu_divu(dec2ifu_divu),\n        .dec2ifu_remu(dec2ifu_remu),\n        .inspect_pc(inspect_pc),\n        .ifu_req_valid(ifu_req_valid),\n        .ifu_req_pc(ifu_req_pc),\n        .ifu_req_seq(ifu_req_seq),\n        .ifu_req_seq_rv32(ifu_req_seq_rv32),\n        .ifu_req_last_pc(ifu_req_last_pc),\n        .pipe_flush_ack(pipe_flush_ack),\n        .ifu_halt_ack(ifu_halt_ack),\n        .ifu_o_ir(ifu_o_ir),\n        .ifu_o_pc(ifu_o_pc),\n        .ifu_o_pc_vld(ifu_o_pc_vld),\n        .ifu_o_misalgn(ifu_o_misalgn),\n        .ifu_o_buserr(ifu_o_buserr),\n        .ifu_o_rs1idx(ifu_o_rs1idx),\n        .ifu_o_rs2idx(ifu_o_rs2idx),\n        .ifu_o_prdt_taken(ifu_o_prdt_taken),\n        .ifu_o_muldiv_b2b(ifu_o_muldiv_b2b),\n        .ifu_o_valid(ifu_o_valid)\n    );\n\n    // Instantiate the IFT2ICB interface converter\n    e203_ifu_ift2icb ift2icb (\n        .clk(clk),\n        .rst_n(rst_n),\n        .ifu_req_valid(ifu_req_valid),\n        .ifu_req_pc(ifu_req_pc),\n        .ifu_req_seq(ifu_req_seq),\n        .ifu_req_seq_rv32(ifu_req_seq_rv32),\n        .ifu_req_last_pc(ifu_req_last_pc),\n        .ifu_req_ready(ifu_req_ready),\n        .ifu_rsp_valid(ifu_rsp_valid),\n        .ifu_rsp_err(ifu_rsp_err),\n        .ifu_rsp_instr(ifu_rsp_instr),\n        .itcm_nohold(itcm_nohold)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 16, "code": "`include \"e203_defines.v\"\n\nmodule e203_itcm_ram #(\n  parameter FORCE_X2ZERO = 0,\n  parameter DP = `E203_ITCM_RAM_DP,\n  parameter DW = `E203_ITCM_RAM_DW,\n  parameter MW = `E203_ITCM_RAM_MW,\n  parameter AW = `E203_ITCM_RAM_AW\n)(\n  input wire sd,\n  input wire ds,\n  input wire ls,\n  input wire cs,\n  input wire we,\n  input wire [AW-1:0] addr,\n  input wire [MW-1:0] wem,\n  input wire [DW-1:0] din,\n  input wire rst_n,\n  input wire clk,\n  output wire [DW-1:0] dout\n);\n\n  sirv_gnrl_ram #(\n    .FORCE_X2ZERO(FORCE_X2ZERO),\n    .DP(DP),\n    .DW(DW),\n    .MW(MW),\n    .AW(AW)\n  ) u_sirv_gnrl_ram (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 5, "code": "module e203_exu_alu(\n    input wire clk,\n    input wire rst_n,\n    input wire i_valid,\n    output wire i_ready,\n    input wire [E203_XLEN-1:0] i_rs1,\n    input wire [E203_XLEN-1:0] i_rs2,\n    input wire [E203_XLEN-1:0] i_imm,\n    input wire [E203_DECINFO_WIDTH-1:0] i_info,\n    input wire [E203_PC_SIZE-1:0] i_pc,\n    input wire [E203_INSTR_SIZE-1:0] i_instr,\n    input wire i_pc_vld,\n    input wire [E203_RFIDX_WIDTH-1:0] i_rdidx,\n    input wire i_rdwen,\n    input wire i_ilegl,\n    input wire i_buserr,\n    input wire i_misalgn,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire cmt_o_valid,\n    input wire cmt_o_ready,\n    output wire [E203_PC_SIZE-1:0] cmt_o_pc,\n    output wire [E203_INSTR_SIZE-1:0] cmt_o_instr,\n    output wire [E203_XLEN-1:0] cmt_o_imm,\n    output wire cmt_o_rv32,\n    output wire cmt_o_bjp,\n    output wire cmt_o_mret,\n    output wire cmt_o_dret,\n    output wire cmt_o_ecall,\n    output wire cmt_o_ebreak,\n    output wire cmt_o_fencei,\n    output wire cmt_o_wfi,\n    output wire cmt_o_ifu_misalgn,\n    output wire cmt_o_ifu_buserr,\n    output wire cmt_o_ifu_ilegl,\n    output wire cmt_o_bjp_prdt,\n    output wire cmt_o_bjp_rslv,\n    output wire cmt_o_misalgn,\n    output wire cmt_o_ld,\n    output wire cmt_o_stamo,\n    output wire cmt_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] cmt_o_badaddr,\n    output wire wbck_o_valid,\n    input wire wbck_o_ready,\n    output wire [E203_XLEN-1:0] wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] wbck_o_rdidx,\n    input wire mdv_nob2b,\n    output wire csr_ena,\n    output wire csr_wr_en,\n    output wire csr_rd_en,\n    output wire [11:0] csr_idx,\n    input wire nonflush_cmt_ena,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output wire [E203_XLEN-1:0] wbck_csr_dat,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_usign,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_longp_wbck_valid,\n    input wire nice_longp_wbck_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire i_nice_cmt_off_ilgl\n);\n    // ALU core logic implementation here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 5, "code": "module e203_exu_decode (\n    input [E203_INSTR_SIZE-1:0] i_instr,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_prdt_taken,\n    input i_misalgn,\n    input i_buserr,\n    input i_muldiv_b2b,\n    input dbg_mode,\n    output dec_rs1x0,\n    output dec_rs2x0,\n    output dec_rs1en,\n    output dec_rs2en,\n    output dec_rdwen,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rdidx,\n    output [E203_DECINFO_WIDTH-1:0] dec_info,\n    output [E203_XLEN-1:0] dec_imm,\n    output [E203_PC_SIZE-1:0] dec_pc,\n    output dec_misalgn,\n    output dec_buserr,\n    output dec_ilegl,\n    output dec_mulhsu,\n    output dec_mul,\n    output dec_div,\n    output dec_rem,\n    output dec_divu,\n    output dec_remu,\n    output dec_rv32,\n    output dec_bjp,\n    output dec_jal,\n    output dec_jalr,\n    output dec_bxx,\n    output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    output [E203_XLEN-1:0] dec_bjp_imm,\n    `ifdef E203_HAS_NICE\n    input nice_xs_off,\n    output dec_nice,\n    output nice_cmt_off_ilgl_o,\n    `endif\n);\n\n    // Decode logic here\n    // This is just a template and does not contain the actual decoding logic\n    // The actual implementation would involve parsing `i_instr` according to the RISC-V encoding schemes\n\n    assign dec_rs1x0 = (dec_rs1idx == 0);\n    assign dec_rs2x0 = (dec_rs2idx == 0);\n    assign dec_rs1en = 1'b0; // Example: set based on opcode and funct3\n    assign dec_rs2en = 1'b0; // Example: set based on opcode and funct3\n    assign dec_rdwen = 1'b0; // Example: set based on opcode\n    assign dec_rs1idx = i_instr[19:15];\n    assign dec_rs2idx = i_instr[24:20];\n    assign dec_rdidx = i_instr[11:7];\n    assign dec_info = {E203_DECINFO_WIDTH{1'b0}}; // Placeholder for actual decode information\n    assign dec_imm = 32'b0; // Placeholder for immediate extraction logic\n    assign dec_pc = i_pc;\n    assign dec_misalgn = i_misalgn;\n    assign dec_buserr = i_buserr;\n    assign dec_ilegl = 1'b0; // Placeholder for illegal instruction detection\n    assign dec_mulhsu = 1'b0; // Example: set based on opcode and funct3/funct7\n    assign dec_mul = 1'b0; // Example: set based on opcode and funct3/funct7\n    assign dec_div = 1'b0; // Example: set based on opcode and funct3/funct7\n    assign dec_rem = 1'b0; // Example: set based on opcode and funct3/funct7\n    assign dec_divu = 1'b0; // Example: set based on opcode and funct3/funct7\n    assign dec_remu = 1'b0; // Example: set based on opcode and funct3/funct7\n    assign dec_rv32 = 1'b1; // Example: set based on instruction length\n    assign dec_bjp = 1'b0; // Example: set based on opcode\n    assign dec_jal = 1'b0; // Example: set based on opcode\n    assign dec_jalr = 1'b0; // Example: set based on opcode\n    assign dec_bxx = 1'b0; // Example: set based on opcode\n    assign dec_jalr_rs1idx = i_instr[19:15];\n    assign dec_bjp_imm = 32'b0; // Placeholder for branch/jump immediate extraction logic\n\n    `ifdef E203_HAS_NICE\n    assign dec_nice = 1'b0; // Example: set based on custom opcode\n    assign nice_cmt_off_ilgl_o = nice_xs_off & dec_nice;\n    `endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 10, "code": "module e203_exu_disp (\n    input wire wfi_halt_exu_req,\n    output wire wfi_halt_exu_ack,\n    input wire oitf_empty,\n    input wire amo_wait,\n    input wire disp_i_valid,\n    output wire disp_i_ready,\n    input wire disp_i_rs1x0,\n    input wire disp_i_rs2x0,\n    input wire disp_i_rs1en,\n    input wire disp_i_rs2en,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input wire [E203_XLEN-1:0] disp_i_rs1,\n    input wire [E203_XLEN-1:0] disp_i_rs2,\n    input wire disp_i_rdwen,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input wire [E203_DECINFO_WIDTH-1:0] disp_i_info,\n    input wire [E203_XLEN-1:0] disp_i_imm,\n    input wire [E203_PC_SIZE-1:0] disp_i_pc,\n    input wire disp_i_misalgn,\n    input wire disp_i_buserr,\n    input wire disp_i_ilegl,\n    output wire disp_o_alu_valid,\n    input wire disp_o_alu_ready,\n    input wire disp_o_alu_longpipe,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs1,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs2,\n    output wire disp_o_alu_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_o_alu_rdidx,\n    output wire [E203_DECINFO_WIDTH-1:0] disp_o_alu_info,\n    output wire [E203_XLEN-1:0] disp_o_alu_imm,\n    output wire [E203_PC_SIZE-1:0] disp_o_alu_pc,\n    output wire [E203_ITAG_WIDTH-1:0] disp_o_alu_itag,\n    output wire disp_o_alu_misalgn,\n    output wire disp_o_alu_buserr,\n    output wire disp_o_alu_ilegl,\n    input wire oitfrd_match_disprs1,\n    input wire oitfrd_match_disprs2,\n    input wire oitfrd_match_disprs3,\n    input wire oitfrd_match_disprd,\n    input wire [E203_ITAG_WIDTH-1:0] disp_oitf_ptr,\n    output wire disp_oitf_ena,\n    input wire disp_oitf_ready,\n    output wire disp_oitf_rs1fpu,\n    output wire disp_oitf_rs2fpu,\n    output wire disp_oitf_rs3fpu,\n    output wire disp_oitf_rdfpu,\n    output wire disp_oitf_rs1en,\n    output wire disp_oitf_rs2en,\n    output wire disp_oitf_rs3en,\n    output wire disp_oitf_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs2idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs3idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rdidx,\n    output wire [E203_PC_SIZE-1:0] disp_oitf_pc,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Implementation of the dispatch logic, dependency checks, and WFI handling\n    // This is a placeholder for the actual logic which would be implemented here.\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 18, "code": "module e203_exu_alu_muldiv(\n    input mdv_nob2b,\n    input muldiv_i_valid,\n    output muldiv_i_ready,\n    input [E203_XLEN-1:0] muldiv_i_rs1,\n    input [E203_XLEN-1:0] muldiv_i_rs2,\n    input [E203_XLEN-1:0] muldiv_i_imm,\n    input [E203_DECINFO_MULDIV_WIDTH-1:0] muldiv_i_info,\n    input [E203_ITAG_WIDTH-1:0] muldiv_i_itag,\n    output muldiv_i_longpipe,\n    input flush_pulse,\n    output muldiv_o_valid,\n    input muldiv_o_ready,\n    output [E203_XLEN-1:0] muldiv_o_wbck_wdat,\n    output muldiv_o_wbck_err,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    output muldiv_req_alu_add,\n    output muldiv_req_alu_sub,\n    input [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output muldiv_sbf_0_ena,\n    output [32:0] muldiv_sbf_0_nxt,\n    input [32:0] muldiv_sbf_0_r,\n    output muldiv_sbf_1_ena,\n    output [32:0] muldiv_sbf_1_nxt,\n    input [32:0] muldiv_sbf_1_r,\n    input clk,\n    input rst_n\n);\n\n// Internal signals and registers\nreg [4:0] state;\nreg [4:0] next_state;\nreg [E203_XLEN-1:0] operand1, operand2;\nreg [E203_XLEN*2-1:0] product;\nreg [E203_XLEN-1:0] quotient, remainder;\nreg [E203_XLEN-1:0] divisor, dividend;\nreg muldiv_i_ready_reg, muldiv_o_valid_reg;\nreg [E203_XLEN-1:0] result;\nwire mul, div, rem;\nwire start_mul, start_div;\nwire mul_done, div_done, rem_done;\n\n// Decode operation type from muldiv_i_info\nassign mul = muldiv_i_info[0];\nassign div = muldiv_i_info[1];\nassign rem = muldiv_i_info[2];\n\n// FSM for controlling the multiplier and divider\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        state <= MULDIV_STATE_0TH;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// State transitions and operations\nalways @(*) begin\n    case (state)\n        MULDIV_STATE_0TH: begin\n            if (muldiv_i_valid && mul) begin\n                next_state = MULDIV_STATE_EXEC;\n            end else if (muldiv_i_valid && (div || rem)) begin\n                next_state = MULDIV_STATE_EXEC;\n            end else begin\n                next_state = MULDIV_STATE_0TH;\n            end\n        end\n        MULDIV_STATE_EXEC: begin\n            if (mul_done || div_done || rem_done) begin\n                next_state = MULDIV_STATE_0TH;\n            end else begin\n                next_state = MULDIV_STATE_EXEC;\n            end\n        end\n        default: begin\n            next_state = MULDIV_STATE_0TH;\n        end\n    endcase\nend\n\n// Execution of multiplication, division, and remainder\nalways @(posedge clk) begin\n    if (state == MULDIV_STATE_EXEC) begin\n        if (mul) begin\n            product <= operand1 * operand2;\n        end\n        if (div || rem) begin\n            quotient <= dividend / divisor;\n            remainder <= dividend % divisor;\n        end\n    end\nend\n\n// Output result handling\nalways @(posedge clk) begin\n    if (state == MULDIV_STATE_0TH && next_state == MULDIV_STATE_EXEC) begin\n        muldiv_i_ready_reg <= 1'b1;\n    end else begin\n        muldiv_i_ready_reg <= 1'b0;\n    end\n\n    if (state == MULDIV_STATE_EXEC && (mul_done || div_done || rem_done)) begin\n        muldiv_o_valid_reg <= 1'b1;\n        result <= (mul ? product[E203_XLEN-1:0] : (div ? quotient : remainder));\n    end else begin\n        muldiv_o_valid_reg <= 1'b0;\n    end\nend\n\nassign muldiv_i_ready = muldiv_i_ready_reg;\nassign muldiv_o_valid = muldiv_o_valid_reg;\nassign muldiv_o_wbck_wdat = result;\nassign muldiv_o_wbck_err = 1'b0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 4, "code": "module itcm_controller (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n    input wire [ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_cmd_valid,\n    input wire ifu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] ifu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] ifu2itcm_icb_cmd_wmask,\n    input wire ifu2itcm_icb_rsp_ready,\n    output wire ifu2itcm_icb_cmd_ready,\n    output wire ifu2itcm_icb_rsp_valid,\n    output wire ifu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    output wire itcm_active,\n    output wire itcm_ram_cs,\n    output wire itcm_ram_we,\n    output wire [RAM_AW-1:0] itcm_ram_addr,\n    output wire [RAM_MW-1:0] itcm_ram_wem,\n    output wire [RAM_DW-1:0] itcm_ram_din,\n    input wire [RAM_DW-1:0] itcm_ram_dout,\n    output wire clk_itcm_ram\n);\n\n    // Internal signals\n    reg [ADDR_WIDTH-1:0] cmd_addr_reg;\n    reg cmd_valid_reg, cmd_read_reg;\n    reg [DATA_WIDTH-1:0] cmd_wdata_reg;\n    reg [WMSK_WIDTH-1:0] cmd_wmask_reg;\n    reg rsp_ready_reg;\n    wire cmd_ready_int;\n    wire rsp_valid_int, rsp_err_int;\n    wire [DATA_WIDTH-1:0] rsp_rdata_int;\n\n    // Command register logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cmd_valid_reg <= 1'b0;\n        end else if (cmd_ready_int) begin\n            cmd_valid_reg <= ifu2itcm_icb_cmd_valid;\n            cmd_addr_reg <= ifu2itcm_icb_cmd_addr;\n            cmd_read_reg <= ifu2itcm_icb_cmd_read;\n            cmd_wdata_reg <= ifu2itcm_icb_cmd_wdata;\n            cmd_wmask_reg <= ifu2itcm_icb_cmd_wmask;\n        end\n    end\n\n    // Response logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            rsp_ready_reg <= 1'b0;\n        end else begin\n            rsp_ready_reg <= ifu2itcm_icb_rsp_ready;\n        end\n    end\n\n    // ITCM RAM interface logic\n    assign itcm_ram_cs = cmd_valid_reg && cmd_ready_int;\n    assign itcm_ram_we = !cmd_read_reg;\n    assign itcm_ram_addr = cmd_addr_reg[RAM_AW-1:0]; // Assuming address is aligned\n    assign itcm_ram_wem = cmd_wmask_reg;\n    assign itcm_ram_din = cmd_wdata_reg;\n\n    // Output assignments\n    assign ifu2itcm_icb_cmd_ready = cmd_ready_int;\n    assign ifu2itcm_icb_rsp_valid = rsp_valid_int;\n    assign ifu2itcm_icb_rsp_err = rsp_err_int;\n    assign ifu2itcm_icb_rsp_rdata = rsp_rdata_int;\n    assign itcm_active = cmd_valid_reg || rsp_ready_reg;\n\n    // Clock gating logic\n    assign clk_itcm_ram = clk & ~tcm_cgstop;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 17, "code": "module e203_exu_alu_dpath(\n    input wire alu_req_alu,\n    input wire alu_req_alu_add,\n    input wire alu_req_alu_sub,\n    input wire alu_req_alu_xor,\n    input wire alu_req_alu_sll,\n    input wire alu_req_alu_srl,\n    input wire alu_req_alu_sra,\n    input wire alu_req_alu_or,\n    input wire alu_req_alu_and,\n    input wire [E203_XLEN-1:0] alu_req_alu_op1,\n    input wire [E203_XLEN-1:0] alu_req_alu_op2,\n    input wire bjp_req_alu,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    input wire agu_req_alu,\n    input wire [E203_XLEN-1:0] agu_req_alu_op1,\n    input wire [E203_XLEN-1:0] agu_req_alu_op2,\n    input wire muldiv_req_alu,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    input wire muldiv_req_alu_add,\n    input wire muldiv_req_alu_sub,\n    input wire muldiv_sbf_0_ena,\n    input wire [32:0] muldiv_sbf_0_nxt,\n    input wire muldiv_sbf_1_ena,\n    input wire [32:0] muldiv_sbf_1_nxt,\n    input wire clk,\n    input wire rst_n,\n    output reg [E203_XLEN-1:0] alu_req_alu_res,\n    output reg [E203_XLEN-1:0] bjp_req_alu_add_res,\n    output reg bjp_req_alu_cmp_res,\n    output reg [E203_XLEN-1:0] agu_req_alu_res,\n    output reg [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output reg [32:0] muldiv_sbf_0_r,\n    output reg [32:0] muldiv_sbf_1_r\n);\n\n    // ALU operation implementation\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            alu_req_alu_res <= 0;\n            bjp_req_alu_add_res <= 0;\n            bjp_req_alu_cmp_res <= 0;\n            agu_req_alu_res <= 0;\n            muldiv_req_alu_res <= 0;\n            muldiv_sbf_0_r <= 0;\n            muldiv_sbf_1_r <= 0;\n        end else begin\n            if (alu_req_alu) begin\n                case (1'b1)\n                    alu_req_alu_add: alu_req_alu_res <= alu_req_alu_op1 + alu_req_alu_op2;\n                    alu_req_alu_sub: alu_req_alu_res <= alu_req_alu_op1 - alu_req_alu_op2;\n                    alu_req_alu_xor: alu_req_alu_res <= alu_req_alu_op1 ^ alu_req_alu_op2;\n                    alu_req_alu_sll: alu_req_alu_res <= alu_req_alu_op1 << alu_req_alu_op2;\n                    alu_req_alu_srl: alu_req_alu_res <= alu_req_alu_op1 >> alu_req_alu_op2;\n                    alu_req_alu_sra: alu_req_alu_res <= $signed(alu_req_alu_op1) >>> alu_req_alu_op2;\n                    alu_req_alu_or: alu_req_alu_res <= alu_req_alu_op1 | alu_req_alu_op2;\n                    alu_req_alu_and: alu_req_alu_res <= alu_req_alu_op1 & alu_req_alu_op2;\n                endcase\n            end\n\n            if (bjp_req_alu) begin\n                bjp_req_alu_add_res <= bjp_req_alu_op1 + bjp_req_alu_op2;\n                bjp_req_alu_cmp_res <= (bjp_req_alu_op1 == bjp_req_alu_op2);\n            end\n\n            if (agu_req_alu) begin\n                agu_req_alu_res <= agu_req_alu_op1 + agu_req_alu_op2; // Example for AGU\n            end\n\n            if (muldiv_req_alu) begin\n                case (1'b1)\n                    muldiv_req_alu_add: muldiv_req_alu_res <= muldiv_req_alu_op1 + muldiv_req_alu_op2;\n                    muldiv_req_alu_sub: muldiv_req_alu_res <= muldiv_req_alu_op1 - muldiv_req_alu_op2;\n                endcase\n            end\n\n            if (muldiv_sbf_0_ena) begin\n                muldiv_sbf_0_r <= muldiv_sbf_0_nxt;\n            end\n\n            if (muldiv_sbf_1_ena) begin\n                muldiv_sbf_1_r <= muldiv_sbf_1_nxt;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 6, "code": "module e203_exu_decode (\n    input [E203_INSTR_SIZE-1:0] i_instr,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_prdt_taken,\n    input i_misalgn,\n    input i_buserr,\n    input i_muldiv_b2b,\n    input dbg_mode,\n    output dec_rs1x0,\n    output dec_rs2x0,\n    output dec_rs1en,\n    output dec_rs2en,\n    output dec_rdwen,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rdidx,\n    output [E203_DECINFO_WIDTH-1:0] dec_info,\n    output [E203_XLEN-1:0] dec_imm,\n    output [E203_PC_SIZE-1:0] dec_pc,\n    output dec_misalgn,\n    output dec_buserr,\n    output dec_ilegl,\n    output dec_mulhsu,\n    output dec_mul,\n    output dec_div,\n    output dec_rem,\n    output dec_divu,\n    output dec_remu,\n    output dec_rv32,\n    output dec_bjp,\n    output dec_jal,\n    output dec_jalr,\n    output dec_bxx,\n    output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    output [E203_XLEN-1:0] dec_bjp_imm,\n    input nice_xs_off,\n    output dec_nice,\n    output nice_cmt_off_ilgl_o\n);\n\n    // Decode logic here\n    // This is a placeholder for the actual decoding logic which would be quite complex\n    // and involve parsing the instruction fields to set the outputs accordingly.\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 15, "code": "module e203_ifu_minidec #(\n  parameter E203_INSTR_SIZE = 32,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_XLEN = 32\n)(\n  input [E203_INSTR_SIZE-1:0] instr,\n  output reg dec_rs1en,\n  output reg dec_rs2en,\n  output reg [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n  output reg [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n  output reg dec_mulhsu,\n  output reg dec_mul,\n  output reg dec_div,\n  output reg dec_rem,\n  output reg dec_divu,\n  output reg dec_remu,\n  output reg dec_rv32,\n  output reg dec_bjp,\n  output reg dec_jal,\n  output reg dec_jalr,\n  output reg dec_bxx,\n  output reg [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  output reg [E203_XLEN-1:0] dec_bjp_imm\n);\n\n  // Internal signals for decoding\n  wire [6:0] opcode = instr[6:0];\n  wire [2:0] funct3 = instr[14:12];\n  wire [6:0] funct7 = instr[31:25];\n\n  always @(*) begin\n    // Default assignments\n    dec_rs1en = 1'b0;\n    dec_rs2en = 1'b0;\n    dec_rs1idx = instr[19:15];\n    dec_rs2idx = instr[24:20];\n    dec_mulhsu = 1'b0;\n    dec_mul = 1'b0;\n    dec_div = 1'b0;\n    dec_rem = 1'b0;\n    dec_divu = 1'b0;\n    dec_remu = 1'b0;\n    dec_rv32 = 1'b1; // Assuming RV32\n    dec_bjp = 1'b0;\n    dec_jal = 1'b0;\n    dec_jalr = 1'b0;\n    dec_bxx = 1'b0;\n    dec_jalr_rs1idx = instr[19:15];\n    dec_bjp_imm = {E203_XLEN{1'b0}};\n\n    case (opcode)\n      7'b0110011: begin // R-type\n        dec_rs1en = 1'b1;\n        dec_rs2en = 1'b1;\n        case (funct3)\n          3'b000: begin\n            if (funct7 == 7'b0000001) begin\n              dec_mul = 1'b1; // MUL\n            end\n          end\n          3'b001: begin\n            if (funct7 == 7'b0000001) begin\n              dec_mulhsu = 1'b1; // MULHSU\n            end\n          end\n        endcase\n      end\n      7'b1101111: begin // JAL\n        dec_jal = 1'b1;\n        dec_bjp = 1'b1;\n        dec_bjp_imm = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0};\n      end\n      7'b1100111: begin // JALR\n        dec_jalr = 1'b1;\n        dec_bjp = 1'b1;\n        dec_bjp_imm = {{20{instr[31]}}, instr[31:20]};\n      end\n      7'b1100011: begin // B-type\n        dec_bxx = 1'b1;\n        dec_bjp = 1'b1;\n        dec_bjp_imm = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};\n      end\n    endcase\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 19, "code": "module e203_exu_branchslv(\n    input wire cmt_i_valid,\n    output wire cmt_i_ready,\n    input wire cmt_i_rv32,\n    input wire cmt_i_dret,\n    input wire cmt_i_mret,\n    input wire cmt_i_fencei,\n    input wire cmt_i_bjp,\n    input wire cmt_i_bjp_prdt,\n    input wire cmt_i_bjp_rslv,\n    input wire [E203_PC_SIZE-1:0] cmt_i_pc,\n    input wire [E203_XLEN-1:0] cmt_i_imm,\n    input wire [E203_PC_SIZE-1:0] csr_epc_r,\n    input wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    input wire nonalu_excpirq_flush_req_raw,\n    input wire brchmis_flush_ack,\n    output wire brchmis_flush_req,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op1,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op2,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_pc,\n    output wire cmt_mret_ena,\n    output wire cmt_dret_ena,\n    output wire cmt_fencei_ena,\n    input wire clk,\n    input wire rst_n\n);\n\n    wire flush_need;\n    wire flush_target_mret;\n    wire flush_target_dret;\n    wire flush_target_fencei;\n    wire flush_target_bjp;\n\n    assign flush_need = (cmt_i_bjp & (cmt_i_bjp_prdt ^ cmt_i_bjp_rslv)) | cmt_i_fencei | cmt_i_mret | cmt_i_dret;\n    assign flush_target_mret = cmt_i_mret;\n    assign flush_target_dret = cmt_i_dret;\n    assign flush_target_fencei = cmt_i_fencei;\n    assign flush_target_bjp = cmt_i_bjp & (cmt_i_bjp_prdt ^ cmt_i_bjp_rslv);\n\n    assign brchmis_flush_req = flush_need & cmt_i_valid & ~nonalu_excpirq_flush_req_raw;\n    assign cmt_mret_ena = cmt_i_mret;\n    assign cmt_dret_ena = cmt_i_dret;\n    assign cmt_fencei_ena = cmt_i_fencei;\n\n    assign cmt_i_ready = ~flush_need & ~nonalu_excpirq_flush_req_raw | (flush_need & brchmis_flush_ack);\n\n    // Calculate flush target address\n    wire [E203_PC_SIZE-1:0] next_pc = cmt_i_rv32 ? (cmt_i_pc + 32'd4) : (cmt_i_pc + 32'd2);\n    wire [E203_PC_SIZE-1:0] branch_target = cmt_i_pc + cmt_i_imm;\n\n    assign brchmis_flush_add_op1 = cmt_i_pc;\n    assign brchmis_flush_add_op2 = cmt_i_imm;\n\n    // Select the correct flush target\n    assign brchmis_flush_pc = flush_target_dret ? csr_dpc_r :\n                              flush_target_mret ? csr_epc_r :\n                              flush_target_fencei ? next_pc :\n                              flush_target_bjp ? branch_target : csr_epc_r;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 5, "code": "module itcm_controller #(\n    parameter ADDR_WIDTH = 32,\n    parameter DATA_WIDTH = 64,\n    parameter WMSK_WIDTH = DATA_WIDTH / 8,\n    parameter RAM_AW = 10,\n    parameter RAM_MW = WMSK_WIDTH,\n    parameter RAM_DW = DATA_WIDTH\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n\n    // IFU Interface\n    input wire ifu2itcm_icb_cmd_valid,\n    output wire ifu2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] ifu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] ifu2itcm_icb_cmd_wmask,\n    output wire ifu2itcm_icb_rsp_valid,\n    input wire ifu2itcm_icb_rsp_ready,\n    output wire ifu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n\n    // LSU Interface\n    input wire lsu2itcm_icb_cmd_valid,\n    output wire lsu2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] lsu2itcm_icb_cmd_addr,\n    input wire lsu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] lsu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] lsu2itcm_icb_cmd_wmask,\n    output wire lsu2itcm_icb_rsp_valid,\n    input wire lsu2itcm_icb_rsp_ready,\n    output wire lsu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] lsu2itcm_icb_rsp_rdata,\n\n    // External Interface (optional)\n    `ifdef E203_HAS_ITCM_EXTITF\n    input wire ext2itcm_icb_cmd_valid,\n    output wire ext2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input wire ext2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] ext2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] ext2itcm_icb_cmd_wmask,\n    output wire ext2itcm_icb_rsp_valid,\n    input wire ext2itcm_icb_rsp_ready,\n    output wire ext2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] ext2itcm_icb_rsp_rdata,\n    `endif\n\n    // RAM Interface\n    output wire itcm_ram_cs,\n    output wire itcm_ram_we,\n    output wire [RAM_AW-1:0] itcm_ram_addr,\n    output wire [RAM_MW-1:0] itcm_ram_wem,\n    output wire [RAM_DW-1:0] itcm_ram_din,\n    input wire [RAM_DW-1:0] itcm_ram_dout,\n    output wire clk_itcm_ram,\n\n    output wire itcm_active\n);\n\n    // Internal signals\n    wire [ADDR_WIDTH-1:0] selected_addr;\n    wire [DATA_WIDTH-1:0] selected_wdata;\n    wire [WMSK_WIDTH-1:0] selected_wmask;\n    wire selected_read;\n    wire selected_valid;\n    wire selected_ready;\n    wire [DATA_WIDTH-1:0] selected_rdata;\n    wire selected_rsp_valid;\n    wire selected_rsp_ready;\n    wire selected_rsp_err;\n\n    // Arbitration logic (simplified example)\n    assign selected_addr = ifu2itcm_icb_cmd_valid ? ifu2itcm_icb_cmd_addr : lsu2itcm_icb_cmd_addr;\n    assign selected_wdata = ifu2itcm_icb_cmd_valid ? ifu2itcm_icb_cmd_wdata : lsu2itcm_icb_cmd_wdata;\n    assign selected_wmask = ifu2itcm_icb_cmd_valid ? ifu2itcm_icb_cmd_wmask : lsu2itcm_icb_cmd_wmask;\n    assign selected_read = ifu2itcm_icb_cmd_valid ? ifu2itcm_icb_cmd_read : lsu2itcm_icb_cmd_read;\n    assign selected_valid = ifu2itcm_icb_cmd_valid || lsu2itcm_icb_cmd_valid;\n    assign ifu2itcm_icb_cmd_ready = selected_ready && ifu2itcm_icb_cmd_valid;\n    assign lsu2itcm_icb_cmd_ready = selected_ready && lsu2itcm_icb_cmd_valid;\n\n    // RAM access logic\n    assign itcm_ram_cs = selected_valid && selected_ready;\n    assign itcm_ram_we = !selected_read;\n    assign itcm_ram_addr = selected_addr[RAM_AW-1:0];\n    assign itcm_ram_wem = selected_wmask;\n    assign itcm_ram_din = selected_wdata;\n\n    // Response logic\n    assign selected_rdata = itcm_ram_dout;\n    assign selected_rsp_valid = itcm_ram_cs && !selected_read;\n    assign selected_rsp_err = 0; // Simplified error handling\n\n    assign ifu2itcm_icb_rsp_valid = selected_rsp_valid && ifu2itcm_icb_cmd_valid;\n    assign lsu2itcm_icb_rsp_valid = selected_rsp_valid && lsu2itcm_icb_cmd_valid;\n    assign ifu2itcm_icb_rsp_rdata = selected_rdata;\n    assign lsu2itcm_icb_rsp_rdata = selected_rdata;\n    assign ifu2itcm_icb_rsp_err = selected_rsp_err;\n    assign lsu2itcm_icb_rsp_err = selected_rsp_err;\n\n    // Clock and active signal\n    assign clk_itcm_ram = clk;\n    assign itcm_active = selected_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 18, "code": "module e203_exu_alu_dpath(\n    input wire alu_req_alu,\n    input wire alu_req_alu_add,\n    input wire alu_req_alu_sub,\n    input wire alu_req_alu_xor,\n    input wire alu_req_alu_sll,\n    input wire alu_req_alu_srl,\n    input wire alu_req_alu_sra,\n    input wire alu_req_alu_or,\n    input wire alu_req_alu_and,\n    input wire [E203_XLEN-1:0] alu_req_alu_op1,\n    input wire [E203_XLEN-1:0] alu_req_alu_op2,\n    input wire bjp_req_alu,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    input wire agu_req_alu,\n    input wire [E203_XLEN-1:0] agu_req_alu_op1,\n    input wire [E203_XLEN-1:0] agu_req_alu_op2,\n    input wire muldiv_req_alu,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    input wire muldiv_req_alu_add,\n    input wire muldiv_req_alu_sub,\n    input wire muldiv_sbf_0_ena,\n    input wire [32:0] muldiv_sbf_0_nxt,\n    input wire muldiv_sbf_1_ena,\n    input wire [32:0] muldiv_sbf_1_nxt,\n    input wire clk,\n    input wire rst_n,\n    output wire [E203_XLEN-1:0] alu_req_alu_res,\n    output wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    output wire bjp_req_alu_cmp_res,\n    output wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output wire [32:0] muldiv_sbf_0_r,\n    output wire [32:0] muldiv_sbf_1_r\n);\n\n    // Internal signals for ALU operations\n    wire [E203_XLEN-1:0] add_res;\n    wire [E203_XLEN-1:0] sub_res;\n    wire [E203_XLEN-1:0] xor_res;\n    wire [E203_XLEN-1:0] sll_res;\n    wire [E203_XLEN-1:0] srl_res;\n    wire [E203_XLEN-1:0] sra_res;\n    wire [E203_XLEN-1:0] or_res;\n    wire [E203_XLEN-1:0] and_res;\n\n    // ALU operation implementations\n    assign add_res = alu_req_alu_op1 + alu_req_alu_op2;\n    assign sub_res = alu_req_alu_op1 - alu_req_alu_op2;\n    assign xor_res = alu_req_alu_op1 ^ alu_req_alu_op2;\n    assign sll_res = alu_req_alu_op1 << alu_req_alu_op2;\n    assign srl_res = alu_req_alu_op1 >> alu_req_alu_op2;\n    assign sra_res = $signed(alu_req_alu_op1) >>> alu_req_alu_op2;\n    assign or_res = alu_req_alu_op1 | alu_req_alu_op2;\n    assign and_res = alu_req_alu_op1 & alu_req_alu_op2;\n\n    // Result multiplexing based on operation request\n    assign alu_req_alu_res = ({E203_XLEN{alu_req_alu_add}} & add_res) |\n                             ({E203_XLEN{alu_req_alu_sub}} & sub_res) |\n                             ({E203_XLEN{alu_req_alu_xor}} & xor_res) |\n                             ({E203_XLEN{alu_req_alu_sll}} & sll_res) |\n                             ({E203_XLEN{alu_req_alu_srl}} & srl_res) |\n                             ({E203_XLEN{alu_req_alu_sra}} & sra_res) |\n                             ({E203_XLEN{alu_req_alu_or}} & or_res) |\n                             ({E203_XLEN{alu_req_alu_and}} & and_res);\n\n    // BJP, AGU, and MULDIV results handling\n    assign bjp_req_alu_add_res = bjp_req_alu_op1 + bjp_req_alu_op2;\n    assign bjp_req_alu_cmp_res = (bjp_req_alu_op1 == bjp_req_alu_op2);\n    assign agu_req_alu_res = agu_req_alu_op1 + agu_req_alu_op2; // Example for AGU add\n    assign muldiv_req_alu_res = (muldiv_req_alu_add ? muldiv_req_alu_op1 + muldiv_req_alu_op2 :\n                                muldiv_req_alu_sub ? muldiv_req_alu_op1 - muldiv_req_alu_op2 : 0);\n\n    // Shared buffer handling\n    sirv_gnrl_dffl #(.DW(33)) sbf_0_dffl (\n        .lden(muldiv_sbf_0_ena),\n        .dnxt(muldiv_sbf_0_nxt),\n        .qout(muldiv_sbf_0_r),\n        .clk(clk)\n    );\n\n    sirv_gnrl_dffl #(.DW(33)) sbf_1_dffl (\n        .lden(muldiv_sbf_1_ena),\n        .dnxt(muldiv_sbf_1_nxt),\n        .qout(muldiv_sbf_1_r),\n        .clk(clk)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 18, "code": "module e203_dtcm_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n    output wire dtcm_active,\n\n    // LSU ICB Interface\n    input wire lsu2dtcm_icb_cmd_valid,\n    output wire lsu2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] lsu2dtcm_icb_cmd_addr,\n    input wire lsu2dtcm_icb_cmd_read,\n    input wire [31:0] lsu2dtcm_icb_cmd_wdata,\n    input wire [3:0] lsu2dtcm_icb_cmd_wmask,\n    output wire lsu2dtcm_icb_rsp_valid,\n    input wire lsu2dtcm_icb_rsp_ready,\n    output wire lsu2dtcm_icb_rsp_err,\n    output wire [31:0] lsu2dtcm_icb_rsp_rdata,\n\n    // External ICB Interface (Optional)\n    `ifdef E203_HAS_DTCM_EXTITF\n    input wire ext2dtcm_icb_cmd_valid,\n    output wire ext2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] ext2dtcm_icb_cmd_addr,\n    input wire ext2dtcm_icb_cmd_read,\n    input wire [31:0] ext2dtcm_icb_cmd_wdata,\n    input wire [3:0] ext2dtcm_icb_cmd_wmask,\n    output wire ext2dtcm_icb_rsp_valid,\n    input wire ext2dtcm_icb_rsp_ready,\n    output wire ext2dtcm_icb_rsp_err,\n    output wire [31:0] ext2dtcm_icb_rsp_rdata,\n    `endif\n\n    // DTCM RAM Interface\n    output wire dtcm_ram_cs,\n    output wire dtcm_ram_we,\n    output wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    output wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    output wire clk_dtcm_ram\n);\n\n    // Internal signals\n    wire icb_cmd_valid;\n    wire icb_cmd_ready;\n    wire [E203_DTCM_ADDR_WIDTH-1:0] icb_cmd_addr;\n    wire icb_cmd_read;\n    wire [31:0] icb_cmd_wdata;\n    wire [3:0] icb_cmd_wmask;\n    wire icb_rsp_valid;\n    wire icb_rsp_ready;\n    wire icb_rsp_err;\n    wire [31:0] icb_rsp_rdata;\n\n    // Arbitration logic (simplified example)\n    assign icb_cmd_valid = lsu2dtcm_icb_cmd_valid; // Priority to LSU\n    assign lsu2dtcm_icb_cmd_ready = icb_cmd_ready;\n    assign icb_cmd_addr = lsu2dtcm_icb_cmd_addr;\n    assign icb_cmd_read = lsu2dtcm_icb_cmd_read;\n    assign icb_cmd_wdata = lsu2dtcm_icb_cmd_wdata;\n    assign icb_cmd_wmask = lsu2dtcm_icb_cmd_wmask;\n\n    assign lsu2dtcm_icb_rsp_valid = icb_rsp_valid;\n    assign icb_rsp_ready = lsu2dtcm_icb_rsp_ready;\n    assign lsu2dtcm_icb_rsp_err = icb_rsp_err;\n    assign lsu2dtcm_icb_rsp_rdata = icb_rsp_rdata;\n\n    // SRAM controller logic\n    assign dtcm_ram_cs = icb_cmd_valid && icb_cmd_ready;\n    assign dtcm_ram_we = !icb_cmd_read;\n    assign dtcm_ram_addr = icb_cmd_addr[E203_DTCM_RAM_AW-1:0];\n    assign dtcm_ram_wem = icb_cmd_read ? 4'b0000 : icb_cmd_wmask;\n    assign dtcm_ram_din = icb_cmd_wdata;\n    assign clk_dtcm_ram = clk;\n\n    // Read data handling\n    assign icb_rsp_valid = dtcm_ram_cs && !icb_cmd_read;\n    assign icb_rsp_rdata = dtcm_ram_dout;\n    assign icb_rsp_err = 1'b0; // Simplified error handling\n\n    // Activity indicator\n    assign dtcm_active = icb_cmd_valid || icb_rsp_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 10, "code": "module e203_lsu(\n    input wire commit_mret,\n    input wire commit_trap,\n    input wire excp_active,\n    output wire lsu_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n    output wire [ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_buserr,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [XLEN-1:0] agu_icb_rsp_rdata,\n\n    input wire nice_mem_holdup,\n    input wire itcm_region_indic,\n    input wire dtcm_region_indic\n);\n    // LSU logic implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 9, "code": "module e203_ifu(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire itcm_nohold,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input wire pipe_flush_req,\n    input wire ifu_halt_req,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire ifu_active,\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    output wire pipe_flush_ack,\n    output wire ifu_halt_ack\n);\n\n    // Internal signals\n    wire ifu_req_valid;\n    wire [E203_PC_SIZE-1:0] ifu_req_pc;\n    wire ifu_req_seq;\n    wire ifu_req_seq_rv32;\n    wire [E203_PC_SIZE-1:0] ifu_req_last_pc;\n    wire ifu_req_ready;\n    wire ifu_rsp_valid;\n    wire ifu_rsp_err;\n    wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr;\n\n    e203_ifu_ifetch ifetch (\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ifu_o_ready(ifu_o_ready),\n        .pipe_flush_req(pipe_flush_req),\n        .pipe_flush_add_op1(pipe_flush_add_op1),\n        .pipe_flush_add_op2(pipe_flush_add_op2),\n        .ifu_halt_req(ifu_halt_req),\n        .oitf_empty(oitf_empty),\n        .rf2ifu_x1(rf2ifu_x1),\n        .rf2ifu_rs1(rf2ifu_rs1),\n        .dec2ifu_rden(dec2ifu_rden),\n        .dec2ifu_rs1en(dec2ifu_rs1en),\n        .dec2ifu_rdidx(dec2ifu_rdidx),\n        .dec2ifu_mulhsu(dec2ifu_mulhsu),\n        .dec2ifu_div(dec2ifu_div),\n        .dec2ifu_rem(dec2ifu_rem),\n        .dec2ifu_divu(dec2ifu_divu),\n        .dec2ifu_remu(dec2ifu_remu),\n        .inspect_pc(inspect_pc),\n        .ifu_req_valid(ifu_req_valid),\n        .ifu_req_pc(ifu_req_pc),\n        .ifu_req_seq(ifu_req_seq),\n        .ifu_req_seq_rv32(ifu_req_seq_rv32),\n        .ifu_req_last_pc(ifu_req_last_pc),\n        .pipe_flush_ack(pipe_flush_ack),\n        .ifu_halt_ack(ifu_halt_ack),\n        .ifu_o_ir(ifu_o_ir),\n        .ifu_o_pc(ifu_o_pc),\n        .ifu_o_pc_vld(ifu_o_pc_vld),\n        .ifu_o_misalgn(ifu_o_misalgn),\n        .ifu_o_buserr(ifu_o_buserr),\n        .ifu_o_rs1idx(ifu_o_rs1idx),\n        .ifu_o_rs2idx(ifu_o_rs2idx),\n        .ifu_o_prdt_taken(ifu_o_prdt_taken),\n        .ifu_o_muldiv_b2b(ifu_o_muldiv_b2b),\n        .ifu_o_valid(ifu_o_valid)\n    );\n\n    e203_ifu_ift2icb ift2icb (\n        .clk(clk),\n        .rst_n(rst_n),\n        .ifu_req_valid(ifu_req_valid),\n        .ifu_req_pc(ifu_req_pc),\n        .ifu_req_seq(ifu_req_seq),\n        .ifu_req_seq_rv32(ifu_req_seq_rv32),\n        .ifu_req_last_pc(ifu_req_last_pc),\n        .ifu_rsp_ready(ifu_o_ready),\n        .itcm_nohold(itcm_nohold),\n        .ifu_req_ready(ifu_req_ready),\n        .ifu_rsp_valid(ifu_rsp_valid),\n        .ifu_rsp_err(ifu_rsp_err),\n        .ifu_rsp_instr(ifu_rsp_instr)\n    );\n\n    assign ifu_active = ifu_req_valid || ifu_rsp_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 9, "code": "module e203_ifu_litebpu #(\n  parameter E203_PC_SIZE = 32,\n  parameter E203_XLEN = 32,\n  parameter E203_RFIDX_WIDTH = 5\n)(\n  input clk,\n  input rst_n,\n  input [E203_PC_SIZE-1:0] pc,\n  input dec_jal,\n  input dec_jalr,\n  input dec_bxx,\n  input [E203_XLEN-1:0] dec_bjp_imm,\n  input [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  input oitf_empty,\n  input ir_empty,\n  input ir_rs1en,\n  input jalr_rs1idx_cam_irrdidx,\n  input dec_i_valid,\n  input ir_valid_clr,\n  input [E203_XLEN-1:0] rf2bpu_x1,\n  input [E203_XLEN-1:0] rf2bpu_rs1,\n  output reg prdt_taken,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op1,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op2,\n  output reg bpu_wait,\n  output reg bpu2rf_rs1_ena\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      prdt_taken <= 1'b0;\n      prdt_pc_add_op1 <= {E203_PC_SIZE{1'b0}};\n      prdt_pc_add_op2 <= {E203_PC_SIZE{1'b0}};\n      bpu_wait <= 1'b0;\n      bpu2rf_rs1_ena <= 1'b0;\n    end else begin\n      // Default assignments\n      prdt_taken <= 1'b0;\n      prdt_pc_add_op1 <= pc;\n      prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n      bpu_wait <= 1'b0;\n      bpu2rf_rs1_ena <= 1'b0;\n\n      // JAL always taken\n      if (dec_jal) begin\n        prdt_taken <= 1'b1;\n        prdt_pc_add_op1 <= pc;\n        prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n      end\n\n      // JALR always taken\n      if (dec_jalr) begin\n        prdt_taken <= 1'b1;\n        case (dec_jalr_rs1idx)\n          5'd0: prdt_pc_add_op1 <= {E203_PC_SIZE{1'b0}};\n          5'd1: begin\n            prdt_pc_add_op1 <= rf2bpu_x1;\n            if (!oitf_empty || jalr_rs1idx_cam_irrdidx) begin\n              bpu_wait <= 1'b1;\n            end\n          end\n          default: begin\n            prdt_pc_add_op1 <= rf2bpu_rs1;\n            if (!ir_empty && ir_rs1en) begin\n              bpu_wait <= 1'b1;\n            end\n          end\n        endcase\n        prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n      end\n\n      // Conditional branches\n      if (dec_bxx) begin\n        if (dec_bjp_imm[31]) begin // Negative offset implies backward jump\n          prdt_taken <= 1'b1;\n        end else begin\n          prdt_taken <= 1'b0;\n        end\n      end\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 16, "code": "module e203_exu_oitf #(\n  parameter E203_ITAG_WIDTH = 4,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_PC_SIZE = 32,\n  parameter E203_OITF_DEPTH = 16\n)(\n  input clk,\n  input rst_n,\n\n  // Dispatch interface\n  input dis_ena,\n  output reg dis_ready,\n  output reg [E203_ITAG_WIDTH-1:0] dis_ptr,\n\n  // Retirement interface\n  input ret_ena,\n  output reg [E203_ITAG_WIDTH-1:0] ret_ptr,\n  output reg [E203_RFIDX_WIDTH-1:0] ret_rdidx,\n  output reg ret_rdwen,\n  output reg ret_rdfpu,\n  output reg [E203_PC_SIZE-1:0] ret_pc,\n\n  // Dispatch instruction details\n  input [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n  input disp_i_rdwen,\n  input disp_i_rdfpu,\n  input [E203_PC_SIZE-1:0] disp_i_pc,\n\n  // Dependency checking outputs\n  output reg oitfrd_match_disprs1,\n  output reg oitfrd_match_disprs2,\n  output reg oitfrd_match_disprs3,\n  output reg oitfrd_match_disprd,\n  output reg oitf_empty\n);\n\n  // Internal OITF storage\n  reg [E203_RFIDX_WIDTH-1:0] rdidx [0:E203_OITF_DEPTH-1];\n  reg [E203_PC_SIZE-1:0] pc [0:E203_OITF_DEPTH-1];\n  reg rdwen [0:E203_OITF_DEPTH-1];\n  reg rdfpu [0:E203_OITF_DEPTH-1];\n  reg [E203_ITAG_WIDTH-1:0] head, tail;\n  reg full, empty;\n\n  // Initialize pointers and status flags\n  initial begin\n    head = 0;\n    tail = 0;\n    full = 0;\n    empty = 1;\n    dis_ready = 1;\n  end\n\n  // Handle dispatch of new instructions\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      head <= 0;\n      tail <= 0;\n      full <= 0;\n      empty <= 1;\n      dis_ready <= 1;\n    end else begin\n      if (dis_ena && dis_ready) begin\n        rdidx[tail] <= disp_i_rdidx;\n        pc[tail] <= disp_i_pc;\n        rdwen[tail] <= disp_i_rdwen;\n        rdfpu[tail] <= disp_i_rdfpu;\n        tail <= tail + 1;\n        empty <= 0;\n        if (tail + 1 == head) begin\n          full <= 1;\n          dis_ready <= 0;\n        end\n      end\n      if (ret_ena) begin\n        ret_rdidx <= rdidx[head];\n        ret_pc <= pc[head];\n        ret_rdwen <= rdwen[head];\n        ret_rdfpu <= rdfpu[head];\n        head <= head + 1;\n        full <= 0;\n        if (head + 1 == tail) begin\n          empty <= 1;\n          dis_ready <= 1;\n        end\n      end\n    end\n  end\n\n  // Dependency checking logic\n  integer i;\n  always @(*) begin\n    oitfrd_match_disprs1 = 0;\n    oitfrd_match_disprs2 = 0;\n    oitfrd_match_disprs3 = 0;\n    oitfrd_match_disprd = 0;\n    for (i = head; i != tail; i = i + 1) begin\n      if (rdwen[i] && (rdidx[i] == disp_i_rdidx)) begin\n        oitfrd_match_disprd = 1;\n      end\n    end\n  end\n\n  // Update output signals\n  always @(posedge clk) begin\n    dis_ptr <= tail;\n    ret_ptr <= head;\n    oitf_empty <= empty;\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 17, "code": "module e203_exu_oitf #(\n  parameter E203_ITAG_WIDTH = 4,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_PC_SIZE = 32,\n  parameter E203_OITF_DEPTH = 16\n)(\n  input  wire                     clk,\n  input  wire                     rst_n,\n\n  output wire                     dis_ready,\n  input  wire                     dis_ena,\n  input  wire                     ret_ena,\n\n  output wire [E203_ITAG_WIDTH-1:0] dis_ptr,\n  output wire [E203_ITAG_WIDTH-1:0] ret_ptr,\n  output wire [E203_RFIDX_WIDTH-1:0] ret_rdidx,\n  output wire                     ret_rdwen,\n  output wire                     ret_rdfpu,\n  output wire [E203_PC_SIZE-1:0]  ret_pc,\n\n  input  wire                     disp_i_rs1en,\n  input  wire                     disp_i_rs2en,\n  input  wire                     disp_i_rs3en,\n  input  wire                     disp_i_rdwen,\n  input  wire                     disp_i_rs1fpu,\n  input  wire                     disp_i_rs2fpu,\n  input  wire                     disp_i_rs3fpu,\n  input  wire                     disp_i_rdfpu,\n  input  wire [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n  input  wire [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n  input  wire [E203_RFIDX_WIDTH-1:0] disp_i_rs3idx,\n  input  wire [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n  input  wire [E203_PC_SIZE-1:0]  disp_i_pc,\n\n  output wire                     oitfrd_match_disprs1,\n  output wire                     oitfrd_match_disprs2,\n  output wire                     oitfrd_match_disprs3,\n  output wire                     oitfrd_match_disprd,\n  output wire                     oitf_empty\n);\n\n  reg [E203_RFIDX_WIDTH-1:0] rdidx [0:E203_OITF_DEPTH-1];\n  reg [E203_PC_SIZE-1:0]     pc [0:E203_OITF_DEPTH-1];\n  reg                        rdwen [0:E203_OITF_DEPTH-1];\n  reg                        rdfpu [0:E203_OITF_DEPTH-1];\n  reg [E203_ITAG_WIDTH-1:0]  head, tail;\n  reg                        full, empty;\n\n  wire ptr_wrap = (head == tail) && (full != empty);\n  assign dis_ready = !full;\n  assign oitf_empty = empty;\n\n  integer i;\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      head <= 0;\n      tail <= 0;\n      full <= 0;\n      empty <= 1;\n      for (i = 0; i < E203_OITF_DEPTH; i = i + 1) begin\n        rdidx[i] <= 0;\n        pc[i] <= 0;\n        rdwen[i] <= 0;\n        rdfpu[i] <= 0;\n      end\n    end else begin\n      if (dis_ena && dis_ready) begin\n        rdidx[head] <= disp_i_rdidx;\n        pc[head] <= disp_i_pc;\n        rdwen[head] <= disp_i_rdwen;\n        rdfpu[head] <= disp_i_rdfpu;\n        head <= head + 1;\n        empty <= 0;\n        if (ptr_wrap) full <= 1;\n      end\n      if (ret_ena && !empty) begin\n        tail <= tail + 1;\n        full <= 0;\n        if (ptr_wrap) empty <= 1;\n      end\n    end\n  end\n\n  assign dis_ptr = head;\n  assign ret_ptr = tail;\n  assign ret_rdidx = rdidx[tail];\n  assign ret_rdwen = rdwen[tail];\n  assign ret_rdfpu = rdfpu[tail];\n  assign ret_pc = pc[tail];\n\n  wire match_rs1 = disp_i_rs1en && (disp_i_rs1idx == rdidx[head]) && rdwen[head];\n  wire match_rs2 = disp_i_rs2en && (disp_i_rs2idx == rdidx[head]) && rdwen[head];\n  wire match_rs3 = disp_i_rs3en && (disp_i_rs3idx == rdidx[head]) && rdwen[head];\n  wire match_rd = disp_i_rdwen && (disp_i_rdidx == rdidx[head]) && rdwen[head];\n\n  assign oitfrd_match_disprs1 = match_rs1;\n  assign oitfrd_match_disprs2 = match_rs2;\n  assign oitfrd_match_disprs3 = match_rs3;\n  assign oitfrd_match_disprd = match_rd;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 18, "code": "module e203_srams #(\n  parameter E203_HAS_ITCM = 1,\n  parameter E203_HAS_DTCM = 1,\n  parameter E203_ITCM_RAM_AW = 12,\n  parameter E203_ITCM_RAM_DW = 32,\n  parameter E203_ITCM_RAM_MW = 4,\n  parameter E203_DTCM_RAM_AW = 12,\n  parameter E203_DTCM_RAM_DW = 32,\n  parameter E203_DTCM_RAM_MW = 4\n)(\n  input  wire                     clk,\n  input  wire                     rst_n,\n\n  // ITCM Interface\n  input  wire                     itcm_ram_cs,\n  input  wire                     itcm_ram_we,\n  input  wire [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n  input  wire [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n  input  wire [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n  output wire [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n\n  // DTCM Interface\n  input  wire                     dtcm_ram_cs,\n  input  wire                     dtcm_ram_we,\n  input  wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n  input  wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n  input  wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n  output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout\n);\n\n  // ITCM RAM instantiation\n  generate\n    if (E203_HAS_ITCM) begin : gen_itcm_ram\n      ram #(\n        .AW(E203_ITCM_RAM_AW),\n        .DW(E203_ITCM_RAM_DW),\n        .MW(E203_ITCM_RAM_MW)\n      ) itcm_ram (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cs(itcm_ram_cs),\n        .we(itcm_ram_we),\n        .addr(itcm_ram_addr),\n        .wem(itcm_ram_wem),\n        .din(itcm_ram_din),\n        .dout(itcm_ram_dout)\n      );\n    end\n  endgenerate\n\n  // DTCM RAM instantiation\n  generate\n    if (E203_HAS_DTCM) begin : gen_dtcm_ram\n      ram #(\n        .AW(E203_DTCM_RAM_AW),\n        .DW(E203_DTCM_RAM_DW),\n        .MW(E203_DTCM_RAM_MW)\n      ) dtcm_ram (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cs(dtcm_ram_cs),\n        .we(dtcm_ram_we),\n        .addr(dtcm_ram_addr),\n        .wem(dtcm_ram_wem),\n        .din(dtcm_ram_din),\n        .dout(dtcm_ram_dout)\n      );\n    end\n  endgenerate\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 4, "code": "module e203_ifu_ifetch(\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_valid,\n    input wire ifu_req_ready,\n    output wire [E203_PC_SIZE-1:0] ifu_req_pc,\n    output wire ifu_req_seq,\n    output wire ifu_req_seq_rv32,\n    output wire [E203_PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_valid,\n    output wire ifu_rsp_ready,\n    input wire ifu_rsp_err,\n    input wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr,\n    input wire pipe_flush_req,\n    output wire pipe_flush_ack,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    `ifdef E203_TIMING_BOOST\n    input wire [E203_PC_SIZE-1:0] pipe_flush_pc,\n    `endif\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    input wire ifu_halt_req,\n    output wire ifu_halt_ack,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu\n);\n    // Implementation of the e203_ifu_ifetch module goes here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 11, "code": "module e203_exu_csr (\n    input nonflush_cmt_ena,\n    input csr_ena,\n    input csr_wr_en,\n    input csr_rd_en,\n    input [11:0] csr_idx,\n    output csr_access_ilgl,\n    output tm_stop,\n    output core_cgstop,\n    output tcm_cgstop,\n    output itcm_nohold,\n    output mdv_nob2b,\n    output [E203_XLEN-1:0] read_csr_dat,\n    input [E203_XLEN-1:0] wbck_csr_dat,\n    input [E203_HART_ID_W-1:0] core_mhartid,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    output status_mie_r,\n    output mtie_r,\n    output msie_r,\n    output meie_r,\n    output wr_dcsr_ena,\n    output wr_dpc_ena,\n    output wr_dscratch_ena,\n    input [E203_XLEN-1:0] dcsr_r,\n    input [E203_PC_SIZE-1:0] dpc_r,\n    input [E203_XLEN-1:0] dscratch_r,\n    output u_mode,\n    output s_mode,\n    output h_mode,\n    output m_mode,\n    input [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    input cmt_badaddr_ena,\n    input [E203_PC_SIZE-1:0] cmt_epc,\n    input cmt_epc_ena,\n    input [E203_XLEN-1:0] cmt_cause,\n    input cmt_cause_ena,\n    input cmt_status_ena,\n    input cmt_instret_ena,\n    input cmt_mret_ena,\n    output [E203_PC_SIZE-1:0] csr_epc_r,\n    output [E203_PC_SIZE-1:0] csr_dpc_r,\n    output [E203_XLEN-1:0] csr_mtvec_r,\n    input clk_aon,\n    input clk,\n    input rst_n\n);\n\n// CSR logic implementation here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 10, "code": "module e203_ifu(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire itcm_nohold,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input wire pipe_flush_req,\n    input wire ifu_halt_req,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire ifu_active,\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    output wire pipe_flush_ack,\n    output wire ifu_halt_ack\n    );\n\n    // Internal signals for submodule connections\n    wire ifu_req_valid;\n    wire [E203_PC_SIZE-1:0] ifu_req_pc;\n    wire ifu_req_seq;\n    wire ifu_req_seq_rv32;\n    wire [E203_PC_SIZE-1:0] ifu_req_last_pc;\n    wire ifu_req_ready;\n    wire ifu_rsp_valid;\n    wire ifu_rsp_err;\n    wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr;\n\n    e203_ifu_ifetch ifetch (\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ifu_o_ready(ifu_o_ready),\n        .pipe_flush_req(pipe_flush_req),\n        .pipe_flush_add_op1(pipe_flush_add_op1),\n        .pipe_flush_add_op2(pipe_flush_add_op2),\n        .ifu_halt_req(ifu_halt_req),\n        .oitf_empty(oitf_empty),\n        .rf2ifu_x1(rf2ifu_x1),\n        .rf2ifu_rs1(rf2ifu_rs1),\n        .dec2ifu_rden(dec2ifu_rden),\n        .dec2ifu_rs1en(dec2ifu_rs1en),\n        .dec2ifu_rdidx(dec2ifu_rdidx),\n        .dec2ifu_mulhsu(dec2ifu_mulhsu),\n        .dec2ifu_div(dec2ifu_div),\n        .dec2ifu_rem(dec2ifu_rem),\n        .dec2ifu_divu(dec2ifu_divu),\n        .dec2ifu_remu(dec2ifu_remu),\n        .inspect_pc(inspect_pc),\n        .ifu_req_valid(ifu_req_valid),\n        .ifu_req_pc(ifu_req_pc),\n        .ifu_req_seq(ifu_req_seq),\n        .ifu_req_seq_rv32(ifu_req_seq_rv32),\n        .ifu_req_last_pc(ifu_req_last_pc),\n        .pipe_flush_ack(pipe_flush_ack),\n        .ifu_halt_ack(ifu_halt_ack),\n        .ifu_o_ir(ifu_o_ir),\n        .ifu_o_pc(ifu_o_pc),\n        .ifu_o_pc_vld(ifu_o_pc_vld),\n        .ifu_o_misalgn(ifu_o_misalgn),\n        .ifu_o_buserr(ifu_o_buserr),\n        .ifu_o_rs1idx(ifu_o_rs1idx),\n        .ifu_o_rs2idx(ifu_o_rs2idx),\n        .ifu_o_prdt_taken(ifu_o_prdt_taken),\n        .ifu_o_muldiv_b2b(ifu_o_muldiv_b2b),\n        .ifu_o_valid(ifu_o_valid)\n    );\n\n    e203_ifu_ift2icb ift2icb (\n        .clk(clk),\n        .rst_n(rst_n),\n        .ifu_req_valid(ifu_req_valid),\n        .ifu_req_pc(ifu_req_pc),\n        .ifu_req_seq(ifu_req_seq),\n        .ifu_req_seq_rv32(ifu_req_seq_rv32),\n        .ifu_req_last_pc(ifu_req_last_pc),\n        .ifu_rsp_ready(ifu_o_ready),\n        .itcm_nohold(itcm_nohold),\n        .ifu_req_ready(ifu_req_ready),\n        .ifu_rsp_valid(ifu_rsp_valid),\n        .ifu_rsp_err(ifu_rsp_err),\n        .ifu_rsp_instr(ifu_rsp_instr)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 16, "code": "module e203_exu_longpwbck (\n    input wire lsu_wbck_i_valid,\n    output wire lsu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] lsu_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] lsu_wbck_i_itag,\n    input wire lsu_wbck_i_err,\n    input wire lsu_cmt_i_buserr,\n    input wire [E203_ADDR_SIZE-1:0] lsu_cmt_i_badaddr,\n    input wire lsu_cmt_i_ld,\n    input wire lsu_cmt_i_st,\n    output wire longp_wbck_o_valid,\n    input wire longp_wbck_o_ready,\n    output wire [E203_FLEN-1:0] longp_wbck_o_wdat,\n    output wire [4:0] longp_wbck_o_flags,\n    output wire [E203_RFIDX_WIDTH-1:0] longp_wbck_o_rdidx,\n    output wire longp_wbck_o_rdfpu,\n    output wire longp_excp_o_valid,\n    input wire longp_excp_o_ready,\n    output wire longp_excp_o_insterr,\n    output wire longp_excp_o_ld,\n    output wire longp_excp_o_st,\n    output wire longp_excp_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] longp_excp_o_badaddr,\n    output wire [E203_PC_SIZE-1:0] longp_excp_o_pc,\n    input wire oitf_empty,\n    input wire [E203_ITAG_WIDTH-1:0] oitf_ret_ptr,\n    input wire [E203_RFIDX_WIDTH-1:0] oitf_ret_rdidx,\n    input wire [E203_PC_SIZE-1:0] oitf_ret_pc,\n    input wire oitf_ret_rdwen,\n    input wire oitf_ret_rdfpu,\n    output wire oitf_ret_ena,\n    input wire clk,\n    input wire rst_n\n    `ifdef E203_HAS_NICE\n    , input wire nice_longp_wbck_i_valid,\n    output wire nice_longp_wbck_i_ready,\n    input wire [E203_XLEN-1:0] nice_longp_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] nice_longp_wbck_i_itag,\n    input wire nice_longp_wbck_i_err\n    `endif\n);\n\n    // Write-back and exception arbitration logic\n    wire wbck_need = (oitf_ret_rdwen && !lsu_wbck_i_err);\n    wire excp_need = (lsu_wbck_i_err || lsu_cmt_i_buserr);\n\n    assign lsu_wbck_i_ready = (wbck_need && longp_wbck_o_ready) && (excp_need && longp_excp_o_ready);\n    assign longp_wbck_o_valid = wbck_need && lsu_wbck_i_valid && !excp_need;\n    assign longp_wbck_o_wdat = lsu_wbck_i_wdat;\n    assign longp_wbck_o_rdidx = oitf_ret_rdidx;\n    assign longp_wbck_o_rdfpu = oitf_ret_rdfpu;\n    assign longp_wbck_o_flags = {lsu_cmt_i_ld, lsu_cmt_i_st, 3'b000}; // Example flags\n\n    assign longp_excp_o_valid = excp_need && lsu_wbck_i_valid && !wbck_need;\n    assign longp_excp_o_insterr = lsu_wbck_i_err;\n    assign longp_excp_o_ld = lsu_cmt_i_ld;\n    assign longp_excp_o_st = lsu_cmt_i_st;\n    assign longp_excp_o_buserr = lsu_cmt_i_buserr;\n    assign longp_excp_o_badaddr = lsu_cmt_i_badaddr;\n    assign longp_excp_o_pc = oitf_ret_pc;\n\n    assign oitf_ret_ena = lsu_wbck_i_ready && lsu_wbck_i_valid;\n\n    `ifdef E203_HAS_NICE\n    assign nice_longp_wbck_i_ready = (wbck_need && longp_wbck_o_ready) && (excp_need && longp_excp_o_ready);\n    `endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 11, "code": "module e203_lsu(\n    input wire commit_mret,\n    input wire commit_trap,\n    input wire excp_active,\n    output wire lsu_active,\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n    output wire [ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_buserr,\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [XLEN-1:0] agu_icb_rsp_rdata,\n    input wire nice_mem_holdup,\n    input wire itcm_region_indic,\n    input wire dtcm_region_indic\n);\n\n    // LSU logic implementation here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 18, "code": "module e203_exu_alu_bjp (\n    input wire bjp_i_valid,\n    output wire bjp_i_ready,\n    input wire [E203_XLEN-1:0] bjp_i_rs1,\n    input wire [E203_XLEN-1:0] bjp_i_rs2,\n    input wire [E203_XLEN-1:0] bjp_i_imm,\n    input wire [E203_PC_SIZE-1:0] bjp_i_pc,\n    input wire [E203_DECINFO_BJP_WIDTH-1:0] bjp_i_info,\n    output wire bjp_o_valid,\n    input wire bjp_o_ready,\n    output wire [E203_XLEN-1:0] bjp_o_wbck_wdat,\n    output wire bjp_o_wbck_err,\n    output wire bjp_o_cmt_bjp,\n    output wire bjp_o_cmt_mret,\n    output wire bjp_o_cmt_dret,\n    output wire bjp_o_cmt_fencei,\n    output wire bjp_o_cmt_prdt,\n    output wire bjp_o_cmt_rslv,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    output wire bjp_req_alu_cmp_eq,\n    output wire bjp_req_alu_cmp_ne,\n    output wire bjp_req_alu_cmp_lt,\n    output wire bjp_req_alu_cmp_gt,\n    output wire bjp_req_alu_cmp_ltu,\n    output wire bjp_req_alu_cmp_gtu,\n    output wire bjp_req_alu_add,\n    input wire bjp_req_alu_cmp_res,\n    input wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Handshake mechanism\n    assign bjp_i_ready = bjp_o_ready;\n    assign bjp_o_valid = bjp_i_valid;\n\n    // Default assignments\n    assign bjp_o_wbck_err = 1'b0;\n    assign bjp_o_wbck_wdat = bjp_req_alu_add_res;\n\n    // Decode instruction type\n    wire is_beq = bjp_i_info[E203_DECINFO_BJP_BEQ];\n    wire is_bne = bjp_i_info[E203_DECINFO_BJP_BNE];\n    wire is_blt = bjp_i_info[E203_DECINFO_BJP_BLT];\n    wire is_bgt = bjp_i_info[E203_DECINFO_BJP_BGT];\n    wire is_bltu = bjp_i_info[E203_DECINFO_BJP_BLTU];\n    wire is_bgtu = bjp_i_info[E203_DECINFO_BJP_BGTU];\n    wire is_mret = bjp_i_info[E203_DECINFO_BJP_MRET];\n    wire is_dret = bjp_i_info[E203_DECINFO_BJP_DRET];\n    wire is_fencei = bjp_i_info[E203_DECINFO_BJP_FENCEI];\n    wire is_jump = bjp_i_info[E203_DECINFO_BJP_JUMP];\n\n    // Commit signals\n    assign bjp_o_cmt_bjp = is_beq | is_bne | is_blt | is_bgt | is_bltu | is_bgtu | is_jump;\n    assign bjp_o_cmt_mret = is_mret;\n    assign bjp_o_cmt_dret = is_dret;\n    assign bjp_o_cmt_fencei = is_fencei;\n\n    // ALU operation requests\n    assign bjp_req_alu_cmp_eq = is_beq;\n    assign bjp_req_alu_cmp_ne = is_bne;\n    assign bjp_req_alu_cmp_lt = is_blt;\n    assign bjp_req_alu_cmp_gt = is_bgt;\n    assign bjp_req_alu_cmp_ltu = is_bltu;\n    assign bjp_req_alu_cmp_gtu = is_bgtu;\n    assign bjp_req_alu_add = is_jump;\n\n    // Operand selection\n    assign bjp_req_alu_op1 = is_jump ? bjp_i_pc : bjp_i_rs1;\n    assign bjp_req_alu_op2 = is_jump ? bjp_i_imm : bjp_i_rs2;\n\n    // Resolved result for branches\n    assign bjp_o_cmt_rslv = is_jump ? 1'b1 : bjp_req_alu_cmp_res;\n    assign bjp_o_cmt_prdt = bjp_i_info[E203_DECINFO_BJP_BPRDT];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 8, "code": "module e203_exu_commit(\n    output commit_mret,\n    output commit_trap,\n    output core_wfi,\n    output nonflush_cmt_ena,\n    output excp_active,\n    input amo_wait,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input alu_cmt_i_valid,\n    output alu_cmt_i_ready,\n    input [E203_PC_SIZE-1:0] alu_cmt_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_cmt_i_instr,\n    input alu_cmt_i_pc_vld,\n    input [E203_XLEN-1:0] alu_cmt_i_imm,\n    input alu_cmt_i_rv32,\n    input alu_cmt_i_bjp,\n    input alu_cmt_i_wfi,\n    input alu_cmt_i_fencei,\n    input alu_cmt_i_mret,\n    input alu_cmt_i_dret,\n    input alu_cmt_i_ecall,\n    input alu_cmt_i_ebreak,\n    input alu_cmt_i_ifu_misalgn,\n    input alu_cmt_i_ifu_buserr,\n    input alu_cmt_i_ifu_ilegl,\n    input alu_cmt_i_bjp_prdt,\n    input alu_cmt_i_bjp_rslv,\n    input alu_cmt_i_misalgn,\n    input alu_cmt_i_ld,\n    input alu_cmt_i_stamo,\n    input alu_cmt_i_buserr,\n    input [E203_ADDR_SIZE-1:0] alu_cmt_i_badaddr,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output cmt_badaddr_ena,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output cmt_epc_ena,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_cause_ena,\n    output cmt_instret_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output cmt_mret_ena,\n    input [E203_PC_SIZE-1:0] csr_epc_r,\n    input [E203_PC_SIZE-1:0] csr_dpc_r,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output longp_excp_i_ready,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input longp_excp_i_insterr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input clk,\n    input rst_n\n);\n    // Implementation of the commit logic and exception handling\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 19, "code": "module e203_exu_alu_bjp (\n    input wire bjp_i_valid,\n    output wire bjp_i_ready,\n    input wire [E203_XLEN-1:0] bjp_i_rs1,\n    input wire [E203_XLEN-1:0] bjp_i_rs2,\n    input wire [E203_XLEN-1:0] bjp_i_imm,\n    input wire [E203_PC_SIZE-1:0] bjp_i_pc,\n    input wire [E203_DECINFO_BJP_WIDTH-1:0] bjp_i_info,\n    output wire bjp_o_valid,\n    input wire bjp_o_ready,\n    output wire [E203_XLEN-1:0] bjp_o_wbck_wdat,\n    output wire bjp_o_wbck_err,\n    output wire bjp_o_cmt_bjp,\n    output wire bjp_o_cmt_mret,\n    output wire bjp_o_cmt_dret,\n    output wire bjp_o_cmt_fencei,\n    output wire bjp_o_cmt_prdt,\n    output wire bjp_o_cmt_rslv,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    output wire bjp_req_alu_cmp_eq,\n    output wire bjp_req_alu_cmp_ne,\n    output wire bjp_req_alu_cmp_lt,\n    output wire bjp_req_alu_cmp_gt,\n    output wire bjp_req_alu_cmp_ltu,\n    output wire bjp_req_alu_cmp_gtu,\n    output wire bjp_req_alu_add,\n    input wire bjp_req_alu_cmp_res,\n    input wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    input wire clk,\n    input wire rst_n\n);\n\n// Handshake signals\nassign bjp_i_ready = bjp_o_ready;\nassign bjp_o_valid = bjp_i_valid;\n\n// Default assignments\nassign bjp_o_wbck_err = 1'b0;\n\n// Operand selection\nassign bjp_req_alu_op1 = (bjp_i_info[E203_DECINFO_BJP_JUMP] ? bjp_i_pc : bjp_i_rs1);\nassign bjp_req_alu_op2 = (bjp_i_info[E203_DECINFO_BJP_JUMP] ? (E203_XLEN == 32 ? 32'd4 : 64'd2) : bjp_i_rs2);\n\n// ALU operation requests\nassign bjp_req_alu_cmp_eq  = bjp_i_info[E203_DECINFO_BJP_BEQ];\nassign bjp_req_alu_cmp_ne  = bjp_i_info[E203_DECINFO_BJP_BNE];\nassign bjp_req_alu_cmp_lt  = bjp_i_info[E203_DECINFO_BJP_BLT];\nassign bjp_req_alu_cmp_gt  = bjp_i_info[E203_DECINFO_BJP_BGT];\nassign bjp_req_alu_cmp_ltu = bjp_i_info[E203_DECINFO_BJP_BLTU];\nassign bjp_req_alu_cmp_gtu = bjp_i_info[E203_DECINFO_BJP_BGTU];\nassign bjp_req_alu_add     = bjp_i_info[E203_DECINFO_BJP_JUMP];\n\n// Commit signals\nassign bjp_o_cmt_bjp    = bjp_i_info[E203_DECINFO_BJP_BXX] | bjp_i_info[E203_DECINFO_BJP_JUMP];\nassign bjp_o_cmt_mret   = bjp_i_info[E203_DECINFO_BJP_MRET];\nassign bjp_o_cmt_dret   = bjp_i_info[E203_DECINFO_BJP_DRET];\nassign bjp_o_cmt_fencei = bjp_i_info[E203_DECINFO_BJP_FENCEI];\n\n// Predicted and resolved results\nassign bjp_o_cmt_prdt = bjp_i_info[E203_DECINFO_BJP_BPRDT];\nassign bjp_o_cmt_rslv = (bjp_i_info[E203_DECINFO_BJP_JUMP] ? 1'b1 : bjp_req_alu_cmp_res);\n\n// Write back data\nassign bjp_o_wbck_wdat = bjp_req_alu_add_res;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 19, "code": "module e203_exu_alu_dpath(\n    input wire alu_req_alu,\n    input wire alu_req_alu_add,\n    input wire alu_req_alu_sub,\n    input wire alu_req_alu_xor,\n    input wire alu_req_alu_sll,\n    input wire alu_req_alu_srl,\n    input wire alu_req_alu_sra,\n    input wire alu_req_alu_or,\n    input wire alu_req_alu_and,\n    input wire [E203_XLEN-1:0] alu_req_alu_op1,\n    input wire [E203_XLEN-1:0] alu_req_alu_op2,\n    input wire bjp_req_alu,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    input wire agu_req_alu,\n    input wire [E203_XLEN-1:0] agu_req_alu_op1,\n    input wire [E203_XLEN-1:0] agu_req_alu_op2,\n    input wire muldiv_req_alu,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    input wire muldiv_req_alu_add,\n    input wire muldiv_req_alu_sub,\n    input wire muldiv_sbf_0_ena,\n    input wire [32:0] muldiv_sbf_0_nxt,\n    input wire muldiv_sbf_1_ena,\n    input wire [32:0] muldiv_sbf_1_nxt,\n    input wire clk,\n    input wire rst_n,\n    output wire [E203_XLEN-1:0] alu_req_alu_res,\n    output wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    output wire bjp_req_alu_cmp_res,\n    output wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output wire [32:0] muldiv_sbf_0_r,\n    output wire [32:0] muldiv_sbf_1_r\n);\n\n    // Internal signals for ALU operations\n    wire [E203_XLEN-1:0] add_res;\n    wire [E203_XLEN-1:0] sub_res;\n    wire [E203_XLEN-1:0] xor_res;\n    wire [E203_XLEN-1:0] or_res;\n    wire [E203_XLEN-1:0] and_res;\n    wire [E203_XLEN-1:0] sll_res;\n    wire [E203_XLEN-1:0] srl_res;\n    wire [E203_XLEN-1:0] sra_res;\n\n    // ALU operation implementations\n    assign add_res = alu_req_alu_op1 + alu_req_alu_op2;\n    assign sub_res = alu_req_alu_op1 - alu_req_alu_op2;\n    assign xor_res = alu_req_alu_op1 ^ alu_req_alu_op2;\n    assign or_res = alu_req_alu_op1 | alu_req_alu_op2;\n    assign and_res = alu_req_alu_op1 & alu_req_alu_op2;\n    assign sll_res = alu_req_alu_op1 << alu_req_alu_op2;\n    assign srl_res = alu_req_alu_op1 >> alu_req_alu_op2;\n    assign sra_res = $signed(alu_req_alu_op1) >>> alu_req_alu_op2;\n\n    // Result multiplexing\n    assign alu_req_alu_res = ({E203_XLEN{alu_req_alu_add}} & add_res) |\n                             ({E203_XLEN{alu_req_alu_sub}} & sub_res) |\n                             ({E203_XLEN{alu_req_alu_xor}} & xor_res) |\n                             ({E203_XLEN{alu_req_alu_or}} & or_res) |\n                             ({E203_XLEN{alu_req_alu_and}} & and_res) |\n                             ({E203_XLEN{alu_req_alu_sll}} & sll_res) |\n                             ({E203_XLEN{alu_req_alu_srl}} & srl_res) |\n                             ({E203_XLEN{alu_req_alu_sra}} & sra_res);\n\n    // BJP operations\n    assign bjp_req_alu_add_res = bjp_req_alu_op1 + bjp_req_alu_op2;\n    assign bjp_req_alu_cmp_res = (bjp_req_alu_op1 == bjp_req_alu_op2);\n\n    // AGU operations\n    assign agu_req_alu_res = agu_req_alu_op1 + agu_req_alu_op2; // Example for AGU add\n\n    // MULDIV operations\n    wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_add_res;\n    wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_sub_res;\n    assign muldiv_add_res = muldiv_req_alu_op1 + muldiv_req_alu_op2;\n    assign muldiv_sub_res = muldiv_req_alu_op1 - muldiv_req_alu_op2;\n    assign muldiv_req_alu_res = ({E203_ALU_ADDER_WIDTH{muldiv_req_alu_add}} & muldiv_add_res) |\n                                ({E203_ALU_ADDER_WIDTH{muldiv_req_alu_sub}} & muldiv_sub_res);\n\n    // Shared buffers\n    sirv_gnrl_dffl #(.DW(33)) sbf_0_dffl (\n        .lden(muldiv_sbf_0_ena),\n        .dnxt(muldiv_sbf_0_nxt),\n        .qout(muldiv_sbf_0_r),\n        .clk(clk)\n    );\n\n    sirv_gnrl_dffl #(.DW(33)) sbf_1_dffl (\n        .lden(muldiv_sbf_1_ena),\n        .dnxt(muldiv_sbf_1_nxt),\n        .qout(muldiv_sbf_1_r),\n        .clk(clk)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 6, "code": "module itcm_controller (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n    input wire [ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_cmd_valid,\n    input wire ifu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] ifu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] ifu2itcm_icb_cmd_wmask,\n    input wire ifu2itcm_icb_rsp_ready,\n    output wire ifu2itcm_icb_cmd_ready,\n    output wire ifu2itcm_icb_rsp_valid,\n    output wire ifu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    output wire itcm_active,\n    output wire itcm_ram_cs,\n    output wire itcm_ram_we,\n    output wire [RAM_AW-1:0] itcm_ram_addr,\n    output wire [RAM_MW-1:0] itcm_ram_wem,\n    output wire [RAM_DW-1:0] itcm_ram_din,\n    input wire [RAM_DW-1:0] itcm_ram_dout,\n    output wire clk_itcm_ram\n);\n\n    // Internal signals\n    wire [ADDR_WIDTH-1:0] lsu2itcm_icb_cmd_addr;\n    wire lsu2itcm_icb_cmd_valid;\n    wire lsu2itcm_icb_cmd_read;\n    wire [DATA_WIDTH-1:0] lsu2itcm_icb_cmd_wdata;\n    wire [WMSK_WIDTH-1:0] lsu2itcm_icb_cmd_wmask;\n    wire lsu2itcm_icb_rsp_ready;\n    wire lsu2itcm_icb_cmd_ready;\n    wire lsu2itcm_icb_rsp_valid;\n    wire lsu2itcm_icb_rsp_err;\n    wire [DATA_WIDTH-1:0] lsu2itcm_icb_rsp_rdata;\n\n    // External interface signals (if E203_HAS_ITCM_EXTITF is defined)\n    `ifdef E203_HAS_ITCM_EXTITF\n    wire [ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr;\n    wire ext2itcm_icb_cmd_valid;\n    wire ext2itcm_icb_cmd_read;\n    wire [DATA_WIDTH-1:0] ext2itcm_icb_cmd_wdata;\n    wire [WMSK_WIDTH-1:0] ext2itcm_icb_cmd_wmask;\n    wire ext2itcm_icb_rsp_ready;\n    wire ext2itcm_icb_cmd_ready;\n    wire ext2itcm_icb_rsp_valid;\n    wire ext2itcm_icb_rsp_err;\n    wire [DATA_WIDTH-1:0] ext2itcm_icb_rsp_rdata;\n    `endif\n\n    // Arbitration logic\n    wire [2:0] arb_select;\n    arbiter #(\n        .NUM_PORTS(3)\n    ) u_arbiter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .request({ext2itcm_icb_cmd_valid, lsu2itcm_icb_cmd_valid, ifu2itcm_icb_cmd_valid}),\n        .grant(arb_select)\n    );\n\n    // Command and data multiplexing\n    assign itcm_ram_addr = (arb_select == 2'b00) ? ifu2itcm_icb_cmd_addr :\n                           (arb_select == 2'b01) ? lsu2itcm_icb_cmd_addr :\n                           ext2itcm_icb_cmd_addr;\n\n    assign itcm_ram_din = (arb_select == 2'b00) ? ifu2itcm_icb_cmd_wdata :\n                          (arb_select == 2'b01) ? lsu2itcm_icb_cmd_wdata :\n                          ext2itcm_icb_cmd_wdata;\n\n    assign itcm_ram_wem = (arb_select == 2'b00) ? ifu2itcm_icb_cmd_wmask :\n                          (arb_select == 2'b01) ? lsu2itcm_icb_cmd_wmask :\n                          ext2itcm_icb_cmd_wmask;\n\n    assign itcm_ram_we = (arb_select == 2'b00) ? ifu2itcm_icb_cmd_read :\n                         (arb_select == 2'b01) ? lsu2itcm_icb_cmd_read :\n                         ext2itcm_icb_cmd_read;\n\n    // Response routing\n    assign ifu2itcm_icb_rsp_rdata = itcm_ram_dout;\n    assign lsu2itcm_icb_rsp_rdata = itcm_ram_dout;\n    `ifdef E203_HAS_ITCM_EXTITF\n    assign ext2itcm_icb_rsp_rdata = itcm_ram_dout;\n    `endif\n\n    // Clock gating control\n    assign clk_itcm_ram = clk & ~tcm_cgstop;\n\n    // Active status signal\n    assign itcm_active = itcm_ram_cs;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 20, "code": "module e203_exu_alu_csrctrl(\n    input wire csr_i_valid,\n    output reg csr_i_ready,\n    input wire [E203_XLEN-1:0] csr_i_rs1,\n    input wire [E203_DECINFO_CSR_WIDTH-1:0] csr_i_info,\n    input wire csr_i_rdwen,\n    output reg csr_ena,\n    output reg csr_wr_en,\n    output reg csr_rd_en,\n    output reg [11:0] csr_idx,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output reg [E203_XLEN-1:0] wbck_csr_dat,\n    output reg csr_o_valid,\n    input wire csr_o_ready,\n    output reg [E203_XLEN-1:0] csr_o_wbck_wdat,\n    output reg csr_o_wbck_err,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Decode CSR instruction information\n    wire csrrw = csr_i_info[E203_DECINFO_CSR_CSRRW];\n    wire csrrs = csr_i_info[E203_DECINFO_CSR_CSRRS];\n    wire csrrc = csr_i_info[E203_DECINFO_CSR_CSRRC];\n    wire rs1imm = csr_i_info[E203_DECINFO_CSR_RS1IMM];\n    wire rs1is0 = csr_i_info[E203_DECINFO_CSR_RS1IS0];\n    wire [4:0] zimm = csr_i_info[E203_DECINFO_CSR_ZIMMM];\n    wire [11:0] csr_idx_info = csr_i_info[E203_DECINFO_CSR_CSRIDX];\n\n    // Prepare source operand\n    wire [E203_XLEN-1:0] csr_op1 = rs1imm ? { {(E203_XLEN-5){1'b0}}, zimm } : csr_i_rs1;\n\n    // Control signal logic\n    always @(*) begin\n        csr_i_ready = csr_o_ready;\n        csr_o_valid = csr_i_valid && csr_o_ready;\n        csr_ena = csr_i_valid && csr_o_ready && !csr_access_ilgl;\n        csr_idx = csr_idx_info;\n        csr_wr_en = csr_i_valid && ((csrrw) || (csrrs && !rs1is0) || (csrrc && !rs1is0));\n        csr_rd_en = csr_i_valid && (csrrw || csrrs || csrrc);\n        wbck_csr_dat = (csrrw ? csr_op1 : \n                        csrrs ? (csr_op1 | read_csr_dat) : \n                        csrrc ? (csr_op1 & ~read_csr_dat) : 0);\n        csr_o_wbck_wdat = read_csr_dat;\n        csr_o_wbck_err = csr_access_ilgl;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 6, "code": "module e203_exu_alu(\n    input  wire        i_valid,\n    output wire        i_ready,\n    output wire        i_longpipe,\n    output wire        nice_csr_valid,\n    input  wire        nice_csr_ready,\n    output wire [31:0] nice_csr_addr,\n    output wire        nice_csr_wr,\n    output wire [31:0] nice_csr_wdata,\n    input  wire [31:0] nice_csr_rdata,\n    input  wire        nice_xs_off,\n    output wire        amo_wait,\n    input  wire        oitf_empty,\n    input  wire [E203_ITAG_WIDTH-1:0] i_itag,\n    input  wire [E203_XLEN-1:0] i_rs1,\n    input  wire [E203_XLEN-1:0] i_rs2,\n    input  wire [E203_XLEN-1:0] i_imm,\n    input  wire [E203_DECINFO_WIDTH-1:0] i_info,\n    input  wire [E203_PC_SIZE-1:0] i_pc,\n    input  wire [E203_INSTR_SIZE-1:0] i_instr,\n    input  wire        i_pc_vld,\n    input  wire [E203_RFIDX_WIDTH-1:0] i_rdidx,\n    input  wire        i_rdwen,\n    input  wire        i_ilegl,\n    input  wire        i_buserr,\n    input  wire        i_misalgn,\n    input  wire        flush_req,\n    input  wire        flush_pulse,\n    output wire        cmt_o_valid,\n    input  wire        cmt_o_ready,\n    output wire        cmt_o_pc_vld,\n    output wire [E203_PC_SIZE-1:0] cmt_o_pc,\n    output wire [E203_INSTR_SIZE-1:0] cmt_o_instr,\n    output wire [E203_XLEN-1:0] cmt_o_imm,\n    output wire        cmt_o_rv32,\n    output wire        cmt_o_bjp,\n    output wire        cmt_o_mret,\n    output wire        cmt_o_dret,\n    output wire        cmt_o_ecall,\n    output wire        cmt_o_ebreak,\n    output wire        cmt_o_fencei,\n    output wire        cmt_o_wfi,\n    output wire        cmt_o_ifu_misalgn,\n    output wire        cmt_o_ifu_buserr,\n    output wire        cmt_o_ifu_ilegl,\n    output wire        cmt_o_bjp_prdt,\n    output wire        cmt_o_bjp_rslv,\n    output wire        cmt_o_misalgn,\n    output wire        cmt_o_ld,\n    output wire        cmt_o_stamo,\n    output wire        cmt_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] cmt_o_badaddr,\n    output wire        wbck_o_valid,\n    input  wire        wbck_o_ready,\n    output wire [E203_XLEN-1:0] wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] wbck_o_rdidx,\n    input  wire        mdv_nob2b,\n    output wire        csr_ena,\n    output wire        csr_wr_en,\n    output wire        csr_rd_en,\n    output wire [11:0] csr_idx,\n    input  wire        nonflush_cmt_ena,\n    input  wire        csr_access_ilgl,\n    input  wire [E203_XLEN-1:0] read_csr_dat,\n    output wire [E203_XLEN-1:0] wbck_csr_dat,\n    output wire        agu_icb_cmd_valid,\n    input  wire        agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire        agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire        agu_icb_cmd_lock,\n    output wire        agu_icb_cmd_excl,\n    output wire [1:0]  agu_icb_cmd_size,\n    output wire        agu_icb_cmd_back2agu,\n    output wire        agu_icb_cmd_usign,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input  wire        agu_icb_rsp_valid,\n    output wire        agu_icb_rsp_ready,\n    input  wire        agu_icb_rsp_err,\n    input  wire        agu_icb_rsp_excl_ok,\n    input  wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire        nice_req_valid,\n    input  wire        nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input  wire        nice_rsp_multicyc_valid,\n    output wire        nice_rsp_multicyc_ready,\n    output wire        nice_longp_wbck_valid,\n    input  wire        nice_longp_wbck_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input  wire        i_nice_cmt_off_ilgl,\n    input  wire        clk,\n    input  wire        rst_n\n);\n    // Module implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 16, "code": "module e203_exu_wbck (\n    input wire alu_wbck_i_valid,\n    output wire alu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] alu_wbck_i_wdat,\n    input wire [E203_RFIDX_WIDTH-1:0] alu_wbck_i_rdidx,\n    input wire longp_wbck_i_valid,\n    output wire longp_wbck_i_ready,\n    input wire [E203_FLEN-1:0] longp_wbck_i_wdat,\n    input wire [4:0] longp_wbck_i_flags,\n    input wire [E203_RFIDX_WIDTH-1:0] longp_wbck_i_rdidx,\n    input wire longp_wbck_i_rdfpu,\n    output wire rf_wbck_o_ena,\n    output wire [E203_XLEN-1:0] rf_wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] rf_wbck_o_rdidx,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Arbitration logic\n    assign longp_wbck_i_ready = longp_wbck_i_valid;\n    assign alu_wbck_i_ready = !longp_wbck_i_valid && alu_wbck_i_valid;\n\n    // Write-back data selection\n    wire [E203_XLEN-1:0] selected_wdat = longp_wbck_i_valid ? longp_wbck_i_wdat : alu_wbck_i_wdat;\n    wire [E203_RFIDX_WIDTH-1:0] selected_rdidx = longp_wbck_i_valid ? longp_wbck_i_rdidx : alu_wbck_i_rdidx;\n    wire selected_rdfpu = longp_wbck_i_valid ? longp_wbck_i_rdfpu : 1'b0;\n\n    // Write-back enable logic\n    assign rf_wbck_o_ena = (alu_wbck_i_valid || longp_wbck_i_valid) && !selected_rdfpu;\n    assign rf_wbck_o_wdat = selected_wdat;\n    assign rf_wbck_o_rdidx = selected_rdidx;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 9, "code": "module e203_ifu_ift2icb (\n    input wire itcm_nohold,\n    input wire ifu_req_valid,\n    input wire [PC_SIZE-1:0] ifu_req_pc,\n    input wire ifu_req_seq,\n    input wire ifu_req_seq_rv32,\n    input wire [PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_ready,\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_ready,\n    output wire ifu_rsp_valid,\n    output wire ifu_rsp_err,\n    output wire [31:0] ifu_rsp_instr,\n    output wire ifu2itcm_icb_cmd_valid,\n    input wire ifu2itcm_icb_cmd_ready,\n    output wire [ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_rsp_valid,\n    output wire ifu2itcm_icb_rsp_ready,\n    input wire ifu2itcm_icb_rsp_err,\n    input wire [ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    output wire ifu2biu_icb_cmd_valid,\n    input wire ifu2biu_icb_cmd_ready,\n    output wire [ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input wire ifu2biu_icb_rsp_valid,\n    output wire ifu2biu_icb_rsp_ready,\n    input wire ifu2biu_icb_rsp_err,\n    input wire [SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata\n);\n\n    // State definitions\n    localparam ICB_STATE_IDLE = 2'b00;\n    localparam ICB_STATE_1ST = 2'b01;\n    localparam ICB_STATE_WAIT2ND = 2'b10;\n    localparam ICB_STATE_2ND = 2'b11;\n\n    // State registers\n    reg [1:0] icb_state;\n    reg [1:0] icb_state_nxt;\n\n    // Handshake signals\n    wire ifu_req_hsked = ifu_req_valid && ifu_req_ready;\n    wire ifu_icb_cmd_hsked = ifu2itcm_icb_cmd_valid && ifu2itcm_icb_cmd_ready;\n    wire ifu_icb_rsp_hsked = ifu2itcm_icb_rsp_valid && ifu2itcm_icb_rsp_ready;\n    wire i_ifu_rsp_hsked = ifu_rsp_valid && ifu_rsp_ready;\n\n    // State transition logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            icb_state <= ICB_STATE_IDLE;\n        end else begin\n            icb_state <= icb_state_nxt;\n        end\n    end\n\n    always @(*) begin\n        case (icb_state)\n            ICB_STATE_IDLE: begin\n                if (ifu_req_hsked)\n                    icb_state_nxt = ICB_STATE_1ST;\n                else\n                    icb_state_nxt = ICB_STATE_IDLE;\n            end\n            ICB_STATE_1ST: begin\n                if (ifu_icb_rsp_hsked)\n                    icb_state_nxt = ifu_req_hsked ? ICB_STATE_1ST : ICB_STATE_IDLE;\n                else\n                    icb_state_nxt = ICB_STATE_1ST;\n            end\n            ICB_STATE_WAIT2ND: begin\n                if (ifu_icb_cmd_ready)\n                    icb_state_nxt = ICB_STATE_2ND;\n                else\n                    icb_state_nxt = ICB_STATE_WAIT2ND;\n            end\n            ICB_STATE_2ND: begin\n                if (i_ifu_rsp_hsked)\n                    icb_state_nxt = ifu_req_hsked ? ICB_STATE_1ST : ICB_STATE_IDLE;\n                else\n                    icb_state_nxt = ICB_STATE_2ND;\n            end\n            default: icb_state_nxt = ICB_STATE_IDLE;\n        endcase\n    end\n\n    // Output logic\n    assign ifu_req_ready = (icb_state == ICB_STATE_IDLE);\n    assign ifu_rsp_valid = (icb_state == ICB_STATE_1ST) && ifu2itcm_icb_rsp_valid;\n    assign ifu_rsp_err = ifu2itcm_icb_rsp_err;\n    assign ifu_rsp_instr = ifu2itcm_icb_rsp_rdata[31:0];\n\n    assign ifu2itcm_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && ifu_req_valid;\n    assign ifu2itcm_icb_cmd_addr = ifu_req_pc[ITCM_ADDR_WIDTH-1:0];\n    assign ifu2itcm_icb_rsp_ready = (icb_state == ICB_STATE_1ST);\n\n    assign ifu2biu_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && ifu_req_valid && !ifu2itcm_icb_cmd_valid;\n    assign ifu2biu_icb_cmd_addr = ifu_req_pc[ADDR_SIZE-1:0];\n    assign ifu2biu_icb_rsp_ready = (icb_state == ICB_STATE_1ST);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 12, "code": "module e203_exu_csr (\n    input wire nonflush_cmt_ena,\n    input wire csr_ena,\n    input wire csr_wr_en,\n    input wire csr_rd_en,\n    input wire [11:0] csr_idx,\n    output wire csr_access_ilgl,\n    output wire tm_stop,\n    output wire core_cgstop,\n    output wire tcm_cgstop,\n    output wire itcm_nohold,\n    output wire mdv_nob2b,\n    output wire [E203_XLEN-1:0] read_csr_dat,\n    input wire [E203_XLEN-1:0] wbck_csr_dat,\n    input wire [E203_HART_ID_W-1:0] core_mhartid,\n    input wire ext_irq_r,\n    input wire sft_irq_r,\n    input wire tmr_irq_r,\n    output wire status_mie_r,\n    output wire mtie_r,\n    output wire msie_r,\n    output wire meie_r,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    input wire [E203_XLEN-1:0] dcsr_r,\n    input wire [E203_PC_SIZE-1:0] dpc_r,\n    input wire [E203_XLEN-1:0] dscratch_r,\n    output wire u_mode,\n    output wire s_mode,\n    output wire h_mode,\n    output wire m_mode,\n    input wire [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    input wire cmt_badaddr_ena,\n    input wire [E203_PC_SIZE-1:0] cmt_epc,\n    input wire cmt_epc_ena,\n    input wire [E203_XLEN-1:0] cmt_cause,\n    input wire cmt_cause_ena,\n    input wire cmt_status_ena,\n    input wire cmt_instret_ena,\n    input wire cmt_mret_ena,\n    output wire [E203_PC_SIZE-1:0] csr_epc_r,\n    output wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    output wire [E203_XLEN-1:0] csr_mtvec_r,\n    input wire clk_aon,\n    input wire clk,\n    input wire rst_n\n);\n\n// CSR logic implementation here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 9, "code": "module e203_exu_commit(\n    output commit_mret,\n    output commit_trap,\n    output core_wfi,\n    output nonflush_cmt_ena,\n    output excp_active,\n    input amo_wait,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input alu_cmt_i_valid,\n    output alu_cmt_i_ready,\n    input [E203_PC_SIZE-1:0] alu_cmt_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_cmt_i_instr,\n    input alu_cmt_i_pc_vld,\n    input [E203_XLEN-1:0] alu_cmt_i_imm,\n    input alu_cmt_i_rv32,\n    input alu_cmt_i_bjp,\n    input alu_cmt_i_wfi,\n    input alu_cmt_i_fencei,\n    input alu_cmt_i_mret,\n    input alu_cmt_i_dret,\n    input alu_cmt_i_ecall,\n    input alu_cmt_i_ebreak,\n    input alu_cmt_i_ifu_misalgn,\n    input alu_cmt_i_ifu_buserr,\n    input alu_cmt_i_ifu_ilegl,\n    input alu_cmt_i_bjp_prdt,\n    input alu_cmt_i_bjp_rslv,\n    input alu_cmt_i_misalgn,\n    input alu_cmt_i_ld,\n    input alu_cmt_i_stamo,\n    input alu_cmt_i_buserr,\n    input [E203_ADDR_SIZE-1:0] alu_cmt_i_badaddr,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output cmt_badaddr_ena,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output cmt_epc_ena,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_cause_ena,\n    output cmt_instret_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output cmt_mret_ena,\n    input [E203_PC_SIZE-1:0] csr_epc_r,\n    input [E203_PC_SIZE-1:0] csr_dpc_r,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output longp_excp_i_ready,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input longp_excp_i_insterr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc\n);\n    // Module implementation\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 4, "code": "module e203_lsu_ctrl(\n    input wire commit_mret,\n    input wire commit_trap,\n    output wire lsu_ctrl_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    input wire nice_mem_holdup,\n    input wire nice_icb_cmd_valid,\n    output wire nice_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] nice_icb_cmd_addr,\n    input wire nice_icb_cmd_read,\n    input wire [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] nice_icb_cmd_wmask,\n    output wire nice_icb_rsp_valid,\n    input wire nice_icb_rsp_ready,\n    output wire nice_icb_rsp_err,\n    output wire [E203_XLEN-1:0] nice_icb_rsp_rdata,\n\n    output wire dcache_icb_cmd_valid,\n    input wire dcache_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] dcache_icb_cmd_addr,\n    output wire dcache_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dcache_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dcache_icb_cmd_wmask,\n    output wire dcache_icb_cmd_lock,\n    output wire dcache_icb_cmd_excl,\n    output wire [1:0] dcache_icb_cmd_size,\n    input wire dcache_icb_rsp_valid,\n    output wire dcache_icb_rsp_ready,\n    input wire dcache_icb_rsp_err,\n    input wire dcache_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dcache_icb_rsp_rdata,\n\n    output wire dtcm_icb_cmd_valid,\n    input wire dtcm_icb_cmd_ready,\n    output wire [E203_DTCM_ADDR_WIDTH-1:0] dtcm_icb_cmd_addr,\n    output wire dtcm_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dtcm_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dtcm_icb_cmd_wmask,\n    output wire dtcm_icb_cmd_lock,\n    output wire dtcm_icb_cmd_excl,\n    output wire [1:0] dtcm_icb_cmd_size,\n    input wire dtcm_icb_rsp_valid,\n    output wire dtcm_icb_rsp_ready,\n    input wire dtcm_icb_rsp_err,\n    input wire dtcm_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dtcm_icb_rsp_rdata,\n    input wire [E203_ADDR_SIZE-1:0] dtcm_region_indic,\n\n    output wire biu_icb_cmd_valid,\n    input wire biu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,\n    output wire biu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] biu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] biu_icb_cmd_wmask,\n    output wire biu_icb_cmd_lock,\n    output wire biu_icb_cmd_excl,\n    output wire [1:0] biu_icb_cmd_size,\n    input wire biu_icb_rsp_valid,\n    output wire biu_icb_rsp_ready,\n    input wire biu_icb_rsp_err,\n    input wire biu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] biu_icb_rsp_rdata\n);\n    // LSU control logic implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 17, "code": "module e203_exu_longpwbck (\n    input wire lsu_wbck_i_valid,\n    output wire lsu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] lsu_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] lsu_wbck_i_itag,\n    input wire lsu_wbck_i_err,\n    input wire lsu_cmt_i_buserr,\n    input wire [E203_ADDR_SIZE-1:0] lsu_cmt_i_badaddr,\n    input wire lsu_cmt_i_ld,\n    input wire lsu_cmt_i_st,\n    output wire longp_wbck_o_valid,\n    input wire longp_wbck_o_ready,\n    output wire [E203_FLEN-1:0] longp_wbck_o_wdat,\n    output wire [4:0] longp_wbck_o_flags,\n    output wire [E203_RFIDX_WIDTH-1:0] longp_wbck_o_rdidx,\n    output wire longp_wbck_o_rdfpu,\n    output wire longp_excp_o_valid,\n    input wire longp_excp_o_ready,\n    output wire longp_excp_o_insterr,\n    output wire longp_excp_o_ld,\n    output wire longp_excp_o_st,\n    output wire longp_excp_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] longp_excp_o_badaddr,\n    output wire [E203_PC_SIZE-1:0] longp_excp_o_pc,\n    input wire oitf_empty,\n    input wire [E203_ITAG_WIDTH-1:0] oitf_ret_ptr,\n    input wire [E203_RFIDX_WIDTH-1:0] oitf_ret_rdidx,\n    input wire [E203_PC_SIZE-1:0] oitf_ret_pc,\n    input wire oitf_ret_rdwen,\n    input wire oitf_ret_rdfpu,\n    output wire oitf_ret_ena,\n    input wire clk,\n    input wire rst_n\n`ifdef E203_HAS_NICE\n    , input wire nice_longp_wbck_i_valid,\n    output wire nice_longp_wbck_i_ready,\n    input wire [E203_XLEN-1:0] nice_longp_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] nice_longp_wbck_i_itag,\n    input wire nice_longp_wbck_i_err\n`endif\n);\n\n    // Write-back and exception arbitration logic\n    wire wbck_need = (lsu_wbck_i_valid && oitf_ret_rdwen && !lsu_wbck_i_err);\n    wire excp_need = (lsu_wbck_i_valid && lsu_wbck_i_err);\n\n    assign lsu_wbck_i_ready = (wbck_need && longp_wbck_o_ready) || (excp_need && longp_excp_o_ready);\n    assign longp_wbck_o_valid = wbck_need && longp_wbck_o_ready;\n    assign longp_wbck_o_wdat = lsu_wbck_i_wdat;\n    assign longp_wbck_o_rdidx = oitf_ret_rdidx;\n    assign longp_wbck_o_rdfpu = oitf_ret_rdfpu;\n    assign longp_wbck_o_flags = {lsu_cmt_i_ld, lsu_cmt_i_st, lsu_cmt_i_buserr, 2'b00}; // Example flags\n\n    assign longp_excp_o_valid = excp_need && longp_excp_o_ready;\n    assign longp_excp_o_insterr = lsu_wbck_i_err;\n    assign longp_excp_o_ld = lsu_cmt_i_ld;\n    assign longp_excp_o_st = lsu_cmt_i_st;\n    assign longp_excp_o_buserr = lsu_cmt_i_buserr;\n    assign longp_excp_o_badaddr = lsu_cmt_i_badaddr;\n    assign longp_excp_o_pc = oitf_ret_pc;\n\n    assign oitf_ret_ena = lsu_wbck_i_ready && lsu_wbck_i_valid;\n\n`ifdef E203_HAS_NICE\n    wire nice_wbck_need = (nice_longp_wbck_i_valid && oitf_ret_rdwen && !nice_longp_wbck_i_err);\n    wire nice_excp_need = (nice_longp_wbck_i_valid && nice_longp_wbck_i_err);\n\n    assign nice_longp_wbck_i_ready = (nice_wbck_need && longp_wbck_o_ready) || (nice_excp_need && longp_excp_o_ready);\n    // Additional logic for handling NICE write-back and exceptions\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 19, "code": "module e203_exu_alu_rglr(\n    input wire alu_i_valid,\n    output wire alu_i_ready,\n    input wire [E203_XLEN-1:0] alu_i_rs1,\n    input wire [E203_XLEN-1:0] alu_i_rs2,\n    input wire [E203_XLEN-1:0] alu_i_imm,\n    input wire [E203_PC_SIZE-1:0] alu_i_pc,\n    input wire [E203_DECINFO_ALU_WIDTH-1:0] alu_i_info,\n    output wire alu_o_valid,\n    input wire alu_o_ready,\n    output wire [E203_XLEN-1:0] alu_o_wbck_wdat,\n    output wire alu_o_wbck_err,\n    output wire alu_o_cmt_ecall,\n    output wire alu_o_cmt_ebreak,\n    output wire alu_o_cmt_wfi,\n    output wire alu_req_alu_add,\n    output wire alu_req_alu_sub,\n    output wire alu_req_alu_xor,\n    output wire alu_req_alu_sll,\n    output wire alu_req_alu_srl,\n    output wire alu_req_alu_sra,\n    output wire alu_req_alu_or,\n    output wire alu_req_alu_and,\n    output wire alu_req_alu_slt,\n    output wire alu_req_alu_sltu,\n    output wire alu_req_alu_lui,\n    output wire [E203_XLEN-1:0] alu_req_alu_op1,\n    output wire [E203_XLEN-1:0] alu_req_alu_op2,\n    output wire [E203_XLEN-1:0] alu_req_alu_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Handshake signals\n    assign alu_i_ready = alu_o_ready;\n    assign alu_o_valid = alu_i_valid;\n\n    // Operation type decoding\n    assign alu_req_alu_add = alu_i_info[E203_DECINFO_ALU_ADD] & ~alu_i_info[E203_DECINFO_ALU_NOP];\n    assign alu_req_alu_sub = alu_i_info[E203_DECINFO_ALU_SUB];\n    assign alu_req_alu_xor = alu_i_info[E203_DECINFO_ALU_XOR];\n    assign alu_req_alu_sll = alu_i_info[E203_DECINFO_ALU_SLL];\n    assign alu_req_alu_srl = alu_i_info[E203_DECINFO_ALU_SRL];\n    assign alu_req_alu_sra = alu_i_info[E203_DECINFO_ALU_SRA];\n    assign alu_req_alu_or  = alu_i_info[E203_DECINFO_ALU_OR];\n    assign alu_req_alu_and = alu_i_info[E203_DECINFO_ALU_AND];\n    assign alu_req_alu_slt = alu_i_info[E203_DECINFO_ALU_SLT];\n    assign alu_req_alu_sltu = alu_i_info[E203_DECINFO_ALU_SLTU];\n    assign alu_req_alu_lui = alu_i_info[E203_DECINFO_ALU_LUI];\n\n    // Operand selection\n    assign alu_req_alu_op1 = alu_i_info[E203_DECINFO_ALU_OP1PC] ? alu_i_pc : alu_i_rs1;\n    assign alu_req_alu_op2 = alu_i_info[E203_DECINFO_ALU_OP2IMM] ? alu_i_imm : alu_i_rs2;\n\n    // Result from ALU\n    assign alu_o_wbck_wdat = alu_req_alu_res;\n\n    // Special instructions handling\n    assign alu_o_cmt_ecall = alu_i_info[E203_DECINFO_ALU_ECAL];\n    assign alu_o_cmt_ebreak = alu_i_info[E203_DECINFO_ALU_EBRK];\n    assign alu_o_cmt_wfi = alu_i_info[E203_DECINFO_ALU_WFI];\n\n    // Error handling\n    assign alu_o_wbck_err = alu_o_cmt_ecall | alu_o_cmt_ebreak | alu_o_cmt_wfi;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 7, "code": "module e203_exu_alu(\n    input         clk,\n    input         rst_n,\n    input         i_valid,\n    output        i_ready,\n    input  [31:0] i_rs1,\n    input  [31:0] i_rs2,\n    input  [31:0] i_imm,\n    input  [6:0]  i_info,\n    output [31:0] o_result,\n    output        o_valid,\n    input         o_ready\n);\n\n    // Define operation types based on i_info\n    localparam OP_ADD  = 7'b0000001;\n    localparam OP_SUB  = 7'b0000010;\n    localparam OP_AND  = 7'b0000100;\n    localparam OP_OR   = 7'b0001000;\n    localparam OP_XOR  = 7'b0010000;\n    localparam OP_SLL  = 7'b0100000;\n    localparam OP_SRL  = 7'b1000000;\n\n    reg [31:0] result;\n    reg        valid_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            result <= 32'b0;\n            valid_reg <= 1'b0;\n        end else begin\n            if (i_valid && o_ready) begin\n                case (i_info)\n                    OP_ADD: result <= i_rs1 + i_rs2;\n                    OP_SUB: result <= i_rs1 - i_rs2;\n                    OP_AND: result <= i_rs1 & i_rs2;\n                    OP_OR:  result <= i_rs1 | i_rs2;\n                    OP_XOR: result <= i_rs1 ^ i_rs2;\n                    OP_SLL: result <= i_rs1 << i_rs2[4:0];\n                    OP_SRL: result <= i_rs1 >> i_rs2[4:0];\n                    default: result <= 32'b0;\n                endcase\n                valid_reg <= 1'b1;\n            end else if (o_ready) begin\n                valid_reg <= 1'b0;\n            end\n        end\n    end\n\n    assign o_result = result;\n    assign o_valid = valid_reg;\n    assign i_ready = o_ready;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 18, "code": "module e203_exu_alu_lsuagu (\n    input wire agu_i_valid,\n    output wire agu_i_ready,\n    input wire [E203_XLEN-1:0] agu_i_rs1,\n    input wire [E203_XLEN-1:0] agu_i_rs2,\n    input wire [E203_XLEN-1:0] agu_i_imm,\n    input wire [E203_DECINFO_AGU_WIDTH-1:0] agu_i_info,\n    input wire [E203_ITAG_WIDTH-1:0] agu_i_itag,\n    output wire agu_i_longpipe,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire amo_wait,\n    input wire oitf_empty,\n    output wire agu_o_valid,\n    input wire agu_o_ready,\n    output wire [E203_XLEN-1:0] agu_o_wbck_wdat,\n    output wire agu_o_wbck_err,\n    output wire agu_o_cmt_misalgn,\n    output wire agu_o_cmt_ld,\n    output wire agu_o_cmt_stamo,\n    output wire agu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] agu_o_cmt_badaddr,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_cmd_usign,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire [E203_XLEN-1:0] agu_req_alu_op1,\n    output wire [E203_XLEN-1:0] agu_req_alu_op2,\n    output wire agu_req_alu_swap,\n    output wire agu_req_alu_add,\n    output wire agu_req_alu_and,\n    output wire agu_req_alu_or,\n    output wire agu_req_alu_xor,\n    output wire agu_req_alu_max,\n    output wire agu_req_alu_min,\n    output wire agu_req_alu_maxu,\n    output wire agu_req_alu_minu,\n    input wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire agu_sbf_0_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_0_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_0_r,\n    output wire agu_sbf_1_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_1_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_1_r,\n    input wire clk,\n    input wire rst_n\n);\n    // Implementation of the AGU logic goes here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 20, "code": "module e203_exu_alu_dpath(\n    input wire alu_req_alu,\n    input wire alu_req_alu_add,\n    input wire alu_req_alu_sub,\n    input wire alu_req_alu_xor,\n    input wire alu_req_alu_sll,\n    input wire alu_req_alu_srl,\n    input wire alu_req_alu_sra,\n    input wire alu_req_alu_or,\n    input wire alu_req_alu_and,\n    input wire [E203_XLEN-1:0] alu_req_alu_op1,\n    input wire [E203_XLEN-1:0] alu_req_alu_op2,\n    input wire bjp_req_alu,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    input wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    input wire agu_req_alu,\n    input wire [E203_XLEN-1:0] agu_req_alu_op1,\n    input wire [E203_XLEN-1:0] agu_req_alu_op2,\n    input wire muldiv_req_alu,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    input wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    input wire muldiv_req_alu_add,\n    input wire muldiv_req_alu_sub,\n    input wire muldiv_sbf_0_ena,\n    input wire [32:0] muldiv_sbf_0_nxt,\n    input wire muldiv_sbf_1_ena,\n    input wire [32:0] muldiv_sbf_1_nxt,\n    input wire clk,\n    input wire rst_n,\n    output wire [E203_XLEN-1:0] alu_req_alu_res,\n    output wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    output wire bjp_req_alu_cmp_res,\n    output wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output wire [32:0] muldiv_sbf_0_r,\n    output wire [32:0] muldiv_sbf_1_r\n);\n\n    // Internal signals for ALU operations\n    wire [E203_XLEN-1:0] add_res;\n    wire [E203_XLEN-1:0] sub_res;\n    wire [E203_XLEN-1:0] and_res;\n    wire [E203_XLEN-1:0] or_res;\n    wire [E203_XLEN-1:0] xor_res;\n    wire [E203_XLEN-1:0] sll_res;\n    wire [E203_XLEN-1:0] srl_res;\n    wire [E203_XLEN-1:0] sra_res;\n\n    // ALU operations\n    assign add_res = alu_req_alu_op1 + alu_req_alu_op2;\n    assign sub_res = alu_req_alu_op1 - alu_req_alu_op2;\n    assign and_res = alu_req_alu_op1 & alu_req_alu_op2;\n    assign or_res  = alu_req_alu_op1 | alu_req_alu_op2;\n    assign xor_res = alu_req_alu_op1 ^ alu_req_alu_op2;\n    assign sll_res = alu_req_alu_op1 << alu_req_alu_op2[E203_XLEN-1:0];\n    assign srl_res = alu_req_alu_op1 >> alu_req_alu_op2[E203_XLEN-1:0];\n    assign sra_res = $signed(alu_req_alu_op1) >>> alu_req_alu_op2[E203_XLEN-1:0];\n\n    // Result multiplexing\n    assign alu_req_alu_res = ({E203_XLEN{alu_req_alu_add}} & add_res) |\n                             ({E203_XLEN{alu_req_alu_sub}} & sub_res) |\n                             ({E203_XLEN{alu_req_alu_and}} & and_res) |\n                             ({E203_XLEN{alu_req_alu_or}} & or_res) |\n                             ({E203_XLEN{alu_req_alu_xor}} & xor_res) |\n                             ({E203_XLEN{alu_req_alu_sll}} & sll_res) |\n                             ({E203_XLEN{alu_req_alu_srl}} & srl_res) |\n                             ({E203_XLEN{alu_req_alu_sra}} & sra_res);\n\n    // BJP, AGU, and MULDIV results\n    assign bjp_req_alu_add_res = bjp_req_alu_op1 + bjp_req_alu_op2;\n    assign bjp_req_alu_cmp_res = (bjp_req_alu_op1 == bjp_req_alu_op2);\n    assign agu_req_alu_res = agu_req_alu_op1 + agu_req_alu_op2;\n    assign muldiv_req_alu_res = (muldiv_req_alu_add ? muldiv_req_alu_op1 + muldiv_req_alu_op2 :\n                                muldiv_req_alu_sub ? muldiv_req_alu_op1 - muldiv_req_alu_op2 : 0);\n\n    // Shared buffers\n    sirv_gnrl_dffl #(33) sbf_0_dffl (\n        .lden(muldiv_sbf_0_ena),\n        .dnxt(muldiv_sbf_0_nxt),\n        .qout(muldiv_sbf_0_r),\n        .clk(clk)\n    );\n\n    sirv_gnrl_dffl #(33) sbf_1_dffl (\n        .lden(muldiv_sbf_1_ena),\n        .dnxt(muldiv_sbf_1_nxt),\n        .qout(muldiv_sbf_1_r),\n        .clk(clk)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 7, "code": "module itcm_controller #(\n    parameter ADDR_WIDTH = 32,\n    parameter DATA_WIDTH = 64,\n    parameter WMSK_WIDTH = DATA_WIDTH / 8,\n    parameter RAM_AW = 10,\n    parameter RAM_MW = WMSK_WIDTH,\n    parameter RAM_DW = DATA_WIDTH\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n\n    // System Interface\n    output wire itcm_active,\n\n    // IFU Interface\n    input wire ifu2itcm_icb_cmd_valid,\n    output wire ifu2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] ifu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] ifu2itcm_icb_cmd_wmask,\n    output wire ifu2itcm_icb_rsp_valid,\n    input wire ifu2itcm_icb_rsp_ready,\n    output wire ifu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n\n    // LSU Interface (Assuming same as IFU)\n    input wire lsu2itcm_icb_cmd_valid,\n    output wire lsu2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] lsu2itcm_icb_cmd_addr,\n    input wire lsu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] lsu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] lsu2itcm_icb_cmd_wmask,\n    output wire lsu2itcm_icb_rsp_valid,\n    input wire lsu2itcm_icb_rsp_ready,\n    output wire lsu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] lsu2itcm_icb_rsp_rdata,\n\n    // RAM Interface\n    output wire itcm_ram_cs,\n    output wire itcm_ram_we,\n    output wire [RAM_AW-1:0] itcm_ram_addr,\n    output wire [RAM_MW-1:0] itcm_ram_wem,\n    output wire [RAM_DW-1:0] itcm_ram_din,\n    input wire [RAM_DW-1:0] itcm_ram_dout,\n    output wire clk_itcm_ram\n);\n\n    // Internal signals\n    wire [ADDR_WIDTH-1:0] selected_addr;\n    wire [DATA_WIDTH-1:0] selected_wdata;\n    wire [WMSK_WIDTH-1:0] selected_wmask;\n    wire selected_read;\n    wire selected_valid;\n    wire selected_ready;\n    wire [DATA_WIDTH-1:0] selected_rdata;\n    wire selected_rsp_valid;\n    wire selected_rsp_ready;\n    wire selected_rsp_err;\n\n    // Arbitration logic (simple round-robin or priority based)\n    // Assuming priority to IFU over LSU for simplicity in this example\n    assign ifu2itcm_icb_cmd_ready = ~lsu2itcm_icb_cmd_valid;\n    assign lsu2itcm_icb_cmd_ready = ~ifu2itcm_icb_cmd_valid & selected_ready;\n\n    assign selected_addr = ifu2itcm_icb_cmd_valid ? ifu2itcm_icb_cmd_addr : lsu2itcm_icb_cmd_addr;\n    assign selected_wdata = ifu2itcm_icb_cmd_valid ? ifu2itcm_icb_cmd_wdata : lsu2itcm_icb_cmd_wdata;\n    assign selected_wmask = ifu2itcm_icb_cmd_valid ? ifu2itcm_icb_cmd_wmask : lsu2itcm_icb_cmd_wmask;\n    assign selected_read = ifu2itcm_icb_cmd_valid ? ifu2itcm_icb_cmd_read : lsu2itcm_icb_cmd_read;\n    assign selected_valid = ifu2itcm_icb_cmd_valid | lsu2itcm_icb_cmd_valid;\n\n    // RAM interface logic\n    assign itcm_ram_cs = selected_valid & selected_ready;\n    assign itcm_ram_we = ~selected_read;\n    assign itcm_ram_addr = selected_addr[RAM_AW-1:0]; // Assuming address is aligned\n    assign itcm_ram_wem = selected_wmask;\n    assign itcm_ram_din = selected_wdata;\n\n    // Response logic\n    assign selected_rsp_valid = itcm_ram_cs & selected_read;\n    assign selected_rdata = itcm_ram_dout;\n    assign selected_rsp_err = 0; // No error handling in this simple example\n\n    // Connect response back to IFU and LSU\n    assign ifu2itcm_icb_rsp_valid = ifu2itcm_icb_cmd_valid & selected_rsp_valid;\n    assign ifu2itcm_icb_rsp_rdata = selected_rdata;\n    assign ifu2itcm_icb_rsp_err = selected_rsp_err;\n\n    assign lsu2itcm_icb_rsp_valid = lsu2itcm_icb_cmd_valid & selected_rsp_valid;\n    assign lsu2itcm_icb_rsp_rdata = selected_rdata;\n    assign lsu2itcm_icb_rsp_err = selected_rsp_err;\n\n    // Clock gating logic\n    assign clk_itcm_ram = clk & ~tcm_cgstop;\n\n    // Active status output\n    assign itcm_active = selected_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 10, "code": "module e203_exu_commit(\n    output commit_mret,\n    output commit_trap,\n    output core_wfi,\n    output nonflush_cmt_ena,\n    output excp_active,\n    input amo_wait,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input alu_cmt_i_valid,\n    output alu_cmt_i_ready,\n    input [E203_PC_SIZE-1:0] alu_cmt_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_cmt_i_instr,\n    input alu_cmt_i_pc_vld,\n    input [E203_XLEN-1:0] alu_cmt_i_imm,\n    input alu_cmt_i_rv32,\n    input alu_cmt_i_bjp,\n    input alu_cmt_i_wfi,\n    input alu_cmt_i_fencei,\n    input alu_cmt_i_mret,\n    input alu_cmt_i_dret,\n    input alu_cmt_i_ecall,\n    input alu_cmt_i_ebreak,\n    input alu_cmt_i_ifu_misalgn,\n    input alu_cmt_i_ifu_buserr,\n    input alu_cmt_i_ifu_ilegl,\n    input alu_cmt_i_bjp_prdt,\n    input alu_cmt_i_bjp_rslv,\n    input alu_cmt_i_misalgn,\n    input alu_cmt_i_ld,\n    input alu_cmt_i_stamo,\n    input alu_cmt_i_buserr,\n    input [E203_ADDR_SIZE-1:0] alu_cmt_i_badaddr,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output cmt_badaddr_ena,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output cmt_epc_ena,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_cause_ena,\n    output cmt_instret_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output cmt_mret_ena,\n    input [E203_PC_SIZE-1:0] csr_epc_r,\n    input [E203_PC_SIZE-1:0] csr_dpc_r,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output longp_excp_i_ready,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input longp_excp_i_insterr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc\n);\n    // Implementation of the commit logic and exception handling\n    // This is a placeholder for the actual logic which would handle the commit stage\n    // including traps, exceptions, and instruction commits based on the inputs.\n\n    assign commit_mret = alu_cmt_i_mret;\n    assign commit_trap = alu_cmt_i_ecall | alu_cmt_i_ebreak | alu_cmt_i_buserr;\n    assign core_wfi = alu_cmt_i_wfi;\n    assign nonflush_cmt_ena = alu_cmt_i_valid & ~commit_trap;\n    assign excp_active = commit_trap;\n\n    assign alu_cmt_i_ready = ~amo_wait; // Ready when not waiting on AMO\n\n    // Example handling for WFI halt requests\n    assign wfi_halt_ifu_req = alu_cmt_i_wfi;\n    assign wfi_halt_exu_req = alu_cmt_i_wfi;\n\n    // Example handling for bad address and exception program counter\n    assign cmt_badaddr = alu_cmt_i_badaddr;\n    assign cmt_badaddr_ena = alu_cmt_i_buserr | alu_cmt_i_ld | alu_cmt_i_stamo;\n    assign cmt_epc = alu_cmt_i_pc;\n    assign cmt_epc_ena = commit_trap;\n\n    // Example handling for exception cause\n    assign cmt_cause = {E203_XLEN{1'b0}}; // Placeholder for actual cause\n    assign cmt_cause_ena = commit_trap;\n\n    // Example handling for debug features\n    assign cmt_dpc = csr_dpc_r;\n    assign cmt_dpc_ena = dbg_mode & dbg_halt_r;\n    assign cmt_dcause = 3'b000; // Placeholder for actual debug cause\n    assign cmt_dcause_ena = dbg_mode & dbg_halt_r;\n\n    // Example handling for machine return enable\n    assign cmt_mret_ena = alu_cmt_i_mret;\n\n    // Placeholder for long-pipe exception handling\n    assign longp_excp_i_ready = 1'b1; // Always ready to accept long-pipe exceptions in this example\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 18, "code": "module e203_exu_longpwbck (\n    input wire lsu_wbck_i_valid,\n    output wire lsu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] lsu_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] lsu_wbck_i_itag,\n    input wire lsu_wbck_i_err,\n    input wire lsu_cmt_i_buserr,\n    input wire [E203_ADDR_SIZE-1:0] lsu_cmt_i_badaddr,\n    input wire lsu_cmt_i_ld,\n    input wire lsu_cmt_i_st,\n    output wire longp_wbck_o_valid,\n    input wire longp_wbck_o_ready,\n    output wire [E203_FLEN-1:0] longp_wbck_o_wdat,\n    output wire [4:0] longp_wbck_o_flags,\n    output wire [E203_RFIDX_WIDTH-1:0] longp_wbck_o_rdidx,\n    output wire longp_wbck_o_rdfpu,\n    output wire longp_excp_o_valid,\n    input wire longp_excp_o_ready,\n    output wire longp_excp_o_insterr,\n    output wire longp_excp_o_ld,\n    output wire longp_excp_o_st,\n    output wire longp_excp_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] longp_excp_o_badaddr,\n    output wire [E203_PC_SIZE-1:0] longp_excp_o_pc,\n    input wire oitf_empty,\n    input wire [E203_ITAG_WIDTH-1:0] oitf_ret_ptr,\n    input wire [E203_RFIDX_WIDTH-1:0] oitf_ret_rdidx,\n    input wire [E203_PC_SIZE-1:0] oitf_ret_pc,\n    input wire oitf_ret_rdwen,\n    input wire oitf_ret_rdfpu,\n    output wire oitf_ret_ena,\n    input wire clk,\n    input wire rst_n\n`ifdef E203_HAS_NICE\n    , input wire nice_longp_wbck_i_valid,\n    output wire nice_longp_wbck_i_ready,\n    input wire [E203_XLEN-1:0] nice_longp_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] nice_longp_wbck_i_itag,\n    input wire nice_longp_wbck_i_err\n`endif\n);\n\n    // Write-back and exception arbitration logic\n    wire wbck_need = oitf_ret_rdwen && !lsu_wbck_i_err;\n    wire excp_need = lsu_wbck_i_err;\n    wire wbck_ready = longp_wbck_o_ready || !wbck_need;\n    wire excp_ready = longp_excp_o_ready || !excp_need;\n\n    assign lsu_wbck_i_ready = wbck_ready && excp_ready;\n\n    // Write-back data selection and flag generation\n    assign longp_wbck_o_valid = lsu_wbck_i_valid && wbck_need && wbck_ready;\n    assign longp_wbck_o_wdat = lsu_wbck_i_wdat;\n    assign longp_wbck_o_flags = {lsu_cmt_i_ld, lsu_cmt_i_st, 3'b000}; // Example flags\n    assign longp_wbck_o_rdidx = oitf_ret_rdidx;\n    assign longp_wbck_o_rdfpu = oitf_ret_rdfpu;\n\n    // Exception handling\n    assign longp_excp_o_valid = lsu_wbck_i_valid && excp_need && excp_ready;\n    assign longp_excp_o_insterr = lsu_wbck_i_err;\n    assign longp_excp_o_ld = lsu_cmt_i_ld;\n    assign longp_excp_o_st = lsu_cmt_i_st;\n    assign longp_excp_o_buserr = lsu_cmt_i_buserr;\n    assign longp_excp_o_badaddr = lsu_cmt_i_badaddr;\n    assign longp_excp_o_pc = oitf_ret_pc;\n\n    // OITF control\n    assign oitf_ret_ena = lsu_wbck_i_ready && lsu_wbck_i_valid;\n\n`ifdef E203_HAS_NICE\n    // NICE module write-back handling\n    assign nice_longp_wbck_i_ready = wbck_ready && excp_ready;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 5, "code": "module e203_lsu_ctrl (\n    input wire commit_mret,\n    input wire commit_trap,\n    output wire lsu_ctrl_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    input wire nice_mem_holdup,\n    input wire nice_icb_cmd_valid,\n    output wire nice_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] nice_icb_cmd_addr,\n    input wire nice_icb_cmd_read,\n    input wire [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] nice_icb_cmd_wmask,\n    output wire nice_icb_rsp_valid,\n    input wire nice_icb_rsp_ready,\n    output wire nice_icb_rsp_err,\n    output wire [E203_XLEN-1:0] nice_icb_rsp_rdata,\n\n    output wire dcache_icb_cmd_valid,\n    input wire dcache_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] dcache_icb_cmd_addr,\n    output wire dcache_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dcache_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dcache_icb_cmd_wmask,\n    output wire dcache_icb_cmd_lock,\n    output wire dcache_icb_cmd_excl,\n    output wire [1:0] dcache_icb_cmd_size,\n    input wire dcache_icb_rsp_valid,\n    output wire dcache_icb_rsp_ready,\n    input wire dcache_icb_rsp_err,\n    input wire dcache_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dcache_icb_rsp_rdata,\n\n    output wire dtcm_icb_cmd_valid,\n    input wire dtcm_icb_cmd_ready,\n    output wire [E203_DTCM_ADDR_WIDTH-1:0] dtcm_icb_cmd_addr,\n    output wire dtcm_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dtcm_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dtcm_icb_cmd_wmask,\n    output wire dtcm_icb_cmd_lock,\n    output wire dtcm_icb_cmd_excl,\n    output wire [1:0] dtcm_icb_cmd_size,\n    input wire dtcm_icb_rsp_valid,\n    output wire dtcm_icb_rsp_ready,\n    input wire dtcm_icb_rsp_err,\n    input wire dtcm_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dtcm_icb_rsp_rdata,\n    input wire [E203_ADDR_SIZE-1:0] dtcm_region_indic,\n\n    output wire biu_icb_cmd_valid,\n    input wire biu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,\n    output wire biu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] biu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] biu_icb_cmd_wmask,\n    output wire biu_icb_cmd_lock,\n    output wire biu_icb_cmd_excl,\n    output wire [1:0] biu_icb_cmd_size,\n    input wire biu_icb_rsp_valid,\n    output wire biu_icb_rsp_ready,\n    input wire biu_icb_rsp_err,\n    input wire biu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] biu_icb_rsp_rdata\n);\n    // Module implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 13, "code": "module e203_exu_csr(\n    input wire nonflush_cmt_ena,\n    input wire csr_ena,\n    input wire csr_wr_en,\n    input wire csr_rd_en,\n    input wire [11:0] csr_idx,\n    output wire csr_access_ilgl,\n    output wire tm_stop,\n    output wire core_cgstop,\n    output wire tcm_cgstop,\n    output wire itcm_nohold,\n    output wire mdv_nob2b,\n    output wire [E203_XLEN-1:0] read_csr_dat,\n    input wire [E203_XLEN-1:0] wbck_csr_dat,\n    input wire [E203_HART_ID_W-1:0] core_mhartid,\n    input wire ext_irq_r,\n    input wire sft_irq_r,\n    input wire tmr_irq_r,\n    output wire status_mie_r,\n    output wire mtie_r,\n    output wire msie_r,\n    output wire meie_r,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    input wire [E203_XLEN-1:0] dcsr_r,\n    input wire [E203_PC_SIZE-1:0] dpc_r,\n    input wire [E203_XLEN-1:0] dscratch_r,\n    output wire u_mode,\n    output wire s_mode,\n    output wire h_mode,\n    output wire m_mode,\n    input wire [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    input wire cmt_badaddr_ena,\n    input wire [E203_PC_SIZE-1:0] cmt_epc,\n    input wire cmt_epc_ena,\n    input wire [E203_XLEN-1:0] cmt_cause,\n    input wire cmt_cause_ena,\n    input wire cmt_status_ena,\n    input wire cmt_instret_ena,\n    input wire cmt_mret_ena,\n    output wire [E203_PC_SIZE-1:0] csr_epc_r,\n    output wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    output wire [E203_XLEN-1:0] csr_mtvec_r,\n    input wire clk_aon,\n    input wire clk,\n    input wire rst_n\n    `ifdef E203_HAS_NICE\n    , output wire nice_xs_off\n    `endif\n);\n\n    // CSR logic implementation\n    // Note: This is a simplified example and does not include actual CSR logic.\n    // The actual implementation would involve decoding csr_idx and performing\n    // read or write operations based on csr_wr_en and csr_rd_en signals.\n\n    assign csr_access_ilgl = 0; // Assuming no illegal access in this example\n    assign tm_stop = 0;\n    assign core_cgstop = 0;\n    assign tcm_cgstop = 0;\n    assign itcm_nohold = 0;\n    assign mdv_nob2b = 0;\n    assign read_csr_dat = 0; // Default read data\n    assign status_mie_r = 0;\n    assign mtie_r = 0;\n    assign msie_r = 0;\n    assign meie_r = 0;\n    assign wr_dcsr_ena = 0;\n    assign wr_dpc_ena = 0;\n    assign wr_dscratch_ena = 0;\n    assign u_mode = 0;\n    assign s_mode = 0;\n    assign h_mode = 0;\n    assign m_mode = 1; // Only machine mode supported\n    assign csr_epc_r = 0;\n    assign csr_dpc_r = 0;\n    assign csr_mtvec_r = 0;\n\n    `ifdef E203_HAS_NICE\n    assign nice_xs_off = 1; // Example: NICE is closed\n    `endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 11, "code": "module e203_exu_disp (\n    input wfi_halt_exu_req,\n    output reg wfi_halt_exu_ack,\n    input oitf_empty,\n    input amo_wait,\n    input disp_i_valid,\n    output reg disp_i_ready,\n    input disp_i_rs1x0,\n    input disp_i_rs2x0,\n    input disp_i_rs1en,\n    input disp_i_rs2en,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input [E203_XLEN-1:0] disp_i_rs1,\n    input [E203_XLEN-1:0] disp_i_rs2,\n    input disp_i_rdwen,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input [E203_DECINFO_WIDTH-1:0] disp_i_info,\n    input [E203_XLEN-1:0] disp_i_imm,\n    input [E203_PC_SIZE-1:0] disp_i_pc,\n    input disp_i_misalgn,\n    input disp_i_buserr,\n    input disp_i_ilegl,\n    output reg disp_o_alu_valid,\n    input disp_o_alu_ready,\n    input disp_o_alu_longpipe,\n    output reg [E203_XLEN-1:0] disp_o_alu_rs1,\n    output reg [E203_XLEN-1:0] disp_o_alu_rs2,\n    output reg disp_o_alu_rdwen,\n    output reg [E203_RFIDX_WIDTH-1:0] disp_o_alu_rdidx,\n    output reg [E203_DECINFO_WIDTH-1:0] disp_o_alu_info,\n    output reg [E203_XLEN-1:0] disp_o_alu_imm,\n    output reg [E203_PC_SIZE-1:0] disp_o_alu_pc,\n    output reg [E203_ITAG_WIDTH-1:0] disp_o_alu_itag,\n    output reg disp_o_alu_misalgn,\n    output reg disp_o_alu_buserr,\n    output reg disp_o_alu_ilegl,\n    input oitfrd_match_disprs1,\n    input oitfrd_match_disprs2,\n    input oitfrd_match_disprs3,\n    input oitfrd_match_disprd,\n    input [E203_ITAG_WIDTH-1:0] disp_oitf_ptr,\n    output reg disp_oitf_ena,\n    input disp_oitf_ready,\n    output reg disp_oitf_rs1fpu,\n    output reg disp_oitf_rs2fpu,\n    output reg disp_oitf_rs3fpu,\n    output reg disp_oitf_rdfpu,\n    output reg disp_oitf_rs1en,\n    output reg disp_oitf_rs2en,\n    output reg disp_oitf_rs3en,\n    output reg disp_oitf_rdwen,\n    output reg [E203_RFIDX_WIDTH-1:0] disp_oitf_rs1idx,\n    output reg [E203_RFIDX_WIDTH-1:0] disp_oitf_rs2idx,\n    output reg [E203_RFIDX_WIDTH-1:0] disp_oitf_rs3idx,\n    output reg [E203_RFIDX_WIDTH-1:0] disp_oitf_rdidx,\n    output reg [E203_PC_SIZE-1:0] disp_oitf_pc,\n    input clk,\n    input rst_n\n);\n\n    always @(*) begin\n        // Default assignments\n        disp_i_ready = 1'b0;\n        disp_o_alu_valid = 1'b0;\n        disp_o_alu_rs1 = disp_i_rs1;\n        disp_o_alu_rs2 = disp_i_rs2;\n        disp_o_alu_rdwen = disp_i_rdwen;\n        disp_o_alu_rdidx = disp_i_rdidx;\n        disp_o_alu_info = disp_i_info;\n        disp_o_alu_imm = disp_i_imm;\n        disp_o_alu_pc = disp_i_pc;\n        disp_o_alu_itag = disp_oitf_ptr;\n        disp_o_alu_misalgn = disp_i_misalgn;\n        disp_o_alu_buserr = disp_i_buserr;\n        disp_o_alu_ilegl = disp_i_ilegl;\n\n        // WFI handling\n        if (wfi_halt_exu_req && oitf_empty && !amo_wait) begin\n            wfi_halt_exu_ack = 1'b1;\n        end else begin\n            wfi_halt_exu_ack = 1'b0;\n        end\n\n        // Dispatch logic\n        if (disp_i_valid && disp_o_alu_ready && !wfi_halt_exu_req && !amo_wait) begin\n            disp_i_ready = 1'b1;\n            disp_o_alu_valid = 1'b1;\n        end\n\n        // Operand forwarding and masking\n        if (disp_i_rs1x0) begin\n            disp_o_alu_rs1 = {E203_XLEN{1'b0}};\n        end\n        if (disp_i_rs2x0) begin\n            disp_o_alu_rs2 = {E203_XLEN{1'b0}};\n        end\n\n        // OITF dispatch logic\n        disp_oitf_ena = disp_o_alu_longpipe && disp_o_alu_valid && disp_oitf_ready;\n        disp_oitf_rs1fpu = 1'b0; // Assuming no FPU\n        disp_oitf_rs2fpu = 1'b0;\n        disp_oitf_rs3fpu = 1'b0;\n        disp_oitf_rdfpu = 1'b0;\n        disp_oitf_rs1en = disp_i_rs1en;\n        disp_oitf_rs2en = disp_i_rs2en;\n        disp_oitf_rs3en = 1'b0; // Assuming no third operand\n        disp_oitf_rdwen = disp_i_rdwen;\n        disp_oitf_rs1idx = disp_i_rs1idx;\n        disp_oitf_rs2idx = disp_i_rs2idx;\n        disp_oitf_rs3idx = {E203_RFIDX_WIDTH{1'b0}};\n        disp_oitf_rdidx = disp_i_rdidx;\n        disp_oitf_pc = disp_i_pc;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 10, "code": "module e203_ifu_ift2icb (\n    input wire itcm_nohold,\n    input wire ifu_req_valid,\n    input wire [PC_SIZE-1:0] ifu_req_pc,\n    input wire ifu_req_seq,\n    input wire ifu_req_seq_rv32,\n    input wire [PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_ready,\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_ready,\n    output wire ifu_rsp_valid,\n    output wire ifu_rsp_err,\n    output wire [31:0] ifu_rsp_instr,\n    output wire ifu2itcm_icb_cmd_valid,\n    input wire ifu2itcm_icb_cmd_ready,\n    output wire [ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_rsp_valid,\n    output wire ifu2itcm_icb_rsp_ready,\n    input wire ifu2itcm_icb_rsp_err,\n    input wire [ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    output wire ifu2biu_icb_cmd_valid,\n    input wire ifu2biu_icb_cmd_ready,\n    output wire [ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input wire ifu2biu_icb_rsp_valid,\n    output wire ifu2biu_icb_rsp_ready,\n    input wire ifu2biu_icb_rsp_err,\n    input wire [SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata\n);\n\n    // State machine definition\n    reg [1:0] icb_state;\n    localparam ICB_STATE_IDLE = 2'b00;\n    localparam ICB_STATE_1ST = 2'b01;\n    localparam ICB_STATE_WAIT2ND = 2'b10;\n    localparam ICB_STATE_2ND = 2'b11;\n\n    // State transition and output logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            icb_state <= ICB_STATE_IDLE;\n        end else begin\n            case (icb_state)\n                ICB_STATE_IDLE: begin\n                    if (ifu_req_valid && ifu_req_ready)\n                        icb_state <= ICB_STATE_1ST;\n                end\n                ICB_STATE_1ST: begin\n                    if (ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid)\n                        icb_state <= (ifu_req_valid && ifu_req_ready) ? ICB_STATE_1ST : ICB_STATE_IDLE;\n                end\n                ICB_STATE_WAIT2ND: begin\n                    if (ifu2itcm_icb_cmd_ready || ifu2biu_icb_cmd_ready)\n                        icb_state <= ICB_STATE_2ND;\n                end\n                ICB_STATE_2ND: begin\n                    if (ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid)\n                        icb_state <= (ifu_req_valid && ifu_req_ready) ? ICB_STATE_1ST : ICB_STATE_IDLE;\n                end\n            endcase\n        end\n    end\n\n    // Output logic for ICB command and response interfaces\n    assign ifu2itcm_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && (ifu_req_pc < `ITCM_ADDR_LIMIT);\n    assign ifu2itcm_icb_cmd_addr = ifu_req_pc;\n    assign ifu2itcm_icb_rsp_ready = ifu_rsp_ready;\n\n    assign ifu2biu_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && (ifu_req_pc >= `ITCM_ADDR_LIMIT);\n    assign ifu2biu_icb_cmd_addr = ifu_req_pc;\n    assign ifu2biu_icb_rsp_ready = ifu_rsp_ready;\n\n    // Output logic for IFU interface\n    assign ifu_req_ready = (icb_state == ICB_STATE_IDLE) || (icb_state == ICB_STATE_2ND && (ifu2itcm_icb_cmd_ready || ifu2biu_icb_cmd_ready));\n    assign ifu_rsp_valid = ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid;\n    assign ifu_rsp_err = ifu2itcm_icb_rsp_err || ifu2biu_icb_rsp_err;\n    assign ifu_rsp_instr = ifu2itcm_icb_rsp_valid ? ifu2itcm_icb_rsp_rdata[31:0] : ifu2biu_icb_rsp_rdata[31:0];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 19, "code": "module e203_exu_alu_lsuagu (\n    input wire agu_i_valid,\n    output wire agu_i_ready,\n    input wire [E203_XLEN-1:0] agu_i_rs1,\n    input wire [E203_XLEN-1:0] agu_i_rs2,\n    input wire [E203_XLEN-1:0] agu_i_imm,\n    input wire [E203_DECINFO_AGU_WIDTH-1:0] agu_i_info,\n    input wire [E203_ITAG_WIDTH-1:0] agu_i_itag,\n    output wire agu_i_longpipe,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire amo_wait,\n    input wire oitf_empty,\n    output wire agu_o_valid,\n    input wire agu_o_ready,\n    output wire [E203_XLEN-1:0] agu_o_wbck_wdat,\n    output wire agu_o_wbck_err,\n    output wire agu_o_cmt_misalgn,\n    output wire agu_o_cmt_ld,\n    output wire agu_o_cmt_stamo,\n    output wire agu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] agu_o_cmt_badaddr,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_cmd_usign,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire [E203_XLEN-1:0] agu_req_alu_op1,\n    output wire [E203_XLEN-1:0] agu_req_alu_op2,\n    output wire agu_req_alu_swap,\n    output wire agu_req_alu_add,\n    output wire agu_req_alu_and,\n    output wire agu_req_alu_or,\n    output wire agu_req_alu_xor,\n    output wire agu_req_alu_max,\n    output wire agu_req_alu_min,\n    output wire agu_req_alu_maxu,\n    output wire agu_req_alu_minu,\n    input wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire agu_sbf_0_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_0_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_0_r,\n    output wire agu_sbf_1_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_1_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_1_r,\n    input wire clk,\n    input wire rst_n\n);\n    // Implementation of the AGU logic goes here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 20, "code": "module e203_exu_alu_lsuagu (\n    input wire agu_i_valid,\n    output wire agu_i_ready,\n    input wire [E203_XLEN-1:0] agu_i_rs1,\n    input wire [E203_XLEN-1:0] agu_i_rs2,\n    input wire [E203_XLEN-1:0] agu_i_imm,\n    input wire [E203_DECINFO_AGU_WIDTH-1:0] agu_i_info,\n    input wire [E203_ITAG_WIDTH-1:0] agu_i_itag,\n    output wire agu_i_longpipe,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire amo_wait,\n    input wire oitf_empty,\n    output wire agu_o_valid,\n    input wire agu_o_ready,\n    output wire [E203_XLEN-1:0] agu_o_wbck_wdat,\n    output wire agu_o_wbck_err,\n    output wire agu_o_cmt_misalgn,\n    output wire agu_o_cmt_ld,\n    output wire agu_o_cmt_stamo,\n    output wire agu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] agu_o_cmt_badaddr,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_cmd_usign,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire [E203_XLEN-1:0] agu_req_alu_op1,\n    output wire [E203_XLEN-1:0] agu_req_alu_op2,\n    output wire agu_req_alu_swap,\n    output wire agu_req_alu_add,\n    output wire agu_req_alu_and,\n    output wire agu_req_alu_or,\n    output wire agu_req_alu_xor,\n    output wire agu_req_alu_max,\n    output wire agu_req_alu_min,\n    output wire agu_req_alu_maxu,\n    output wire agu_req_alu_minu,\n    input wire [E203_XLEN-1:0] agu_req_alu_res,\n    output wire agu_sbf_0_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_0_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_0_r,\n    output wire agu_sbf_1_ena,\n    output wire [E203_XLEN-1:0] agu_sbf_1_nxt,\n    input wire [E203_XLEN-1:0] agu_sbf_1_r,\n    input wire clk,\n    input wire rst_n\n);\n    // Implementation of AGU logic here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 7, "code": "module e203_exu_excp(\n    output commit_trap,\n    output core_wfi,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input amo_wait,\n    input alu_excp_i_valid,\n    input alu_excp_i_ld,\n    input alu_excp_i_stamo,\n    input alu_excp_i_misalgn,\n    input alu_excp_i_buserr,\n    input alu_excp_i_ecall,\n    input alu_excp_i_ebreak,\n    input alu_excp_i_wfi,\n    input alu_excp_i_ifu_misalgn,\n    input alu_excp_i_ifu_buserr,\n    input alu_excp_i_ifu_ilegl,\n    input [E203_PC_SIZE-1:0] alu_excp_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_excp_i_instr,\n    input alu_excp_i_pc_vld,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input longp_excp_i_insterr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input excpirq_flush_ack,\n    output excpirq_flush_req,\n    output nonalu_excpirq_flush_req_raw,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op1,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op2,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input cmt_dret_ena,\n    input cmt_ena,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_badaddr_ena,\n    output cmt_epc_ena,\n    output cmt_cause_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output excp_active,\n    input clk,\n    input rst_n\n);\n    // Module implementation\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 11, "code": "module e203_exu_commit(\n    output commit_mret,\n    output commit_trap,\n    output core_wfi,\n    output nonflush_cmt_ena,\n    output excp_active,\n    input amo_wait,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input alu_cmt_i_valid,\n    output alu_cmt_i_ready,\n    input [E203_PC_SIZE-1:0] alu_cmt_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_cmt_i_instr,\n    input alu_cmt_i_pc_vld,\n    input [E203_XLEN-1:0] alu_cmt_i_imm,\n    input alu_cmt_i_rv32,\n    input alu_cmt_i_bjp,\n    input alu_cmt_i_wfi,\n    input alu_cmt_i_fencei,\n    input alu_cmt_i_mret,\n    input alu_cmt_i_dret,\n    input alu_cmt_i_ecall,\n    input alu_cmt_i_ebreak,\n    input alu_cmt_i_ifu_misalgn,\n    input alu_cmt_i_ifu_buserr,\n    input alu_cmt_i_ifu_ilegl,\n    input alu_cmt_i_bjp_prdt,\n    input alu_cmt_i_bjp_rslv,\n    input alu_cmt_i_misalgn,\n    input alu_cmt_i_ld,\n    input alu_cmt_i_stamo,\n    input alu_cmt_i_buserr,\n    input [E203_ADDR_SIZE-1:0] alu_cmt_i_badaddr,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output cmt_badaddr_ena,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output cmt_epc_ena,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_cause_ena,\n    output cmt_instret_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output cmt_mret_ena,\n    input [E203_PC_SIZE-1:0] csr_epc_r,\n    input [E203_PC_SIZE-1:0] csr_dpc_r,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output longp_excp_i_ready,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input longp_excp_i_insterr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input clk,\n    input rst_n\n);\n    // Module implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 14, "code": "module e203_exu_csr (\n    input wire nonflush_cmt_ena,\n    input wire csr_ena,\n    input wire csr_wr_en,\n    input wire csr_rd_en,\n    input wire [11:0] csr_idx,\n    output wire csr_access_ilgl,\n    output wire tm_stop,\n    output wire core_cgstop,\n    output wire tcm_cgstop,\n    output wire itcm_nohold,\n    output wire mdv_nob2b,\n    output wire [E203_XLEN-1:0] read_csr_dat,\n    input wire [E203_XLEN-1:0] wbck_csr_dat,\n    input wire [E203_HART_ID_W-1:0] core_mhartid,\n    input wire ext_irq_r,\n    input wire sft_irq_r,\n    input wire tmr_irq_r,\n    output wire status_mie_r,\n    output wire mtie_r,\n    output wire msie_r,\n    output wire meie_r,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    input wire [E203_XLEN-1:0] dcsr_r,\n    input wire [E203_PC_SIZE-1:0] dpc_r,\n    input wire [E203_XLEN-1:0] dscratch_r,\n    output wire u_mode,\n    output wire s_mode,\n    output wire h_mode,\n    output wire m_mode,\n    input wire [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    input wire cmt_badaddr_ena,\n    input wire [E203_PC_SIZE-1:0] cmt_epc,\n    input wire cmt_epc_ena,\n    input wire [E203_XLEN-1:0] cmt_cause,\n    input wire cmt_cause_ena,\n    input wire cmt_status_ena,\n    input wire cmt_instret_ena,\n    input wire cmt_mret_ena,\n    output wire [E203_PC_SIZE-1:0] csr_epc_r,\n    output wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    output wire [E203_XLEN-1:0] csr_mtvec_r,\n    input wire clk_aon,\n    input wire clk,\n    input wire rst_n\n);\n\n// Implementation of CSR logic here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 12, "code": "module e203_exu_commit(\n    output commit_mret,\n    output commit_trap,\n    output core_wfi,\n    output nonflush_cmt_ena,\n    output excp_active,\n    input amo_wait,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input alu_cmt_i_valid,\n    output alu_cmt_i_ready,\n    input [E203_PC_SIZE-1:0] alu_cmt_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_cmt_i_instr,\n    input alu_cmt_i_pc_vld,\n    input [E203_XLEN-1:0] alu_cmt_i_imm,\n    input alu_cmt_i_rv32,\n    input alu_cmt_i_bjp,\n    input alu_cmt_i_wfi,\n    input alu_cmt_i_fencei,\n    input alu_cmt_i_mret,\n    input alu_cmt_i_dret,\n    input alu_cmt_i_ecall,\n    input alu_cmt_i_ebreak,\n    input alu_cmt_i_ifu_misalgn,\n    input alu_cmt_i_ifu_buserr,\n    input alu_cmt_i_ifu_ilegl,\n    input alu_cmt_i_bjp_prdt,\n    input alu_cmt_i_bjp_rslv,\n    input alu_cmt_i_misalgn,\n    input alu_cmt_i_ld,\n    input alu_cmt_i_stamo,\n    input alu_cmt_i_buserr,\n    input [E203_ADDR_SIZE-1:0] alu_cmt_i_badaddr,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output cmt_badaddr_ena,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output cmt_epc_ena,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_cause_ena,\n    output cmt_instret_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output cmt_mret_ena,\n    input [E203_PC_SIZE-1:0] csr_epc_r,\n    input [E203_PC_SIZE-1:0] csr_dpc_r,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output longp_excp_i_ready,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input longp_excp_i_insterr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc\n);\n    // Module implementation\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 19, "code": "module e203_dtcm_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n\n    // LSU ICB Interface\n    input wire lsu2dtcm_icb_cmd_valid,\n    output wire lsu2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] lsu2dtcm_icb_cmd_addr,\n    input wire lsu2dtcm_icb_cmd_read,\n    input wire [31:0] lsu2dtcm_icb_cmd_wdata,\n    input wire [3:0] lsu2dtcm_icb_cmd_wmask,\n    output wire lsu2dtcm_icb_rsp_valid,\n    input wire lsu2dtcm_icb_rsp_ready,\n    output wire lsu2dtcm_icb_rsp_err,\n    output wire [31:0] lsu2dtcm_icb_rsp_rdata,\n\n    // External ICB Interface (optional)\n    `ifdef E203_HAS_DTCM_EXTITF\n    input wire ext2dtcm_icb_cmd_valid,\n    output wire ext2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] ext2dtcm_icb_cmd_addr,\n    input wire ext2dtcm_icb_cmd_read,\n    input wire [31:0] ext2dtcm_icb_cmd_wdata,\n    input wire [3:0] ext2dtcm_icb_cmd_wmask,\n    output wire ext2dtcm_icb_rsp_valid,\n    input wire ext2dtcm_icb_rsp_ready,\n    output wire ext2dtcm_icb_rsp_err,\n    output wire [31:0] ext2dtcm_icb_rsp_rdata,\n    `endif\n\n    // DTCM RAM Interface\n    output wire dtcm_ram_cs,\n    output wire dtcm_ram_we,\n    output wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    output wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    output wire clk_dtcm_ram,\n\n    output wire dtcm_active\n);\n\n    // Internal signals\n    wire icb_cmd_valid;\n    wire icb_cmd_ready;\n    wire [E203_DTCM_ADDR_WIDTH-1:0] icb_cmd_addr;\n    wire icb_cmd_read;\n    wire [31:0] icb_cmd_wdata;\n    wire [3:0] icb_cmd_wmask;\n    wire icb_rsp_valid;\n    wire icb_rsp_ready;\n    wire icb_rsp_err;\n    wire [31:0] icb_rsp_rdata;\n\n    // Arbitration logic (if external interface is present)\n    `ifdef E203_HAS_DTCM_EXTITF\n    assign icb_cmd_valid = lsu2dtcm_icb_cmd_valid || ext2dtcm_icb_cmd_valid;\n    assign icb_cmd_addr = lsu2dtcm_icb_cmd_valid ? lsu2dtcm_icb_cmd_addr : ext2dtcm_icb_cmd_addr;\n    assign icb_cmd_read = lsu2dtcm_icb_cmd_valid ? lsu2dtcm_icb_cmd_read : ext2dtcm_icb_cmd_read;\n    assign icb_cmd_wdata = lsu2dtcm_icb_cmd_valid ? lsu2dtcm_icb_cmd_wdata : ext2dtcm_icb_cmd_wdata;\n    assign icb_cmd_wmask = lsu2dtcm_icb_cmd_valid ? lsu2dtcm_icb_cmd_wmask : ext2dtcm_icb_cmd_wmask;\n\n    assign lsu2dtcm_icb_cmd_ready = icb_cmd_ready && lsu2dtcm_icb_cmd_valid;\n    assign ext2dtcm_icb_cmd_ready = icb_cmd_ready && ext2dtcm_icb_cmd_valid;\n\n    assign lsu2dtcm_icb_rsp_valid = icb_rsp_valid && lsu2dtcm_icb_rsp_ready;\n    assign ext2dtcm_icb_rsp_valid = icb_rsp_valid && ext2dtcm_icb_rsp_ready;\n    assign lsu2dtcm_icb_rsp_err = icb_rsp_err;\n    assign ext2dtcm_icb_rsp_err = icb_rsp_err;\n    assign lsu2dtcm_icb_rsp_rdata = icb_rsp_rdata;\n    assign ext2dtcm_icb_rsp_rdata = icb_rsp_rdata;\n    `else\n    assign icb_cmd_valid = lsu2dtcm_icb_cmd_valid;\n    assign icb_cmd_addr = lsu2dtcm_icb_cmd_addr;\n    assign icb_cmd_read = lsu2dtcm_icb_cmd_read;\n    assign icb_cmd_wdata = lsu2dtcm_icb_cmd_wdata;\n    assign icb_cmd_wmask = lsu2dtcm_icb_cmd_wmask;\n\n    assign lsu2dtcm_icb_cmd_ready = icb_cmd_ready;\n    assign lsu2dtcm_icb_rsp_valid = icb_rsp_valid;\n    assign lsu2dtcm_icb_rsp_err = icb_rsp_err;\n    assign lsu2dtcm_icb_rsp_rdata = icb_rsp_rdata;\n    `endif\n\n    // SRAM controller logic\n    assign dtcm_ram_cs = icb_cmd_valid && icb_cmd_ready;\n    assign dtcm_ram_we = !icb_cmd_read;\n    assign dtcm_ram_addr = icb_cmd_addr[E203_DTCM_RAM_AW-1:0];\n    assign dtcm_ram_wem = icb_cmd_wmask;\n    assign dtcm_ram_din = icb_cmd_wdata;\n    assign clk_dtcm_ram = clk;\n\n    // Activity signal\n    assign dtcm_active = icb_cmd_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 18, "code": "module e203_exu_oitf #(\n  parameter E203_ITAG_WIDTH = 4,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_PC_SIZE = 32,\n  parameter E203_OITF_DEPTH = 16\n)(\n  input clk,\n  input rst_n,\n\n  // Dispatch interface\n  input dis_ena,\n  output reg dis_ready,\n  output reg [E203_ITAG_WIDTH-1:0] dis_ptr,\n  input [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n  input [E203_PC_SIZE-1:0] disp_i_pc,\n  input disp_i_rdwen,\n  input disp_i_rdfpu,\n\n  // Retirement interface\n  input ret_ena,\n  output reg [E203_ITAG_WIDTH-1:0] ret_ptr,\n  output reg [E203_RFIDX_WIDTH-1:0] ret_rdidx,\n  output reg ret_rdwen,\n  output reg ret_rdfpu,\n  output reg [E203_PC_SIZE-1:0] ret_pc,\n\n  // Dependency checking outputs\n  output reg oitfrd_match_disprs1,\n  output reg oitfrd_match_disprs2,\n  output reg oitfrd_match_disprs3,\n  output reg oitfrd_match_disprd,\n  output reg oitf_empty\n);\n\n  // Internal registers for OITF entries\n  reg [E203_RFIDX_WIDTH-1:0] rdidx [0:E203_OITF_DEPTH-1];\n  reg [E203_PC_SIZE-1:0] pc [0:E203_OITF_DEPTH-1];\n  reg rdwen [0:E203_OITF_DEPTH-1];\n  reg rdfpu [0:E203_OITF_DEPTH-1];\n  reg [E203_ITAG_WIDTH-1:0] head, tail;\n  reg full, empty;\n\n  // Initialize pointers and flags\n  initial begin\n    dis_ptr = 0;\n    ret_ptr = 0;\n    head = 0;\n    tail = 0;\n    full = 0;\n    empty = 1;\n    dis_ready = 1;\n  end\n\n  // Dispatch logic\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      dis_ptr <= 0;\n      head <= 0;\n      full <= 0;\n      empty <= 1;\n      dis_ready <= 1;\n    end else if (dis_ena && dis_ready) begin\n      rdidx[dis_ptr] <= disp_i_rdidx;\n      pc[dis_ptr] <= disp_i_pc;\n      rdwen[dis_ptr] <= disp_i_rdwen;\n      rdfpu[dis_ptr] <= disp_i_rdfpu;\n      dis_ptr <= (dis_ptr + 1) % E203_OITF_DEPTH;\n      if (dis_ptr == tail) full <= 1;\n      empty <= 0;\n    end\n  end\n\n  // Retirement logic\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      ret_ptr <= 0;\n      tail <= 0;\n      empty <= 1;\n      full <= 0;\n    end else if (ret_ena) begin\n      ret_rdidx <= rdidx[ret_ptr];\n      ret_pc <= pc[ret_ptr];\n      ret_rdwen <= rdwen[ret_ptr];\n      ret_rdfpu <= rdfpu[ret_ptr];\n      ret_ptr <= (ret_ptr + 1) % E203_OITF_DEPTH;\n      if (ret_ptr == head) empty <= 1;\n      full <= 0;\n    end\n  end\n\n  // Dependency checking logic\n  always @(*) begin\n    oitfrd_match_disprs1 = 0;\n    oitfrd_match_disprs2 = 0;\n    oitfrd_match_disprs3 = 0;\n    oitfrd_match_disprd = 0;\n    for (int i = 0; i < E203_OITF_DEPTH; i++) begin\n      if (rdwen[i]) begin\n        if (rdidx[i] == disp_i_rs1idx) oitfrd_match_disprs1 = 1;\n        if (rdidx[i] == disp_i_rs2idx) oitfrd_match_disprs2 = 1;\n        if (rdidx[i] == disp_i_rs3idx) oitfrd_match_disprs3 = 1;\n        if (rdidx[i] == disp_i_rdidx) oitfrd_match_disprd = 1;\n      end\n    end\n  end\n\n  // Update empty flag\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      empty <= 1;\n    end else begin\n      empty <= (head == tail) && !full;\n    end\n  end\n\n  // Update dis_ready based on full flag\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      dis_ready <= 1;\n    end else begin\n      dis_ready <= !full;\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 19, "code": "module e203_exu_longpwbck (\n    input wire lsu_wbck_i_valid,\n    output wire lsu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] lsu_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] lsu_wbck_i_itag,\n    input wire lsu_wbck_i_err,\n    input wire lsu_cmt_i_buserr,\n    input wire [E203_ADDR_SIZE-1:0] lsu_cmt_i_badaddr,\n    input wire lsu_cmt_i_ld,\n    input wire lsu_cmt_i_st,\n    output wire longp_wbck_o_valid,\n    input wire longp_wbck_o_ready,\n    output wire [E203_FLEN-1:0] longp_wbck_o_wdat,\n    output wire [4:0] longp_wbck_o_flags,\n    output wire [E203_RFIDX_WIDTH-1:0] longp_wbck_o_rdidx,\n    output wire longp_wbck_o_rdfpu,\n    output wire longp_excp_o_valid,\n    input wire longp_excp_o_ready,\n    output wire longp_excp_o_insterr,\n    output wire longp_excp_o_ld,\n    output wire longp_excp_o_st,\n    output wire longp_excp_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] longp_excp_o_badaddr,\n    output wire [E203_PC_SIZE-1:0] longp_excp_o_pc,\n    input wire oitf_empty,\n    input wire [E203_ITAG_WIDTH-1:0] oitf_ret_ptr,\n    input wire [E203_RFIDX_WIDTH-1:0] oitf_ret_rdidx,\n    input wire [E203_PC_SIZE-1:0] oitf_ret_pc,\n    input wire oitf_ret_rdwen,\n    input wire oitf_ret_rdfpu,\n    output wire oitf_ret_ena,\n    input wire clk,\n    input wire rst_n\n    `ifdef E203_HAS_NICE\n    , input wire nice_longp_wbck_i_valid,\n    output wire nice_longp_wbck_i_ready,\n    input wire [E203_XLEN-1:0] nice_longp_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] nice_longp_wbck_i_itag,\n    input wire nice_longp_wbck_i_err\n    `endif\n);\n\n    // Internal signals for arbitration and control logic\n    wire wbck_i_valid;\n    wire wbck_i_ready;\n    wire [E203_XLEN-1:0] wbck_i_wdat;\n    wire [E203_ITAG_WIDTH-1:0] wbck_i_itag;\n    wire wbck_i_err;\n\n    // Arbitration logic\n    assign wbck_i_valid = lsu_wbck_i_valid `ifdef E203_HAS_NICE || nice_longp_wbck_i_valid `endif;\n    assign wbck_i_wdat = lsu_wbck_i_valid ? lsu_wbck_i_wdat : `ifdef E203_HAS_NICE nice_longp_wbck_i_wdat `endif;\n    assign wbck_i_itag = lsu_wbck_i_valid ? lsu_wbck_i_itag : `ifdef E203_HAS_NICE nice_longp_wbck_i_itag `endif;\n    assign wbck_i_err = lsu_wbck_i_valid ? lsu_wbck_i_err : `ifdef E203_HAS_NICE nice_longp_wbck_i_err `endif;\n\n    // Write-back and exception control logic\n    assign lsu_wbck_i_ready = wbck_i_ready && (oitf_ret_ptr == wbck_i_itag) && !oitf_empty;\n    `ifdef E203_HAS_NICE\n    assign nice_longp_wbck_i_ready = wbck_i_ready && (oitf_ret_ptr == wbck_i_itag) && !oitf_empty;\n    `endif\n\n    assign wbck_i_ready = (longp_wbck_o_ready || !oitf_ret_rdwen) && (longp_excp_o_ready || !wbck_i_err);\n    assign longp_wbck_o_valid = wbck_i_valid && oitf_ret_rdwen && !wbck_i_err && longp_wbck_o_ready;\n    assign longp_wbck_o_wdat = wbck_i_wdat;\n    assign longp_wbck_o_rdidx = oitf_ret_rdidx;\n    assign longp_wbck_o_rdfpu = oitf_ret_rdfpu;\n\n    assign longp_excp_o_valid = wbck_i_valid && wbck_i_err && longp_excp_o_ready;\n    assign longp_excp_o_insterr = wbck_i_err;\n    assign longp_excp_o_ld = lsu_cmt_i_ld;\n    assign longp_excp_o_st = lsu_cmt_i_st;\n    assign longp_excp_o_buserr = lsu_cmt_i_buserr;\n    assign longp_excp_o_badaddr = lsu_cmt_i_badaddr;\n    assign longp_excp_o_pc = oitf_ret_pc;\n\n    assign oitf_ret_ena = wbck_i_ready && wbck_i_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 20, "code": "module e203_exu_alu_bjp (\n    input wire bjp_i_valid,\n    output wire bjp_i_ready,\n    input wire [E203_XLEN-1:0] bjp_i_rs1,\n    input wire [E203_XLEN-1:0] bjp_i_rs2,\n    input wire [E203_XLEN-1:0] bjp_i_imm,\n    input wire [E203_PC_SIZE-1:0] bjp_i_pc,\n    input wire [E203_DECINFO_BJP_WIDTH-1:0] bjp_i_info,\n    output wire bjp_o_valid,\n    input wire bjp_o_ready,\n    output wire [E203_XLEN-1:0] bjp_o_wbck_wdat,\n    output wire bjp_o_wbck_err,\n    output wire bjp_o_cmt_bjp,\n    output wire bjp_o_cmt_mret,\n    output wire bjp_o_cmt_dret,\n    output wire bjp_o_cmt_fencei,\n    output wire bjp_o_cmt_prdt,\n    output wire bjp_o_cmt_rslv,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    output wire bjp_req_alu_cmp_eq,\n    output wire bjp_req_alu_cmp_ne,\n    output wire bjp_req_alu_cmp_lt,\n    output wire bjp_req_alu_cmp_gt,\n    output wire bjp_req_alu_cmp_ltu,\n    output wire bjp_req_alu_cmp_gtu,\n    output wire bjp_req_alu_add,\n    input wire bjp_req_alu_cmp_res,\n    input wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Handshake mechanism\n    assign bjp_i_ready = bjp_o_ready;\n    assign bjp_o_valid = bjp_i_valid;\n\n    // Default assignments\n    assign bjp_o_wbck_err = 1'b0;\n    assign bjp_o_cmt_mret = bjp_i_info[E203_DECINFO_BJP_MRET];\n    assign bjp_o_cmt_dret = bjp_i_info[E203_DECINFO_BJP_DRET];\n    assign bjp_o_cmt_fencei = bjp_i_info[E203_DECINFO_BJP_FENCEI];\n    assign bjp_o_cmt_bjp = bjp_i_info[E203_DECINFO_BJP_BXX] | bjp_i_info[E203_DECINFO_BJP_JUMP];\n    assign bjp_o_cmt_prdt = bjp_i_info[E203_DECINFO_BJP_BPRDT];\n    assign bjp_o_cmt_rslv = bjp_req_alu_cmp_res;\n\n    // ALU operation requests\n    assign bjp_req_alu_cmp_eq = bjp_i_info[E203_DECINFO_BJP_BEQ];\n    assign bjp_req_alu_cmp_ne = bjp_i_info[E203_DECINFO_BJP_BNE];\n    assign bjp_req_alu_cmp_lt = bjp_i_info[E203_DECINFO_BJP_BLT];\n    assign bjp_req_alu_cmp_gt = bjp_i_info[E203_DECINFO_BJP_BGT];\n    assign bjp_req_alu_cmp_ltu = bjp_i_info[E203_DECINFO_BJP_BLTU];\n    assign bjp_req_alu_cmp_gtu = bjp_i_info[E203_DECINFO_BJP_BGTU];\n    assign bjp_req_alu_add = bjp_i_info[E203_DECINFO_BJP_JUMP];\n\n    // Operand selection\n    assign bjp_req_alu_op1 = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? bjp_i_pc : bjp_i_rs1;\n    assign bjp_req_alu_op2 = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? bjp_i_imm : bjp_i_rs2;\n\n    // Write back data\n    assign bjp_o_wbck_wdat = bjp_req_alu_add_res;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 7, "code": "module e203_exu_decode(\n    input [E203_INSTR_SIZE-1:0] i_instr,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_prdt_taken,\n    input i_misalgn,\n    input i_buserr,\n    input i_muldiv_b2b,\n    input dbg_mode,\n    output dec_rs1x0,\n    output dec_rs2x0,\n    output dec_rs1en,\n    output dec_rs2en,\n    output dec_rdwen,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rdidx,\n    output [E203_DECINFO_WIDTH-1:0] dec_info,\n    output [E203_XLEN-1:0] dec_imm,\n    output [E203_PC_SIZE-1:0] dec_pc,\n    output dec_misalgn,\n    output dec_buserr,\n    output dec_ilegl,\n    output dec_mulhsu,\n    output dec_mul,\n    output dec_div,\n    output dec_rem,\n    output dec_divu,\n    output dec_remu,\n    output dec_rv32,\n    output dec_bjp,\n    output dec_jal,\n    output dec_jalr,\n    output dec_bxx,\n    output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    output [E203_XLEN-1:0] dec_bjp_imm,\n    input nice_xs_off,\n    output dec_nice,\n    output nice_cmt_off_ilgl_o\n);\n\n    // Internal signal declarations\n    wire [6:0] opcode = i_instr[6:0];\n    wire [2:0] funct3 = i_instr[14:12];\n    wire [6:0] funct7 = i_instr[31:25];\n    wire [4:0] rs1 = i_instr[19:15];\n    wire [4:0] rs2 = i_instr[24:20];\n    wire [4:0] rd = i_instr[11:7];\n    wire [11:0] imm12 = i_instr[31:20];\n    wire [11:0] imm12_I = {{20{i_instr[31]}}, i_instr[31:20]};\n    wire [11:0] imm12_S = {{20{i_instr[31]}}, i_instr[31:25], i_instr[11:7]};\n    wire [12:0] imm13 = {{19{i_instr[31]}}, i_instr[31], i_instr[7], i_instr[30:25], i_instr[11:8], 1'b0};\n    wire [31:0] imm20_U = {i_instr[31:12], 12'h000};\n    wire [20:0] imm21 = {{11{i_instr[31]}}, i_instr[31], i_instr[19:12], i_instr[20], i_instr[30:21], 1'b0};\n\n    // Decode logic\n    assign dec_rs1x0 = (rs1 == 5'b00000);\n    assign dec_rs2x0 = (rs2 == 5'b00000);\n    assign dec_rs1en = (opcode == 7'b1100111 || opcode == 7'b0000011 || opcode == 7'b0100011);\n    assign dec_rs2en = (opcode == 7'b0100011);\n    assign dec_rdwen = (opcode == 7'b1100111 || opcode == 7'b0000011);\n    assign dec_rs1idx = rs1;\n    assign dec_rs2idx = rs2;\n    assign dec_rdidx = rd;\n    assign dec_info = {E203_DECINFO_WIDTH{1'b0}}; // Placeholder for actual decode information\n    assign dec_imm = imm12_I; // Placeholder for actual immediate extraction\n    assign dec_pc = i_pc;\n    assign dec_misalgn = i_misalgn;\n    assign dec_buserr = i_buserr;\n    assign dec_ilegl = (opcode == 7'b0000000 || opcode == 7'b1111111); // Example illegal condition\n    assign dec_mulhsu = (funct7 == 7'b0000001 && funct3 == 3'b010);\n    assign dec_mul = (funct7 == 7'b0000001 && funct3 == 3'b000);\n    assign dec_div = (funct7 == 7'b0000001 && funct3 == 3'b100);\n    assign dec_rem = (funct7 == 7'b0000001 && funct3 == 3'b110);\n    assign dec_divu = (funct7 == 7'b0000001 && funct3 == 3'b101);\n    assign dec_remu = (funct7 == 7'b0000001 && funct3 == 3'b111);\n    assign dec_rv32 = (i_instr[1:0] == 2'b11);\n    assign dec_bjp = (opcode == 7'b1101111 || opcode == 7'b1100111 || opcode == 7'b1100011);\n    assign dec_jal = (opcode == 7'b1101111);\n    assign dec_jalr = (opcode == 7'b1100111);\n    assign dec_bxx = (opcode == 7'b1100011);\n    assign dec_jalr_rs1idx = rs1;\n    assign dec_bjp_imm = imm13;\n    assign dec_nice = `E203_HAS_NICE && (opcode == 7'b0001011); // Example NICE instruction\n    assign nice_cmt_off_ilgl_o = nice_xs_off && dec_nice;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 20, "code": "module e203_exu_alu_rglr(\n    input wire alu_i_valid,\n    output reg alu_i_ready,\n    input wire [E203_XLEN-1:0] alu_i_rs1,\n    input wire [E203_XLEN-1:0] alu_i_rs2,\n    input wire [E203_XLEN-1:0] alu_i_imm,\n    input wire [E203_PC_SIZE-1:0] alu_i_pc,\n    input wire [E203_DECINFO_ALU_WIDTH-1:0] alu_i_info,\n    output reg alu_o_valid,\n    input wire alu_o_ready,\n    output reg [E203_XLEN-1:0] alu_o_wbck_wdat,\n    output reg alu_o_wbck_err,\n    output reg alu_o_cmt_ecall,\n    output reg alu_o_cmt_ebreak,\n    output reg alu_o_cmt_wfi,\n    output reg alu_req_alu_add,\n    output reg alu_req_alu_sub,\n    output reg alu_req_alu_xor,\n    output reg alu_req_alu_sll,\n    output reg alu_req_alu_srl,\n    output reg alu_req_alu_sra,\n    output reg alu_req_alu_or,\n    output reg alu_req_alu_and,\n    output reg alu_req_alu_slt,\n    output reg alu_req_alu_sltu,\n    output reg alu_req_alu_lui,\n    output reg [E203_XLEN-1:0] alu_req_alu_op1,\n    output reg [E203_XLEN-1:0] alu_req_alu_op2,\n    output reg [E203_XLEN-1:0] alu_req_alu_res,\n    input wire clk,\n    input wire rst_n\n);\n\n    always @(*) begin\n        // Handshake signals\n        alu_i_ready = alu_o_ready;\n        alu_o_valid = alu_i_valid;\n\n        // Default outputs\n        alu_o_wbck_wdat = 0;\n        alu_o_wbck_err = 0;\n        alu_o_cmt_ecall = 0;\n        alu_o_cmt_ebreak = 0;\n        alu_o_cmt_wfi = 0;\n\n        // Default request signals\n        alu_req_alu_add = 0;\n        alu_req_alu_sub = 0;\n        alu_req_alu_xor = 0;\n        alu_req_alu_sll = 0;\n        alu_req_alu_srl = 0;\n        alu_req_alu_sra = 0;\n        alu_req_alu_or = 0;\n        alu_req_alu_and = 0;\n        alu_req_alu_slt = 0;\n        alu_req_alu_sltu = 0;\n        alu_req_alu_lui = 0;\n\n        // Select operands\n        alu_req_alu_op1 = (alu_i_info[E203_DECINFO_ALU_OP1PC]) ? alu_i_pc : alu_i_rs1;\n        alu_req_alu_op2 = (alu_i_info[E203_DECINFO_ALU_OP2IMM]) ? alu_i_imm : alu_i_rs2;\n\n        // Operation decoding\n        if (alu_i_valid) begin\n            case (1'b1)\n                alu_i_info[E203_DECINFO_ALU_ADD]: alu_req_alu_add = 1;\n                alu_i_info[E203_DECINFO_ALU_SUB]: alu_req_alu_sub = 1;\n                alu_i_info[E203_DECINFO_ALU_XOR]: alu_req_alu_xor = 1;\n                alu_i_info[E203_DECINFO_ALU_SLL]: alu_req_alu_sll = 1;\n                alu_i_info[E203_DECINFO_ALU_SRL]: alu_req_alu_srl = 1;\n                alu_i_info[E203_DECINFO_ALU_SRA]: alu_req_alu_sra = 1;\n                alu_i_info[E203_DECINFO_ALU_OR]: alu_req_alu_or = 1;\n                alu_i_info[E203_DECINFO_ALU_AND]: alu_req_alu_and = 1;\n                alu_i_info[E203_DECINFO_ALU_SLT]: alu_req_alu_slt = 1;\n                alu_i_info[E203_DECINFO_ALU_SLTU]: alu_req_alu_sltu = 1;\n                alu_i_info[E203_DECINFO_ALU_LUI]: alu_req_alu_lui = 1;\n            endcase\n\n            // Special instructions\n            if (alu_i_info[E203_DECINFO_ALU_ECAL]) begin\n                alu_o_cmt_ecall = 1;\n                alu_o_wbck_err = 1;\n            end\n            if (alu_i_info[E203_DECINFO_ALU_EBRK]) begin\n                alu_o_cmt_ebreak = 1;\n                alu_o_wbck_err = 1;\n            end\n            if (alu_i_info[E203_DECINFO_ALU_WFI]) begin\n                alu_o_cmt_wfi = 1;\n                alu_o_wbck_err = 1;\n            end\n        end\n    end\n\n    // Result from shared data path\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            alu_req_alu_res <= 0;\n        end else if (alu_i_valid && alu_o_ready) begin\n            alu_req_alu_res <= alu_o_wbck_wdat;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 15, "code": "module e203_exu_csr(\n    input nonflush_cmt_ena,\n    input csr_ena,\n    input csr_wr_en,\n    input csr_rd_en,\n    input [11:0] csr_idx,\n    output csr_access_ilgl,\n    output tm_stop,\n    output core_cgstop,\n    output tcm_cgstop,\n    output itcm_nohold,\n    output mdv_nob2b,\n    output [E203_XLEN-1:0] read_csr_dat,\n    input [E203_XLEN-1:0] wbck_csr_dat,\n    input [E203_HART_ID_W-1:0] core_mhartid,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    output status_mie_r,\n    output mtie_r,\n    output msie_r,\n    output meie_r,\n    output wr_dcsr_ena,\n    output wr_dpc_ena,\n    output wr_dscratch_ena,\n    input [E203_XLEN-1:0] dcsr_r,\n    input [E203_PC_SIZE-1:0] dpc_r,\n    input [E203_XLEN-1:0] dscratch_r,\n    output u_mode,\n    output s_mode,\n    output h_mode,\n    output m_mode,\n    input [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    input cmt_badaddr_ena,\n    input [E203_PC_SIZE-1:0] cmt_epc,\n    input cmt_epc_ena,\n    input [E203_XLEN-1:0] cmt_cause,\n    input cmt_cause_ena,\n    input cmt_status_ena,\n    input cmt_instret_ena,\n    input cmt_mret_ena,\n    output [E203_PC_SIZE-1:0] csr_epc_r,\n    output [E203_PC_SIZE-1:0] csr_dpc_r,\n    output [E203_XLEN-1:0] csr_mtvec_r,\n    input clk_aon,\n    input clk,\n    input rst_n\n);\n\n// CSR logic implementation here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 8, "code": "module e203_exu_decode(\n    input [E203_INSTR_SIZE-1:0] i_instr,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_prdt_taken,\n    input i_misalgn,\n    input i_buserr,\n    input i_muldiv_b2b,\n    input dbg_mode,\n    output dec_rs1x0,\n    output dec_rs2x0,\n    output dec_rs1en,\n    output dec_rs2en,\n    output dec_rdwen,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rdidx,\n    output [E203_DECINFO_WIDTH-1:0] dec_info,\n    output [E203_XLEN-1:0] dec_imm,\n    output [E203_PC_SIZE-1:0] dec_pc,\n    output dec_misalgn,\n    output dec_buserr,\n    output dec_ilegl,\n    output dec_mulhsu,\n    output dec_mul,\n    output dec_div,\n    output dec_rem,\n    output dec_divu,\n    output dec_remu,\n    output dec_rv32,\n    output dec_bjp,\n    output dec_jal,\n    output dec_jalr,\n    output dec_bxx,\n    output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    output [E203_XLEN-1:0] dec_bjp_imm,\n    // Optional NICE interface\n    `ifdef E203_HAS_NICE\n    input nice_xs_off,\n    output dec_nice,\n    output nice_cmt_off_ilgl_o,\n    `endif\n    output dec_ilegl\n);\n\n    // Instruction decoding logic here\n    // This is a simplified example and does not cover all cases or signals\n\n    assign dec_rs1x0 = (dec_rs1idx == 0);\n    assign dec_rs2x0 = (dec_rs2idx == 0);\n    assign dec_rs1en = |(i_instr[19:15]); // Enable if rs1 is non-zero\n    assign dec_rs2en = |(i_instr[24:20]); // Enable if rs2 is non-zero\n    assign dec_rdwen = |(i_instr[11:7]);  // Enable if rd is non-zero\n\n    // Example of decoding an ADD instruction\n    wire is_add = (i_instr[6:0] == 7'b0110011) && (i_instr[14:12] == 3'b000) && (i_instr[31:25] == 7'b0000000);\n    assign dec_mul = is_add; // Simplified, normally you would decode a MUL instruction\n\n    // Propagate error signals\n    assign dec_misalgn = i_misalgn;\n    assign dec_buserr = i_buserr;\n\n    // Set illegal instruction flag based on some condition\n    assign dec_ilegl = (i_instr == 32'h00000000) || (i_instr == 32'hffffffff);\n\n    // More decoding logic would be needed here for a complete implementation\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 20, "code": "module e203_exu_branchslv (\n    input wire cmt_i_valid,\n    output wire cmt_i_ready,\n    input wire cmt_i_rv32,\n    input wire cmt_i_dret,\n    input wire cmt_i_mret,\n    input wire cmt_i_fencei,\n    input wire cmt_i_bjp,\n    input wire cmt_i_bjp_prdt,\n    input wire cmt_i_bjp_rslv,\n    input wire [E203_PC_SIZE-1:0] cmt_i_pc,\n    input wire [E203_XLEN-1:0] cmt_i_imm,\n    input wire [E203_PC_SIZE-1:0] csr_epc_r,\n    input wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    input wire nonalu_excpirq_flush_req_raw,\n    input wire brchmis_flush_ack,\n    output wire brchmis_flush_req,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op1,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_add_op2,\n    output wire [E203_PC_SIZE-1:0] brchmis_flush_pc,\n    output wire cmt_mret_ena,\n    output wire cmt_dret_ena,\n    output wire cmt_fencei_ena,\n    input wire clk,\n    input wire rst_n\n);\n\n    wire flush_need;\n    wire flush_target_calc;\n    wire pipeline_flush_control;\n    wire prioritizing_flush_sources;\n    wire controls_ready_signal;\n    wire special_signal_commit;\n\n    // Flush Need Generation\n    assign flush_need = (cmt_i_bjp & (cmt_i_bjp_prdt ^ cmt_i_bjp_rslv)) | cmt_i_fencei | cmt_i_mret | cmt_i_dret;\n\n    // Flush Target Calculation\n    always @(*) begin\n        if (cmt_i_dret) begin\n            brchmis_flush_add_op1 = csr_dpc_r;\n        end else if (cmt_i_mret) begin\n            brchmis_flush_add_op1 = csr_epc_r;\n        end else if (cmt_i_bjp & cmt_i_bjp_prdt & ~cmt_i_bjp_rslv) begin\n            brchmis_flush_add_op1 = cmt_i_pc + (cmt_i_rv32 ? 4 : 2);\n        end else if (cmt_i_bjp & ~cmt_i_bjp_prdt & cmt_i_bjp_rslv) begin\n            brchmis_flush_add_op1 = cmt_i_pc + cmt_i_imm;\n        end else begin\n            brchmis_flush_add_op1 = csr_epc_r;\n        end\n    end\n\n    // Pipeline Flush Control\n    assign brchmis_flush_req = flush_need & cmt_i_valid & ~nonalu_excpirq_flush_req_raw;\n\n    // Prioritizing Flush Sources\n    // Non-ALU exception/interrupt flushes mask branch misprediction flushes\n    assign prioritizing_flush_sources = nonalu_excpirq_flush_req_raw;\n\n    // Controls the ready signal for the instruction\n    assign cmt_i_ready = ~flush_need & ~nonalu_excpirq_flush_req_raw & brchmis_flush_ack;\n\n    // Special Signal Commit\n    assign cmt_mret_ena = cmt_i_mret & flush_need & brchmis_flush_ack;\n    assign cmt_dret_ena = cmt_i_dret & flush_need & brchmis_flush_ack;\n    assign cmt_fencei_ena = cmt_i_fencei & flush_need & brchmis_flush_ack;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 10, "code": "module e203_ifu_litebpu #(\n  parameter E203_PC_SIZE = 32,\n  parameter E203_XLEN = 32,\n  parameter E203_RFIDX_WIDTH = 5\n)(\n  input clk,\n  input rst_n,\n  input [E203_PC_SIZE-1:0] pc,\n  input dec_jal,\n  input dec_jalr,\n  input dec_bxx,\n  input [E203_XLEN-1:0] dec_bjp_imm,\n  input [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  input oitf_empty,\n  input ir_empty,\n  input ir_rs1en,\n  input jalr_rs1idx_cam_irrdidx,\n  input dec_i_valid,\n  input ir_valid_clr,\n  input [E203_XLEN-1:0] rf2bpu_x1,\n  input [E203_XLEN-1:0] rf2bpu_rs1,\n  output reg prdt_taken,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op1,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op2,\n  output reg bpu_wait,\n  output reg bpu2rf_rs1_ena\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      prdt_taken <= 1'b0;\n      prdt_pc_add_op1 <= {E203_PC_SIZE{1'b0}};\n      prdt_pc_add_op2 <= {E203_PC_SIZE{1'b0}};\n      bpu_wait <= 1'b0;\n      bpu2rf_rs1_ena <= 1'b0;\n    end else begin\n      // Predict taken for JAL and JALR unconditionally\n      prdt_taken <= dec_jal | dec_jalr;\n      // Calculate the target address\n      if (dec_jal) begin\n        prdt_pc_add_op1 <= pc;\n        prdt_pc_add_op2 <= dec_bjp_imm;\n      end else if (dec_jalr) begin\n        if (dec_jalr_rs1idx == 0) begin\n          prdt_pc_add_op1 <= 0;\n        end else if (dec_jalr_rs1idx == 1) begin\n          prdt_pc_add_op1 <= rf2bpu_x1;\n          bpu_wait <= !oitf_empty; // Wait if OITF is not empty\n        end else begin\n          prdt_pc_add_op1 <= rf2bpu_rs1;\n          bpu_wait <= !ir_empty && ir_rs1en && jalr_rs1idx_cam_irrdidx;\n        end\n        prdt_pc_add_op2 <= dec_bjp_imm;\n      end else if (dec_bxx) begin\n        prdt_taken <= dec_bjp_imm[E203_XLEN-1]; // Negative offset implies taken\n        prdt_pc_add_op1 <= pc;\n        prdt_pc_add_op2 <= dec_bjp_imm;\n      end\n      // Manage rs1 read enable signal\n      bpu2rf_rs1_ena <= dec_jalr && (dec_jalr_rs1idx != 0) && (dec_jalr_rs1idx != 1);\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 8, "code": "module e203_exu_alu(\n    input wire clk,\n    input wire rst_n,\n    input wire i_valid,\n    output wire i_ready,\n    input wire [E203_XLEN-1:0] i_rs1,\n    input wire [E203_XLEN-1:0] i_rs2,\n    input wire [E203_XLEN-1:0] i_imm,\n    input wire [E203_DECINFO_WIDTH-1:0] i_info,\n    input wire [E203_PC_SIZE-1:0] i_pc,\n    input wire [E203_INSTR_SIZE-1:0] i_instr,\n    input wire i_pc_vld,\n    input wire [E203_RFIDX_WIDTH-1:0] i_rdidx,\n    input wire i_rdwen,\n    input wire i_ilegl,\n    input wire i_buserr,\n    input wire i_misalgn,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire cmt_o_valid,\n    input wire cmt_o_ready,\n    output wire [E203_PC_SIZE-1:0] cmt_o_pc,\n    output wire [E203_INSTR_SIZE-1:0] cmt_o_instr,\n    output wire [E203_XLEN-1:0] cmt_o_imm,\n    output wire cmt_o_rv32,\n    output wire cmt_o_bjp,\n    output wire cmt_o_mret,\n    output wire cmt_o_dret,\n    output wire cmt_o_ecall,\n    output wire cmt_o_ebreak,\n    output wire cmt_o_fencei,\n    output wire cmt_o_wfi,\n    output wire cmt_o_ifu_misalgn,\n    output wire cmt_o_ifu_buserr,\n    output wire cmt_o_ifu_ilegl,\n    output wire cmt_o_bjp_prdt,\n    output wire cmt_o_bjp_rslv,\n    output wire cmt_o_misalgn,\n    output wire cmt_o_ld,\n    output wire cmt_o_stamo,\n    output wire cmt_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] cmt_o_badaddr,\n    output wire wbck_o_valid,\n    input wire wbck_o_ready,\n    output wire [E203_XLEN-1:0] wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] wbck_o_rdidx,\n    input wire mdv_nob2b,\n    output wire csr_ena,\n    output wire csr_wr_en,\n    output wire csr_rd_en,\n    output wire [11:0] csr_idx,\n    input wire nonflush_cmt_ena,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output wire [E203_XLEN-1:0] wbck_csr_dat,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_usign,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_longp_wbck_valid,\n    input wire nice_longp_wbck_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire i_nice_cmt_off_ilgl\n);\n    // ALU core logic implementation\n    // Add your ALU, AGU, CSR, MUL/DIV, and NICE logic here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 12, "code": "module e203_exu_disp(\n    input wfi_halt_exu_req,\n    output reg wfi_halt_exu_ack,\n    input oitf_empty,\n    input amo_wait,\n    input disp_i_valid,\n    output reg disp_i_ready,\n    input disp_i_rs1x0,\n    input disp_i_rs2x0,\n    input disp_i_rs1en,\n    input disp_i_rs2en,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input [E203_XLEN-1:0] disp_i_rs1,\n    input [E203_XLEN-1:0] disp_i_rs2,\n    input disp_i_rdwen,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input [E203_DECINFO_WIDTH-1:0] disp_i_info,\n    input [E203_XLEN-1:0] disp_i_imm,\n    input [E203_PC_SIZE-1:0] disp_i_pc,\n    input disp_i_misalgn,\n    input disp_i_buserr,\n    input disp_i_ilegl,\n    output reg disp_o_alu_valid,\n    input disp_o_alu_ready,\n    input disp_o_alu_longpipe,\n    output reg [E203_XLEN-1:0] disp_o_alu_rs1,\n    output reg [E203_XLEN-1:0] disp_o_alu_rs2,\n    output reg disp_o_alu_rdwen,\n    output reg [E203_RFIDX_WIDTH-1:0] disp_o_alu_rdidx,\n    output reg [E203_DECINFO_WIDTH-1:0] disp_o_alu_info,\n    output reg [E203_XLEN-1:0] disp_o_alu_imm,\n    output reg [E203_PC_SIZE-1:0] disp_o_alu_pc,\n    output reg [E203_ITAG_WIDTH-1:0] disp_o_alu_itag,\n    output reg disp_o_alu_misalgn,\n    output reg disp_o_alu_buserr,\n    output reg disp_o_alu_ilegl,\n    input oitfrd_match_disprs1,\n    input oitfrd_match_disprs2,\n    input oitfrd_match_disprs3,\n    input oitfrd_match_disprd,\n    input [E203_ITAG_WIDTH-1:0] disp_oitf_ptr,\n    output reg disp_oitf_ena,\n    input disp_oitf_ready,\n    output reg disp_oitf_rs1fpu,\n    output reg disp_oitf_rs2fpu,\n    output reg disp_oitf_rs3fpu,\n    output reg disp_oitf_rdfpu,\n    output reg disp_oitf_rs1en,\n    output reg disp_oitf_rs2en,\n    output reg disp_oitf_rs3en,\n    output reg disp_oitf_rdwen,\n    output reg [E203_RFIDX_WIDTH-1:0] disp_oitf_rs1idx,\n    output reg [E203_RFIDX_WIDTH-1:0] disp_oitf_rs2idx,\n    output reg [E203_RFIDX_WIDTH-1:0] disp_oitf_rs3idx,\n    output reg [E203_RFIDX_WIDTH-1:0] disp_oitf_rdidx,\n    output reg [E203_PC_SIZE-1:0] disp_oitf_pc,\n    input clk,\n    input rst_n\n);\n\n    always @(*) begin\n        // Default assignments\n        disp_i_ready = 1'b0;\n        disp_o_alu_valid = 1'b0;\n        disp_o_alu_rs1 = disp_i_rs1;\n        disp_o_alu_rs2 = disp_i_rs2;\n        disp_o_alu_rdwen = disp_i_rdwen;\n        disp_o_alu_rdidx = disp_i_rdidx;\n        disp_o_alu_info = disp_i_info;\n        disp_o_alu_imm = disp_i_imm;\n        disp_o_alu_pc = disp_i_pc;\n        disp_o_alu_itag = disp_oitf_ptr;\n        disp_o_alu_misalgn = disp_i_misalgn;\n        disp_o_alu_buserr = disp_i_buserr;\n        disp_o_alu_ilegl = disp_i_ilegl;\n        disp_oitf_ena = 1'b0;\n        disp_oitf_rs1fpu = 1'b0;\n        disp_oitf_rs2fpu = 1'b0;\n        disp_oitf_rs3fpu = 1'b0;\n        disp_oitf_rdfpu = 1'b0;\n        disp_oitf_rs1en = disp_i_rs1en;\n        disp_oitf_rs2en = disp_i_rs2en;\n        disp_oitf_rs3en = 1'b0;\n        disp_oitf_rdwen = disp_i_rdwen;\n        disp_oitf_rs1idx = disp_i_rs1idx;\n        disp_oitf_rs2idx = disp_i_rs2idx;\n        disp_oitf_rs3idx = 0;\n        disp_oitf_rdidx = disp_i_rdidx;\n        disp_oitf_pc = disp_i_pc;\n        wfi_halt_exu_ack = 1'b0;\n\n        if (oitf_empty && !amo_wait && disp_i_valid) begin\n            disp_i_ready = 1'b1;\n            disp_o_alu_valid = disp_o_alu_ready;\n            disp_oitf_ena = disp_o_alu_longpipe && disp_o_alu_ready;\n            if (wfi_halt_exu_req) begin\n                wfi_halt_exu_ack = 1'b1;\n                disp_i_ready = 1'b0;\n                disp_o_alu_valid = 1'b0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 13, "code": "module e203_exu_commit(\n    output commit_mret,\n    output commit_trap,\n    output core_wfi,\n    output nonflush_cmt_ena,\n    output excp_active,\n    input amo_wait,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input alu_cmt_i_valid,\n    output alu_cmt_i_ready,\n    input [E203_PC_SIZE-1:0] alu_cmt_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_cmt_i_instr,\n    input alu_cmt_i_pc_vld,\n    input [E203_XLEN-1:0] alu_cmt_i_imm,\n    input alu_cmt_i_rv32,\n    input alu_cmt_i_bjp,\n    input alu_cmt_i_wfi,\n    input alu_cmt_i_fencei,\n    input alu_cmt_i_mret,\n    input alu_cmt_i_dret,\n    input alu_cmt_i_ecall,\n    input alu_cmt_i_ebreak,\n    input alu_cmt_i_ifu_misalgn,\n    input alu_cmt_i_ifu_buserr,\n    input alu_cmt_i_ifu_ilegl,\n    input alu_cmt_i_bjp_prdt,\n    input alu_cmt_i_bjp_rslv,\n    input alu_cmt_i_misalgn,\n    input alu_cmt_i_ld,\n    input alu_cmt_i_stamo,\n    input alu_cmt_i_buserr,\n    input [E203_ADDR_SIZE-1:0] alu_cmt_i_badaddr,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output cmt_badaddr_ena,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output cmt_epc_ena,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_cause_ena,\n    output cmt_instret_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output cmt_mret_ena,\n    input [E203_PC_SIZE-1:0] csr_epc_r,\n    input [E203_PC_SIZE-1:0] csr_dpc_r,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output longp_excp_i_ready,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input longp_excp_i_insterr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input clk,\n    input rst_n\n);\n\n// Implementation of the commit logic and exception handling\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 14, "code": "module e203_exu_commit(\n    output commit_mret,\n    output commit_trap,\n    output core_wfi,\n    output nonflush_cmt_ena,\n    output excp_active,\n    input amo_wait,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input alu_cmt_i_valid,\n    output alu_cmt_i_ready,\n    input [E203_PC_SIZE-1:0] alu_cmt_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_cmt_i_instr,\n    input alu_cmt_i_pc_vld,\n    input [E203_XLEN-1:0] alu_cmt_i_imm,\n    input alu_cmt_i_rv32,\n    input alu_cmt_i_bjp,\n    input alu_cmt_i_wfi,\n    input alu_cmt_i_fencei,\n    input alu_cmt_i_mret,\n    input alu_cmt_i_dret,\n    input alu_cmt_i_ecall,\n    input alu_cmt_i_ebreak,\n    input alu_cmt_i_ifu_misalgn,\n    input alu_cmt_i_ifu_buserr,\n    input alu_cmt_i_ifu_ilegl,\n    input alu_cmt_i_bjp_prdt,\n    input alu_cmt_i_bjp_rslv,\n    input alu_cmt_i_misalgn,\n    input alu_cmt_i_ld,\n    input alu_cmt_i_stamo,\n    input alu_cmt_i_buserr,\n    input [E203_ADDR_SIZE-1:0] alu_cmt_i_badaddr,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output cmt_badaddr_ena,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output cmt_epc_ena,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_cause_ena,\n    output cmt_instret_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output cmt_mret_ena,\n    input [E203_PC_SIZE-1:0] csr_epc_r,\n    input [E203_PC_SIZE-1:0] csr_dpc_r,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output longp_excp_i_ready,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input longp_excp_i_insterr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input clk,\n    input rst_n\n);\n\n// Implementation of the commit logic, exception handling, and flush control\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 15, "code": "module e203_exu_commit(\n    output commit_mret,\n    output commit_trap,\n    output core_wfi,\n    output nonflush_cmt_ena,\n    output excp_active,\n    input amo_wait,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input alu_cmt_i_valid,\n    output alu_cmt_i_ready,\n    input [E203_PC_SIZE-1:0] alu_cmt_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_cmt_i_instr,\n    input alu_cmt_i_pc_vld,\n    input [E203_XLEN-1:0] alu_cmt_i_imm,\n    input alu_cmt_i_rv32,\n    input alu_cmt_i_bjp,\n    input alu_cmt_i_wfi,\n    input alu_cmt_i_fencei,\n    input alu_cmt_i_mret,\n    input alu_cmt_i_dret,\n    input alu_cmt_i_ecall,\n    input alu_cmt_i_ebreak,\n    input alu_cmt_i_ifu_misalgn,\n    input alu_cmt_i_ifu_buserr,\n    input alu_cmt_i_ifu_ilegl,\n    input alu_cmt_i_bjp_prdt,\n    input alu_cmt_i_bjp_rslv,\n    input alu_cmt_i_misalgn,\n    input alu_cmt_i_ld,\n    input alu_cmt_i_stamo,\n    input alu_cmt_i_buserr,\n    input [E203_ADDR_SIZE-1:0] alu_cmt_i_badaddr,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output cmt_badaddr_ena,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output cmt_epc_ena,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_cause_ena,\n    output cmt_instret_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output cmt_mret_ena,\n    input [E203_PC_SIZE-1:0] csr_epc_r,\n    input [E203_PC_SIZE-1:0] csr_dpc_r,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output longp_excp_i_ready,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input longp_excp_i_insterr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc\n);\n    // Module implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 17, "code": "module e203_exu_wbck (\n    input wire alu_wbck_i_valid,\n    output wire alu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] alu_wbck_i_wdat,\n    input wire [E203_RFIDX_WIDTH-1:0] alu_wbck_i_rdidx,\n    input wire longp_wbck_i_valid,\n    output wire longp_wbck_i_ready,\n    input wire [E203_FLEN-1:0] longp_wbck_i_wdat,\n    input wire [4:0] longp_wbck_i_flags,\n    input wire [E203_RFIDX_WIDTH-1:0] longp_wbck_i_rdidx,\n    input wire longp_wbck_i_rdfpu,\n    output wire rf_wbck_o_ena,\n    output wire [E203_XLEN-1:0] rf_wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] rf_wbck_o_rdidx,\n    input wire clk,\n    input wire rst_n\n);\n\n// Arbitration logic\nassign longp_wbck_i_ready = longp_wbck_i_valid;\nassign alu_wbck_i_ready = !longp_wbck_i_valid & alu_wbck_i_valid;\n\n// Write-back data selection\nwire [E203_XLEN-1:0] selected_wdat = longp_wbck_i_valid ? longp_wbck_i_wdat : alu_wbck_i_wdat;\nwire [E203_RFIDX_WIDTH-1:0] selected_rdidx = longp_wbck_i_valid ? longp_wbck_i_rdidx : alu_wbck_i_rdidx;\nwire selected_rdfpu = longp_wbck_i_valid ? longp_wbck_i_rdfpu : 1'b0;\n\n// Write-back enable\nassign rf_wbck_o_ena = (alu_wbck_i_valid | longp_wbck_i_valid) & !selected_rdfpu;\n\n// Output assignment\nassign rf_wbck_o_wdat = selected_wdat;\nassign rf_wbck_o_rdidx = selected_rdidx;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 11, "code": "module e203_ifu(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire itcm_nohold,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire ifu_active,\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    input wire pipe_flush_req,\n    output wire pipe_flush_ack,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input wire ifu_halt_req,\n    output wire ifu_halt_ack,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu\n);\n\n    // Internal signals for submodule connections and control logic\n    wire [E203_PC_SIZE-1:0] ifetch_pc;\n    wire ifetch_req_valid;\n    wire [E203_PC_SIZE-1:0] ifetch_req_pc;\n    wire ifetch_req_seq;\n    wire ifetch_req_seq_rv32;\n    wire [E203_PC_SIZE-1:0] ifetch_req_last_pc;\n    wire ifetch_halt_ack;\n    wire [E203_INSTR_SIZE-1:0] ifetch_instr;\n    wire ifetch_rsp_valid;\n    wire ifetch_rsp_err;\n\n    // Instantiate the instruction fetch module\n    e203_ifu_ifetch ifetch(\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ifu_o_ready(ifu_o_ready),\n        .pipe_flush_req(pipe_flush_req),\n        .pipe_flush_add_op1(pipe_flush_add_op1),\n        .pipe_flush_add_op2(pipe_flush_add_op2),\n        .ifu_halt_req(ifu_halt_req),\n        .oitf_empty(oitf_empty),\n        .rf2ifu_x1(rf2ifu_x1),\n        .rf2ifu_rs1(rf2ifu_rs1),\n        .dec2ifu_rden(dec2ifu_rden),\n        .dec2ifu_rs1en(dec2ifu_rs1en),\n        .dec2ifu_rdidx(dec2ifu_rdidx),\n        .dec2ifu_mulhsu(dec2ifu_mulhsu),\n        .dec2ifu_div(dec2ifu_div),\n        .dec2ifu_rem(dec2ifu_rem),\n        .dec2ifu_divu(dec2ifu_divu),\n        .dec2ifu_remu(dec2ifu_remu),\n        .inspect_pc(inspect_pc),\n        .ifu_req_valid(ifetch_req_valid),\n        .ifu_req_pc(ifetch_req_pc),\n        .ifu_req_seq(ifetch_req_seq),\n        .ifu_req_seq_rv32(ifetch_req_seq_rv32),\n        .ifu_req_last_pc(ifetch_req_last_pc),\n        .pipe_flush_ack(pipe_flush_ack),\n        .ifu_halt_ack(ifetch_halt_ack),\n        .ifu_o_ir(ifu_o_ir),\n        .ifu_o_pc(ifu_o_pc),\n        .ifu_o_pc_vld(ifu_o_pc_vld),\n        .ifu_o_misalgn(ifu_o_misalgn),\n        .ifu_o_buserr(ifu_o_buserr),\n        .ifu_o_rs1idx(ifu_o_rs1idx),\n        .ifu_o_rs2idx(ifu_o_rs2idx),\n        .ifu_o_prdt_taken(ifu_o_prdt_taken),\n        .ifu_o_muldiv_b2b(ifu_o_muldiv_b2b),\n        .ifu_o_valid(ifu_o_valid),\n        .ifu_rsp_valid(ifetch_rsp_valid),\n        .ifu_rsp_err(ifetch_rsp_err),\n        .ifu_rsp_instr(ifetch_instr)\n    );\n\n    // Control logic for IFU activity and halt acknowledgment\n    assign ifu_active = ifetch_req_valid;\n    assign ifu_halt_ack = ifetch_halt_ack;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 9, "code": "module e203_exu_alu(\n    input wire clk,\n    input wire rst_n,\n    input wire i_valid,\n    output wire i_ready,\n    input wire [E203_XLEN-1:0] i_rs1,\n    input wire [E203_XLEN-1:0] i_rs2,\n    input wire [E203_XLEN-1:0] i_imm,\n    input wire [E203_DECINFO_WIDTH-1:0] i_info,\n    input wire [E203_PC_SIZE-1:0] i_pc,\n    input wire [E203_INSTR_SIZE-1:0] i_instr,\n    input wire i_pc_vld,\n    input wire [E203_RFIDX_WIDTH-1:0] i_rdidx,\n    input wire i_rdwen,\n    input wire i_ilegl,\n    input wire i_buserr,\n    input wire i_misalgn,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire cmt_o_valid,\n    input wire cmt_o_ready,\n    output wire [E203_PC_SIZE-1:0] cmt_o_pc,\n    output wire [E203_INSTR_SIZE-1:0] cmt_o_instr,\n    output wire [E203_XLEN-1:0] cmt_o_imm,\n    output wire cmt_o_rv32,\n    output wire cmt_o_bjp,\n    output wire cmt_o_mret,\n    output wire cmt_o_dret,\n    output wire cmt_o_ecall,\n    output wire cmt_o_ebreak,\n    output wire cmt_o_fencei,\n    output wire cmt_o_wfi,\n    output wire cmt_o_ifu_misalgn,\n    output wire cmt_o_ifu_buserr,\n    output wire cmt_o_ifu_ilegl,\n    output wire cmt_o_bjp_prdt,\n    output wire cmt_o_bjp_rslv,\n    output wire cmt_o_misalgn,\n    output wire cmt_o_ld,\n    output wire cmt_o_stamo,\n    output wire cmt_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] cmt_o_badaddr,\n    output wire wbck_o_valid,\n    input wire wbck_o_ready,\n    output wire [E203_XLEN-1:0] wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] wbck_o_rdidx,\n    input wire mdv_nob2b,\n    output wire csr_ena,\n    output wire csr_wr_en,\n    output wire csr_rd_en,\n    output wire [11:0] csr_idx,\n    input wire nonflush_cmt_ena,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output wire [E203_XLEN-1:0] wbck_csr_dat,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_usign,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_longp_wbck_valid,\n    input wire nice_longp_wbck_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire i_nice_cmt_off_ilgl\n);\n\n    // Internal signals and logic for ALU operation\n    // Implement the ALU operations, CSR operations, and other functionalities as per the design specifications\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 16, "code": "module e203_exu_commit(\n    output commit_mret,\n    output commit_trap,\n    output core_wfi,\n    output nonflush_cmt_ena,\n    output excp_active,\n    input amo_wait,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input alu_cmt_i_valid,\n    output alu_cmt_i_ready,\n    input [E203_PC_SIZE-1:0] alu_cmt_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_cmt_i_instr,\n    input alu_cmt_i_pc_vld,\n    input [E203_XLEN-1:0] alu_cmt_i_imm,\n    input alu_cmt_i_rv32,\n    input alu_cmt_i_bjp,\n    input alu_cmt_i_wfi,\n    input alu_cmt_i_fencei,\n    input alu_cmt_i_mret,\n    input alu_cmt_i_dret,\n    input alu_cmt_i_ecall,\n    input alu_cmt_i_ebreak,\n    input alu_cmt_i_ifu_misalgn,\n    input alu_cmt_i_ifu_buserr,\n    input alu_cmt_i_ifu_ilegl,\n    input alu_cmt_i_bjp_prdt,\n    input alu_cmt_i_bjp_rslv,\n    input alu_cmt_i_misalgn,\n    input alu_cmt_i_ld,\n    input alu_cmt_i_stamo,\n    input alu_cmt_i_buserr,\n    input [E203_ADDR_SIZE-1:0] alu_cmt_i_badaddr,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output cmt_badaddr_ena,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output cmt_epc_ena,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_cause_ena,\n    output cmt_instret_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output cmt_mret_ena,\n    input [E203_PC_SIZE-1:0] csr_epc_r,\n    input [E203_PC_SIZE-1:0] csr_dpc_r,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output longp_excp_i_ready,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input longp_excp_i_insterr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input clk,\n    input rst_n\n);\n    // Implementation of the commit logic and exception handling\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 19, "code": "module e203_exu_alu_muldiv(\n    input mdv_nob2b,\n    input muldiv_i_valid,\n    output muldiv_i_ready,\n    input [E203_XLEN-1:0] muldiv_i_rs1,\n    input [E203_XLEN-1:0] muldiv_i_rs2,\n    input [E203_XLEN-1:0] muldiv_i_imm,\n    input [E203_DECINFO_MULDIV_WIDTH-1:0] muldiv_i_info,\n    input [E203_ITAG_WIDTH-1:0] muldiv_i_itag,\n    output muldiv_i_longpipe,\n    input flush_pulse,\n    output muldiv_o_valid,\n    input muldiv_o_ready,\n    output [E203_XLEN-1:0] muldiv_o_wbck_wdat,\n    output muldiv_o_wbck_err,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    output muldiv_req_alu_add,\n    output muldiv_req_alu_sub,\n    input [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output muldiv_sbf_0_ena,\n    output [32:0] muldiv_sbf_0_nxt,\n    input [32:0] muldiv_sbf_0_r,\n    output muldiv_sbf_1_ena,\n    output [32:0] muldiv_sbf_1_nxt,\n    input [32:0] muldiv_sbf_1_r,\n    input clk,\n    input rst_n\n);\n    // Internal signals and registers\n    reg [4:0] state;\n    reg [4:0] next_state;\n\n    // State definitions\n    localparam MULDIV_STATE_0TH = 5'd0;\n    localparam MULDIV_STATE_EXEC = 5'd1;\n    localparam MULDIV_STATE_REMD_CHCK = 5'd2;\n    localparam MULDIV_STATE_QUOT_CORR = 5'd3;\n    localparam MULDIV_STATE_REMD_CORR = 5'd4;\n\n    // FSM for managing multiplier and divider operations\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= MULDIV_STATE_0TH;\n        else if (flush_pulse)\n            state <= MULDIV_STATE_0TH;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            MULDIV_STATE_0TH: begin\n                if (muldiv_i_valid)\n                    next_state = MULDIV_STATE_EXEC;\n                else\n                    next_state = MULDIV_STATE_0TH;\n            end\n            MULDIV_STATE_EXEC: begin\n                // Assuming 17 cycles for multiplication and 33 for division\n                if (/* condition for multiplication or division completion */)\n                    next_state = MULDIV_STATE_REMD_CHCK;\n                else\n                    next_state = MULDIV_STATE_EXEC;\n            end\n            MULDIV_STATE_REMD_CHCK: begin\n                if (/* condition for remainder check */)\n                    next_state = MULDIV_STATE_QUOT_CORR;\n                else\n                    next_state = MULDIV_STATE_0TH;\n            end\n            MULDIV_STATE_QUOT_CORR: begin\n                next_state = MULDIV_STATE_REMD_CORR;\n            end\n            MULDIV_STATE_REMD_CORR: begin\n                next_state = MULDIV_STATE_0TH;\n            end\n            default: next_state = MULDIV_STATE_0TH;\n        endcase\n    end\n\n    // Output logic and other combinational logic\n    assign muldiv_i_ready = (state == MULDIV_STATE_0TH);\n    assign muldiv_o_valid = (state == MULDIV_STATE_REMD_CORR);\n    assign muldiv_o_wbck_wdat = /* result from operations */;\n    assign muldiv_o_wbck_err = 1'b0;\n\n    // More logic as required for Booth encoding, partial product accumulation, etc.\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 10, "code": "module e203_exu_alu(\n    input         clk,\n    input         rst_n,\n    input         i_valid,\n    output        i_ready,\n    input  [31:0] i_rs1,\n    input  [31:0] i_rs2,\n    input  [31:0] i_imm,\n    input  [6:0]  i_info,\n    output [31:0] o_result,\n    output        o_valid,\n    input         o_ready\n);\n\n    // Define operation types based on i_info\n    wire is_add  = i_info[0];\n    wire is_sub  = i_info[1];\n    wire is_and  = i_info[2];\n    wire is_or   = i_info[3];\n    wire is_xor  = i_info[4];\n    wire is_sll  = i_info[5];\n    wire is_srl  = i_info[6];\n\n    reg [31:0] result;\n    reg        valid_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            result <= 32'b0;\n            valid_reg <= 1'b0;\n        end else begin\n            if (i_valid && i_ready) begin\n                // Perform the operation based on the type\n                if (is_add) begin\n                    result <= i_rs1 + i_rs2;\n                end else if (is_sub) begin\n                    result <= i_rs1 - i_rs2;\n                end else if (is_and) begin\n                    result <= i_rs1 & i_rs2;\n                end else if (is_or) begin\n                    result <= i_rs1 | i_rs2;\n                end else if (is_xor) begin\n                    result <= i_rs1 ^ i_rs2;\n                end else if (is_sll) begin\n                    result <= i_rs1 << i_rs2[4:0];\n                end else if (is_srl) begin\n                    result <= i_rs1 >> i_rs2[4:0];\n                end\n                valid_reg <= 1'b1;\n            end else if (o_ready) begin\n                valid_reg <= 1'b0;\n            end\n        end\n    end\n\n    assign o_result = result;\n    assign o_valid = valid_reg;\n    assign i_ready = !valid_reg || o_ready;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 20, "code": "module e203_dtcm_ctrl (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n    output wire dtcm_active,\n\n    // LSU ICB Interface\n    input wire lsu2dtcm_icb_cmd_valid,\n    output wire lsu2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] lsu2dtcm_icb_cmd_addr,\n    input wire lsu2dtcm_icb_cmd_read,\n    input wire [31:0] lsu2dtcm_icb_cmd_wdata,\n    input wire [3:0] lsu2dtcm_icb_cmd_wmask,\n    output wire lsu2dtcm_icb_rsp_valid,\n    input wire lsu2dtcm_icb_rsp_ready,\n    output wire lsu2dtcm_icb_rsp_err,\n    output wire [31:0] lsu2dtcm_icb_rsp_rdata,\n\n    // External ICB Interface (Optional)\n    `ifdef E203_HAS_DTCM_EXTITF\n    input wire ext2dtcm_icb_cmd_valid,\n    output wire ext2dtcm_icb_cmd_ready,\n    input wire [E203_DTCM_ADDR_WIDTH-1:0] ext2dtcm_icb_cmd_addr,\n    input wire ext2dtcm_icb_cmd_read,\n    input wire [31:0] ext2dtcm_icb_cmd_wdata,\n    input wire [3:0] ext2dtcm_icb_cmd_wmask,\n    output wire ext2dtcm_icb_rsp_valid,\n    input wire ext2dtcm_icb_rsp_ready,\n    output wire ext2dtcm_icb_rsp_err,\n    output wire [31:0] ext2dtcm_icb_rsp_rdata,\n    `endif\n\n    // DTCM RAM Interface\n    output wire dtcm_ram_cs,\n    output wire dtcm_ram_we,\n    output wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    output wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    output wire clk_dtcm_ram\n);\n\n    // Internal signals for arbitration and control\n    wire arb_cmd_valid;\n    wire arb_cmd_ready;\n    wire [E203_DTCM_ADDR_WIDTH-1:0] arb_cmd_addr;\n    wire arb_cmd_read;\n    wire [31:0] arb_cmd_wdata;\n    wire [3:0] arb_cmd_wmask;\n    wire arb_rsp_valid;\n    wire arb_rsp_ready;\n    wire arb_rsp_err;\n    wire [31:0] arb_rsp_rdata;\n\n    // Instantiate the bus arbiter\n    sirv_gnrl_icb_arbt #(\n        .ARBT_SCHEME(0),\n        .ALLOW_0CYCL_RSP(0),\n        .FIFO_OUTS_NUM(E203_DTCM_OUTS_NUM),\n        .FIFO_CUT_READY(0),\n        .USR_W(1),\n        .ARBT_NUM(DTCM_ARBT_I_NUM),\n        .AW(E203_DTCM_ADDR_WIDTH),\n        .DW(32),\n        .ARBT_PTR_W(DTCM_ARBT_I_PTR_W)\n    ) u_dtcm_arbiter (\n        .o_icb_cmd_valid(arb_cmd_valid),\n        .o_icb_cmd_ready(arb_cmd_ready),\n        .o_icb_cmd_read(arb_cmd_read),\n        .o_icb_cmd_addr(arb_cmd_addr),\n        .o_icb_cmd_wdata(arb_cmd_wdata),\n        .o_icb_cmd_wmask(arb_cmd_wmask),\n        .o_icb_rsp_valid(arb_rsp_valid),\n        .o_icb_rsp_ready(arb_rsp_ready),\n        .o_icb_rsp_err(arb_rsp_err),\n        .o_icb_rsp_rdata(arb_rsp_rdata),\n        .i_bus_icb_cmd_ready({ext2dtcm_icb_cmd_ready, lsu2dtcm_icb_cmd_ready}),\n        .i_bus_icb_cmd_valid({ext2dtcm_icb_cmd_valid, lsu2dtcm_icb_cmd_valid}),\n        .i_bus_icb_cmd_read({ext2dtcm_icb_cmd_read, lsu2dtcm_icb_cmd_read}),\n        .i_bus_icb_cmd_addr({ext2dtcm_icb_cmd_addr, lsu2dtcm_icb_cmd_addr}),\n        .i_bus_icb_cmd_wdata({ext2dtcm_icb_cmd_wdata, lsu2dtcm_icb_cmd_wdata}),\n        .i_bus_icb_cmd_wmask({ext2dtcm_icb_cmd_wmask, lsu2dtcm_icb_cmd_wmask}),\n        .i_bus_icb_rsp_valid({ext2dtcm_icb_rsp_valid, lsu2dtcm_icb_rsp_valid}),\n        .i_bus_icb_rsp_ready({ext2dtcm_icb_rsp_ready, lsu2dtcm_icb_rsp_ready}),\n        .i_bus_icb_rsp_err({ext2dtcm_icb_rsp_err, lsu2dtcm_icb_rsp_err}),\n        .i_bus_icb_rsp_rdata({ext2dtcm_icb_rsp_rdata, lsu2dtcm_icb_rsp_rdata}),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\n    // Control logic for DTCM RAM\n    assign dtcm_ram_cs = arb_cmd_valid && arb_cmd_ready;\n    assign dtcm_ram_we = !arb_cmd_read;\n    assign dtcm_ram_addr = arb_cmd_addr[E203_DTCM_RAM_AW-1:0];\n    assign dtcm_ram_wem = arb_cmd_wmask;\n    assign dtcm_ram_din = arb_cmd_wdata;\n    assign clk_dtcm_ram = clk;\n\n    // Response logic\n    assign arb_rsp_valid = dtcm_ram_cs;\n    assign arb_rsp_rdata = dtcm_ram_dout;\n    assign arb_rsp_err = 0; // Assuming no error handling for simplicity\n\n    // Activity indicator\n    assign dtcm_active = arb_cmd_valid || arb_rsp_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 18, "code": "module e203_exu_wbck (\n    input wire alu_wbck_i_valid,\n    output wire alu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] alu_wbck_i_wdat,\n    input wire [E203_RFIDX_WIDTH-1:0] alu_wbck_i_rdidx,\n    input wire longp_wbck_i_valid,\n    output wire longp_wbck_i_ready,\n    input wire [E203_FLEN-1:0] longp_wbck_i_wdat,\n    input wire [4:0] longp_wbck_i_flags,\n    input wire [E203_RFIDX_WIDTH-1:0] longp_wbck_i_rdidx,\n    input wire longp_wbck_i_rdfpu,\n    output wire rf_wbck_o_ena,\n    output wire [E203_XLEN-1:0] rf_wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] rf_wbck_o_rdidx,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Arbitration logic\n    assign longp_wbck_i_ready = longp_wbck_i_valid;\n    assign alu_wbck_i_ready = !longp_wbck_i_valid && alu_wbck_i_valid;\n\n    // Write-back data selection\n    wire [E203_XLEN-1:0] selected_wdat = longp_wbck_i_valid ? longp_wbck_i_wdat : alu_wbck_i_wdat;\n    wire [E203_RFIDX_WIDTH-1:0] selected_rdidx = longp_wbck_i_valid ? longp_wbck_i_rdidx : alu_wbck_i_rdidx;\n    wire selected_rdfpu = longp_wbck_i_valid ? longp_wbck_i_rdfpu : 1'b0;\n\n    // Write-back enable\n    assign rf_wbck_o_ena = (alu_wbck_i_valid || longp_wbck_i_valid) && !selected_rdfpu;\n\n    // Write-back data and register index output\n    assign rf_wbck_o_wdat = selected_wdat;\n    assign rf_wbck_o_rdidx = selected_rdidx;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 17, "code": "module e203_exu_commit(\n    output commit_mret,\n    output commit_trap,\n    output core_wfi,\n    output nonflush_cmt_ena,\n    output excp_active,\n    input amo_wait,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input alu_cmt_i_valid,\n    output alu_cmt_i_ready,\n    input [E203_PC_SIZE-1:0] alu_cmt_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_cmt_i_instr,\n    input alu_cmt_i_pc_vld,\n    input [E203_XLEN-1:0] alu_cmt_i_imm,\n    input alu_cmt_i_rv32,\n    input alu_cmt_i_bjp,\n    input alu_cmt_i_wfi,\n    input alu_cmt_i_fencei,\n    input alu_cmt_i_mret,\n    input alu_cmt_i_dret,\n    input alu_cmt_i_ecall,\n    input alu_cmt_i_ebreak,\n    input alu_cmt_i_ifu_misalgn,\n    input alu_cmt_i_ifu_buserr,\n    input alu_cmt_i_ifu_ilegl,\n    input alu_cmt_i_bjp_prdt,\n    input alu_cmt_i_bjp_rslv,\n    input alu_cmt_i_misalgn,\n    input alu_cmt_i_ld,\n    input alu_cmt_i_stamo,\n    input alu_cmt_i_buserr,\n    input [E203_ADDR_SIZE-1:0] alu_cmt_i_badaddr,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output cmt_badaddr_ena,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output cmt_epc_ena,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_cause_ena,\n    output cmt_instret_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output cmt_mret_ena,\n    input [E203_PC_SIZE-1:0] csr_epc_r,\n    input [E203_PC_SIZE-1:0] csr_dpc_r,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output longp_excp_i_ready,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input longp_excp_i_insterr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc\n);\n    // Module implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 9, "code": "module e203_exu_decode (\n    input [E203_INSTR_SIZE-1:0] i_instr,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_prdt_taken,\n    input i_misalgn,\n    input i_buserr,\n    input i_muldiv_b2b,\n    input dbg_mode,\n    output dec_rs1x0,\n    output dec_rs2x0,\n    output dec_rs1en,\n    output dec_rs2en,\n    output dec_rdwen,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rdidx,\n    output [E203_DECINFO_WIDTH-1:0] dec_info,\n    output [E203_XLEN-1:0] dec_imm,\n    output [E203_PC_SIZE-1:0] dec_pc,\n    output dec_misalgn,\n    output dec_buserr,\n    output dec_ilegl,\n    output dec_mulhsu,\n    output dec_mul,\n    output dec_div,\n    output dec_rem,\n    output dec_divu,\n    output dec_remu,\n    output dec_rv32,\n    output dec_bjp,\n    output dec_jal,\n    output dec_jalr,\n    output dec_bxx,\n    output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    output [E203_XLEN-1:0] dec_bjp_imm,\n    `ifdef E203_HAS_NICE\n    input nice_xs_off,\n    output dec_nice,\n    output nice_cmt_off_ilgl_o,\n    `endif\n);\n\n    // Decode logic here\n    // Example of decoding an R-type instruction\n    wire [6:0] opcode = i_instr[6:0];\n    wire [2:0] funct3 = i_instr[14:12];\n    wire [6:0] funct7 = i_instr[31:25];\n    wire [4:0] rs1 = i_instr[19:15];\n    wire [4:0] rs2 = i_instr[24:20];\n    wire [4:0] rd = i_instr[11:7];\n\n    assign dec_rs1idx = rs1;\n    assign dec_rs2idx = rs2;\n    assign dec_rdidx = rd;\n\n    assign dec_rs1x0 = (rs1 == 5'b00000);\n    assign dec_rs2x0 = (rs2 == 5'b00000);\n    assign dec_rs1en = (opcode == 7'b0110011); // Example for R-type\n    assign dec_rs2en = (opcode == 7'b0110011); // Example for R-type\n    assign dec_rdwen = (opcode == 7'b0110011); // Example for R-type\n\n    // Example of setting illegal instruction flag\n    assign dec_ilegl = (opcode == 7'b0000000) || (opcode == 7'b1111111);\n\n    // Example of setting the information bus\n    assign dec_info = {E203_DECINFO_WIDTH{1'b0}}; // Default to all zeros\n\n    // Example of setting immediate values for I-type instructions\n    assign dec_imm = {{20{i_instr[31]}}, i_instr[31:20]}; // Sign-extended\n\n    // Pass through signals\n    assign dec_misalgn = i_misalgn;\n    assign dec_buserr = i_buserr;\n    assign dec_pc = i_pc;\n\n    // Example of decoding multiply instructions\n    assign dec_mul = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b000);\n    assign dec_mulhsu = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b010);\n\n    // More decoding logic as needed...\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 10, "code": "module e203_exu_decode (\n    input [E203_INSTR_SIZE-1:0] i_instr,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_prdt_taken,\n    input i_misalgn,\n    input i_buserr,\n    input i_muldiv_b2b,\n    input dbg_mode,\n    output dec_rs1x0,\n    output dec_rs2x0,\n    output dec_rs1en,\n    output dec_rs2en,\n    output dec_rdwen,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rdidx,\n    output [E203_DECINFO_WIDTH-1:0] dec_info,\n    output [E203_XLEN-1:0] dec_imm,\n    output [E203_PC_SIZE-1:0] dec_pc,\n    output dec_misalgn,\n    output dec_buserr,\n    output dec_ilegl,\n    output dec_mulhsu,\n    output dec_mul,\n    output dec_div,\n    output dec_rem,\n    output dec_divu,\n    output dec_remu,\n    output dec_rv32,\n    output dec_bjp,\n    output dec_jal,\n    output dec_jalr,\n    output dec_bxx,\n    output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    output [E203_XLEN-1:0] dec_bjp_imm,\n    `ifdef E203_HAS_NICE\n    input nice_xs_off,\n    output dec_nice,\n    output nice_cmt_off_ilgl_o,\n    `endif\n);\n\n    // Instruction decoding logic here\n    // This is a simplified example and needs to be expanded based on actual ISA specifications\n\n    assign dec_rs1x0 = (dec_rs1idx == 0);\n    assign dec_rs2x0 = (dec_rs2idx == 0);\n    assign dec_rs1en = |dec_rs1idx; // Enabled if rs1idx is non-zero\n    assign dec_rs2en = |dec_rs2idx; // Enabled if rs2idx is non-zero\n    assign dec_rdwen = |dec_rdidx;  // Enabled if rdidx is non-zero\n\n    // Example decoding for an R-type instruction\n    wire [6:0] opcode = i_instr[6:0];\n    wire [2:0] funct3 = i_instr[14:12];\n    wire [6:0] funct7 = i_instr[31:25];\n\n    always @(*) begin\n        case (opcode)\n            7'b0110011: begin // R-type\n                dec_rs1idx = i_instr[19:15];\n                dec_rs2idx = i_instr[24:20];\n                dec_rdidx = i_instr[11:7];\n                dec_rdwen = 1'b1;\n                case (funct3)\n                    3'b000: begin\n                        if (funct7 == 7'b0000000)\n                            dec_info = `E203_DECINFO_ALU_ADD;\n                        else if (funct7 == 7'b0100000)\n                            dec_info = `E203_DECINFO_ALU_SUB;\n                    end\n                    // Additional funct3 and funct7 decoding\n                endcase\n            end\n            // Additional opcode decoding\n        endcase\n    end\n\n    // Set illegal instruction flag if no valid decoding\n    assign dec_ilegl = (dec_info == 0);\n\n    // Propagate error signals\n    assign dec_misalgn = i_misalgn;\n    assign dec_buserr = i_buserr;\n\n    // Example for NICE extension\n    `ifdef E203_HAS_NICE\n    assign dec_nice = (opcode == `NICE_OPCODE);\n    assign nice_cmt_off_ilgl_o = nice_xs_off & dec_nice;\n    `endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 12, "code": "module e203_ifu (\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire itcm_nohold,\n    input wire [E203_ADDR_SIZE-1:0] itcm_region_indic,\n    input wire pipe_flush_req,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input wire ifu_halt_req,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire ifu_active,\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    output wire pipe_flush_ack,\n    output wire ifu_halt_ack\n);\n\n    // Internal signals\n    wire ifu_req_valid;\n    wire [E203_PC_SIZE-1:0] ifu_req_pc;\n    wire ifu_req_seq;\n    wire ifu_req_seq_rv32;\n    wire [E203_PC_SIZE-1:0] ifu_req_last_pc;\n    wire ifu_req_ready;\n    wire ifu_rsp_valid;\n    wire ifu_rsp_err;\n    wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr;\n\n    // Instantiate the instruction fetch module\n    e203_ifu_ifetch ifetch (\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ifu_o_ready(ifu_o_ready),\n        .pipe_flush_req(pipe_flush_req),\n        .pipe_flush_add_op1(pipe_flush_add_op1),\n        .pipe_flush_add_op2(pipe_flush_add_op2),\n        .ifu_halt_req(ifu_halt_req),\n        .oitf_empty(oitf_empty),\n        .rf2ifu_x1(rf2ifu_x1),\n        .rf2ifu_rs1(rf2ifu_rs1),\n        .dec2ifu_rden(dec2ifu_rden),\n        .dec2ifu_rs1en(dec2ifu_rs1en),\n        .dec2ifu_rdidx(dec2ifu_rdidx),\n        .dec2ifu_mulhsu(dec2ifu_mulhsu),\n        .dec2ifu_div(dec2ifu_div),\n        .dec2ifu_rem(dec2ifu_rem),\n        .dec2ifu_divu(dec2ifu_divu),\n        .dec2ifu_remu(dec2ifu_remu),\n        .inspect_pc(inspect_pc),\n        .ifu_req_valid(ifu_req_valid),\n        .ifu_req_pc(ifu_req_pc),\n        .ifu_req_seq(ifu_req_seq),\n        .ifu_req_seq_rv32(ifu_req_seq_rv32),\n        .ifu_req_last_pc(ifu_req_last_pc),\n        .pipe_flush_ack(pipe_flush_ack),\n        .ifu_halt_ack(ifu_halt_ack),\n        .ifu_o_ir(ifu_o_ir),\n        .ifu_o_pc(ifu_o_pc),\n        .ifu_o_pc_vld(ifu_o_pc_vld),\n        .ifu_o_misalgn(ifu_o_misalgn),\n        .ifu_o_buserr(ifu_o_buserr),\n        .ifu_o_rs1idx(ifu_o_rs1idx),\n        .ifu_o_rs2idx(ifu_o_rs2idx),\n        .ifu_o_prdt_taken(ifu_o_prdt_taken),\n        .ifu_o_muldiv_b2b(ifu_o_muldiv_b2b),\n        .ifu_o_valid(ifu_o_valid)\n    );\n\n    // Instantiate the bus interface unit\n    e203_ifu_ift2icb ift2icb (\n        .clk(clk),\n        .rst_n(rst_n),\n        .ifu_req_valid(ifu_req_valid),\n        .ifu_req_pc(ifu_req_pc),\n        .ifu_req_seq(ifu_req_seq),\n        .ifu_req_seq_rv32(ifu_req_seq_rv32),\n        .ifu_req_last_pc(ifu_req_last_pc),\n        .ifu_rsp_ready(ifu_o_ready),\n        .itcm_nohold(itcm_nohold),\n        .itcm_region_indic(itcm_region_indic),\n        .ifu_req_ready(ifu_req_ready),\n        .ifu_rsp_valid(ifu_rsp_valid),\n        .ifu_rsp_err(ifu_rsp_err),\n        .ifu_rsp_instr(ifu_rsp_instr)\n    );\n\n    assign ifu_active = ifu_req_valid || ifu_rsp_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 18, "code": "module e203_exu_commit(\n    output commit_mret,\n    output commit_trap,\n    output core_wfi,\n    output nonflush_cmt_ena,\n    output excp_active,\n    input amo_wait,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input alu_cmt_i_valid,\n    output alu_cmt_i_ready,\n    input [E203_PC_SIZE-1:0] alu_cmt_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_cmt_i_instr,\n    input alu_cmt_i_pc_vld,\n    input [E203_XLEN-1:0] alu_cmt_i_imm,\n    input alu_cmt_i_rv32,\n    input alu_cmt_i_bjp,\n    input alu_cmt_i_wfi,\n    input alu_cmt_i_fencei,\n    input alu_cmt_i_mret,\n    input alu_cmt_i_dret,\n    input alu_cmt_i_ecall,\n    input alu_cmt_i_ebreak,\n    input alu_cmt_i_ifu_misalgn,\n    input alu_cmt_i_ifu_buserr,\n    input alu_cmt_i_ifu_ilegl,\n    input alu_cmt_i_bjp_prdt,\n    input alu_cmt_i_bjp_rslv,\n    input alu_cmt_i_misalgn,\n    input alu_cmt_i_ld,\n    input alu_cmt_i_stamo,\n    input alu_cmt_i_buserr,\n    input [E203_ADDR_SIZE-1:0] alu_cmt_i_badaddr,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output cmt_badaddr_ena,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output cmt_epc_ena,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_cause_ena,\n    output cmt_instret_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output cmt_mret_ena,\n    input [E203_PC_SIZE-1:0] csr_epc_r,\n    input [E203_PC_SIZE-1:0] csr_dpc_r,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output longp_excp_i_ready,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input longp_excp_i_insterr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input clk,\n    input rst_n\n);\n    // Module implementation\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 11, "code": "module e203_exu_alu(\n    input         clk,\n    input         rst_n,\n    input         i_valid,\n    output        i_ready,\n    input  [31:0] i_rs1,\n    input  [31:0] i_rs2,\n    input  [31:0] i_imm,\n    input  [31:0] i_info,\n    input  [31:0] i_pc,\n    input  [31:0] i_instr,\n    output        o_valid,\n    input         o_ready,\n    output [31:0] o_result\n);\n\n    // ALU operation decoding\n    wire [3:0] alu_op = i_info[3:0]; // Simplified decode information\n    reg [31:0] alu_result;\n    wire       add_sub_op = (alu_op == 4'b0000) || (alu_op == 4'b0001);\n    wire       and_op     = (alu_op == 4'b0010);\n    wire       or_op      = (alu_op == 4'b0011);\n    wire       xor_op     = (alu_op == 4'b0100);\n    wire       slt_op     = (alu_op == 4'b0101);\n    wire       sltu_op    = (alu_op == 4'b0110);\n    wire       sll_op     = (alu_op == 4'b0111);\n    wire       srl_op     = (alu_op == 4'b1000);\n    wire       sra_op     = (alu_op == 4'b1001);\n\n    // ALU computation\n    always @(*) begin\n        case (1'b1) // synthesis parallel_case\n            add_sub_op: alu_result = (alu_op == 4'b0001) ? (i_rs1 - i_rs2) : (i_rs1 + i_rs2);\n            and_op:     alu_result = i_rs1 & i_rs2;\n            or_op:      alu_result = i_rs1 | i_rs2;\n            xor_op:     alu_result = i_rs1 ^ i_rs2;\n            slt_op:     alu_result = ($signed(i_rs1) < $signed(i_rs2)) ? 32'd1 : 32'd0;\n            sltu_op:    alu_result = (i_rs1 < i_rs2) ? 32'd1 : 32'd0;\n            sll_op:     alu_result = i_rs1 << i_rs2[4:0];\n            srl_op:     alu_result = i_rs1 >> i_rs2[4:0];\n            sra_op:     alu_result = $signed(i_rs1) >>> i_rs2[4:0];\n            default:    alu_result = 32'd0;\n        endcase\n    end\n\n    // Handshaking signals\n    assign i_ready = o_ready;\n    assign o_valid = i_valid;\n    assign o_result = alu_result;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 11, "code": "module e203_ifu_litebpu #(\n  parameter E203_PC_SIZE = 32,\n  parameter E203_XLEN = 32,\n  parameter E203_RFIDX_WIDTH = 5\n)(\n  input clk,\n  input rst_n,\n  input [E203_PC_SIZE-1:0] pc,\n  input dec_jal,\n  input dec_jalr,\n  input dec_bxx,\n  input [E203_XLEN-1:0] dec_bjp_imm,\n  input [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  input oitf_empty,\n  input ir_empty,\n  input ir_rs1en,\n  input jalr_rs1idx_cam_irrdidx,\n  input dec_i_valid,\n  input ir_valid_clr,\n  input [E203_XLEN-1:0] rf2bpu_x1,\n  input [E203_XLEN-1:0] rf2bpu_rs1,\n  output reg prdt_taken,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op1,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op2,\n  output reg bpu_wait,\n  output reg bpu2rf_rs1_ena\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      prdt_taken <= 1'b0;\n      prdt_pc_add_op1 <= {E203_PC_SIZE{1'b0}};\n      prdt_pc_add_op2 <= {E203_PC_SIZE{1'b0}};\n      bpu_wait <= 1'b0;\n      bpu2rf_rs1_ena <= 1'b0;\n    end else begin\n      prdt_taken <= (dec_jal || dec_jalr || (dec_bxx && dec_bjp_imm[E203_XLEN-1]));\n      prdt_pc_add_op1 <= (dec_jal || dec_bxx) ? pc : \n                         (dec_jalr && dec_jalr_rs1idx == 0) ? 0 :\n                         (dec_jalr && dec_jalr_rs1idx == 1) ? rf2bpu_x1 : rf2bpu_rs1;\n      prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n      bpu_wait <= (dec_jalr && !oitf_empty && (jalr_rs1idx_cam_irrdidx || !ir_empty));\n      bpu2rf_rs1_ena <= dec_jalr && (dec_jalr_rs1idx != 0) && (dec_jalr_rs1idx != 1);\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 11, "code": "module e203_exu_decode (\n    input [E203_INSTR_SIZE-1:0] i_instr,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_prdt_taken,\n    input i_misalgn,\n    input i_buserr,\n    input i_muldiv_b2b,\n    input dbg_mode,\n    output dec_rs1x0,\n    output dec_rs2x0,\n    output dec_rs1en,\n    output dec_rs2en,\n    output dec_rdwen,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rdidx,\n    output [E203_DECINFO_WIDTH-1:0] dec_info,\n    output [E203_XLEN-1:0] dec_imm,\n    output [E203_PC_SIZE-1:0] dec_pc,\n    output dec_misalgn,\n    output dec_buserr,\n    output dec_ilegl,\n    output dec_mulhsu,\n    output dec_mul,\n    output dec_div,\n    output dec_rem,\n    output dec_divu,\n    output dec_remu,\n    output dec_rv32,\n    output dec_bjp,\n    output dec_jal,\n    output dec_jalr,\n    output dec_bxx,\n    output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    output [E203_XLEN-1:0] dec_bjp_imm,\n    `ifdef E203_HAS_NICE\n    input nice_xs_off,\n    output dec_nice,\n    output nice_cmt_off_ilgl_o,\n    `endif\n);\n\n    // Instruction decoding logic here\n    // This is a placeholder for the actual decoding logic that would be implemented\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 12, "code": "module e203_exu_alu(\n    input wire clk,\n    input wire rst_n,\n    input wire i_valid,\n    output wire i_ready,\n    input wire [E203_XLEN-1:0] i_rs1,\n    input wire [E203_XLEN-1:0] i_rs2,\n    input wire [E203_XLEN-1:0] i_imm,\n    input wire [E203_DECINFO_WIDTH-1:0] i_info,\n    input wire [E203_PC_SIZE-1:0] i_pc,\n    input wire [E203_INSTR_SIZE-1:0] i_instr,\n    input wire i_pc_vld,\n    input wire [E203_RFIDX_WIDTH-1:0] i_rdidx,\n    input wire i_rdwen,\n    input wire i_ilegl,\n    input wire i_buserr,\n    input wire i_misalgn,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire cmt_o_valid,\n    input wire cmt_o_ready,\n    output wire [E203_PC_SIZE-1:0] cmt_o_pc,\n    output wire [E203_INSTR_SIZE-1:0] cmt_o_instr,\n    output wire [E203_XLEN-1:0] cmt_o_imm,\n    output wire cmt_o_rv32,\n    output wire cmt_o_bjp,\n    output wire cmt_o_mret,\n    output wire cmt_o_dret,\n    output wire cmt_o_ecall,\n    output wire cmt_o_ebreak,\n    output wire cmt_o_fencei,\n    output wire cmt_o_wfi,\n    output wire cmt_o_ifu_misalgn,\n    output wire cmt_o_ifu_buserr,\n    output wire cmt_o_ifu_ilegl,\n    output wire cmt_o_bjp_prdt,\n    output wire cmt_o_bjp_rslv,\n    output wire cmt_o_misalgn,\n    output wire cmt_o_ld,\n    output wire cmt_o_stamo,\n    output wire cmt_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] cmt_o_badaddr,\n    output wire wbck_o_valid,\n    input wire wbck_o_ready,\n    output wire [E203_XLEN-1:0] wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] wbck_o_rdidx,\n    input wire mdv_nob2b,\n    output wire csr_ena,\n    output wire csr_wr_en,\n    output wire csr_rd_en,\n    output wire [11:0] csr_idx,\n    input wire nonflush_cmt_ena,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output wire [E203_XLEN-1:0] wbck_csr_dat,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_usign,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_longp_wbck_valid,\n    input wire nice_longp_wbck_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire i_nice_cmt_off_ilgl\n);\n    // ALU core logic implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 8, "code": "module e203_exu_excp (\n    output commit_trap,\n    output core_wfi,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input amo_wait,\n    input alu_excp_i_valid,\n    input alu_excp_i_ld,\n    input alu_excp_i_stamo,\n    input alu_excp_i_misalgn,\n    input alu_excp_i_buserr,\n    input alu_excp_i_ecall,\n    input alu_excp_i_ebreak,\n    input alu_excp_i_wfi,\n    input alu_excp_i_ifu_misalgn,\n    input alu_excp_i_ifu_buserr,\n    input alu_excp_i_ifu_ilegl,\n    input [E203_PC_SIZE-1:0] alu_excp_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_excp_i_instr,\n    input alu_excp_i_pc_vld,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input longp_excp_i_insterr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input excpirq_flush_ack,\n    output excpirq_flush_req,\n    output nonalu_excpirq_flush_req_raw,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op1,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op2,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input cmt_dret_ena,\n    input cmt_ena,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_badaddr_ena,\n    output cmt_epc_ena,\n    output cmt_cause_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output excp_active,\n    input clk,\n    input rst_n\n);\n    // Implementation of exception handling logic\n    // This is a simplified example and may need to be expanded based on specific requirements\n\n    // Exception cause calculation\n    reg [E203_XLEN-1:0] cause;\n    always @(*) begin\n        if (alu_excp_i_valid) begin\n            if (alu_excp_i_ecall) cause = 11; // Environment call from M-mode\n            else if (alu_excp_i_ebreak) cause = 3; // Breakpoint\n            else if (alu_excp_i_misalgn) cause = 0; // Instruction address misaligned\n            else if (alu_excp_i_buserr) cause = 1; // Instruction access fault\n            else cause = 31; // Reserved\n        end\n        else if (longp_excp_i_valid) begin\n            if (longp_excp_i_ld || longp_excp_i_st) cause = 5; // Load access fault\n            else if (longp_excp_i_buserr) cause = 7; // Store/AMO access fault\n            else cause = 31; // Reserved\n        end\n        else cause = 31; // Reserved\n    end\n\n    // Exception PC and bad address calculation\n    reg [E203_PC_SIZE-1:0] excp_pc;\n    reg [E203_ADDR_SIZE-1:0] badaddr;\n    always @(*) begin\n        if (alu_excp_i_valid) begin\n            excp_pc = alu_excp_i_pc;\n            badaddr = alu_excp_i_pc; // Simplified, typically depends on the type of exception\n        end\n        else if (longp_excp_i_valid) begin\n            excp_pc = longp_excp_i_pc;\n            badaddr = longp_excp_i_badaddr;\n        end\n        else begin\n            excp_pc = 0;\n            badaddr = 0;\n        end\n    end\n\n    // Exception commit logic\n    assign commit_trap = alu_excp_i_valid || longp_excp_i_valid;\n    assign cmt_cause = cause;\n    assign cmt_epc = excp_pc;\n    assign cmt_badaddr = badaddr;\n    assign cmt_cause_ena = commit_trap;\n    assign cmt_epc_ena = commit_trap;\n    assign cmt_badaddr_ena = commit_trap;\n\n    // WFI handling\n    reg core_wfi_reg;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) core_wfi_reg <= 1'b0;\n        else if (alu_excp_i_wfi && cmt_ena) core_wfi_reg <= 1'b1;\n        else if (dbg_irq_r || lcl_irq_r || ext_irq_r || sft_irq_r || tmr_irq_r) core_wfi_reg <= 1'b0;\n    end\n\n    assign core_wfi = core_wfi_reg;\n    assign wfi_halt_ifu_req = core_wfi_reg && !wfi_halt_ifu_ack;\n    assign wfi_halt_exu_req = core_wfi_reg && !wfi_halt_exu_ack;\n\n    // Pipeline flush request\n    assign excpirq_flush_req = commit_trap;\n    assign excpirq_flush_add_op1 = csr_mtvec_r;\n    assign excpirq_flush_add_op2 = 0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 16, "code": "module e203_exu_csr(\n    input wire nonflush_cmt_ena,\n    input wire csr_ena,\n    input wire csr_wr_en,\n    input wire csr_rd_en,\n    input wire [11:0] csr_idx,\n    output wire csr_access_ilgl,\n    output wire tm_stop,\n    output wire core_cgstop,\n    output wire tcm_cgstop,\n    output wire itcm_nohold,\n    output wire mdv_nob2b,\n    output wire [E203_XLEN-1:0] read_csr_dat,\n    input wire [E203_XLEN-1:0] wbck_csr_dat,\n    input wire [E203_HART_ID_W-1:0] core_mhartid,\n    input wire ext_irq_r,\n    input wire sft_irq_r,\n    input wire tmr_irq_r,\n    output wire status_mie_r,\n    output wire mtie_r,\n    output wire msie_r,\n    output wire meie_r,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    input wire [E203_XLEN-1:0] dcsr_r,\n    input wire [E203_PC_SIZE-1:0] dpc_r,\n    input wire [E203_XLEN-1:0] dscratch_r,\n    output wire u_mode,\n    output wire s_mode,\n    output wire h_mode,\n    output wire m_mode,\n    input wire [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    input wire cmt_badaddr_ena,\n    input wire [E203_PC_SIZE-1:0] cmt_epc,\n    input wire cmt_epc_ena,\n    input wire [E203_XLEN-1:0] cmt_cause,\n    input wire cmt_cause_ena,\n    input wire cmt_status_ena,\n    input wire cmt_instret_ena,\n    input wire cmt_mret_ena,\n    output wire [E203_PC_SIZE-1:0] csr_epc_r,\n    output wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    output wire [E203_XLEN-1:0] csr_mtvec_r,\n    input wire clk_aon,\n    input wire clk,\n    input wire rst_n\n    `ifdef E203_HAS_NICE\n    , output wire nice_xs_off\n    `endif\n);\n\n    // CSR logic implementation here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 20, "code": "module e203_exu_alu_muldiv(\n    input mdv_nob2b,\n    input muldiv_i_valid,\n    output muldiv_i_ready,\n    input [E203_XLEN-1:0] muldiv_i_rs1,\n    input [E203_XLEN-1:0] muldiv_i_rs2,\n    input [E203_XLEN-1:0] muldiv_i_imm,\n    input [E203_DECINFO_MULDIV_WIDTH-1:0] muldiv_i_info,\n    input [E203_ITAG_WIDTH-1:0] muldiv_i_itag,\n    output muldiv_i_longpipe,\n    input flush_pulse,\n    output muldiv_o_valid,\n    input muldiv_o_ready,\n    output [E203_XLEN-1:0] muldiv_o_wbck_wdat,\n    output muldiv_o_wbck_err,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    output muldiv_req_alu_add,\n    output muldiv_req_alu_sub,\n    input [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output muldiv_sbf_0_ena,\n    output [32:0] muldiv_sbf_0_nxt,\n    input [32:0] muldiv_sbf_0_r,\n    output muldiv_sbf_1_ena,\n    output [32:0] muldiv_sbf_1_nxt,\n    input [32:0] muldiv_sbf_1_r,\n    input clk,\n    input rst_n\n);\n\n    // Internal signals and registers\n    reg [4:0] state;\n    reg [4:0] next_state;\n    reg [E203_XLEN-1:0] operand1, operand2;\n    reg [E203_XLEN-1:0] result;\n    wire operation_complete;\n    wire start_operation;\n    wire [E203_XLEN-1:0] alu_result;\n\n    // State definitions\n    localparam MULDIV_STATE_IDLE      = 5'd0;\n    localparam MULDIV_STATE_EXEC      = 5'd1;\n    localparam MULDIV_STATE_REMD_CHCK = 5'd2;\n    localparam MULDIV_STATE_QUOT_CORR = 5'd3;\n    localparam MULDIV_STATE_REMD_CORR = 5'd4;\n\n    // FSM for handling multiplier and divider operations\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= MULDIV_STATE_IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            MULDIV_STATE_IDLE: begin\n                if (start_operation)\n                    next_state = MULDIV_STATE_EXEC;\n                else\n                    next_state = MULDIV_STATE_IDLE;\n            end\n            MULDIV_STATE_EXEC: begin\n                if (operation_complete)\n                    next_state = MULDIV_STATE_REMD_CHCK;\n                else\n                    next_state = MULDIV_STATE_EXEC;\n            end\n            MULDIV_STATE_REMD_CHCK: begin\n                if (muldiv_i_info[0]) // Example condition for remainder check\n                    next_state = MULDIV_STATE_QUOT_CORR;\n                else\n                    next_state = MULDIV_STATE_IDLE;\n            end\n            MULDIV_STATE_QUOT_CORR: begin\n                next_state = MULDIV_STATE_REMD_CORR;\n            end\n            MULDIV_STATE_REMD_CORR: begin\n                next_state = MULDIV_STATE_IDLE;\n            end\n            default: begin\n                next_state = MULDIV_STATE_IDLE;\n            end\n        endcase\n    end\n\n    // Example operation logic\n    assign start_operation = muldiv_i_valid && muldiv_i_ready;\n    assign operation_complete = (state == MULDIV_STATE_EXEC) && (/* condition */);\n\n    // Result handling\n    always @(posedge clk) begin\n        if (state == MULDIV_STATE_EXEC) begin\n            result <= alu_result; // Example accumulation or computation\n        end\n    end\n\n    // Output assignments\n    assign muldiv_i_ready = (state == MULDIV_STATE_IDLE);\n    assign muldiv_o_valid = (state == MULDIV_STATE_REMD_CORR);\n    assign muldiv_o_wbck_wdat = result;\n    assign muldiv_o_wbck_err = 1'b0; // Assuming no error handling for simplicity\n\n    // ALU datapath connections\n    assign muldiv_req_alu_op1 = operand1;\n    assign muldiv_req_alu_op2 = operand2;\n    assign muldiv_req_alu_add = (state == MULDIV_STATE_EXEC);\n    assign muldiv_req_alu_sub = !muldiv_req_alu_add;\n    assign alu_result = muldiv_req_alu_res;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 17, "code": "module e203_exu_csr (\n    input wire nonflush_cmt_ena,\n    input wire csr_ena,\n    input wire csr_wr_en,\n    input wire csr_rd_en,\n    input wire [11:0] csr_idx,\n    output wire csr_access_ilgl,\n    output wire tm_stop,\n    output wire core_cgstop,\n    output wire tcm_cgstop,\n    output wire itcm_nohold,\n    output wire mdv_nob2b,\n    output wire [E203_XLEN-1:0] read_csr_dat,\n    input wire [E203_XLEN-1:0] wbck_csr_dat,\n    input wire [E203_HART_ID_W-1:0] core_mhartid,\n    input wire ext_irq_r,\n    input wire sft_irq_r,\n    input wire tmr_irq_r,\n    output wire status_mie_r,\n    output wire mtie_r,\n    output wire msie_r,\n    output wire meie_r,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    input wire [E203_XLEN-1:0] dcsr_r,\n    input wire [E203_PC_SIZE-1:0] dpc_r,\n    input wire [E203_XLEN-1:0] dscratch_r,\n    output wire u_mode,\n    output wire s_mode,\n    output wire h_mode,\n    output wire m_mode,\n    input wire [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    input wire cmt_badaddr_ena,\n    input wire [E203_PC_SIZE-1:0] cmt_epc,\n    input wire cmt_epc_ena,\n    input wire [E203_XLEN-1:0] cmt_cause,\n    input wire cmt_cause_ena,\n    input wire cmt_status_ena,\n    input wire cmt_instret_ena,\n    input wire cmt_mret_ena,\n    output wire [E203_PC_SIZE-1:0] csr_epc_r,\n    output wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    output wire [E203_XLEN-1:0] csr_mtvec_r,\n    input wire clk_aon,\n    input wire clk,\n    input wire rst_n\n);\n\n// CSR logic implementation here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 6, "code": "module e203_exu(\n    // Basic Interface\n    output commit_mret,\n    output commit_trap,\n    output exu_active,\n    output excp_active,\n    output core_wfi,\n    output tm_stop,\n    output itcm_nohold,\n    output core_cgstop,\n    output tcm_cgstop,\n    input [E203_HART_ID_W-1:0] core_mhartid,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    output wfi_halt_ifu_req,\n    input wfi_halt_ifu_ack,\n    output oitf_empty,\n    output [E203_XLEN-1:0] rf2ifu_x1,\n    output [E203_XLEN-1:0] rf2ifu_rs1,\n    output dec2ifu_rden,\n    output dec2ifu_rs1en,\n    output [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    output dec2ifu_mulhsu,\n    output dec2ifu_div,\n    output dec2ifu_rem,\n    output dec2ifu_divu,\n    output dec2ifu_remu,\n    input test_mode,\n    input clk_aon,\n    input clk,\n    input rst_n,\n\n    // From/To debug ctrl module\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output wr_dcsr_ena,\n    output wr_dpc_ena,\n    output wr_dscratch_ena,\n    output [E203_XLEN-1:0] wr_csr_nxt,\n    input [E203_XLEN-1:0] dcsr_r,\n    input [E203_PC_SIZE-1:0] dpc_r,\n    input [E203_XLEN-1:0] dscratch_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input dbg_stopcycle,\n\n    // IFU IR stage to EXU interface\n    input i_valid,\n    output i_ready,\n    input [E203_INSTR_SIZE-1:0] i_ir,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_pc_vld,\n    input i_misalgn,\n    input i_buserr,\n    input i_prdt_taken,\n    input i_muldiv_b2b,\n    input [E203_RFIDX_WIDTH-1:0] i_rs1idx,\n    input [E203_RFIDX_WIDTH-1:0] i_rs2idx,\n\n    // Flush interface to IFU\n    input pipe_flush_ack,\n    output pipe_flush_req,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    `ifdef E203_TIMING_BOOST\n    output [E203_PC_SIZE-1:0] pipe_flush_pc,\n    `endif\n\n    // LSU Write-Back Interface\n    input lsu_o_valid,\n    output lsu_o_ready,\n    input [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    input [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    input lsu_o_wbck_err,\n    input lsu_o_cmt_ld,\n    input lsu_o_cmt_st,\n    input [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    input lsu_o_cmt_buserr,\n\n    // AGU ICB Interface to LSU-ctrl\n    output agu_icb_cmd_valid,\n    input agu_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output agu_icb_cmd_read,\n    output [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output agu_icb_cmd_lock,\n    output agu_icb_cmd_excl,\n    output [1:0] agu_icb_cmd_size,\n    output agu_icb_cmd_back2agu,\n    output agu_icb_cmd_usign,\n    output [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input agu_icb_rsp_valid,\n    output agu_icb_rsp_ready,\n    input agu_icb_rsp_err,\n    input agu_icb_rsp_excl_ok,\n    input [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    // CSR_NICE Interface(optional)\n    `ifdef E203_HAS_CSR_NICE\n    output nice_csr_valid,\n    input nice_csr_ready,\n    output [31:0] nice_csr_addr,\n    output nice_csr_wr,\n    output [31:0] nice_csr_wdata,\n    input [31:0] nice_csr_rdata,\n    `endif\n\n    // NICE Interface(optional)\n    `ifdef E203_HAS_NICE\n    output nice_req_valid,\n    input nice_req_ready,\n    output [E203_XLEN-1:0] nice_req_inst,\n    output [E203_XLEN-1:0] nice_req_rs1,\n    output [E203_XLEN-1:0] nice_req_rs2,\n    input nice_rsp_multicyc_valid,\n    output nice_rsp_multicyc_ready,\n    input [E203_XLEN-1:0] nice_rsp_multicyc_dat,\n    input nice_rsp_multicyc_err\n    `endif\n);\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 13, "code": "module e203_exu_disp (\n    input wire wfi_halt_exu_req,\n    output wire wfi_halt_exu_ack,\n    input wire oitf_empty,\n    input wire amo_wait,\n    input wire disp_i_valid,\n    output wire disp_i_ready,\n    input wire disp_i_rs1x0,\n    input wire disp_i_rs2x0,\n    input wire disp_i_rs1en,\n    input wire disp_i_rs2en,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input wire [E203_XLEN-1:0] disp_i_rs1,\n    input wire [E203_XLEN-1:0] disp_i_rs2,\n    input wire disp_i_rdwen,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input wire [E203_DECINFO_WIDTH-1:0] disp_i_info,\n    input wire [E203_XLEN-1:0] disp_i_imm,\n    input wire [E203_PC_SIZE-1:0] disp_i_pc,\n    input wire disp_i_misalgn,\n    input wire disp_i_buserr,\n    input wire disp_i_ilegl,\n    output wire disp_o_alu_valid,\n    input wire disp_o_alu_ready,\n    input wire disp_o_alu_longpipe,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs1,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs2,\n    output wire disp_o_alu_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_o_alu_rdidx,\n    output wire [E203_DECINFO_WIDTH-1:0] disp_o_alu_info,\n    output wire [E203_XLEN-1:0] disp_o_alu_imm,\n    output wire [E203_PC_SIZE-1:0] disp_o_alu_pc,\n    output wire [E203_ITAG_WIDTH-1:0] disp_o_alu_itag,\n    output wire disp_o_alu_misalgn,\n    output wire disp_o_alu_buserr,\n    output wire disp_o_alu_ilegl,\n    input wire oitfrd_match_disprs1,\n    input wire oitfrd_match_disprs2,\n    input wire oitfrd_match_disprs3,\n    input wire oitfrd_match_disprd,\n    input wire [E203_ITAG_WIDTH-1:0] disp_oitf_ptr,\n    output wire disp_oitf_ena,\n    input wire disp_oitf_ready,\n    output wire disp_oitf_rs1fpu,\n    output wire disp_oitf_rs2fpu,\n    output wire disp_oitf_rs3fpu,\n    output wire disp_oitf_rdfpu,\n    output wire disp_oitf_rs1en,\n    output wire disp_oitf_rs2en,\n    output wire disp_oitf_rs3en,\n    output wire disp_oitf_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs2idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs3idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rdidx,\n    output wire [E203_PC_SIZE-1:0] disp_oitf_pc,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Implementation of the dispatch logic\n    // This is a simplified example and may need to be expanded based on actual design requirements\n\n    assign disp_i_ready = !amo_wait && disp_o_alu_ready && !wfi_halt_exu_req;\n\n    assign disp_o_alu_valid = disp_i_valid && disp_i_ready;\n    assign disp_o_alu_rs1 = disp_i_rs1;\n    assign disp_o_alu_rs2 = disp_i_rs2;\n    assign disp_o_alu_rdwen = disp_i_rdwen;\n    assign disp_o_alu_rdidx = disp_i_rdidx;\n    assign disp_o_alu_info = disp_i_info;\n    assign disp_o_alu_imm = disp_i_imm;\n    assign disp_o_alu_pc = disp_i_pc;\n    assign disp_o_alu_itag = disp_oitf_ptr;\n    assign disp_o_alu_misalgn = disp_i_misalgn;\n    assign disp_o_alu_buserr = disp_i_buserr;\n    assign disp_o_alu_ilegl = disp_i_ilegl;\n\n    assign disp_oitf_ena = disp_o_alu_valid && disp_o_alu_longpipe && disp_oitf_ready;\n    assign disp_oitf_rs1fpu = 0; // Assuming no FPU in this example\n    assign disp_oitf_rs2fpu = 0;\n    assign disp_oitf_rs3fpu = 0;\n    assign disp_oitf_rdfpu = 0;\n    assign disp_oitf_rs1en = disp_i_rs1en;\n    assign disp_oitf_rs2en = disp_i_rs2en;\n    assign disp_oitf_rs3en = 0; // Assuming no third operand\n    assign disp_oitf_rdwen = disp_i_rdwen;\n    assign disp_oitf_rs1idx = disp_i_rs1idx;\n    assign disp_oitf_rs2idx = disp_i_rs2idx;\n    assign disp_oitf_rs3idx = 0; // Assuming no third operand\n    assign disp_oitf_rdidx = disp_i_rdidx;\n    assign disp_oitf_pc = disp_i_pc;\n\n    assign wfi_halt_exu_ack = wfi_halt_exu_req && oitf_empty;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 18, "code": "module e203_exu_csr(\n    input nonflush_cmt_ena,\n    input csr_ena,\n    input csr_wr_en,\n    input csr_rd_en,\n    input [11:0] csr_idx,\n    output reg csr_access_ilgl,\n    output reg tm_stop,\n    output reg core_cgstop,\n    output reg tcm_cgstop,\n    output reg itcm_nohold,\n    output reg mdv_nob2b,\n    output [E203_XLEN-1:0] read_csr_dat,\n    input [E203_XLEN-1:0] wbck_csr_dat,\n    input [E203_HART_ID_W-1:0] core_mhartid,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    output reg status_mie_r,\n    output reg mtie_r,\n    output reg msie_r,\n    output reg meie_r,\n    output reg wr_dcsr_ena,\n    output reg wr_dpc_ena,\n    output reg wr_dscratch_ena,\n    input [E203_XLEN-1:0] dcsr_r,\n    input [E203_PC_SIZE-1:0] dpc_r,\n    input [E203_XLEN-1:0] dscratch_r,\n    output reg u_mode,\n    output reg s_mode,\n    output reg h_mode,\n    output reg m_mode,\n    input [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    input cmt_badaddr_ena,\n    input [E203_PC_SIZE-1:0] cmt_epc,\n    input cmt_epc_ena,\n    input [E203_XLEN-1:0] cmt_cause,\n    input cmt_cause_ena,\n    input cmt_status_ena,\n    input cmt_instret_ena,\n    input cmt_mret_ena,\n    output [E203_PC_SIZE-1:0] csr_epc_r,\n    output [E203_PC_SIZE-1:0] csr_dpc_r,\n    output [E203_XLEN-1:0] csr_mtvec_r,\n    input clk_aon,\n    input clk,\n    input rst_n\n);\n\n// CSR logic implementation here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 13, "code": "module e203_exu_alu(\n    input wire i_valid,\n    output wire i_ready,\n    output wire i_longpipe,\n    output wire nice_csr_valid,\n    input wire nice_csr_ready,\n    output wire [31:0] nice_csr_addr,\n    output wire nice_csr_wr,\n    output wire [31:0] nice_csr_wdata,\n    input wire [31:0] nice_csr_rdata,\n    input wire nice_xs_off,\n    output wire amo_wait,\n    input wire oitf_empty,\n    input wire [E203_ITAG_WIDTH-1:0] i_itag,\n    input wire [E203_XLEN-1:0] i_rs1,\n    input wire [E203_XLEN-1:0] i_rs2,\n    input wire [E203_XLEN-1:0] i_imm,\n    input wire [E203_DECINFO_WIDTH-1:0] i_info,\n    input wire [E203_PC_SIZE-1:0] i_pc,\n    input wire [E203_INSTR_SIZE-1:0] i_instr,\n    input wire i_pc_vld,\n    input wire [E203_RFIDX_WIDTH-1:0] i_rdidx,\n    input wire i_rdwen,\n    input wire i_ilegl,\n    input wire i_buserr,\n    input wire i_misalgn,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire cmt_o_valid,\n    input wire cmt_o_ready,\n    output wire cmt_o_pc_vld,\n    output wire [E203_PC_SIZE-1:0] cmt_o_pc,\n    output wire [E203_INSTR_SIZE-1:0] cmt_o_instr,\n    output wire [E203_XLEN-1:0] cmt_o_imm,\n    output wire cmt_o_rv32,\n    output wire cmt_o_bjp,\n    output wire cmt_o_mret,\n    output wire cmt_o_dret,\n    output wire cmt_o_ecall,\n    output wire cmt_o_ebreak,\n    output wire cmt_o_fencei,\n    output wire cmt_o_wfi,\n    output wire cmt_o_ifu_misalgn,\n    output wire cmt_o_ifu_buserr,\n    output wire cmt_o_ifu_ilegl,\n    output wire cmt_o_bjp_prdt,\n    output wire cmt_o_bjp_rslv,\n    output wire cmt_o_misalgn,\n    output wire cmt_o_ld,\n    output wire cmt_o_stamo,\n    output wire cmt_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] cmt_o_badaddr,\n    output wire wbck_o_valid,\n    input wire wbck_o_ready,\n    output wire [E203_XLEN-1:0] wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] wbck_o_rdidx,\n    input wire mdv_nob2b,\n    output wire csr_ena,\n    output wire csr_wr_en,\n    output wire csr_rd_en,\n    output wire [11:0] csr_idx,\n    input wire nonflush_cmt_ena,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output wire [E203_XLEN-1:0] wbck_csr_dat,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_usign,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_longp_wbck_valid,\n    input wire nice_longp_wbck_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire i_nice_cmt_off_ilgl,\n    input wire clk,\n    input wire rst_n\n);\n    // Module implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 14, "code": "module e203_exu_alu(\n    input wire clk,\n    input wire rst_n,\n    input wire i_valid,\n    output wire i_ready,\n    input wire [E203_XLEN-1:0] i_rs1,\n    input wire [E203_XLEN-1:0] i_rs2,\n    input wire [E203_XLEN-1:0] i_imm,\n    input wire [E203_DECINFO_WIDTH-1:0] i_info,\n    input wire [E203_PC_SIZE-1:0] i_pc,\n    input wire [E203_INSTR_SIZE-1:0] i_instr,\n    input wire i_pc_vld,\n    input wire [E203_RFIDX_WIDTH-1:0] i_rdidx,\n    input wire i_rdwen,\n    input wire i_ilegl,\n    input wire i_buserr,\n    input wire i_misalgn,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire cmt_o_valid,\n    input wire cmt_o_ready,\n    output wire [E203_PC_SIZE-1:0] cmt_o_pc,\n    output wire [E203_INSTR_SIZE-1:0] cmt_o_instr,\n    output wire [E203_XLEN-1:0] cmt_o_imm,\n    output wire cmt_o_rv32,\n    output wire cmt_o_bjp,\n    output wire cmt_o_mret,\n    output wire cmt_o_dret,\n    output wire cmt_o_ecall,\n    output wire cmt_o_ebreak,\n    output wire cmt_o_fencei,\n    output wire cmt_o_wfi,\n    output wire cmt_o_ifu_misalgn,\n    output wire cmt_o_ifu_buserr,\n    output wire cmt_o_ifu_ilegl,\n    output wire cmt_o_bjp_prdt,\n    output wire cmt_o_bjp_rslv,\n    output wire cmt_o_misalgn,\n    output wire cmt_o_ld,\n    output wire cmt_o_stamo,\n    output wire cmt_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] cmt_o_badaddr,\n    output wire wbck_o_valid,\n    input wire wbck_o_ready,\n    output wire [E203_XLEN-1:0] wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] wbck_o_rdidx,\n    input wire mdv_nob2b,\n    output wire csr_ena,\n    output wire csr_wr_en,\n    output wire csr_rd_en,\n    output wire [11:0] csr_idx,\n    input wire nonflush_cmt_ena,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output wire [E203_XLEN-1:0] wbck_csr_dat,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_usign,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_longp_wbck_valid,\n    input wire nice_longp_wbck_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire i_nice_cmt_off_ilgl\n);\n    // ALU core logic implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 12, "code": "module e203_lsu(\n    input wire commit_mret,\n    input wire commit_trap,\n    input wire excp_active,\n    output wire lsu_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n    output wire [ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_buserr,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [XLEN/8-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [XLEN-1:0] agu_icb_rsp_rdata\n);\n    // LSU logic implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 12, "code": "module e203_exu_decode(\n    input [E203_INSTR_SIZE-1:0] i_instr,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_prdt_taken,\n    input i_misalgn,\n    input i_buserr,\n    input i_muldiv_b2b,\n    input dbg_mode,\n    output dec_rs1x0,\n    output dec_rs2x0,\n    output dec_rs1en,\n    output dec_rs2en,\n    output dec_rdwen,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rdidx,\n    output [E203_DECINFO_WIDTH-1:0] dec_info,\n    output [E203_XLEN-1:0] dec_imm,\n    output [E203_PC_SIZE-1:0] dec_pc,\n    output dec_misalgn,\n    output dec_buserr,\n    output dec_ilegl,\n    output dec_mulhsu,\n    output dec_mul,\n    output dec_div,\n    output dec_rem,\n    output dec_divu,\n    output dec_remu,\n    output dec_rv32,\n    output dec_bjp,\n    output dec_jal,\n    output dec_jalr,\n    output dec_bxx,\n    output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    output [E203_XLEN-1:0] dec_bjp_imm,\n    input nice_xs_off,\n    output dec_nice,\n    output nice_cmt_off_ilgl_o\n);\n\n    // Instruction decoding logic here\n    // This is a placeholder for the actual decoding logic\n    // which would be quite extensive and involve parsing\n    // the instruction fields to set the outputs accordingly.\n\n    // Example of setting some outputs based on instruction type\n    always @(*) begin\n        case (i_instr[6:0]) // opcode\n            7'b0110011: begin // R-type\n                dec_rs1en = 1'b1;\n                dec_rs2en = 1'b1;\n                dec_rdwen = 1'b1;\n                dec_rs1idx = i_instr[19:15];\n                dec_rs2idx = i_instr[24:20];\n                dec_rdidx = i_instr[11:7];\n                // Further decode funct3 and funct7 to set other controls\n            end\n            7'b0010011: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs2en = 1'b0;\n                dec_rdwen = 1'b1;\n                dec_rs1idx = i_instr[19:15];\n                dec_rs2idx = 5'b0;\n                dec_rdidx = i_instr[11:7];\n                // Set immediate and other specific controls\n            end\n            // Additional cases for other types\n        endcase\n    end\n\n    // Set illegal instruction flag based on conditions\n    always @(*) begin\n        if (i_instr == 32'h00000000 || i_instr == 32'hFFFFFFFF)\n            dec_ilegl = 1'b1;\n        else\n            dec_ilegl = 1'b0;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 9, "code": "module e203_exu_excp(\n    output commit_trap,\n    output core_wfi,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input amo_wait,\n    input alu_excp_i_valid,\n    input alu_excp_i_ld,\n    input alu_excp_i_stamo,\n    input alu_excp_i_misalgn,\n    input alu_excp_i_buserr,\n    input alu_excp_i_ecall,\n    input alu_excp_i_ebreak,\n    input alu_excp_i_wfi,\n    input alu_excp_i_ifu_misalgn,\n    input alu_excp_i_ifu_buserr,\n    input alu_excp_i_ifu_ilegl,\n    input [E203_PC_SIZE-1:0] alu_excp_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_excp_i_instr,\n    input alu_excp_i_pc_vld,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input longp_excp_i_insterr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input excpirq_flush_ack,\n    output excpirq_flush_req,\n    output nonalu_excpirq_flush_req_raw,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op1,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op2,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input cmt_dret_ena,\n    input cmt_ena,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_badaddr_ena,\n    output cmt_epc_ena,\n    output cmt_cause_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output excp_active,\n    input clk,\n    input rst_n\n);\n\n    // Implementation of exception handling logic\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 15, "code": "module e203_exu_alu(\n    input wire clk,\n    input wire rst_n,\n    input wire i_valid,\n    output wire i_ready,\n    input wire [E203_XLEN-1:0] i_rs1,\n    input wire [E203_XLEN-1:0] i_rs2,\n    input wire [E203_XLEN-1:0] i_imm,\n    input wire [E203_DECINFO_WIDTH-1:0] i_info,\n    input wire [E203_PC_SIZE-1:0] i_pc,\n    input wire [E203_INSTR_SIZE-1:0] i_instr,\n    input wire i_pc_vld,\n    input wire [E203_RFIDX_WIDTH-1:0] i_rdidx,\n    input wire i_rdwen,\n    input wire i_ilegl,\n    input wire i_buserr,\n    input wire i_misalgn,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire cmt_o_valid,\n    input wire cmt_o_ready,\n    output wire [E203_PC_SIZE-1:0] cmt_o_pc,\n    output wire [E203_INSTR_SIZE-1:0] cmt_o_instr,\n    output wire [E203_XLEN-1:0] cmt_o_imm,\n    output wire cmt_o_rv32,\n    output wire cmt_o_bjp,\n    output wire cmt_o_mret,\n    output wire cmt_o_dret,\n    output wire cmt_o_ecall,\n    output wire cmt_o_ebreak,\n    output wire cmt_o_fencei,\n    output wire cmt_o_wfi,\n    output wire cmt_o_ifu_misalgn,\n    output wire cmt_o_ifu_buserr,\n    output wire cmt_o_ifu_ilegl,\n    output wire cmt_o_bjp_prdt,\n    output wire cmt_o_bjp_rslv,\n    output wire cmt_o_misalgn,\n    output wire cmt_o_ld,\n    output wire cmt_o_stamo,\n    output wire cmt_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] cmt_o_badaddr,\n    output wire wbck_o_valid,\n    input wire wbck_o_ready,\n    output wire [E203_XLEN-1:0] wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] wbck_o_rdidx,\n    input wire mdv_nob2b,\n    output wire csr_ena,\n    output wire csr_wr_en,\n    output wire csr_rd_en,\n    output wire [11:0] csr_idx,\n    input wire nonflush_cmt_ena,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output wire [E203_XLEN-1:0] wbck_csr_dat,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_usign,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_longp_wbck_valid,\n    input wire nice_longp_wbck_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire i_nice_cmt_off_ilgl\n);\n    // ALU core logic implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 13, "code": "module e203_ifu(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire itcm_nohold,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input wire pipe_flush_req,\n    input wire ifu_halt_req,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire ifu_active,\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    output wire pipe_flush_ack,\n    input wire `ifdef E203_TIMING_BOOST pipe_flush_pc, `endif\n    input wire `ifdef E203_HAS_ITCM ifu2itcm_holdup, `endif\n    input wire `ifdef E203_HAS_ITCM [E203_ADDR_SIZE-1:0] itcm_region_indic, `endif\n    output wire `ifdef E203_HAS_ITCM ifu2itcm_icb_cmd_valid, `endif\n    input wire `ifdef E203_HAS_ITCM ifu2itcm_icb_cmd_ready, `endif\n    output wire `ifdef E203_HAS_ITCM [E203_ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr, `endif\n    input wire `ifdef E203_HAS_ITCM ifu2itcm_icb_rsp_valid, `endif\n    output wire `ifdef E203_HAS_ITCM ifu2itcm_icb_rsp_ready, `endif\n    input wire `ifdef E203_HAS_ITCM ifu2itcm_icb_rsp_err, `endif\n    input wire `ifdef E203_HAS_ITCM [E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata, `endif\n    output wire `ifdef E203_HAS_MEM_ITF ifu2biu_icb_cmd_valid, `endif\n    input wire `ifdef E203_HAS_MEM_ITF ifu2biu_icb_cmd_ready, `endif\n    output wire `ifdef E203_HAS_MEM_ITF [E203_ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr, `endif\n    input wire `ifdef E203_HAS_MEM_ITF ifu2biu_icb_rsp_valid, `endif\n    output wire `ifdef E203_HAS_MEM_ITF ifu2biu_icb_rsp_ready, `endif\n    input wire `ifdef E203_HAS_MEM_ITF ifu2biu_icb_rsp_err, `endif\n    input wire `ifdef E203_HAS_MEM_ITF [E203_SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata, `endif\n    output wire ifu_halt_ack\n);\n\n    // Internal signals and logic here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 19, "code": "module e203_exu_wbck (\n    input wire alu_wbck_i_valid,\n    output wire alu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] alu_wbck_i_wdat,\n    input wire [E203_RFIDX_WIDTH-1:0] alu_wbck_i_rdidx,\n    input wire longp_wbck_i_valid,\n    output wire longp_wbck_i_ready,\n    input wire [E203_FLEN-1:0] longp_wbck_i_wdat,\n    input wire [4:0] longp_wbck_i_flags,\n    input wire [E203_RFIDX_WIDTH-1:0] longp_wbck_i_rdidx,\n    input wire longp_wbck_i_rdfpu,\n    output wire rf_wbck_o_ena,\n    output wire [E203_XLEN-1:0] rf_wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] rf_wbck_o_rdidx,\n    input wire clk,\n    input wire rst_n\n);\n\n// Arbitration logic\nassign longp_wbck_i_ready = longp_wbck_i_valid;\nassign alu_wbck_i_ready = !longp_wbck_i_valid & alu_wbck_i_valid;\n\n// Write-back data selection\nwire [E203_XLEN-1:0] selected_wdat = longp_wbck_i_valid ? longp_wbck_i_wdat : alu_wbck_i_wdat;\nwire [E203_RFIDX_WIDTH-1:0] selected_rdidx = longp_wbck_i_valid ? longp_wbck_i_rdidx : alu_wbck_i_rdidx;\nwire selected_valid = longp_wbck_i_valid | alu_wbck_i_valid;\nwire write_to_rf = selected_valid & !longp_wbck_i_rdfpu;\n\n// Output assignments\nassign rf_wbck_o_ena = write_to_rf;\nassign rf_wbck_o_wdat = selected_wdat;\nassign rf_wbck_o_rdidx = selected_rdidx;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 12, "code": "module e203_ifu_litebpu #(\n  parameter E203_PC_SIZE = 32,\n  parameter E203_XLEN = 32,\n  parameter E203_RFIDX_WIDTH = 5\n)(\n  input clk,\n  input rst_n,\n  input [E203_PC_SIZE-1:0] pc,\n  input dec_jal,\n  input dec_jalr,\n  input dec_bxx,\n  input [E203_XLEN-1:0] dec_bjp_imm,\n  input [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  input oitf_empty,\n  input ir_empty,\n  input ir_rs1en,\n  input jalr_rs1idx_cam_irrdidx,\n  input dec_i_valid,\n  input ir_valid_clr,\n  input [E203_XLEN-1:0] rf2bpu_x1,\n  input [E203_XLEN-1:0] rf2bpu_rs1,\n  output reg prdt_taken,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op1,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op2,\n  output reg bpu_wait,\n  output reg bpu2rf_rs1_ena\n);\n\n  // Prediction logic\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      prdt_taken <= 1'b0;\n      prdt_pc_add_op1 <= {E203_PC_SIZE{1'b0}};\n      prdt_pc_add_op2 <= {E203_PC_SIZE{1'b0}};\n      bpu_wait <= 1'b0;\n      bpu2rf_rs1_ena <= 1'b0;\n    end else begin\n      // Default values\n      prdt_taken <= 1'b0;\n      prdt_pc_add_op1 <= pc;\n      prdt_pc_add_op2 <= dec_bjp_imm;\n      bpu_wait <= 1'b0;\n      bpu2rf_rs1_ena <= 1'b0;\n\n      if (dec_i_valid) begin\n        if (dec_jal) begin\n          prdt_taken <= 1'b1;\n        end else if (dec_jalr) begin\n          prdt_taken <= 1'b1;\n          if (dec_jalr_rs1idx == 0) begin\n            prdt_pc_add_op1 <= 0;\n          end else if (dec_jalr_rs1idx == 1) begin\n            prdt_pc_add_op1 <= rf2bpu_x1;\n            if (!oitf_empty || jalr_rs1idx_cam_irrdidx) begin\n              bpu_wait <= 1'b1;\n            end\n          end else begin\n            prdt_pc_add_op1 <= rf2bpu_rs1;\n            if (!oitf_empty || (ir_rs1en && !ir_empty)) begin\n              bpu_wait <= 1'b1;\n            end\n          end\n        end else if (dec_bxx) begin\n          if (dec_bjp_imm[E203_XLEN-1]) begin // Check if the immediate is negative\n            prdt_taken <= 1'b1;\n          end\n        end\n      end\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 7, "code": "module e203_exu(\n    output commit_mret,\n    output commit_trap,\n    output exu_active,\n    output excp_active,\n    output core_wfi,\n    output tm_stop,\n    output itcm_nohold,\n    output core_cgstop,\n    output tcm_cgstop,\n    input [E203_HART_ID_W-1:0] core_mhartid,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    output wfi_halt_ifu_req,\n    input wfi_halt_ifu_ack,\n    output oitf_empty,\n    output [E203_XLEN-1:0] rf2ifu_x1,\n    output [E203_XLEN-1:0] rf2ifu_rs1,\n    output dec2ifu_rden,\n    output dec2ifu_rs1en,\n    output [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    output dec2ifu_mulhsu,\n    output dec2ifu_div,\n    output dec2ifu_rem,\n    output dec2ifu_divu,\n    output dec2ifu_remu,\n    input test_mode,\n    input clk_aon,\n    input clk,\n    input rst_n,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output wr_dcsr_ena,\n    output wr_dpc_ena,\n    output wr_dscratch_ena,\n    output [E203_XLEN-1:0] wr_csr_nxt,\n    input [E203_XLEN-1:0] dcsr_r,\n    input [E203_PC_SIZE-1:0] dpc_r,\n    input [E203_XLEN-1:0] dscratch_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input dbg_stopcycle,\n    input i_valid,\n    output i_ready,\n    input [E203_INSTR_SIZE-1:0] i_ir,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_pc_vld,\n    input i_misalgn,\n    input i_buserr,\n    input i_prdt_taken,\n    input i_muldiv_b2b,\n    input [E203_RFIDX_WIDTH-1:0] i_rs1idx,\n    input [E203_RFIDX_WIDTH-1:0] i_rs2idx,\n    input pipe_flush_ack,\n    output pipe_flush_req,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input lsu_o_valid,\n    output lsu_o_ready,\n    input [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    input [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    input lsu_o_wbck_err,\n    input lsu_o_cmt_ld,\n    input lsu_o_cmt_st,\n    input [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    input lsu_o_cmt_buserr,\n    output agu_icb_cmd_valid,\n    input agu_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output agu_icb_cmd_read,\n    output [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    output agu_icb_cmd_lock,\n    output agu_icb_cmd_excl,\n    output [1:0] agu_icb_cmd_size,\n    output agu_icb_cmd_back2agu,\n    output agu_icb_cmd_usign,\n    output [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input agu_icb_rsp_valid,\n    output agu_icb_rsp_ready,\n    input agu_icb_rsp_err,\n    input agu_icb_rsp_excl_ok,\n    input [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output nice_csr_valid,\n    input nice_csr_ready,\n    output [31:0] nice_csr_addr,\n    output nice_csr_wr,\n    output [31:0] nice_csr_wdata,\n    input [31:0] nice_csr_rdata\n);\n    // Module implementation\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 8, "code": "module e203_exu(\n    output commit_mret,\n    output commit_trap,\n    output exu_active,\n    output excp_active,\n    output core_wfi,\n    output tm_stop,\n    output itcm_nohold,\n    output core_cgstop,\n    output tcm_cgstop,\n    input [E203_HART_ID_W-1:0] core_mhartid,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    output wfi_halt_ifu_req,\n    input wfi_halt_ifu_ack,\n    output oitf_empty,\n    output [E203_XLEN-1:0] rf2ifu_x1,\n    output [E203_XLEN-1:0] rf2ifu_rs1,\n    output dec2ifu_rden,\n    output dec2ifu_rs1en,\n    output [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    output dec2ifu_mulhsu,\n    output dec2ifu_div,\n    output dec2ifu_rem,\n    output dec2ifu_divu,\n    output dec2ifu_remu,\n    input test_mode,\n    input clk_aon,\n    input clk,\n    input rst_n,\n    output cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output wr_dcsr_ena,\n    output wr_dpc_ena,\n    output wr_dscratch_ena,\n    output [E203_XLEN-1:0] wr_csr_nxt,\n    input [E203_XLEN-1:0] dcsr_r,\n    input [E203_PC_SIZE-1:0] dpc_r,\n    input [E203_XLEN-1:0] dscratch_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input dbg_stopcycle,\n    input i_valid,\n    output i_ready,\n    input [E203_INSTR_SIZE-1:0] i_ir,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_pc_vld,\n    input i_misalgn,\n    input i_buserr,\n    input i_prdt_taken,\n    input i_muldiv_b2b,\n    input [E203_RFIDX_WIDTH-1:0] i_rs1idx,\n    input [E203_RFIDX_WIDTH-1:0] i_rs2idx,\n    input pipe_flush_ack,\n    output pipe_flush_req,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input lsu_o_valid,\n    output lsu_o_ready,\n    input [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    input [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    input lsu_o_wbck_err,\n    input lsu_o_cmt_ld,\n    input lsu_o_cmt_st,\n    input [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    input lsu_o_cmt_buserr,\n    output agu_icb_cmd_valid,\n    input agu_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output agu_icb_cmd_read,\n    output [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    output agu_icb_cmd_lock,\n    output agu_icb_cmd_excl,\n    output [1:0] agu_icb_cmd_size,\n    output agu_icb_cmd_back2agu,\n    output agu_icb_cmd_usign,\n    output [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input agu_icb_rsp_valid,\n    output agu_icb_rsp_ready,\n    input agu_icb_rsp_err,\n    input agu_icb_rsp_excl_ok,\n    input [E203_XLEN-1:0] agu_icb_rsp_rdata\n);\n    // Module implementation\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 13, "code": "module e203_exu_decode (\n    input [E203_INSTR_SIZE-1:0] i_instr,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_prdt_taken,\n    input i_misalgn,\n    input i_buserr,\n    input i_muldiv_b2b,\n    input dbg_mode,\n    output dec_rs1x0,\n    output dec_rs2x0,\n    output dec_rs1en,\n    output dec_rs2en,\n    output dec_rdwen,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rdidx,\n    output [E203_DECINFO_WIDTH-1:0] dec_info,\n    output [E203_XLEN-1:0] dec_imm,\n    output [E203_PC_SIZE-1:0] dec_pc,\n    output dec_misalgn,\n    output dec_buserr,\n    output dec_ilegl,\n    output dec_mulhsu,\n    output dec_mul,\n    output dec_div,\n    output dec_rem,\n    output dec_divu,\n    output dec_remu,\n    output dec_rv32,\n    output dec_bjp,\n    output dec_jal,\n    output dec_jalr,\n    output dec_bxx,\n    output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    output [E203_XLEN-1:0] dec_bjp_imm,\n    output dec_nice,\n    output nice_cmt_off_ilgl_o\n);\n\n    // Decode logic here\n    // This is a placeholder for the actual implementation which would include:\n    // - Parsing the instruction to determine the type (R, I, S, B, U, J)\n    // - Extracting fields such as opcode, funct3, funct7, rs1, rs2, rd\n    // - Setting output signals based on the instruction type and fields\n\n    // Example for ADD instruction\n    wire is_r_type = (i_instr[6:0] == 7'b0110011);\n    wire is_add = is_r_type && (i_instr[14:12] == 3'b000) && (i_instr[31:25] == 7'b0000000);\n\n    assign dec_rs1idx = i_instr[19:15];\n    assign dec_rs2idx = i_instr[24:20];\n    assign dec_rdidx = i_instr[11:7];\n    assign dec_rs1en = is_add;\n    assign dec_rs2en = is_add;\n    assign dec_rdwen = is_add;\n    assign dec_info = {E203_DECINFO_WIDTH{1'b0}}; // Needs to be properly assigned based on the instruction\n    assign dec_imm = {E203_XLEN{1'b0}}; // For I-type, S-type, B-type, U-type, J-type\n    assign dec_pc = i_pc;\n    assign dec_misalgn = i_misalgn;\n    assign dec_buserr = i_buserr;\n    assign dec_ilegl = !(is_add); // Simplified: illegal if not an ADD instruction\n    assign dec_mulhsu = 1'b0; // Example, needs actual implementation\n    assign dec_mul = 1'b0; // Example, needs actual implementation\n    assign dec_div = 1'b0; // Example, needs actual implementation\n    assign dec_rem = 1'b0; // Example, needs actual implementation\n    assign dec_divu = 1'b0; // Example, needs actual implementation\n    assign dec_remu = 1'b0; // Example, needs actual implementation\n    assign dec_rv32 = 1'b1; // Assuming always RV32 for simplicity\n    assign dec_bjp = 1'b0; // Example, needs actual implementation\n    assign dec_jal = 1'b0; // Example, needs actual implementation\n    assign dec_jalr = 1'b0; // Example, needs actual implementation\n    assign dec_bxx = 1'b0; // Example, needs actual implementation\n    assign dec_jalr_rs1idx = {E203_RFIDX_WIDTH{1'b0}}; // Example, needs actual implementation\n    assign dec_bjp_imm = {E203_XLEN{1'b0}}; // Example, needs actual implementation\n    assign dec_nice = 1'b0; // Example, needs actual implementation\n    assign nice_cmt_off_ilgl_o = 1'b0; // Example, needs actual implementation\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 9, "code": "module e203_exu(\n    output commit_mret,\n    output commit_trap,\n    output exu_active,\n    output excp_active,\n    output core_wfi,\n    output tm_stop,\n    output itcm_nohold,\n    output core_cgstop,\n    output tcm_cgstop,\n    input [E203_HART_ID_W-1:0] core_mhartid,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    output wfi_halt_ifu_req,\n    input wfi_halt_ifu_ack,\n    output oitf_empty,\n    output [E203_XLEN-1:0] rf2ifu_x1,\n    output [E203_XLEN-1:0] rf2ifu_rs1,\n    output dec2ifu_rden,\n    output dec2ifu_rs1en,\n    output [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    output dec2ifu_mulhsu,\n    output dec2ifu_div,\n    output dec2ifu_rem,\n    output dec2ifu_divu,\n    output dec2ifu_remu,\n    input test_mode,\n    input clk_aon,\n    input clk,\n    input rst_n,\n    output cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output wr_dcsr_ena,\n    output wr_dpc_ena,\n    output wr_dscratch_ena,\n    output [E203_XLEN-1:0] wr_csr_nxt,\n    input [E203_XLEN-1:0] dcsr_r,\n    input [E203_PC_SIZE-1:0] dpc_r,\n    input [E203_XLEN-1:0] dscratch_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input dbg_stopcycle,\n    input i_valid,\n    output i_ready,\n    input [E203_INSTR_SIZE-1:0] i_ir,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_pc_vld,\n    input i_misalgn,\n    input i_buserr,\n    input i_prdt_taken,\n    input i_muldiv_b2b,\n    input [E203_RFIDX_WIDTH-1:0] i_rs1idx,\n    input [E203_RFIDX_WIDTH-1:0] i_rs2idx,\n    input pipe_flush_ack,\n    output pipe_flush_req,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input lsu_o_valid,\n    output lsu_o_ready,\n    input [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    input [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    input lsu_o_wbck_err,\n    input lsu_o_cmt_ld,\n    input lsu_o_cmt_st,\n    input [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    input lsu_o_cmt_buserr,\n    output agu_icb_cmd_valid,\n    input agu_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output agu_icb_cmd_read,\n    output [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    output agu_icb_cmd_lock,\n    output agu_icb_cmd_excl,\n    output [1:0] agu_icb_cmd_size,\n    output agu_icb_cmd_back2agu,\n    output agu_icb_cmd_usign,\n    output [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input agu_icb_rsp_valid,\n    output agu_icb_rsp_ready,\n    input agu_icb_rsp_err,\n    input agu_icb_rsp_excl_ok,\n    input [E203_XLEN-1:0] agu_icb_rsp_rdata\n);\n    // Implementation of the e203_exu module\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 16, "code": "module e203_exu_alu(\n    input wire clk,\n    input wire rst_n,\n    input wire i_valid,\n    output wire i_ready,\n    input wire [E203_XLEN-1:0] i_rs1,\n    input wire [E203_XLEN-1:0] i_rs2,\n    input wire [E203_XLEN-1:0] i_imm,\n    input wire [E203_DECINFO_WIDTH-1:0] i_info,\n    input wire [E203_PC_SIZE-1:0] i_pc,\n    input wire [E203_INSTR_SIZE-1:0] i_instr,\n    input wire i_pc_vld,\n    input wire [E203_RFIDX_WIDTH-1:0] i_rdidx,\n    input wire i_rdwen,\n    input wire i_ilegl,\n    input wire i_buserr,\n    input wire i_misalgn,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire cmt_o_valid,\n    input wire cmt_o_ready,\n    output wire [E203_PC_SIZE-1:0] cmt_o_pc,\n    output wire [E203_INSTR_SIZE-1:0] cmt_o_instr,\n    output wire [E203_XLEN-1:0] cmt_o_imm,\n    output wire cmt_o_rv32,\n    output wire cmt_o_bjp,\n    output wire cmt_o_mret,\n    output wire cmt_o_dret,\n    output wire cmt_o_ecall,\n    output wire cmt_o_ebreak,\n    output wire cmt_o_fencei,\n    output wire cmt_o_wfi,\n    output wire cmt_o_ifu_misalgn,\n    output wire cmt_o_ifu_buserr,\n    output wire cmt_o_ifu_ilegl,\n    output wire cmt_o_bjp_prdt,\n    output wire cmt_o_bjp_rslv,\n    output wire cmt_o_misalgn,\n    output wire cmt_o_ld,\n    output wire cmt_o_stamo,\n    output wire cmt_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] cmt_o_badaddr,\n    output wire wbck_o_valid,\n    input wire wbck_o_ready,\n    output wire [E203_XLEN-1:0] wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] wbck_o_rdidx\n);\n\n    // Internal signals for ALU operations\n    wire alu_op_add;\n    wire alu_op_sub;\n    wire alu_op_and;\n    wire alu_op_or;\n    wire alu_op_xor;\n    wire alu_op_sll;\n    wire alu_op_srl;\n    wire alu_op_sra;\n    wire alu_op_slt;\n    wire alu_op_sltu;\n    wire [E203_XLEN-1:0] alu_result;\n    wire alu_ready;\n    wire alu_valid;\n\n    // Decode the instruction\n    assign alu_op_add = i_info[E203_DECINFO_ALU_ADD];\n    assign alu_op_sub = i_info[E203_DECINFO_ALU_SUB];\n    assign alu_op_and = i_info[E203_DECINFO_ALU_AND];\n    assign alu_op_or  = i_info[E203_DECINFO_ALU_OR];\n    assign alu_op_xor = i_info[E203_DECINFO_ALU_XOR];\n    assign alu_op_sll = i_info[E203_DECINFO_ALU_SLL];\n    assign alu_op_srl = i_info[E203_DECINFO_ALU_SRL];\n    assign alu_op_sra = i_info[E203_DECINFO_ALU_SRA];\n    assign alu_op_slt = i_info[E203_DECINFO_ALU_SLT];\n    assign alu_op_sltu = i_info[E203_DECINFO_ALU_SLTU];\n\n    // ALU instance\n    e203_exu_alu_rglr u_alu_rglr (\n        .clk(clk),\n        .rst_n(rst_n),\n        .alu_i_valid(i_valid),\n        .alu_i_ready(alu_ready),\n        .alu_i_rs1(i_rs1),\n        .alu_i_rs2(i_rs2),\n        .alu_i_imm(i_imm),\n        .alu_i_info(i_info),\n        .alu_o_valid(alu_valid),\n        .alu_o_wbck_wdat(alu_result)\n    );\n\n    // Commit logic\n    assign cmt_o_valid = alu_valid && alu_ready;\n    assign cmt_o_pc = i_pc;\n    assign cmt_o_instr = i_instr;\n    assign cmt_o_imm = i_imm;\n    assign cmt_o_rv32 = (E203_XLEN == 32);\n    assign cmt_o_bjp = i_info[E203_DECINFO_GRP_BJP];\n    assign cmt_o_mret = i_info[E203_DECINFO_GRP_CSR] && i_instr[20]; // Example condition for MRET\n    assign cmt_o_dret = i_info[E203_DECINFO_GRP_CSR] && i_instr[21]; // Example condition for DRET\n    assign cmt_o_ecall = i_info[E203_DECINFO_GRP_CSR] && i_instr[22]; // Example condition for ECALL\n    assign cmt_o_ebreak = i_info[E203_DECINFO_GRP_CSR] && i_instr[23]; // Example condition for EBREAK\n    assign cmt_o_fencei = i_info[E203_DECINFO_GRP_CSR] && i_instr[24]; // Example condition for FENCEI\n    assign cmt_o_wfi = i_info[E203_DECINFO_GRP_CSR] && i_instr[25]; // Example condition for WFI\n\n    // Write-back logic\n    assign wbck_o_valid = alu_valid && alu_ready && wbck_o_ready;\n    assign wbck_o_wdat = alu_result;\n    assign wbck_o_rdidx = i_rdidx;\n\n    // Ready signal handling\n    assign i_ready = alu_ready;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 10, "code": "module e203_exu(\n    // Basic Interface\n    output commit_mret,\n    output commit_trap,\n    output exu_active,\n    output excp_active,\n    output core_wfi,\n    output tm_stop,\n    output itcm_nohold,\n    output core_cgstop,\n    output tcm_cgstop,\n    input [E203_HART_ID_W-1:0] core_mhartid,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    output wfi_halt_ifu_req,\n    input wfi_halt_ifu_ack,\n    output oitf_empty,\n    output [E203_XLEN-1:0] rf2ifu_x1,\n    output [E203_XLEN-1:0] rf2ifu_rs1,\n    output dec2ifu_rden,\n    output dec2ifu_rs1en,\n    output [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    output dec2ifu_mulhsu,\n    output dec2ifu_div,\n    output dec2ifu_rem,\n    output dec2ifu_divu,\n    output dec2ifu_remu,\n    input test_mode,\n    input clk_aon,\n    input clk,\n    input rst_n,\n\n    // From/To debug ctrl module\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output wr_dcsr_ena,\n    output wr_dpc_ena,\n    output wr_dscratch_ena,\n    output [E203_XLEN-1:0] wr_csr_nxt,\n    input [E203_XLEN-1:0] dcsr_r,\n    input [E203_PC_SIZE-1:0] dpc_r,\n    input [E203_XLEN-1:0] dscratch_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input dbg_stopcycle,\n\n    // IFU IR stage to EXU interface\n    input i_valid,\n    output i_ready,\n    input [E203_INSTR_SIZE-1:0] i_ir,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_pc_vld,\n    input i_misalgn,\n    input i_buserr,\n    input i_prdt_taken,\n    input i_muldiv_b2b,\n    input [E203_RFIDX_WIDTH-1:0] i_rs1idx,\n    input [E203_RFIDX_WIDTH-1:0] i_rs2idx,\n\n    // Flush interface to IFU\n    input pipe_flush_ack,\n    output pipe_flush_req,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    `ifdef E203_TIMING_BOOST\n    output [E203_PC_SIZE-1:0] pipe_flush_pc,\n    `endif\n\n    // LSU Write-Back Interface\n    input lsu_o_valid,\n    output lsu_o_ready,\n    input [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    input [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    input lsu_o_wbck_err,\n    input lsu_o_cmt_ld,\n    input lsu_o_cmt_st,\n    input [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    input lsu_o_cmt_buserr,\n\n    // AGU ICB Interface to LSU-ctrl\n    output agu_icb_cmd_valid,\n    input agu_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output agu_icb_cmd_read,\n    output [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    output agu_icb_cmd_lock,\n    output agu_icb_cmd_excl,\n    output [1:0] agu_icb_cmd_size,\n    output agu_icb_cmd_back2agu,\n    output agu_icb_cmd_usign,\n    output [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input agu_icb_rsp_valid,\n    output agu_icb_rsp_ready,\n    input agu_icb_rsp_err,\n    input agu_icb_rsp_excl_ok,\n    input [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    // CSR_NICE Interface(optional)\n    `ifdef E203_HAS_CSR_NICE\n    output nice_csr_valid,\n    input nice_csr_ready,\n    output [31:0] nice_csr_addr,\n    output nice_csr_wr,\n    output [31:0] nice_csr_wdata,\n    input [31:0] nice_csr_rdata,\n    `endif\n\n    // NICE Interface(optional)\n    `ifdef E203_HAS_NICE\n    output nice_req_valid,\n    input nice_req_ready,\n    output [E203_XLEN-1:0] nice_req_inst,\n    output [E203_XLEN-1:0] nice_req_rs1,\n    output [E203_XLEN-1:0] nice_req_rs2,\n    input nice_rsp_multicyc_valid,\n    output nice_rsp_multicyc_ready,\n    input [E203_XLEN-1:0] nice_rsp_multicyc_dat,\n    input nice_rsp_multicyc_err\n    `endif\n);\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 19, "code": "module e203_exu_csr (\n    input wire nonflush_cmt_ena,\n    input wire csr_ena,\n    input wire csr_wr_en,\n    input wire csr_rd_en,\n    input wire [11:0] csr_idx,\n    output wire csr_access_ilgl,\n    output wire tm_stop,\n    output wire core_cgstop,\n    output wire tcm_cgstop,\n    output wire itcm_nohold,\n    output wire mdv_nob2b,\n    output wire [E203_XLEN-1:0] read_csr_dat,\n    input wire [E203_XLEN-1:0] wbck_csr_dat,\n    input wire [E203_HART_ID_W-1:0] core_mhartid,\n    input wire ext_irq_r,\n    input wire sft_irq_r,\n    input wire tmr_irq_r,\n    output wire status_mie_r,\n    output wire mtie_r,\n    output wire msie_r,\n    output wire meie_r,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    input wire [E203_XLEN-1:0] dcsr_r,\n    input wire [E203_PC_SIZE-1:0] dpc_r,\n    input wire [E203_XLEN-1:0] dscratch_r,\n    output wire u_mode,\n    output wire s_mode,\n    output wire h_mode,\n    output wire m_mode,\n    input wire [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    input wire cmt_badaddr_ena,\n    input wire [E203_PC_SIZE-1:0] cmt_epc,\n    input wire cmt_epc_ena,\n    input wire [E203_XLEN-1:0] cmt_cause,\n    input wire cmt_cause_ena,\n    input wire cmt_status_ena,\n    input wire cmt_instret_ena,\n    input wire cmt_mret_ena,\n    output wire [E203_PC_SIZE-1:0] csr_epc_r,\n    output wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    output wire [E203_XLEN-1:0] csr_mtvec_r,\n    input wire clk_aon,\n    input wire clk,\n    input wire rst_n\n`ifdef E203_HAS_NICE\n    , output wire nice_xs_off\n`endif\n);\n\n    // CSR logic implementation here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 11, "code": "module e203_exu(\n    // Basic Interface\n    output commit_mret,\n    output commit_trap,\n    output exu_active,\n    output excp_active,\n    output core_wfi,\n    output tm_stop,\n    output itcm_nohold,\n    output core_cgstop,\n    output tcm_cgstop,\n    input [E203_HART_ID_W-1:0] core_mhartid,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    output wfi_halt_ifu_req,\n    input wfi_halt_ifu_ack,\n    output oitf_empty,\n    output [E203_XLEN-1:0] rf2ifu_x1,\n    output [E203_XLEN-1:0] rf2ifu_rs1,\n    output dec2ifu_rden,\n    output dec2ifu_rs1en,\n    output [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    output dec2ifu_mulhsu,\n    output dec2ifu_div,\n    output dec2ifu_rem,\n    output dec2ifu_divu,\n    output dec2ifu_remu,\n    input test_mode,\n    input clk_aon,\n    input clk,\n    input rst_n,\n\n    // From/To debug ctrl module\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output wr_dcsr_ena,\n    output wr_dpc_ena,\n    output wr_dscratch_ena,\n    output [E203_XLEN-1:0] wr_csr_nxt,\n    input [E203_XLEN-1:0] dcsr_r,\n    input [E203_PC_SIZE-1:0] dpc_r,\n    input [E203_XLEN-1:0] dscratch_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input dbg_stopcycle,\n\n    // IFU IR stage to EXU interface\n    input i_valid,\n    output i_ready,\n    input [E203_INSTR_SIZE-1:0] i_ir,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_pc_vld,\n    input i_misalgn,\n    input i_buserr,\n    input i_prdt_taken,\n    input i_muldiv_b2b,\n    input [E203_RFIDX_WIDTH-1:0] i_rs1idx,\n    input [E203_RFIDX_WIDTH-1:0] i_rs2idx,\n\n    // Flush interface to IFU\n    input pipe_flush_ack,\n    output pipe_flush_req,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n`ifdef E203_TIMING_BOOST\n    output [E203_PC_SIZE-1:0] pipe_flush_pc,\n`endif\n\n    // LSU Write-Back Interface\n    input lsu_o_valid,\n    output lsu_o_ready,\n    input [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    input [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    input lsu_o_wbck_err,\n    input lsu_o_cmt_ld,\n    input lsu_o_cmt_st,\n    input [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    input lsu_o_cmt_buserr,\n\n    // AGU ICB Interface to LSU-ctrl\n    output agu_icb_cmd_valid,\n    input agu_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output agu_icb_cmd_read,\n    output [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    output agu_icb_cmd_lock,\n    output agu_icb_cmd_excl,\n    output [1:0] agu_icb_cmd_size,\n    output agu_icb_cmd_back2agu,\n    output agu_icb_cmd_usign,\n    output [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input agu_icb_rsp_valid,\n    output agu_icb_rsp_ready,\n    input agu_icb_rsp_err,\n    input agu_icb_rsp_excl_ok,\n    input [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    // CSR_NICE Interface(optional)\n`ifdef E203_HAS_CSR_NICE\n    output nice_csr_valid,\n    input nice_csr_ready,\n    output [31:0] nice_csr_addr,\n    output nice_csr_wr,\n    output [31:0] nice_csr_wdata,\n    input [31:0] nice_csr_rdata,\n`endif\n\n    // NICE Interface(optional)\n`ifdef E203_HAS_NICE\n    output nice_req_valid,\n    input nice_req_ready,\n    output [E203_XLEN-1:0] nice_req_inst,\n    output [E203_XLEN-1:0] nice_req_rs1,\n    output [E203_XLEN-1:0] nice_req_rs2,\n    input nice_rsp_multicyc_valid,\n    output nice_rsp_multicyc_ready,\n    input [E203_XLEN-1:0] nice_rsp_multicyc_dat,\n    input nice_rsp_multicyc_err\n`endif\n);\n    // Module implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 20, "code": "module e203_exu_wbck(\n    input wire alu_wbck_i_valid,\n    output reg alu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] alu_wbck_i_wdat,\n    input wire [E203_RFIDX_WIDTH-1:0] alu_wbck_i_rdidx,\n    input wire longp_wbck_i_valid,\n    output reg longp_wbck_i_ready,\n    input wire [E203_FLEN-1:0] longp_wbck_i_wdat,\n    input wire [4:0] longp_wbck_i_flags,\n    input wire [E203_RFIDX_WIDTH-1:0] longp_wbck_i_rdidx,\n    input wire longp_wbck_i_rdfpu,\n    output reg rf_wbck_o_ena,\n    output reg [E203_XLEN-1:0] rf_wbck_o_wdat,\n    output reg [E203_RFIDX_WIDTH-1:0] rf_wbck_o_rdidx,\n    input wire clk,\n    input wire rst_n\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            alu_wbck_i_ready <= 1'b0;\n            longp_wbck_i_ready <= 1'b0;\n            rf_wbck_o_ena <= 1'b0;\n            rf_wbck_o_wdat <= {E203_XLEN{1'b0}};\n            rf_wbck_o_rdidx <= {E203_RFIDX_WIDTH{1'b0}};\n        end else begin\n            // Long-pipeline write-back has higher priority\n            if (longp_wbck_i_valid) begin\n                longp_wbck_i_ready <= 1'b1;\n                alu_wbck_i_ready <= 1'b0;\n                rf_wbck_o_ena <= ~longp_wbck_i_rdfpu;\n                rf_wbck_o_wdat <= longp_wbck_i_wdat[E203_XLEN-1:0]; // Truncate or zero-extend based on E203_XLEN\n                rf_wbck_o_rdidx <= longp_wbck_i_rdidx;\n            end else if (alu_wbck_i_valid) begin\n                alu_wbck_i_ready <= 1'b1;\n                longp_wbck_i_ready <= 1'b0;\n                rf_wbck_o_ena <= 1'b1;\n                rf_wbck_o_wdat <= alu_wbck_i_wdat;\n                rf_wbck_o_rdidx <= alu_wbck_i_rdidx;\n            end else begin\n                alu_wbck_i_ready <= 1'b0;\n                longp_wbck_i_ready <= 1'b0;\n                rf_wbck_o_ena <= 1'b0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 12, "code": "module e203_exu(\n    output commit_mret,\n    output commit_trap,\n    output exu_active,\n    output excp_active,\n    output core_wfi,\n    output tm_stop,\n    output itcm_nohold,\n    output core_cgstop,\n    output tcm_cgstop,\n    input [E203_HART_ID_W-1:0] core_mhartid,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    output wfi_halt_ifu_req,\n    input wfi_halt_ifu_ack,\n    output oitf_empty,\n    output [E203_XLEN-1:0] rf2ifu_x1,\n    output [E203_XLEN-1:0] rf2ifu_rs1,\n    output dec2ifu_rden,\n    output dec2ifu_rs1en,\n    output [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    output dec2ifu_mulhsu,\n    output dec2ifu_div,\n    output dec2ifu_rem,\n    output dec2ifu_divu,\n    output dec2ifu_remu,\n    input test_mode,\n    input clk_aon,\n    input clk,\n    input rst_n,\n    output cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output wr_dcsr_ena,\n    output wr_dpc_ena,\n    output wr_dscratch_ena,\n    output [E203_XLEN-1:0] wr_csr_nxt,\n    input [E203_XLEN-1:0] dcsr_r,\n    input [E203_PC_SIZE-1:0] dpc_r,\n    input [E203_XLEN-1:0] dscratch_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input dbg_stopcycle,\n    input i_valid,\n    output i_ready,\n    input [E203_INSTR_SIZE-1:0] i_ir,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_pc_vld,\n    input i_misalgn,\n    input i_buserr,\n    input i_prdt_taken,\n    input i_muldiv_b2b,\n    input [E203_RFIDX_WIDTH-1:0] i_rs1idx,\n    input [E203_RFIDX_WIDTH-1:0] i_rs2idx,\n    input pipe_flush_ack,\n    output pipe_flush_req,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input lsu_o_valid,\n    output lsu_o_ready,\n    input [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    input [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    input lsu_o_wbck_err,\n    input lsu_o_cmt_ld,\n    input lsu_o_cmt_st,\n    input [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    input lsu_o_cmt_buserr,\n    output agu_icb_cmd_valid,\n    input agu_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output agu_icb_cmd_read,\n    output [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    output agu_icb_cmd_lock,\n    output agu_icb_cmd_excl,\n    output [1:0] agu_icb_cmd_size,\n    output agu_icb_cmd_back2agu,\n    output agu_icb_cmd_usign,\n    output [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input agu_icb_rsp_valid,\n    output agu_icb_rsp_ready,\n    input agu_icb_rsp_err,\n    input agu_icb_rsp_excl_ok,\n    input [E203_XLEN-1:0] agu_icb_rsp_rdata\n);\n    // Module implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 13, "code": "module e203_exu(\n    output commit_mret,\n    output commit_trap,\n    output exu_active,\n    output excp_active,\n    output core_wfi,\n    output tm_stop,\n    output itcm_nohold,\n    output core_cgstop,\n    output tcm_cgstop,\n    input [E203_HART_ID_W-1:0] core_mhartid,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    output wfi_halt_ifu_req,\n    input wfi_halt_ifu_ack,\n    output oitf_empty,\n    output [E203_XLEN-1:0] rf2ifu_x1,\n    output [E203_XLEN-1:0] rf2ifu_rs1,\n    output dec2ifu_rden,\n    output dec2ifu_rs1en,\n    output [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    output dec2ifu_mulhsu,\n    output dec2ifu_div,\n    output dec2ifu_rem,\n    output dec2ifu_divu,\n    output dec2ifu_remu,\n    input test_mode,\n    input clk_aon,\n    input clk,\n    input rst_n,\n    output cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output wr_dcsr_ena,\n    output wr_dpc_ena,\n    output wr_dscratch_ena,\n    output [E203_XLEN-1:0] wr_csr_nxt,\n    input [E203_XLEN-1:0] dcsr_r,\n    input [E203_PC_SIZE-1:0] dpc_r,\n    input [E203_XLEN-1:0] dscratch_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input dbg_stopcycle,\n    input i_valid,\n    output i_ready,\n    input [E203_INSTR_SIZE-1:0] i_ir,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_pc_vld,\n    input i_misalgn,\n    input i_buserr,\n    input i_prdt_taken,\n    input i_muldiv_b2b,\n    input [E203_RFIDX_WIDTH-1:0] i_rs1idx,\n    input [E203_RFIDX_WIDTH-1:0] i_rs2idx,\n    input pipe_flush_ack,\n    output pipe_flush_req,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input lsu_o_valid,\n    output lsu_o_ready,\n    input [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    input [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    input lsu_o_wbck_err,\n    input lsu_o_cmt_ld,\n    input lsu_o_cmt_st,\n    input [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    input lsu_o_cmt_buserr,\n    output agu_icb_cmd_valid,\n    input agu_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output agu_icb_cmd_read,\n    output [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    output agu_icb_cmd_lock,\n    output agu_icb_cmd_excl,\n    output [1:0] agu_icb_cmd_size,\n    output agu_icb_cmd_back2agu,\n    output agu_icb_cmd_usign,\n    output [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input agu_icb_rsp_valid,\n    output agu_icb_rsp_ready,\n    input agu_icb_rsp_err,\n    input agu_icb_rsp_excl_ok,\n    input [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output nice_csr_valid,\n    input nice_csr_ready,\n    output [31:0] nice_csr_addr,\n    output nice_csr_wr,\n    output [31:0] nice_csr_wdata,\n    input [31:0] nice_csr_rdata\n);\n    // Module implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 20, "code": "module e203_exu_csr (\n    input wire nonflush_cmt_ena,\n    input wire csr_ena,\n    input wire csr_wr_en,\n    input wire csr_rd_en,\n    input wire [11:0] csr_idx,\n    output wire csr_access_ilgl,\n    output wire tm_stop,\n    output wire core_cgstop,\n    output wire tcm_cgstop,\n    output wire itcm_nohold,\n    output wire mdv_nob2b,\n    output wire [E203_XLEN-1:0] read_csr_dat,\n    input wire [E203_XLEN-1:0] wbck_csr_dat,\n    input wire [E203_HART_ID_W-1:0] core_mhartid,\n    input wire ext_irq_r,\n    input wire sft_irq_r,\n    input wire tmr_irq_r,\n    output wire status_mie_r,\n    output wire mtie_r,\n    output wire msie_r,\n    output wire meie_r,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    input wire [E203_XLEN-1:0] dcsr_r,\n    input wire [E203_PC_SIZE-1:0] dpc_r,\n    input wire [E203_XLEN-1:0] dscratch_r,\n    output wire u_mode,\n    output wire s_mode,\n    output wire h_mode,\n    output wire m_mode,\n    input wire [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    input wire cmt_badaddr_ena,\n    input wire [E203_PC_SIZE-1:0] cmt_epc,\n    input wire cmt_epc_ena,\n    input wire [E203_XLEN-1:0] cmt_cause,\n    input wire cmt_cause_ena,\n    input wire cmt_status_ena,\n    input wire cmt_instret_ena,\n    input wire cmt_mret_ena,\n    output wire [E203_PC_SIZE-1:0] csr_epc_r,\n    output wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    output wire [E203_XLEN-1:0] csr_mtvec_r,\n    input wire clk_aon,\n    input wire clk,\n    input wire rst_n\n);\n\n// Optional interface for NICE feature\n`ifdef E203_HAS_NICE\n    output wire nice_xs_off;\n`endif\n\n// CSR logic implementation\nassign csr_access_ilgl = 0; // Assuming no illegal access in this design\nassign m_mode = 1;\nassign u_mode = 0;\nassign s_mode = 0;\nassign h_mode = 0;\n\n// CSR read and write operations\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        // Reset logic for CSRs\n    end else if (csr_ena) begin\n        if (csr_wr_en && !csr_access_ilgl) begin\n            // Write logic for CSRs\n        end\n        if (csr_rd_en && !csr_access_ilgl) begin\n            // Read logic for CSRs\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 14, "code": "module e203_exu(\n    // Basic Interface\n    output commit_mret,\n    output commit_trap,\n    output exu_active,\n    output excp_active,\n    output core_wfi,\n    output tm_stop,\n    output itcm_nohold,\n    output core_cgstop,\n    output tcm_cgstop,\n    input [E203_HART_ID_W-1:0] core_mhartid,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    output wfi_halt_ifu_req,\n    input wfi_halt_ifu_ack,\n    output oitf_empty,\n    output [E203_XLEN-1:0] rf2ifu_x1,\n    output [E203_XLEN-1:0] rf2ifu_rs1,\n    output dec2ifu_rden,\n    output dec2ifu_rs1en,\n    output [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    output dec2ifu_mulhsu,\n    output dec2ifu_div,\n    output dec2ifu_rem,\n    output dec2ifu_divu,\n    output dec2ifu_remu,\n    input test_mode,\n    input clk_aon,\n    input clk,\n    input rst_n,\n\n    // From/To debug ctrl module\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output wr_dcsr_ena,\n    output wr_dpc_ena,\n    output wr_dscratch_ena,\n    output [E203_XLEN-1:0] wr_csr_nxt,\n    input [E203_XLEN-1:0] dcsr_r,\n    input [E203_PC_SIZE-1:0] dpc_r,\n    input [E203_XLEN-1:0] dscratch_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input dbg_stopcycle,\n\n    // IFU IR stage to EXU interface\n    input i_valid,\n    output i_ready,\n    input [E203_INSTR_SIZE-1:0] i_ir,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_pc_vld,\n    input i_misalgn,\n    input i_buserr,\n    input i_prdt_taken,\n    input i_muldiv_b2b,\n    input [E203_RFIDX_WIDTH-1:0] i_rs1idx,\n    input [E203_RFIDX_WIDTH-1:0] i_rs2idx,\n\n    // Flush interface to IFU\n    input pipe_flush_ack,\n    output pipe_flush_req,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n`ifdef E203_TIMING_BOOST\n    output [E203_PC_SIZE-1:0] pipe_flush_pc,\n`endif\n\n    // LSU Write-Back Interface\n    input lsu_o_valid,\n    output lsu_o_ready,\n    input [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    input [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    input lsu_o_wbck_err,\n    input lsu_o_cmt_ld,\n    input lsu_o_cmt_st,\n    input [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    input lsu_o_cmt_buserr,\n\n    // AGU ICB Interface to LSU-ctrl\n    output agu_icb_cmd_valid,\n    input agu_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output agu_icb_cmd_read,\n    output [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    output agu_icb_cmd_lock,\n    output agu_icb_cmd_excl,\n    output [1:0] agu_icb_cmd_size,\n    output agu_icb_cmd_back2agu,\n    output agu_icb_cmd_usign,\n    output [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input agu_icb_rsp_valid,\n    output agu_icb_rsp_ready,\n    input agu_icb_rsp_err,\n    input agu_icb_rsp_excl_ok,\n    input [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    // CSR_NICE Interface(optional)\n`ifdef E203_HAS_CSR_NICE\n    output nice_csr_valid,\n    input nice_csr_ready,\n    output [31:0] nice_csr_addr,\n    output nice_csr_wr,\n    output [31:0] nice_csr_wdata,\n    input [31:0] nice_csr_rdata,\n`endif\n\n    // NICE Interface(optional)\n`ifdef E203_HAS_NICE\n    output nice_req_valid,\n    input nice_req_ready,\n    output [E203_XLEN-1:0] nice_req_inst,\n    output [E203_XLEN-1:0] nice_req_rs1,\n    output [E203_XLEN-1:0] nice_req_rs2,\n    input nice_rsp_multicyc_valid,\n    output nice_rsp_multicyc_ready,\n    input [E203_XLEN-1:0] nice_rsp_multicyc_dat,\n    input nice_rsp_multicyc_err\n`endif\n);\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 14, "code": "module e203_exu_decode(\n    input [E203_INSTR_SIZE-1:0] i_instr,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_prdt_taken,\n    input i_misalgn,\n    input i_buserr,\n    input i_muldiv_b2b,\n    input dbg_mode,\n    output dec_rs1x0,\n    output dec_rs2x0,\n    output dec_rs1en,\n    output dec_rs2en,\n    output dec_rdwen,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rdidx,\n    output [E203_DECINFO_WIDTH-1:0] dec_info,\n    output [E203_XLEN-1:0] dec_imm,\n    output [E203_PC_SIZE-1:0] dec_pc,\n    output dec_misalgn,\n    output dec_buserr,\n    output dec_ilegl,\n    output dec_mulhsu,\n    output dec_mul,\n    output dec_div,\n    output dec_rem,\n    output dec_divu,\n    output dec_remu,\n    output dec_rv32,\n    output dec_bjp,\n    output dec_jal,\n    output dec_jalr,\n    output dec_bxx,\n    output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    output [E203_XLEN-1:0] dec_bjp_imm,\n    output dec_nice,\n    output nice_cmt_off_ilgl_o\n);\n\n    // Decode logic here\n    // Example: Decoding an R-type instruction\n    wire [6:0] opcode = i_instr[6:0];\n    wire [2:0] funct3 = i_instr[14:12];\n    wire [6:0] funct7 = i_instr[31:25];\n    wire [4:0] rs1 = i_instr[19:15];\n    wire [4:0] rs2 = i_instr[24:20];\n    wire [4:0] rd = i_instr[11:7];\n\n    assign dec_rs1idx = rs1;\n    assign dec_rs2idx = rs2;\n    assign dec_rdidx = rd;\n\n    assign dec_rs1x0 = (rs1 == 5'b00000);\n    assign dec_rs2x0 = (rs2 == 5'b00000);\n    assign dec_rs1en = (opcode == 7'b0110011); // Example for R-type\n    assign dec_rs2en = (opcode == 7'b0110011); // Example for R-type\n    assign dec_rdwen = (opcode == 7'b0110011); // Example for R-type\n\n    // Example for illegal instruction detection\n    assign dec_ilegl = (opcode == 7'b0000000);\n\n    // Example for specific instruction decoding\n    assign dec_mul = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b000);\n    assign dec_div = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b100);\n\n    // Propagate error signals\n    assign dec_misalgn = i_misalgn;\n    assign dec_buserr = i_buserr;\n\n    // Set PC output\n    assign dec_pc = i_pc;\n\n    // Additional decoding logic as required by the specification\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 13, "code": "module e203_ifu_litebpu #(\n  parameter E203_PC_SIZE = 32,\n  parameter E203_XLEN = 32,\n  parameter E203_RFIDX_WIDTH = 5\n)(\n  input clk,\n  input rst_n,\n  input [E203_PC_SIZE-1:0] pc,\n  input dec_jal,\n  input dec_jalr,\n  input dec_bxx,\n  input [E203_XLEN-1:0] dec_bjp_imm,\n  input [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  input oitf_empty,\n  input ir_empty,\n  input ir_rs1en,\n  input jalr_rs1idx_cam_irrdidx,\n  input dec_i_valid,\n  input ir_valid_clr,\n  input [E203_XLEN-1:0] rf2bpu_x1,\n  input [E203_XLEN-1:0] rf2bpu_rs1,\n  output reg prdt_taken,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op1,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op2,\n  output reg bpu_wait,\n  output reg bpu2rf_rs1_ena\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      prdt_taken <= 1'b0;\n      prdt_pc_add_op1 <= {E203_PC_SIZE{1'b0}};\n      prdt_pc_add_op2 <= {E203_PC_SIZE{1'b0}};\n      bpu_wait <= 1'b0;\n      bpu2rf_rs1_ena <= 1'b0;\n    end else begin\n      // Default assignments\n      prdt_taken <= 1'b0;\n      prdt_pc_add_op1 <= pc;\n      prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n      bpu_wait <= 1'b0;\n      bpu2rf_rs1_ena <= 1'b0;\n\n      // Handle JAL instruction\n      if (dec_jal) begin\n        prdt_taken <= 1'b1;\n        prdt_pc_add_op1 <= pc;\n        prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n      end\n\n      // Handle JALR instruction\n      if (dec_jalr) begin\n        prdt_taken <= 1'b1;\n        case (dec_jalr_rs1idx)\n          5'd0: prdt_pc_add_op1 <= {E203_PC_SIZE{1'b0}};\n          5'd1: begin\n            prdt_pc_add_op1 <= rf2bpu_x1;\n            if (!oitf_empty || jalr_rs1idx_cam_irrdidx) begin\n              bpu_wait <= 1'b1;\n            end\n          end\n          default: begin\n            prdt_pc_add_op1 <= rf2bpu_rs1;\n            if (!ir_empty && ir_rs1en) begin\n              bpu_wait <= 1'b1;\n            end\n          end\n        endcase\n        prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n      end\n\n      // Handle conditional branch instruction\n      if (dec_bxx) begin\n        if (dec_bjp_imm[E203_XLEN-1]) begin // Negative offset implies backward jump\n          prdt_taken <= 1'b1;\n        end\n        prdt_pc_add_op1 <= pc;\n        prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n      end\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 15, "code": "module e203_exu_nice (\n    input wire nice_i_xs_off,\n    input wire nice_i_valid,\n    output wire nice_i_ready,\n    input wire [E203_XLEN-1:0] nice_i_instr,\n    input wire [E203_XLEN-1:0] nice_i_rs1,\n    input wire [E203_XLEN-1:0] nice_i_rs2,\n    input wire [E203_ITAG_WIDTH-1:0] nice_i_itag,\n    output wire nice_o_longpipe,\n    output wire nice_o_valid,\n    input wire nice_o_ready,\n    output wire nice_o_itag_valid,\n    input wire nice_o_itag_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire clk,\n    input wire rst_n\n);\n\n    // FIFO for instruction tags\n    wire fifo_i_vld = nice_i_valid && !nice_i_xs_off && nice_o_ready;\n    wire fifo_i_rdy;\n    wire [E203_ITAG_WIDTH-1:0] fifo_i_dat = nice_i_itag;\n    wire fifo_o_vld;\n    wire fifo_o_rdy = nice_o_itag_ready && nice_rsp_multicyc_valid;\n    wire [E203_ITAG_WIDTH-1:0] fifo_o_dat;\n\n    sirv_gnrl_fifo #(\n        .CUT_READY(1),\n        .MSKO(0),\n        .DP(4),\n        .DW(E203_ITAG_WIDTH)\n    ) itag_fifo (\n        .i_vld(fifo_i_vld),\n        .i_rdy(fifo_i_rdy),\n        .i_dat(fifo_i_dat),\n        .o_vld(fifo_o_vld),\n        .o_rdy(fifo_o_rdy),\n        .o_dat(fifo_o_dat),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\n    assign nice_i_ready = fifo_i_rdy && nice_o_ready;\n    assign nice_req_valid = nice_i_valid && !nice_i_xs_off && nice_req_ready;\n    assign nice_req_instr = nice_i_instr;\n    assign nice_req_rs1 = nice_i_rs1;\n    assign nice_req_rs2 = nice_i_rs2;\n    assign nice_rsp_multicyc_ready = fifo_o_rdy;\n    assign nice_o_itag_valid = fifo_o_vld && nice_rsp_multicyc_valid;\n    assign nice_o_itag = fifo_o_dat;\n    assign nice_o_valid = nice_i_valid && !nice_i_xs_off && nice_o_ready;\n    assign nice_o_longpipe = !nice_i_xs_off;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 15, "code": "module e203_exu(\n    output commit_mret,\n    output commit_trap,\n    output exu_active,\n    output excp_active,\n    output core_wfi,\n    output tm_stop,\n    output itcm_nohold,\n    output core_cgstop,\n    output tcm_cgstop,\n    input [E203_HART_ID_W-1:0] core_mhartid,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    output wfi_halt_ifu_req,\n    input wfi_halt_ifu_ack,\n    output oitf_empty,\n    output [E203_XLEN-1:0] rf2ifu_x1,\n    output [E203_XLEN-1:0] rf2ifu_rs1,\n    output dec2ifu_rden,\n    output dec2ifu_rs1en,\n    output [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    output dec2ifu_mulhsu,\n    output dec2ifu_div,\n    output dec2ifu_rem,\n    output dec2ifu_divu,\n    output dec2ifu_remu,\n    input test_mode,\n    input clk_aon,\n    input clk,\n    input rst_n,\n    output cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output wr_dcsr_ena,\n    output wr_dpc_ena,\n    output wr_dscratch_ena,\n    output [E203_XLEN-1:0] wr_csr_nxt,\n    input [E203_XLEN-1:0] dcsr_r,\n    input [E203_PC_SIZE-1:0] dpc_r,\n    input [E203_XLEN-1:0] dscratch_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input dbg_stopcycle,\n    input i_valid,\n    output i_ready,\n    input [E203_INSTR_SIZE-1:0] i_ir,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_pc_vld,\n    input i_misalgn,\n    input i_buserr,\n    input i_prdt_taken,\n    input i_muldiv_b2b,\n    input [E203_RFIDX_WIDTH-1:0] i_rs1idx,\n    input [E203_RFIDX_WIDTH-1:0] i_rs2idx,\n    input pipe_flush_ack,\n    output pipe_flush_req,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input lsu_o_valid,\n    output lsu_o_ready,\n    input [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    input [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    input lsu_o_wbck_err,\n    input lsu_o_cmt_ld,\n    input lsu_o_cmt_st,\n    input [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    input lsu_o_cmt_buserr,\n    output agu_icb_cmd_valid,\n    input agu_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output agu_icb_cmd_read,\n    output [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    output agu_icb_cmd_lock,\n    output agu_icb_cmd_excl,\n    output [1:0] agu_icb_cmd_size,\n    output agu_icb_cmd_back2agu,\n    output agu_icb_cmd_usign,\n    output [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input agu_icb_rsp_valid,\n    output agu_icb_rsp_ready,\n    input agu_icb_rsp_err,\n    input agu_icb_rsp_excl_ok,\n    input [E203_XLEN-1:0] agu_icb_rsp_rdata\n);\n    // Module implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 16, "code": "module e203_exu(\n    input clk,\n    input rst_n,\n    input [E203_INSTR_SIZE-1:0] i_ir,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_valid,\n    output i_ready,\n    input i_misalgn,\n    input i_buserr,\n    input i_prdt_taken,\n    input i_muldiv_b2b,\n    input [E203_RFIDX_WIDTH-1:0] i_rs1idx,\n    input [E203_RFIDX_WIDTH-1:0] i_rs2idx,\n    output commit_mret,\n    output commit_trap,\n    output exu_active,\n    output excp_active,\n    output core_wfi,\n    output tm_stop,\n    output itcm_nohold,\n    output core_cgstop,\n    output tcm_cgstop,\n    input [E203_HART_ID_W-1:0] core_mhartid,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    output wfi_halt_ifu_req,\n    input wfi_halt_ifu_ack,\n    output oitf_empty,\n    output [E203_XLEN-1:0] rf2ifu_x1,\n    output [E203_XLEN-1:0] rf2ifu_rs1,\n    output dec2ifu_rden,\n    output dec2ifu_rs1en,\n    output [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    output dec2ifu_mulhsu,\n    output dec2ifu_div,\n    output dec2ifu_rem,\n    output dec2ifu_divu,\n    output dec2ifu_remu,\n    input test_mode,\n    input clk_aon\n);\n\n    // Internal signals\n    wire alu_op;\n    wire [E203_XLEN-1:0] alu_result;\n    wire alu_ready;\n    wire [E203_XLEN-1:0] regfile_data;\n    wire regfile_write;\n    wire [E203_RFIDX_WIDTH-1:0] regfile_idx;\n    wire flush;\n    wire [E203_PC_SIZE-1:0] flush_pc;\n\n    // Instantiate submodules here\n    // Example: ALU, RegFile, etc.\n\n    // Control logic\n    assign i_ready = alu_ready; // Simplified example\n    assign flush = (i_misalgn || i_buserr); // Simplified flush condition\n    assign flush_pc = i_pc + 4; // Simplified next PC calculation\n\n    // ALU operations\n    assign alu_op = (i_ir[6:0] == 7'b0110011); // Example: R-type instructions\n    alu u_alu (\n        .clk(clk),\n        .rst_n(rst_n),\n        .op(alu_op),\n        .in1(regfile_data),\n        .in2(rf2ifu_rs1),\n        .result(alu_result),\n        .ready(alu_ready)\n    );\n\n    // Register file operations\n    regfile u_regfile (\n        .clk(clk),\n        .rst_n(rst_n),\n        .read_idx1(i_rs1idx),\n        .read_idx2(i_rs2idx),\n        .write_en(regfile_write),\n        .write_idx(regfile_idx),\n        .write_data(alu_result),\n        .read_data1(regfile_data),\n        .read_data2(rf2ifu_rs1)\n    );\n\n    // Commit logic\n    assign commit_mret = (i_ir[31:20] == 12'h302); // Example: MRET instruction\n    assign commit_trap = flush;\n    assign exu_active = i_valid; // Simplified activity indicator\n    assign excp_active = flush;\n    assign core_wfi = (i_ir[6:0] == 7'b0001011); // Example: WFI instruction\n    assign tm_stop = core_wfi; // Stop the timer on WFI\n\n    // Clock gating and power management\n    assign itcm_nohold = !flush;\n    assign core_cgstop = !exu_active;\n    assign tcm_cgstop = !oitf_empty;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 19, "code": "module e203_exu_commit(\n    output commit_mret,\n    output commit_trap,\n    output core_wfi,\n    output nonflush_cmt_ena,\n    output excp_active,\n    input amo_wait,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input alu_cmt_i_valid,\n    output alu_cmt_i_ready,\n    input [E203_PC_SIZE-1:0] alu_cmt_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_cmt_i_instr,\n    input alu_cmt_i_pc_vld,\n    input [E203_XLEN-1:0] alu_cmt_i_imm,\n    input alu_cmt_i_rv32,\n    input alu_cmt_i_bjp,\n    input alu_cmt_i_wfi,\n    input alu_cmt_i_fencei,\n    input alu_cmt_i_mret,\n    input alu_cmt_i_dret,\n    input alu_cmt_i_ecall,\n    input alu_cmt_i_ebreak,\n    input alu_cmt_i_ifu_misalgn,\n    input alu_cmt_i_ifu_buserr,\n    input alu_cmt_i_ifu_ilegl,\n    input alu_cmt_i_bjp_prdt,\n    input alu_cmt_i_bjp_rslv,\n    input alu_cmt_i_misalgn,\n    input alu_cmt_i_ld,\n    input alu_cmt_i_stamo,\n    input alu_cmt_i_buserr,\n    input [E203_ADDR_SIZE-1:0] alu_cmt_i_badaddr,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output cmt_badaddr_ena,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output cmt_epc_ena,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_cause_ena,\n    output cmt_instret_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output cmt_mret_ena,\n    input [E203_PC_SIZE-1:0] csr_epc_r,\n    input [E203_PC_SIZE-1:0] csr_dpc_r,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output longp_excp_i_ready,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input longp_excp_i_insterr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc\n);\n    // Module implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 10, "code": "module e203_exu_excp(\n    output commit_trap,\n    output core_wfi,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input amo_wait,\n    input alu_excp_i_valid,\n    input alu_excp_i_ld,\n    input alu_excp_i_stamo,\n    input alu_excp_i_misalgn,\n    input alu_excp_i_buserr,\n    input alu_excp_i_ecall,\n    input alu_excp_i_ebreak,\n    input alu_excp_i_wfi,\n    input alu_excp_i_ifu_misalgn,\n    input alu_excp_i_ifu_buserr,\n    input alu_excp_i_ifu_ilegl,\n    input [E203_PC_SIZE-1:0] alu_excp_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_excp_i_instr,\n    input alu_excp_i_pc_vld,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input longp_excp_i_insterr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input excpirq_flush_ack,\n    output excpirq_flush_req,\n    output nonalu_excpirq_flush_req_raw,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op1,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op2,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input cmt_dret_ena,\n    input cmt_ena,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_badaddr_ena,\n    output cmt_epc_ena,\n    output cmt_cause_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output excp_active,\n    input clk,\n    input rst_n\n);\n    // Implementation of exception handling logic\n    // This is a placeholder for the actual implementation\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 17, "code": "module e203_exu_alu(\n    input wire clk,\n    input wire rst_n,\n    input wire i_valid,\n    output wire i_ready,\n    input wire [E203_XLEN-1:0] i_rs1,\n    input wire [E203_XLEN-1:0] i_rs2,\n    input wire [E203_XLEN-1:0] i_imm,\n    input wire [E203_DECINFO_WIDTH-1:0] i_info,\n    input wire [E203_PC_SIZE-1:0] i_pc,\n    input wire [E203_INSTR_SIZE-1:0] i_instr,\n    input wire i_pc_vld,\n    input wire [E203_RFIDX_WIDTH-1:0] i_rdidx,\n    input wire i_rdwen,\n    input wire i_ilegl,\n    input wire i_buserr,\n    input wire i_misalgn,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire cmt_o_valid,\n    input wire cmt_o_ready,\n    output wire [E203_PC_SIZE-1:0] cmt_o_pc,\n    output wire [E203_INSTR_SIZE-1:0] cmt_o_instr,\n    output wire [E203_XLEN-1:0] cmt_o_imm,\n    output wire cmt_o_rv32,\n    output wire cmt_o_bjp,\n    output wire cmt_o_mret,\n    output wire cmt_o_dret,\n    output wire cmt_o_ecall,\n    output wire cmt_o_ebreak,\n    output wire cmt_o_fencei,\n    output wire cmt_o_wfi,\n    output wire cmt_o_ifu_misalgn,\n    output wire cmt_o_ifu_buserr,\n    output wire cmt_o_ifu_ilegl,\n    output wire cmt_o_bjp_prdt,\n    output wire cmt_o_bjp_rslv,\n    output wire cmt_o_misalgn,\n    output wire cmt_o_ld,\n    output wire cmt_o_stamo,\n    output wire cmt_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] cmt_o_badaddr,\n    output wire wbck_o_valid,\n    input wire wbck_o_ready,\n    output wire [E203_XLEN-1:0] wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] wbck_o_rdidx,\n    input wire mdv_nob2b,\n    output wire csr_ena,\n    output wire csr_wr_en,\n    output wire csr_rd_en,\n    output wire [11:0] csr_idx,\n    input wire nonflush_cmt_ena,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output wire [E203_XLEN-1:0] wbck_csr_dat,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_usign,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_longp_wbck_valid,\n    input wire nice_longp_wbck_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire i_nice_cmt_off_ilgl\n);\n    // ALU core logic implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 18, "code": "module e203_exu_alu(\n    input wire i_valid,\n    output wire i_ready,\n    output wire i_longpipe,\n    output wire nice_csr_valid,\n    input wire nice_csr_ready,\n    output wire [31:0] nice_csr_addr,\n    output wire nice_csr_wr,\n    output wire [31:0] nice_csr_wdata,\n    input wire [31:0] nice_csr_rdata,\n    input wire nice_xs_off,\n    output wire amo_wait,\n    input wire oitf_empty,\n    input wire [E203_ITAG_WIDTH-1:0] i_itag,\n    input wire [E203_XLEN-1:0] i_rs1,\n    input wire [E203_XLEN-1:0] i_rs2,\n    input wire [E203_XLEN-1:0] i_imm,\n    input wire [E203_DECINFO_WIDTH-1:0] i_info,\n    input wire [E203_PC_SIZE-1:0] i_pc,\n    input wire [E203_INSTR_SIZE-1:0] i_instr,\n    input wire i_pc_vld,\n    input wire [E203_RFIDX_WIDTH-1:0] i_rdidx,\n    input wire i_rdwen,\n    input wire i_ilegl,\n    input wire i_buserr,\n    input wire i_misalgn,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire cmt_o_valid,\n    input wire cmt_o_ready,\n    output wire cmt_o_pc_vld,\n    output wire [E203_PC_SIZE-1:0] cmt_o_pc,\n    output wire [E203_INSTR_SIZE-1:0] cmt_o_instr,\n    output wire [E203_XLEN-1:0] cmt_o_imm,\n    output wire cmt_o_rv32,\n    output wire cmt_o_bjp,\n    output wire cmt_o_mret,\n    output wire cmt_o_dret,\n    output wire cmt_o_ecall,\n    output wire cmt_o_ebreak,\n    output wire cmt_o_fencei,\n    output wire cmt_o_wfi,\n    output wire cmt_o_ifu_misalgn,\n    output wire cmt_o_ifu_buserr,\n    output wire cmt_o_ifu_ilegl,\n    output wire cmt_o_bjp_prdt,\n    output wire cmt_o_bjp_rslv,\n    output wire cmt_o_misalgn,\n    output wire cmt_o_ld,\n    output wire cmt_o_stamo,\n    output wire cmt_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] cmt_o_badaddr,\n    output wire wbck_o_valid,\n    input wire wbck_o_ready,\n    output wire [E203_XLEN-1:0] wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] wbck_o_rdidx,\n    input wire mdv_nob2b,\n    output wire csr_ena,\n    output wire csr_wr_en,\n    output wire csr_rd_en,\n    output wire [11:0] csr_idx,\n    input wire nonflush_cmt_ena,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output wire [E203_XLEN-1:0] wbck_csr_dat,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_usign,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_longp_wbck_valid,\n    input wire nice_longp_wbck_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire i_nice_cmt_off_ilgl,\n    input wire clk,\n    input wire rst_n\n);\n    // Module implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 15, "code": "module e203_exu_decode (\n    input [E203_INSTR_SIZE-1:0] i_instr,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_prdt_taken,\n    input i_misalgn,\n    input i_buserr,\n    input i_muldiv_b2b,\n    input dbg_mode,\n    output dec_rs1x0,\n    output dec_rs2x0,\n    output dec_rs1en,\n    output dec_rs2en,\n    output dec_rdwen,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rdidx,\n    output [E203_DECINFO_WIDTH-1:0] dec_info,\n    output [E203_XLEN-1:0] dec_imm,\n    output [E203_PC_SIZE-1:0] dec_pc,\n    output dec_misalgn,\n    output dec_buserr,\n    output dec_ilegl,\n    output dec_mulhsu,\n    output dec_mul,\n    output dec_div,\n    output dec_rem,\n    output dec_divu,\n    output dec_remu,\n    output dec_rv32,\n    output dec_bjp,\n    output dec_jal,\n    output dec_jalr,\n    output dec_bxx,\n    output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    output [E203_XLEN-1:0] dec_bjp_imm,\n    output dec_nice,\n    output nice_cmt_off_ilgl_o\n);\n\n    // Instruction decoding logic here\n    // This is a placeholder for the actual decoding logic\n    // which would involve parsing the instruction fields\n    // and setting the output signals accordingly.\n\n    // Example of setting outputs based on instruction fields\n    assign dec_rs1x0 = (dec_rs1idx == 0);\n    assign dec_rs2x0 = (dec_rs2idx == 0);\n    assign dec_rdwen = (i_instr[6:0] == 7'b0110011); // Example for R-type instructions\n    assign dec_rs1en = 1'b1; // Assume all instructions read rs1\n    assign dec_rs2en = 1'b1; // Assume all instructions read rs2\n    assign dec_ilegl = (i_instr == 32'h00000000) || (i_instr == 32'hFFFFFFFF); // Illegal instruction check\n\n    // Example decoding for a specific instruction\n    always @(*) begin\n        case (i_instr[6:0])\n            7'b0110011: begin // R-type\n                dec_info = {E203_DECINFO_WIDTH{1'b0}};\n                dec_info[E203_DECINFO_GRP_ALU] = 1'b1;\n                dec_mul = (i_instr[31:25] == 7'b0000001) && (i_instr[14:12] == 3'b000);\n                dec_div = (i_instr[31:25] == 7'b0000001) && (i_instr[14:12] == 3'b100);\n            end\n            default: begin\n                dec_info = {E203_DECINFO_WIDTH{1'b0}};\n            end\n        endcase\n    end\n\n    // Propagate error signals\n    assign dec_misalgn = i_misalgn;\n    assign dec_buserr = i_buserr;\n\n    // Additional decoding logic as per the specification\n    // This includes setting up the correct indices, immediate values, etc.\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 20, "code": "module e203_exu_commit(\n    input wire clk,\n    input wire rst_n,\n    input wire alu_cmt_i_valid,\n    output wire alu_cmt_i_ready,\n    input wire [E203_PC_SIZE-1:0] alu_cmt_i_pc,\n    input wire [E203_INSTR_SIZE-1:0] alu_cmt_i_instr,\n    input wire alu_cmt_i_pc_vld,\n    input wire [E203_XLEN-1:0] alu_cmt_i_imm,\n    input wire alu_cmt_i_rv32,\n    input wire alu_cmt_i_bjp,\n    input wire alu_cmt_i_wfi,\n    input wire alu_cmt_i_fencei,\n    input wire alu_cmt_i_mret,\n    input wire alu_cmt_i_dret,\n    input wire alu_cmt_i_ecall,\n    input wire alu_cmt_i_ebreak,\n    input wire alu_cmt_i_ifu_misalgn,\n    input wire alu_cmt_i_ifu_buserr,\n    input wire alu_cmt_i_ifu_ilegl,\n    input wire alu_cmt_i_bjp_prdt,\n    input wire alu_cmt_i_bjp_rslv,\n    input wire alu_cmt_i_misalgn,\n    input wire alu_cmt_i_ld,\n    input wire alu_cmt_i_stamo,\n    input wire alu_cmt_i_buserr,\n    input wire [E203_ADDR_SIZE-1:0] alu_cmt_i_badaddr,\n    output wire commit_mret,\n    output wire commit_trap,\n    output wire core_wfi,\n    output wire nonflush_cmt_ena,\n    output wire excp_active,\n    input wire amo_wait,\n    output wire wfi_halt_ifu_req,\n    output wire wfi_halt_exu_req,\n    input wire wfi_halt_ifu_ack,\n    input wire wfi_halt_exu_ack,\n    input wire dbg_irq_r,\n    input wire [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input wire ext_irq_r,\n    input wire sft_irq_r,\n    input wire tmr_irq_r,\n    input wire [E203_EVT_NUM-1:0] evt_r,\n    input wire status_mie_r,\n    input wire mtie_r,\n    input wire msie_r,\n    input wire meie_r,\n    output wire alu_cmt_i_ready,\n    output wire [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output wire cmt_badaddr_ena,\n    output wire [E203_PC_SIZE-1:0] cmt_epc,\n    output wire cmt_epc_ena,\n    output wire [E203_XLEN-1:0] cmt_cause,\n    output wire cmt_cause_ena,\n    output wire cmt_instret_ena,\n    output wire cmt_status_ena,\n    output wire [E203_PC_SIZE-1:0] cmt_dpc,\n    output wire cmt_dpc_ena,\n    output wire [2:0] cmt_dcause,\n    output wire cmt_dcause_ena,\n    output wire cmt_mret_ena,\n    input wire [E203_PC_SIZE-1:0] csr_epc_r,\n    input wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    input wire [E203_XLEN-1:0] csr_mtvec_r,\n    input wire dbg_mode,\n    input wire dbg_halt_r,\n    input wire dbg_step_r,\n    input wire dbg_ebreakm_r,\n    input wire oitf_empty,\n    input wire u_mode,\n    input wire s_mode,\n    input wire h_mode,\n    input wire m_mode,\n    output wire longp_excp_i_ready,\n    input wire longp_excp_i_valid,\n    input wire longp_excp_i_ld,\n    input wire longp_excp_i_st,\n    input wire longp_excp_i_buserr,\n    input wire [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input wire longp_excp_i_insterr,\n    input wire [E203_PC_SIZE-1:0] longp_excp_i_pc\n);\n    // Implementation of the commit logic, exception handling, and flush control\n\n    // Example of signal assignments and logic\n    assign commit_mret = alu_cmt_i_mret;\n    assign commit_trap = alu_cmt_i_ecall | alu_cmt_i_ebreak | alu_cmt_i_buserr;\n    assign core_wfi = alu_cmt_i_wfi;\n    assign nonflush_cmt_ena = alu_cmt_i_valid & ~commit_trap;\n    assign excp_active = commit_trap;\n\n    // Example of ready signal logic\n    assign alu_cmt_i_ready = ~amo_wait;\n\n    // Example of exception and commit control\n    assign cmt_badaddr = alu_cmt_i_badaddr;\n    assign cmt_badaddr_ena = alu_cmt_i_buserr | alu_cmt_i_misalgn;\n    assign cmt_epc = csr_epc_r;\n    assign cmt_epc_ena = commit_trap;\n    assign cmt_cause = {E203_XLEN{1'b0}}; // Placeholder for exception cause\n    assign cmt_cause_ena = commit_trap;\n\n    // Debug and halt request handling\n    assign wfi_halt_ifu_req = alu_cmt_i_wfi & ~wfi_halt_ifu_ack;\n    assign wfi_halt_exu_req = alu_cmt_i_wfi & ~wfi_halt_exu_ack;\n\n    // Placeholder for additional logic\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 17, "code": "module e203_exu(\n    input clk,\n    input rst_n,\n    input [31:0] i_instr,\n    input [31:0] i_pc,\n    input i_valid,\n    output i_ready,\n    input i_misalgn,\n    input i_buserr,\n    input i_muldiv_b2b,\n    input dbg_mode,\n    output [31:0] dec_rs1x0,\n    output [31:0] dec_rs2x0,\n    output dec_rs1en,\n    output dec_rs2en,\n    output dec_rdwen,\n    output [4:0] dec_rs1idx,\n    output [4:0] dec_rs2idx,\n    output [4:0] dec_rdidx,\n    output [31:0] dec_info,\n    output [31:0] dec_imm,\n    output [31:0] dec_pc,\n    output dec_misalgn,\n    output dec_buserr,\n    output dec_ilegl,\n    output dec_mulhsu,\n    output dec_mul,\n    output dec_div,\n    output dec_rem,\n    output dec_divu,\n    output dec_remu,\n    output dec_rv32,\n    output dec_bjp,\n    output dec_jal,\n    output dec_jalr,\n    output dec_bxx,\n    output [4:0] dec_jalr_rs1idx,\n    output [31:0] dec_bjp_imm\n);\n    // Internal signals\n    wire [31:0] alu_result;\n    wire [31:0] muldiv_result;\n    wire [31:0] csr_result;\n    wire [31:0] agu_result;\n    wire [31:0] bjp_result;\n\n    // ALU instance\n    e203_exu_alu u_alu(\n        .clk(clk),\n        .rst_n(rst_n),\n        .i_valid(i_valid),\n        .i_instr(i_instr),\n        .i_pc(i_pc),\n        .alu_result(alu_result)\n    );\n\n    // MULDIV instance\n    e203_exu_muldiv u_muldiv(\n        .clk(clk),\n        .rst_n(rst_n),\n        .i_valid(i_valid),\n        .i_instr(i_instr),\n        .muldiv_result(muldiv_result)\n    );\n\n    // CSR instance\n    e203_exu_csr u_csr(\n        .clk(clk),\n        .rst_n(rst_n),\n        .i_valid(i_valid),\n        .i_instr(i_instr),\n        .csr_result(csr_result)\n    );\n\n    // AGU instance\n    e203_exu_agu u_agu(\n        .clk(clk),\n        .rst_n(rst_n),\n        .i_valid(i_valid),\n        .i_instr(i_instr),\n        .agu_result(agu_result)\n    );\n\n    // BJP instance\n    e203_exu_bjp u_bjp(\n        .clk(clk),\n        .rst_n(rst_n),\n        .i_valid(i_valid),\n        .i_instr(i_instr),\n        .bjp_result(bjp_result)\n    );\n\n    // Decode logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            dec_rs1x0 <= 32'b0;\n            dec_rs2x0 <= 32'b0;\n            dec_rs1en <= 1'b0;\n            dec_rs2en <= 1'b0;\n            dec_rdwen <= 1'b0;\n            dec_rs1idx <= 5'b0;\n            dec_rs2idx <= 5'b0;\n            dec_rdidx <= 5'b0;\n            dec_info <= 32'b0;\n            dec_imm <= 32'b0;\n            dec_pc <= 32'b0;\n            dec_misalgn <= 1'b0;\n            dec_buserr <= 1'b0;\n            dec_ilegl <= 1'b0;\n            dec_mulhsu <= 1'b0;\n            dec_mul <= 1'b0;\n            dec_div <= 1'b0;\n            dec_rem <= 1'b0;\n            dec_divu <= 1'b0;\n            dec_remu <= 1'b0;\n            dec_rv32 <= 1'b0;\n            dec_bjp <= 1'b0;\n            dec_jal <= 1'b0;\n            dec_jalr <= 1'b0;\n            dec_bxx <= 1'b0;\n            dec_jalr_rs1idx <= 5'b0;\n            dec_bjp_imm <= 32'b0;\n        end else if (i_valid) begin\n            // Decode logic here\n        end\n    end\n\n    // Ready signal logic\n    assign i_ready = ~i_valid; // Placeholder for actual ready logic\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 19, "code": "module e203_exu_alu(\n    input wire clk,\n    input wire rst_n,\n    input wire i_valid,\n    output wire i_ready,\n    input wire [E203_XLEN-1:0] i_rs1,\n    input wire [E203_XLEN-1:0] i_rs2,\n    input wire [E203_XLEN-1:0] i_imm,\n    input wire [E203_DECINFO_WIDTH-1:0] i_info,\n    input wire [E203_PC_SIZE-1:0] i_pc,\n    input wire [E203_INSTR_SIZE-1:0] i_instr,\n    input wire i_pc_vld,\n    input wire [E203_RFIDX_WIDTH-1:0] i_rdidx,\n    input wire i_rdwen,\n    input wire i_ilegl,\n    input wire i_buserr,\n    input wire i_misalgn,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire cmt_o_valid,\n    input wire cmt_o_ready,\n    output wire [E203_PC_SIZE-1:0] cmt_o_pc,\n    output wire [E203_INSTR_SIZE-1:0] cmt_o_instr,\n    output wire [E203_XLEN-1:0] cmt_o_imm,\n    output wire cmt_o_rv32,\n    output wire cmt_o_bjp,\n    output wire cmt_o_mret,\n    output wire cmt_o_dret,\n    output wire cmt_o_ecall,\n    output wire cmt_o_ebreak,\n    output wire cmt_o_fencei,\n    output wire cmt_o_wfi,\n    output wire cmt_o_ifu_misalgn,\n    output wire cmt_o_ifu_buserr,\n    output wire cmt_o_ifu_ilegl,\n    output wire cmt_o_bjp_prdt,\n    output wire cmt_o_bjp_rslv,\n    output wire cmt_o_misalgn,\n    output wire cmt_o_ld,\n    output wire cmt_o_stamo,\n    output wire cmt_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] cmt_o_badaddr,\n    output wire wbck_o_valid,\n    input wire wbck_o_ready,\n    output wire [E203_XLEN-1:0] wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] wbck_o_rdidx,\n    input wire mdv_nob2b,\n    output wire csr_ena,\n    output wire csr_wr_en,\n    output wire csr_rd_en,\n    output wire [11:0] csr_idx,\n    input wire nonflush_cmt_ena,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output wire [E203_XLEN-1:0] wbck_csr_dat,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_usign,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_longp_wbck_valid,\n    input wire nice_longp_wbck_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire i_nice_cmt_off_ilgl\n);\n\n    // Internal signals for ALU operations\n    wire alu_op_add;\n    wire alu_op_sub;\n    wire alu_op_and;\n    wire alu_op_or;\n    wire alu_op_xor;\n    wire alu_op_sll;\n    wire alu_op_srl;\n    wire alu_op_sra;\n    wire alu_op_slt;\n    wire alu_op_sltu;\n    wire alu_op_lui;\n\n    // Decode instruction information\n    assign alu_op_add = i_info[E203_DECINFO_ALU_ADD];\n    assign alu_op_sub = i_info[E203_DECINFO_ALU_SUB];\n    assign alu_op_and = i_info[E203_DECINFO_ALU_AND];\n    assign alu_op_or = i_info[E203_DECINFO_ALU_OR];\n    assign alu_op_xor = i_info[E203_DECINFO_ALU_XOR];\n    assign alu_op_sll = i_info[E203_DECINFO_ALU_SLL];\n    assign alu_op_srl = i_info[E203_DECINFO_ALU_SRL];\n    assign alu_op_sra = i_info[E203_DECINFO_ALU_SRA];\n    assign alu_op_slt = i_info[E203_DECINFO_ALU_SLT];\n    assign alu_op_sltu = i_info[E203_DECINFO_ALU_SLTU];\n    assign alu_op_lui = i_info[E203_DECINFO_ALU_LUI];\n\n    // ALU core logic\n    reg [E203_XLEN-1:0] alu_result;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            alu_result <= {E203_XLEN{1'b0}};\n        end else if (i_valid && i_ready) begin\n            case (1'b1) // synthesis parallel_case\n                alu_op_add: alu_result <= i_rs1 + i_rs2;\n                alu_op_sub: alu_result <= i_rs1 - i_rs2;\n                alu_op_and: alu_result <= i_rs1 & i_rs2;\n                alu_op_or: alu_result <= i_rs1 | i_rs2;\n                alu_op_xor: alu_result <= i_rs1 ^ i_rs2;\n                alu_op_sll: alu_result <= i_rs1 << i_rs2[E203_XLEN-1:0];\n                alu_op_srl: alu_result <= i_rs1 >> i_rs2[E203_XLEN-1:0];\n                alu_op_sra: alu_result <= $signed(i_rs1) >>> i_rs2[E203_XLEN-1:0];\n                alu_op_slt: alu_result <= $signed(i_rs1) < $signed(i_rs2);\n                alu_op_sltu: alu_result <= i_rs1 < i_rs2;\n                alu_op_lui: alu_result <= {i_imm[E203_XLEN-1:12], 12'h000};\n                default: alu_result <= {E203_XLEN{1'b0}};\n            endcase\n        end\n    end\n\n    // Output assignments\n    assign wbck_o_wdat = alu_result;\n    assign wbck_o_valid = i_valid && i_ready && i_rdwen;\n    assign wbck_o_rdidx = i_rdidx;\n\n    // Ready/Valid handshake\n    assign i_ready = !wbck_o_valid || wbck_o_ready;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 16, "code": "module e203_exu_decode (\n    input [E203_INSTR_SIZE-1:0] i_instr,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_prdt_taken,\n    input i_misalgn,\n    input i_buserr,\n    input i_muldiv_b2b,\n    input dbg_mode,\n    output dec_rs1x0,\n    output dec_rs2x0,\n    output dec_rs1en,\n    output dec_rs2en,\n    output dec_rdwen,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rdidx,\n    output [E203_DECINFO_WIDTH-1:0] dec_info,\n    output [E203_XLEN-1:0] dec_imm,\n    output [E203_PC_SIZE-1:0] dec_pc,\n    output dec_misalgn,\n    output dec_buserr,\n    output dec_ilegl,\n    output dec_mulhsu,\n    output dec_mul,\n    output dec_div,\n    output dec_rem,\n    output dec_divu,\n    output dec_remu,\n    output dec_rv32,\n    output dec_bjp,\n    output dec_jal,\n    output dec_jalr,\n    output dec_bxx,\n    output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    output [E203_XLEN-1:0] dec_bjp_imm,\n    `ifdef E203_HAS_NICE\n    input nice_xs_off,\n    output dec_nice,\n    output nice_cmt_off_ilgl_o,\n    `endif\n);\n\n    // Instruction decoding logic here\n    // This is a placeholder for the actual decoding logic\n    // which would involve parsing the instruction fields\n    // and setting the output signals accordingly.\n\n    // Example: Decode an ADD instruction\n    wire [6:0] opcode = i_instr[6:0];\n    wire [2:0] funct3 = i_instr[14:12];\n    wire [6:0] funct7 = i_instr[31:25];\n\n    assign dec_rs1idx = i_instr[19:15];\n    assign dec_rs2idx = i_instr[24:20];\n    assign dec_rdidx = i_instr[11:7];\n\n    assign dec_rs1en = (opcode == 7'b0110011); // R-type\n    assign dec_rs2en = (opcode == 7'b0110011); // R-type\n    assign dec_rdwen = (opcode == 7'b0110011); // R-type\n\n    assign dec_info = {E203_DECINFO_WIDTH{1'b0}}; // Default to all zeros\n    assign dec_imm = {E203_XLEN{1'b0}}; // Default to all zeros\n    assign dec_pc = i_pc;\n    assign dec_misalgn = i_misalgn;\n    assign dec_buserr = i_buserr;\n    assign dec_ilegl = 1'b0; // Default to legal instruction\n\n    // Example specific decoding\n    assign dec_mul = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b000);\n    assign dec_div = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b100);\n\n    `ifdef E203_HAS_NICE\n    assign dec_nice = 1'b0; // Placeholder for NICE instruction detection\n    assign nice_cmt_off_ilgl_o = nice_xs_off && dec_nice;\n    `endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 18, "code": "module e203_exu(\n    output commit_mret,\n    output commit_trap,\n    output exu_active,\n    output excp_active,\n    output core_wfi,\n    output tm_stop,\n    output itcm_nohold,\n    output core_cgstop,\n    output tcm_cgstop,\n    input [E203_HART_ID_W-1:0] core_mhartid,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    output wfi_halt_ifu_req,\n    input wfi_halt_ifu_ack,\n    output oitf_empty,\n    output [E203_XLEN-1:0] rf2ifu_x1,\n    output [E203_XLEN-1:0] rf2ifu_rs1,\n    output dec2ifu_rden,\n    output dec2ifu_rs1en,\n    output [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    output dec2ifu_mulhsu,\n    output dec2ifu_div,\n    output dec2ifu_rem,\n    output dec2ifu_divu,\n    output dec2ifu_remu,\n    input test_mode,\n    input clk_aon,\n    input clk,\n    input rst_n,\n    output cmt_dpc,\n    output cmt_dpc_ena,\n    output cmt_dcause,\n    output cmt_dcause_ena,\n    output wr_dcsr_ena,\n    output wr_dpc_ena,\n    output wr_dscratch_ena,\n    output [E203_XLEN-1:0] wr_csr_nxt,\n    input [E203_XLEN-1:0] dcsr_r,\n    input [E203_PC_SIZE-1:0] dpc_r,\n    input [E203_XLEN-1:0] dscratch_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input dbg_stopcycle,\n    input i_valid,\n    output i_ready,\n    input [E203_INSTR_SIZE-1:0] i_ir,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_pc_vld,\n    input i_misalgn,\n    input i_buserr,\n    input i_prdt_taken,\n    input i_muldiv_b2b,\n    input [E203_RFIDX_WIDTH-1:0] i_rs1idx,\n    input [E203_RFIDX_WIDTH-1:0] i_rs2idx,\n    input pipe_flush_ack,\n    output pipe_flush_req,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input lsu_o_valid,\n    output lsu_o_ready,\n    input [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    input [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    input lsu_o_wbck_err,\n    input lsu_o_cmt_ld,\n    input lsu_o_cmt_st,\n    input [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    input lsu_o_cmt_buserr,\n    output agu_icb_cmd_valid,\n    input agu_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output agu_icb_cmd_read,\n    output [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    output agu_icb_cmd_lock,\n    output agu_icb_cmd_excl,\n    output [1:0] agu_icb_cmd_size,\n    output agu_icb_cmd_back2agu,\n    output agu_icb_cmd_usign,\n    output [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input agu_icb_rsp_valid,\n    output agu_icb_rsp_ready,\n    input agu_icb_rsp_err,\n    input agu_icb_rsp_excl_ok,\n    input [E203_XLEN-1:0] agu_icb_rsp_rdata\n);\n    // Module implementation\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 8, "code": "module itcm_controller #(\n    parameter ADDR_WIDTH = 32,\n    parameter DATA_WIDTH = 64,\n    parameter WMSK_WIDTH = DATA_WIDTH / 8,\n    parameter RAM_AW = 10,\n    parameter RAM_MW = DATA_WIDTH / 8,\n    parameter RAM_DW = DATA_WIDTH\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n\n    // IFU Interface\n    input wire ifu2itcm_icb_cmd_valid,\n    output wire ifu2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] ifu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] ifu2itcm_icb_cmd_wmask,\n    output wire ifu2itcm_icb_rsp_valid,\n    input wire ifu2itcm_icb_rsp_ready,\n    output wire ifu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n\n    // LSU Interface\n    input wire lsu2itcm_icb_cmd_valid,\n    output wire lsu2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] lsu2itcm_icb_cmd_addr,\n    input wire lsu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] lsu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] lsu2itcm_icb_cmd_wmask,\n    output wire lsu2itcm_icb_rsp_valid,\n    input wire lsu2itcm_icb_rsp_ready,\n    output wire lsu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] lsu2itcm_icb_rsp_rdata,\n\n    // RAM Interface\n    output wire itcm_ram_cs,\n    output wire itcm_ram_we,\n    output wire [RAM_AW-1:0] itcm_ram_addr,\n    output wire [RAM_MW-1:0] itcm_ram_wem,\n    output wire [RAM_DW-1:0] itcm_ram_din,\n    input wire [RAM_DW-1:0] itcm_ram_dout,\n    output wire clk_itcm_ram,\n\n    // Status Output\n    output wire itcm_active\n);\n\n    // Internal signals\n    wire [ADDR_WIDTH-1:0] selected_addr;\n    wire [DATA_WIDTH-1:0] selected_wdata;\n    wire [WMSK_WIDTH-1:0] selected_wmask;\n    wire selected_read;\n    wire selected_valid;\n    wire selected_ready;\n    wire [DATA_WIDTH-1:0] selected_rdata;\n    wire selected_rsp_valid;\n    wire selected_rsp_ready;\n    wire selected_rsp_err;\n\n    // Arbitration logic (simplified example)\n    assign selected_addr = ifu2itcm_icb_cmd_valid ? ifu2itcm_icb_cmd_addr : lsu2itcm_icb_cmd_addr;\n    assign selected_wdata = ifu2itcm_icb_cmd_valid ? ifu2itcm_icb_cmd_wdata : lsu2itcm_icb_cmd_wdata;\n    assign selected_wmask = ifu2itcm_icb_cmd_valid ? ifu2itcm_icb_cmd_wmask : lsu2itcm_icb_cmd_wmask;\n    assign selected_read = ifu2itcm_icb_cmd_valid ? ifu2itcm_icb_cmd_read : lsu2itcm_icb_cmd_read;\n    assign selected_valid = ifu2itcm_icb_cmd_valid || lsu2itcm_icb_cmd_valid;\n    assign ifu2itcm_icb_cmd_ready = selected_ready && ifu2itcm_icb_cmd_valid;\n    assign lsu2itcm_icb_cmd_ready = selected_ready && lsu2itcm_icb_cmd_valid;\n\n    // RAM access logic\n    assign itcm_ram_cs = selected_valid && selected_ready;\n    assign itcm_ram_we = !selected_read;\n    assign itcm_ram_addr = selected_addr[RAM_AW-1:0];\n    assign itcm_ram_wem = selected_wmask;\n    assign itcm_ram_din = selected_wdata;\n    assign selected_rdata = itcm_ram_dout;\n\n    // Response logic\n    assign selected_rsp_valid = itcm_ram_cs;\n    assign selected_rsp_ready = ifu2itcm_icb_rsp_ready || lsu2itcm_icb_rsp_ready;\n    assign selected_rsp_err = 0; // Simplified: No error handling\n\n    assign ifu2itcm_icb_rsp_valid = selected_rsp_valid && ifu2itcm_icb_cmd_valid;\n    assign ifu2itcm_icb_rsp_rdata = selected_rdata;\n    assign ifu2itcm_icb_rsp_err = selected_rsp_err;\n\n    assign lsu2itcm_icb_rsp_valid = selected_rsp_valid && lsu2itcm_icb_cmd_valid;\n    assign lsu2itcm_icb_rsp_rdata = selected_rdata;\n    assign lsu2itcm_icb_rsp_err = selected_rsp_err;\n\n    // Clock and reset logic\n    assign clk_itcm_ram = clk;\n    assign itcm_active = selected_valid; // Indicates activity for power management\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 6, "code": "module e203_lsu_ctrl(\n    input wire commit_mret,\n    input wire commit_trap,\n    output wire lsu_ctrl_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    input wire nice_mem_holdup,\n    input wire nice_icb_cmd_valid,\n    output wire nice_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] nice_icb_cmd_addr,\n    input wire nice_icb_cmd_read,\n    input wire [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] nice_icb_cmd_wmask,\n    output wire nice_icb_rsp_valid,\n    input wire nice_icb_rsp_ready,\n    output wire nice_icb_rsp_err,\n    output wire [E203_XLEN-1:0] nice_icb_rsp_rdata,\n\n    output wire dcache_icb_cmd_valid,\n    input wire dcache_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] dcache_icb_cmd_addr,\n    output wire dcache_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dcache_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dcache_icb_cmd_wmask,\n    output wire dcache_icb_cmd_lock,\n    output wire dcache_icb_cmd_excl,\n    output wire [1:0] dcache_icb_cmd_size,\n    input wire dcache_icb_rsp_valid,\n    output wire dcache_icb_rsp_ready,\n    input wire dcache_icb_rsp_err,\n    input wire dcache_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dcache_icb_rsp_rdata,\n\n    output wire dtcm_icb_cmd_valid,\n    input wire dtcm_icb_cmd_ready,\n    output wire [E203_DTCM_ADDR_WIDTH-1:0] dtcm_icb_cmd_addr,\n    output wire dtcm_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dtcm_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dtcm_icb_cmd_wmask,\n    output wire dtcm_icb_cmd_lock,\n    output wire dtcm_icb_cmd_excl,\n    output wire [1:0] dtcm_icb_cmd_size,\n    input wire dtcm_icb_rsp_valid,\n    output wire dtcm_icb_rsp_ready,\n    input wire dtcm_icb_rsp_err,\n    input wire dtcm_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dtcm_icb_rsp_rdata,\n    input wire [E203_ADDR_SIZE-1:0] dtcm_region_indic,\n\n    output wire biu_icb_cmd_valid,\n    input wire biu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,\n    output wire biu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] biu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] biu_icb_cmd_wmask,\n    output wire biu_icb_cmd_lock,\n    output wire biu_icb_cmd_excl,\n    output wire [1:0] biu_icb_cmd_size,\n    input wire biu_icb_rsp_valid,\n    output wire biu_icb_rsp_ready,\n    input wire biu_icb_rsp_err,\n    input wire biu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] biu_icb_rsp_rdata\n);\n    // Module implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 7, "code": "module e203_lsu_ctrl(\n    input wire commit_mret,\n    input wire commit_trap,\n    output wire lsu_ctrl_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    input wire nice_mem_holdup,\n    input wire nice_icb_cmd_valid,\n    output wire nice_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] nice_icb_cmd_addr,\n    input wire nice_icb_cmd_read,\n    input wire [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] nice_icb_cmd_wmask,\n    output wire nice_icb_rsp_valid,\n    input wire nice_icb_rsp_ready,\n    output wire nice_icb_rsp_err,\n    output wire [E203_XLEN-1:0] nice_icb_rsp_rdata,\n\n    output wire dcache_icb_cmd_valid,\n    input wire dcache_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] dcache_icb_cmd_addr,\n    output wire dcache_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dcache_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dcache_icb_cmd_wmask,\n    output wire dcache_icb_cmd_lock,\n    output wire dcache_icb_cmd_excl,\n    output wire [1:0] dcache_icb_cmd_size,\n    input wire dcache_icb_rsp_valid,\n    output wire dcache_icb_rsp_ready,\n    input wire dcache_icb_rsp_err,\n    input wire dcache_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dcache_icb_rsp_rdata,\n\n    output wire dtcm_icb_cmd_valid,\n    input wire dtcm_icb_cmd_ready,\n    output wire [E203_DTCM_ADDR_WIDTH-1:0] dtcm_icb_cmd_addr,\n    output wire dtcm_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dtcm_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dtcm_icb_cmd_wmask,\n    output wire dtcm_icb_cmd_lock,\n    output wire dtcm_icb_cmd_excl,\n    output wire [1:0] dtcm_icb_cmd_size,\n    input wire dtcm_icb_rsp_valid,\n    output wire dtcm_icb_rsp_ready,\n    input wire dtcm_icb_rsp_err,\n    input wire dtcm_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dtcm_icb_rsp_rdata,\n    input wire [E203_ADDR_SIZE-1:0] dtcm_region_indic,\n\n    output wire biu_icb_cmd_valid,\n    input wire biu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,\n    output wire biu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] biu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] biu_icb_cmd_wmask,\n    output wire biu_icb_cmd_lock,\n    output wire biu_icb_cmd_excl,\n    output wire [1:0] biu_icb_cmd_size,\n    input wire biu_icb_rsp_valid,\n    output wire biu_icb_rsp_ready,\n    input wire biu_icb_rsp_err,\n    input wire biu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] biu_icb_rsp_rdata,\n\n    input wire clk,\n    input wire rst_n\n);\n    // LSU control logic implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 8, "code": "module e203_lsu_ctrl(\n    input wire commit_mret,\n    input wire commit_trap,\n    output wire lsu_ctrl_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    input wire nice_mem_holdup,\n    input wire nice_icb_cmd_valid,\n    output wire nice_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] nice_icb_cmd_addr,\n    input wire nice_icb_cmd_read,\n    input wire [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] nice_icb_cmd_wmask,\n    output wire nice_icb_rsp_valid,\n    input wire nice_icb_rsp_ready,\n    output wire nice_icb_rsp_err,\n    output wire [E203_XLEN-1:0] nice_icb_rsp_rdata,\n\n    output wire dcache_icb_cmd_valid,\n    input wire dcache_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] dcache_icb_cmd_addr,\n    output wire dcache_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dcache_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dcache_icb_cmd_wmask,\n    output wire dcache_icb_cmd_lock,\n    output wire dcache_icb_cmd_excl,\n    output wire [1:0] dcache_icb_cmd_size,\n    input wire dcache_icb_rsp_valid,\n    output wire dcache_icb_rsp_ready,\n    input wire dcache_icb_rsp_err,\n    input wire dcache_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dcache_icb_rsp_rdata,\n\n    output wire dtcm_icb_cmd_valid,\n    input wire dtcm_icb_cmd_ready,\n    output wire [E203_DTCM_ADDR_WIDTH-1:0] dtcm_icb_cmd_addr,\n    output wire dtcm_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dtcm_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dtcm_icb_cmd_wmask,\n    output wire dtcm_icb_cmd_lock,\n    output wire dtcm_icb_cmd_excl,\n    output wire [1:0] dtcm_icb_cmd_size,\n    input wire dtcm_icb_rsp_valid,\n    output wire dtcm_icb_rsp_ready,\n    input wire dtcm_icb_rsp_err,\n    input wire dtcm_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dtcm_icb_rsp_rdata,\n    input wire [E203_ADDR_SIZE-1:0] dtcm_region_indic,\n\n    output wire biu_icb_cmd_valid,\n    input wire biu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,\n    output wire biu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] biu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] biu_icb_cmd_wmask,\n    output wire biu_icb_cmd_lock,\n    output wire biu_icb_cmd_excl,\n    output wire [1:0] biu_icb_cmd_size,\n    input wire biu_icb_rsp_valid,\n    output wire biu_icb_rsp_ready,\n    input wire biu_icb_rsp_err,\n    input wire biu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] biu_icb_rsp_rdata\n);\n    // Module implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 11, "code": "module e203_ifu_ift2icb (\n    input wire itcm_nohold,\n    input wire ifu_req_valid,\n    input wire [PC_SIZE-1:0] ifu_req_pc,\n    input wire ifu_req_seq,\n    input wire ifu_req_seq_rv32,\n    input wire [PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_ready,\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_ready,\n    output wire ifu_rsp_valid,\n    output wire ifu_rsp_err,\n    output wire [31:0] ifu_rsp_instr,\n    output wire ifu2itcm_icb_cmd_valid,\n    input wire ifu2itcm_icb_cmd_ready,\n    output wire [ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_rsp_valid,\n    output wire ifu2itcm_icb_rsp_ready,\n    input wire ifu2itcm_icb_rsp_err,\n    input wire [ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    output wire ifu2biu_icb_cmd_valid,\n    input wire ifu2biu_icb_cmd_ready,\n    output wire [ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input wire ifu2biu_icb_rsp_valid,\n    output wire ifu2biu_icb_rsp_ready,\n    input wire ifu2biu_icb_rsp_err,\n    input wire [SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata\n);\n\n    // State machine definition\n    localparam ICB_STATE_IDLE = 2'b00;\n    localparam ICB_STATE_1ST = 2'b01;\n    localparam ICB_STATE_WAIT2ND = 2'b10;\n    localparam ICB_STATE_2ND = 2'b11;\n\n    reg [1:0] icb_state, icb_state_nxt;\n    wire icb_state_ena;\n\n    // State transition logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            icb_state <= ICB_STATE_IDLE;\n        end else if (icb_state_ena) begin\n            icb_state <= icb_state_nxt;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (icb_state)\n            ICB_STATE_IDLE: begin\n                if (ifu_req_valid && ifu_req_ready)\n                    icb_state_nxt = ICB_STATE_1ST;\n                else\n                    icb_state_nxt = ICB_STATE_IDLE;\n            end\n            ICB_STATE_1ST: begin\n                if (ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid)\n                    icb_state_nxt = ICB_STATE_WAIT2ND;\n                else\n                    icb_state_nxt = ICB_STATE_1ST;\n            end\n            ICB_STATE_WAIT2ND: begin\n                if (ifu2itcm_icb_cmd_ready || ifu2biu_icb_cmd_ready)\n                    icb_state_nxt = ICB_STATE_2ND;\n                else\n                    icb_state_nxt = ICB_STATE_WAIT2ND;\n            end\n            ICB_STATE_2ND: begin\n                if (ifu_rsp_ready)\n                    icb_state_nxt = ICB_STATE_IDLE;\n                else\n                    icb_state_nxt = ICB_STATE_2ND;\n            end\n            default: icb_state_nxt = ICB_STATE_IDLE;\n        endcase\n    end\n\n    assign icb_state_ena = 1'b1; // Enable state update every cycle\n\n    // Output logic\n    assign ifu_req_ready = (icb_state == ICB_STATE_IDLE);\n    assign ifu_rsp_valid = (icb_state == ICB_STATE_2ND) && (ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid);\n    assign ifu_rsp_err = (icb_state == ICB_STATE_2ND) && (ifu2itcm_icb_rsp_err || ifu2biu_icb_rsp_err);\n    assign ifu_rsp_instr = (icb_state == ICB_STATE_2ND) ? (ifu2itcm_icb_rsp_valid ? ifu2itcm_icb_rsp_rdata : ifu2biu_icb_rsp_rdata) : 32'b0;\n\n    // ICB command signals\n    assign ifu2itcm_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && ifu_req_valid;\n    assign ifu2itcm_icb_cmd_addr = ifu_req_pc[ITCM_ADDR_WIDTH-1:0];\n    assign ifu2itcm_icb_rsp_ready = (icb_state == ICB_STATE_1ST) || (icb_state == ICB_STATE_2ND);\n\n    assign ifu2biu_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && ifu_req_valid;\n    assign ifu2biu_icb_cmd_addr = ifu_req_pc[ADDR_SIZE-1:0];\n    assign ifu2biu_icb_rsp_ready = (icb_state == ICB_STATE_1ST) || (icb_state == ICB_STATE_2ND);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 14, "code": "module e203_exu_disp (\n    input wire wfi_halt_exu_req,\n    output wire wfi_halt_exu_ack,\n    input wire oitf_empty,\n    input wire amo_wait,\n    input wire disp_i_valid,\n    output wire disp_i_ready,\n    input wire disp_i_rs1x0,\n    input wire disp_i_rs2x0,\n    input wire disp_i_rs1en,\n    input wire disp_i_rs2en,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input wire [E203_XLEN-1:0] disp_i_rs1,\n    input wire [E203_XLEN-1:0] disp_i_rs2,\n    input wire disp_i_rdwen,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input wire [E203_DECINFO_WIDTH-1:0] disp_i_info,\n    input wire [E203_XLEN-1:0] disp_i_imm,\n    input wire [E203_PC_SIZE-1:0] disp_i_pc,\n    input wire disp_i_misalgn,\n    input wire disp_i_buserr,\n    input wire disp_i_ilegl,\n    output wire disp_o_alu_valid,\n    input wire disp_o_alu_ready,\n    input wire disp_o_alu_longpipe,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs1,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs2,\n    output wire disp_o_alu_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_o_alu_rdidx,\n    output wire [E203_DECINFO_WIDTH-1:0] disp_o_alu_info,\n    output wire [E203_XLEN-1:0] disp_o_alu_imm,\n    output wire [E203_PC_SIZE-1:0] disp_o_alu_pc,\n    output wire [E203_ITAG_WIDTH-1:0] disp_o_alu_itag,\n    output wire disp_o_alu_misalgn,\n    output wire disp_o_alu_buserr,\n    output wire disp_o_alu_ilegl,\n    input wire oitfrd_match_disprs1,\n    input wire oitfrd_match_disprs2,\n    input wire oitfrd_match_disprs3,\n    input wire oitfrd_match_disprd,\n    input wire [E203_ITAG_WIDTH-1:0] disp_oitf_ptr,\n    output wire disp_oitf_ena,\n    input wire disp_oitf_ready,\n    output wire disp_oitf_rs1fpu,\n    output wire disp_oitf_rs2fpu,\n    output wire disp_oitf_rs3fpu,\n    output wire disp_oitf_rdfpu,\n    output wire disp_oitf_rs1en,\n    output wire disp_oitf_rs2en,\n    output wire disp_oitf_rs3en,\n    output wire disp_oitf_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs2idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs3idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rdidx,\n    output wire [E203_PC_SIZE-1:0] disp_oitf_pc,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Implementation of dispatch logic, dependency checks, and WFI handling\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 19, "code": "module e203_exu(\n    output commit_mret,\n    output commit_trap,\n    output exu_active,\n    output excp_active,\n    output core_wfi,\n    output tm_stop,\n    output itcm_nohold,\n    output core_cgstop,\n    output tcm_cgstop,\n    input [E203_HART_ID_W-1:0] core_mhartid,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    output wfi_halt_ifu_req,\n    input wfi_halt_ifu_ack,\n    output oitf_empty,\n    output [E203_XLEN-1:0] rf2ifu_x1,\n    output [E203_XLEN-1:0] rf2ifu_rs1,\n    output dec2ifu_rden,\n    output dec2ifu_rs1en,\n    output [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    output dec2ifu_mulhsu,\n    output dec2ifu_div,\n    output dec2ifu_rem,\n    output dec2ifu_divu,\n    output dec2ifu_remu,\n    input test_mode,\n    input clk_aon,\n    input clk,\n    input rst_n,\n    output cmt_dpc,\n    output cmt_dpc_ena,\n    output cmt_dcause,\n    output cmt_dcause_ena,\n    output wr_dcsr_ena,\n    output wr_dpc_ena,\n    output wr_dscratch_ena,\n    output [E203_XLEN-1:0] wr_csr_nxt,\n    input [E203_XLEN-1:0] dcsr_r,\n    input [E203_PC_SIZE-1:0] dpc_r,\n    input [E203_XLEN-1:0] dscratch_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input dbg_stopcycle,\n    input i_valid,\n    output i_ready,\n    input [E203_INSTR_SIZE-1:0] i_ir,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_pc_vld,\n    input i_misalgn,\n    input i_buserr,\n    input i_prdt_taken,\n    input i_muldiv_b2b,\n    input [E203_RFIDX_WIDTH-1:0] i_rs1idx,\n    input [E203_RFIDX_WIDTH-1:0] i_rs2idx,\n    input pipe_flush_ack,\n    output pipe_flush_req,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input lsu_o_valid,\n    output lsu_o_ready,\n    input [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    input [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    input lsu_o_wbck_err,\n    input lsu_o_cmt_ld,\n    input lsu_o_cmt_st,\n    input [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    input lsu_o_cmt_buserr,\n    output agu_icb_cmd_valid,\n    input agu_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output agu_icb_cmd_read,\n    output [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    output agu_icb_cmd_lock,\n    output agu_icb_cmd_excl,\n    output [1:0] agu_icb_cmd_size,\n    output agu_icb_cmd_back2agu,\n    output agu_icb_cmd_usign,\n    output [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input agu_icb_rsp_valid,\n    output agu_icb_rsp_ready,\n    input agu_icb_rsp_err,\n    input agu_icb_rsp_excl_ok,\n    input [E203_XLEN-1:0] agu_icb_rsp_rdata\n);\n    // Module implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 20, "code": "module e203_exu(\n    output commit_mret,\n    output commit_trap,\n    output exu_active,\n    output excp_active,\n    output core_wfi,\n    output tm_stop,\n    output itcm_nohold,\n    output core_cgstop,\n    output tcm_cgstop,\n    input [E203_HART_ID_W-1:0] core_mhartid,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input [E203_EVT_NUM-1:0] evt_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    output wfi_halt_ifu_req,\n    input wfi_halt_ifu_ack,\n    output oitf_empty,\n    output [E203_XLEN-1:0] rf2ifu_x1,\n    output [E203_XLEN-1:0] rf2ifu_rs1,\n    output dec2ifu_rden,\n    output dec2ifu_rs1en,\n    output [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    output dec2ifu_mulhsu,\n    output dec2ifu_div,\n    output dec2ifu_rem,\n    output dec2ifu_divu,\n    output dec2ifu_remu,\n    input test_mode,\n    input clk_aon,\n    input clk,\n    input rst_n,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output wr_dcsr_ena,\n    output wr_dpc_ena,\n    output wr_dscratch_ena,\n    output [E203_XLEN-1:0] wr_csr_nxt,\n    input [E203_XLEN-1:0] dcsr_r,\n    input [E203_PC_SIZE-1:0] dpc_r,\n    input [E203_XLEN-1:0] dscratch_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input dbg_stopcycle,\n    input i_valid,\n    output i_ready,\n    input [E203_INSTR_SIZE-1:0] i_ir,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_pc_vld,\n    input i_misalgn,\n    input i_buserr,\n    input i_prdt_taken,\n    input i_muldiv_b2b,\n    input [E203_RFIDX_WIDTH-1:0] i_rs1idx,\n    input [E203_RFIDX_WIDTH-1:0] i_rs2idx,\n    input pipe_flush_ack,\n    output pipe_flush_req,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    output [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input lsu_o_valid,\n    output lsu_o_ready,\n    input [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    input [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    input lsu_o_wbck_err,\n    input lsu_o_cmt_ld,\n    input lsu_o_cmt_st,\n    input [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    input lsu_o_cmt_buserr,\n    output agu_icb_cmd_valid,\n    input agu_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output agu_icb_cmd_read,\n    output [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    output agu_icb_cmd_lock,\n    output agu_icb_cmd_excl,\n    output [1:0] agu_icb_cmd_size,\n    output agu_icb_cmd_back2agu,\n    output agu_icb_cmd_usign,\n    output [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input agu_icb_rsp_valid,\n    output agu_icb_rsp_ready,\n    input agu_icb_rsp_err,\n    input agu_icb_rsp_excl_ok,\n    input [E203_XLEN-1:0] agu_icb_rsp_rdata\n);\n    // Module implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 15, "code": "module e203_exu_disp(\n    input wire wfi_halt_exu_req,\n    output wire wfi_halt_exu_ack,\n    input wire oitf_empty,\n    input wire amo_wait,\n    input wire disp_i_valid,\n    output wire disp_i_ready,\n    input wire disp_i_rs1x0,\n    input wire disp_i_rs2x0,\n    input wire disp_i_rs1en,\n    input wire disp_i_rs2en,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input wire [E203_XLEN-1:0] disp_i_rs1,\n    input wire [E203_XLEN-1:0] disp_i_rs2,\n    input wire disp_i_rdwen,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input wire [E203_DECINFO_WIDTH-1:0] disp_i_info,\n    input wire [E203_XLEN-1:0] disp_i_imm,\n    input wire [E203_PC_SIZE-1:0] disp_i_pc,\n    input wire disp_i_misalgn,\n    input wire disp_i_buserr,\n    input wire disp_i_ilegl,\n    output wire disp_o_alu_valid,\n    input wire disp_o_alu_ready,\n    input wire disp_o_alu_longpipe,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs1,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs2,\n    output wire disp_o_alu_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_o_alu_rdidx,\n    output wire [E203_DECINFO_WIDTH-1:0] disp_o_alu_info,\n    output wire [E203_XLEN-1:0] disp_o_alu_imm,\n    output wire [E203_PC_SIZE-1:0] disp_o_alu_pc,\n    output wire [E203_ITAG_WIDTH-1:0] disp_o_alu_itag,\n    output wire disp_o_alu_misalgn,\n    output wire disp_o_alu_buserr,\n    output wire disp_o_alu_ilegl,\n    input wire oitfrd_match_disprs1,\n    input wire oitfrd_match_disprs2,\n    input wire oitfrd_match_disprs3,\n    input wire oitfrd_match_disprd,\n    input wire [E203_ITAG_WIDTH-1:0] disp_oitf_ptr,\n    output wire disp_oitf_ena,\n    input wire disp_oitf_ready,\n    output wire disp_oitf_rs1fpu,\n    output wire disp_oitf_rs2fpu,\n    output wire disp_oitf_rs3fpu,\n    output wire disp_oitf_rdfpu,\n    output wire disp_oitf_rs1en,\n    output wire disp_oitf_rs2en,\n    output wire disp_oitf_rs3en,\n    output wire disp_oitf_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs2idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs3idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rdidx,\n    output wire [E203_PC_SIZE-1:0] disp_oitf_pc,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Implementation of dispatch logic, dependency checks, and WFI handling\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 14, "code": "module e203_ifu(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire itcm_nohold,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input wire pipe_flush_req,\n    input wire ifu_halt_req,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire ifu_active,\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    output wire pipe_flush_ack,\n    input wire ifu2itcm_holdup,\n    input wire [E203_ADDR_SIZE-1:0] itcm_region_indic,\n    output wire ifu2itcm_icb_cmd_valid,\n    input wire ifu2itcm_icb_cmd_ready,\n    output wire [E203_ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_rsp_valid,\n    output wire ifu2itcm_icb_rsp_ready,\n    input wire ifu2itcm_icb_rsp_err,\n    input wire [E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    output wire ifu2biu_icb_cmd_valid,\n    input wire ifu2biu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input wire ifu2biu_icb_rsp_valid,\n    output wire ifu2biu_icb_rsp_ready,\n    input wire ifu2biu_icb_rsp_err,\n    input wire [E203_SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata,\n    output wire ifu_halt_ack\n);\n\n    // Internal signals\n    wire [E203_PC_SIZE-1:0] next_pc;\n    wire fetch_valid;\n    wire [E203_INSTR_SIZE-1:0] fetched_instr;\n    wire fetch_error;\n    wire [E203_PC_SIZE-1:0] current_pc;\n    wire pc_update;\n    wire flush_ack;\n    wire halt_ack;\n\n    // Instantiate IFU fetch module\n    e203_ifu_ifetch ifetch(\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ifu_o_ready(ifu_o_ready),\n        .pipe_flush_req(pipe_flush_req),\n        .pipe_flush_add_op1(pipe_flush_add_op1),\n        .pipe_flush_add_op2(pipe_flush_add_op2),\n        .ifu_halt_req(ifu_halt_req),\n        .oitf_empty(oitf_empty),\n        .rf2ifu_x1(rf2ifu_x1),\n        .rf2ifu_rs1(rf2ifu_rs1),\n        .dec2ifu_rden(dec2ifu_rden),\n        .dec2ifu_rs1en(dec2ifu_rs1en),\n        .dec2ifu_rdidx(dec2ifu_rdidx),\n        .dec2ifu_mulhsu(dec2ifu_mulhsu),\n        .dec2ifu_div(dec2ifu_div),\n        .dec2ifu_rem(dec2ifu_rem),\n        .dec2ifu_divu(dec2ifu_divu),\n        .dec2ifu_remu(dec2ifu_remu),\n        .inspect_pc(inspect_pc),\n        .ifu_req_valid(fetch_valid),\n        .ifu_req_pc(current_pc),\n        .pipe_flush_ack(flush_ack),\n        .ifu_halt_ack(halt_ack),\n        .ifu_o_ir(fetched_instr),\n        .ifu_o_pc(next_pc),\n        .ifu_o_pc_vld(ifu_o_pc_vld),\n        .ifu_o_misalgn(ifu_o_misalgn),\n        .ifu_o_buserr(fetch_error),\n        .ifu_o_rs1idx(ifu_o_rs1idx),\n        .ifu_o_rs2idx(ifu_o_rs2idx),\n        .ifu_o_prdt_taken(ifu_o_prdt_taken),\n        .ifu_o_muldiv_b2b(ifu_o_muldiv_b2b),\n        .ifu_o_valid(ifu_o_valid)\n    );\n\n    // Instantiate IFU to ICB interface module\n    e203_ifu_ift2icb ift2icb(\n        .clk(clk),\n        .rst_n(rst_n),\n        .ifu_req_valid(fetch_valid),\n        .ifu_req_pc(current_pc),\n        .ifu_rsp_ready(ifu_o_ready),\n        .itcm_nohold(itcm_nohold),\n        .itcm_region_indic(itcm_region_indic),\n        .ifu2itcm_icb_cmd_ready(ifu2itcm_icb_cmd_ready),\n        .ifu2itcm_icb_rsp_valid(ifu2itcm_icb_rsp_valid),\n        .ifu2itcm_icb_rsp_err(ifu2itcm_icb_rsp_err),\n        .ifu2itcm_icb_rsp_rdata(ifu2itcm_icb_rsp_rdata),\n        .ifu2biu_icb_cmd_ready(ifu2biu_icb_cmd_ready),\n        .ifu2biu_icb_rsp_valid(ifu2biu_icb_rsp_valid),\n        .ifu2biu_icb_rsp_err(ifu2biu_icb_rsp_err),\n        .ifu2biu_icb_rsp_rdata(ifu2biu_icb_rsp_rdata),\n        .ifu_req_ready(pc_update),\n        .ifu_rsp_valid(fetch_valid),\n        .ifu_rsp_err(fetch_error),\n        .ifu_rsp_instr(fetched_instr),\n        .ifu2itcm_icb_cmd_valid(ifu2itcm_icb_cmd_valid),\n        .ifu2itcm_icb_cmd_addr(ifu2itcm_icb_cmd_addr),\n        .ifu2itcm_icb_rsp_ready(ifu2itcm_icb_rsp_ready),\n        .ifu2biu_icb_cmd_valid(ifu2biu_icb_cmd_valid),\n        .ifu2biu_icb_cmd_addr(ifu2biu_icb_cmd_addr),\n        .ifu2biu_icb_rsp_ready(ifu2biu_icb_rsp_ready)\n    );\n\n    // Output assignments\n    assign ifu_o_ir = fetched_instr;\n    assign ifu_o_pc = next_pc;\n    assign pipe_flush_ack = flush_ack;\n    assign ifu_halt_ack = halt_ack;\n    assign ifu_active = fetch_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 11, "code": "module e203_exu_excp(\n    output commit_trap,\n    output core_wfi,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input amo_wait,\n    input alu_excp_i_valid,\n    input alu_excp_i_ld,\n    input alu_excp_i_stamo,\n    input alu_excp_i_misalgn,\n    input alu_excp_i_buserr,\n    input alu_excp_i_ecall,\n    input alu_excp_i_ebreak,\n    input alu_excp_i_wfi,\n    input alu_excp_i_ifu_misalgn,\n    input alu_excp_i_ifu_buserr,\n    input alu_excp_i_ifu_ilegl,\n    input [E203_PC_SIZE-1:0] alu_excp_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_excp_i_instr,\n    input alu_excp_i_pc_vld,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input longp_excp_i_insterr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input excpirq_flush_ack,\n    output excpirq_flush_req,\n    output nonalu_excpirq_flush_req_raw,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op1,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op2,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input cmt_dret_ena,\n    input cmt_ena,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_badaddr_ena,\n    output cmt_epc_ena,\n    output cmt_cause_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output excp_active,\n    input clk,\n    input rst_n\n);\n    // Implementation of exception handling logic\n    // This is a template and needs to be completed based on specific requirements and architecture details\n\n    // Registers and wires for internal state\n    reg [E203_PC_SIZE-1:0] next_pc;\n    reg flush_pipeline;\n    wire [E203_PC_SIZE-1:0] mtvec_base = csr_mtvec_r;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            next_pc <= 0;\n            flush_pipeline <= 0;\n        end else begin\n            if (alu_excp_i_valid) begin\n                // Handle ALU exceptions\n                next_pc <= mtvec_base;\n                flush_pipeline <= 1;\n            end else if (longp_excp_i_valid) begin\n                // Handle long-pipe exceptions\n                next_pc <= mtvec_base;\n                flush_pipeline <= 1;\n            end else if (dbg_irq_r) begin\n                // Handle debug interrupts\n                next_pc <= mtvec_base;\n                flush_pipeline <= 1;\n            end else begin\n                flush_pipeline <= 0;\n            end\n        end\n    end\n\n    assign excpirq_flush_req = flush_pipeline;\n    assign excpirq_flush_add_op1 = mtvec_base;\n    assign excpirq_flush_add_op2 = 0;\n\n    // Additional logic for handling exceptions and interrupts\n    // This includes setting up cause registers, bad address registers, etc.\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 17, "code": "module e203_exu_decode(\n    input [E203_INSTR_SIZE-1:0] i_instr,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_prdt_taken,\n    input i_misalgn,\n    input i_buserr,\n    input i_muldiv_b2b,\n    input dbg_mode,\n    output dec_rs1x0,\n    output dec_rs2x0,\n    output dec_rs1en,\n    output dec_rs2en,\n    output dec_rdwen,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rdidx,\n    output [E203_DECINFO_WIDTH-1:0] dec_info,\n    output [E203_XLEN-1:0] dec_imm,\n    output [E203_PC_SIZE-1:0] dec_pc,\n    output dec_misalgn,\n    output dec_buserr,\n    output dec_ilegl,\n    output dec_mulhsu,\n    output dec_mul,\n    output dec_div,\n    output dec_rem,\n    output dec_divu,\n    output dec_remu,\n    output dec_rv32,\n    output dec_bjp,\n    output dec_jal,\n    output dec_jalr,\n    output dec_bxx,\n    output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    output [E203_XLEN-1:0] dec_bjp_imm,\n    output dec_nice,\n    output nice_cmt_off_ilgl_o\n);\n\n    // Decode logic here\n    // This is a placeholder for the actual decoding logic\n    // which would involve parsing the i_instr input according\n    // to the RISC-V encoding specifications.\n\n    // Example of setting outputs based on instruction decode:\n    assign dec_rs1x0 = (dec_rs1idx == 0);\n    assign dec_rs2x0 = (dec_rs2idx == 0);\n    assign dec_rs1en = |i_instr[19:15]; // Example condition\n    assign dec_rs2en = |i_instr[24:20]; // Example condition\n    assign dec_rdwen = |i_instr[11:7];  // Example condition\n\n    // Example decoding information bus\n    // This is highly simplified and needs to be expanded based on actual instruction set\n    assign dec_info = {E203_DECINFO_WIDTH{1'b0}}; // Default to all zeros\n\n    // Example immediate extraction\n    assign dec_imm = {{20{i_instr[31]}}, i_instr[31:20]}; // For I-type instructions\n\n    // Propagate the PC and error signals\n    assign dec_pc = i_pc;\n    assign dec_misalgn = i_misalgn;\n    assign dec_buserr = i_buserr;\n\n    // Example illegal instruction detection\n    assign dec_ilegl = (i_instr == 32'h00000000) || (i_instr == 32'hFFFFFFFF);\n\n    // Example multiply/divide flags\n    assign dec_mulhsu = 1'b0; // Placeholder\n    assign dec_mul = 1'b0;    // Placeholder\n    assign dec_div = 1'b0;    // Placeholder\n    assign dec_rem = 1'b0;    // Placeholder\n    assign dec_divu = 1'b0;   // Placeholder\n    assign dec_remu = 1'b0;   // Placeholder\n\n    // Example RV32 flag\n    assign dec_rv32 = 1'b1; // Assuming always RV32 for simplicity\n\n    // Example branch/jump flags\n    assign dec_bjp = 1'b0; // Placeholder\n    assign dec_jal = 1'b0; // Placeholder\n    assign dec_jalr = 1'b0; // Placeholder\n    assign dec_bxx = 1'b0;  // Placeholder\n\n    // Example NICE flags\n    assign dec_nice = 1'b0; // Placeholder\n    assign nice_cmt_off_ilgl_o = 1'b0; // Placeholder\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 9, "code": "module itcm_controller (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n    input wire [ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] ifu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] ifu2itcm_icb_cmd_wmask,\n    input wire ifu2itcm_icb_cmd_valid,\n    input wire ifu2itcm_icb_rsp_ready,\n    output wire ifu2itcm_icb_cmd_ready,\n    output wire [DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    output wire ifu2itcm_icb_rsp_valid,\n    output wire ifu2itcm_icb_rsp_err,\n    output wire itcm_active,\n    output wire itcm_ram_cs,\n    output wire itcm_ram_we,\n    output wire [RAM_AW-1:0] itcm_ram_addr,\n    output wire [RAM_MW-1:0] itcm_ram_wem,\n    output wire [RAM_DW-1:0] itcm_ram_din,\n    input wire [RAM_DW-1:0] itcm_ram_dout,\n    output wire clk_itcm_ram\n);\n\n    // Internal signals\n    wire [ADDR_WIDTH-1:0] lsu2itcm_icb_cmd_addr;\n    wire lsu2itcm_icb_cmd_read;\n    wire [DATA_WIDTH-1:0] lsu2itcm_icb_cmd_wdata;\n    wire [WMSK_WIDTH-1:0] lsu2itcm_icb_cmd_wmask;\n    wire lsu2itcm_icb_cmd_valid;\n    wire lsu2itcm_icb_rsp_ready;\n    wire lsu2itcm_icb_cmd_ready;\n    wire [DATA_WIDTH-1:0] lsu2itcm_icb_rsp_rdata;\n    wire lsu2itcm_icb_rsp_valid;\n    wire lsu2itcm_icb_rsp_err;\n\n    // External interface signals (if E203_HAS_ITCM_EXTITF is defined)\n    `ifdef E203_HAS_ITCM_EXTITF\n    wire [ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr;\n    wire ext2itcm_icb_cmd_read;\n    wire [DATA_WIDTH-1:0] ext2itcm_icb_cmd_wdata;\n    wire [WMSK_WIDTH-1:0] ext2itcm_icb_cmd_wmask;\n    wire ext2itcm_icb_cmd_valid;\n    wire ext2itcm_icb_rsp_ready;\n    wire ext2itcm_icb_cmd_ready;\n    wire [DATA_WIDTH-1:0] ext2itcm_icb_rsp_rdata;\n    wire ext2itcm_icb_rsp_valid;\n    wire ext2itcm_icb_rsp_err;\n    `endif\n\n    // Arbitration logic\n    // Priority: LSU > IFU > External (if exists)\n    assign itcm_active = ifu2itcm_icb_cmd_valid || lsu2itcm_icb_cmd_valid || `ifdef E203_HAS_ITCM_EXTITF ext2itcm_icb_cmd_valid `endif;\n\n    // Command ready signals\n    assign ifu2itcm_icb_cmd_ready = !lsu2itcm_icb_cmd_valid && (!`ifdef E203_HAS_ITCM_EXTITF ext2itcm_icb_cmd_valid `endif);\n    assign lsu2itcm_icb_cmd_ready = 1'b1; // LSU has the highest priority\n    `ifdef E203_HAS_ITCM_EXTITF\n    assign ext2itcm_icb_cmd_ready = !lsu2itcm_icb_cmd_valid && !ifu2itcm_icb_cmd_valid;\n    `endif\n\n    // Response logic\n    assign ifu2itcm_icb_rsp_valid = ifu2itcm_icb_cmd_valid && ifu2itcm_icb_rsp_ready;\n    assign lsu2itcm_icb_rsp_valid = lsu2itcm_icb_cmd_valid && lsu2itcm_icb_rsp_ready;\n    `ifdef E203_HAS_ITCM_EXTITF\n    assign ext2itcm_icb_rsp_valid = ext2itcm_icb_cmd_valid && ext2itcm_icb_rsp_ready;\n    `endif\n\n    // Error handling\n    assign ifu2itcm_icb_rsp_err = (ifu2itcm_icb_cmd_addr >= ITCM_SIZE);\n    assign lsu2itcm_icb_rsp_err = (lsu2itcm_icb_cmd_addr >= ITCM_SIZE);\n    `ifdef E203_HAS_ITCM_EXTITF\n    assign ext2itcm_icb_rsp_err = (ext2itcm_icb_cmd_addr >= ITCM_SIZE);\n    `endif\n\n    // RAM interface logic\n    assign itcm_ram_cs = itcm_active;\n    assign itcm_ram_we = ifu2itcm_icb_cmd_valid ? ifu2itcm_icb_cmd_read : lsu2itcm_icb_cmd_read;\n    assign itcm_ram_addr = ifu2itcm_icb_cmd_valid ? ifu2itcm_icb_cmd_addr : lsu2itcm_icb_cmd_addr;\n    assign itcm_ram_wem = ifu2itcm_icb_cmd_valid ? ifu2itcm_icb_cmd_wmask : lsu2itcm_icb_cmd_wmask;\n    assign itcm_ram_din = ifu2itcm_icb_cmd_valid ? ifu2itcm_icb_cmd_wdata : lsu2itcm_icb_cmd_wdata;\n\n    // Clock gating control\n    assign clk_itcm_ram = clk & ~tcm_cgstop;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 12, "code": "module e203_exu_excp(\n    output commit_trap,\n    output core_wfi,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input amo_wait,\n    input alu_excp_i_valid,\n    input alu_excp_i_ld,\n    input alu_excp_i_stamo,\n    input alu_excp_i_misalgn,\n    input alu_excp_i_buserr,\n    input alu_excp_i_ecall,\n    input alu_excp_i_ebreak,\n    input alu_excp_i_wfi,\n    input alu_excp_i_ifu_misalgn,\n    input alu_excp_i_ifu_buserr,\n    input alu_excp_i_ifu_ilegl,\n    input [E203_PC_SIZE-1:0] alu_excp_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_excp_i_instr,\n    input alu_excp_i_pc_vld,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input longp_excp_i_insterr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input excpirq_flush_ack,\n    output excpirq_flush_req,\n    output nonalu_excpirq_flush_req_raw,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op1,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op2,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input cmt_dret_ena,\n    input cmt_ena,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_badaddr_ena,\n    output cmt_epc_ena,\n    output cmt_cause_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output excp_active,\n    input clk,\n    input rst_n\n);\n    // Implementation of exception handling logic\n    // This is a placeholder for the actual implementation\n    // which would include state machines, control logic, etc.\n\n    // Example of setting outputs based on exception inputs\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            commit_trap <= 1'b0;\n            core_wfi <= 1'b0;\n            wfi_halt_ifu_req <= 1'b0;\n            wfi_halt_exu_req <= 1'b0;\n            excpirq_flush_req <= 1'b0;\n            nonalu_excpirq_flush_req_raw <= 1'b0;\n            excpirq_flush_add_op1 <= {E203_PC_SIZE{1'b0}};\n            excpirq_flush_add_op2 <= {E203_PC_SIZE{1'b0}};\n            cmt_badaddr <= {E203_ADDR_SIZE{1'b0}};\n            cmt_epc <= {E203_PC_SIZE{1'b0}};\n            cmt_cause <= {E203_XLEN{1'b0}};\n            cmt_badaddr_ena <= 1'b0;\n            cmt_epc_ena <= 1'b0;\n            cmt_cause_ena <= 1'b0;\n            cmt_status_ena <= 1'b0;\n            cmt_dpc <= {E203_PC_SIZE{1'b0}};\n            cmt_dpc_ena <= 1'b0;\n            cmt_dcause <= 3'b000;\n            cmt_dcause_ena <= 1'b0;\n            excp_active <= 1'b0;\n        end else begin\n            // Exception handling logic\n            // Update PC, cause, bad address, etc.\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 18, "code": "module e203_exu_decode (\n    input [E203_INSTR_SIZE-1:0] i_instr,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_prdt_taken,\n    input i_misalgn,\n    input i_buserr,\n    input i_muldiv_b2b,\n    input dbg_mode,\n    output dec_rs1x0,\n    output dec_rs2x0,\n    output dec_rs1en,\n    output dec_rs2en,\n    output dec_rdwen,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rdidx,\n    output [E203_DECINFO_WIDTH-1:0] dec_info,\n    output [E203_XLEN-1:0] dec_imm,\n    output [E203_PC_SIZE-1:0] dec_pc,\n    output dec_misalgn,\n    output dec_buserr,\n    output dec_ilegl,\n    output dec_mulhsu,\n    output dec_mul,\n    output dec_div,\n    output dec_rem,\n    output dec_divu,\n    output dec_remu,\n    output dec_rv32,\n    output dec_bjp,\n    output dec_jal,\n    output dec_jalr,\n    output dec_bxx,\n    output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    output [E203_XLEN-1:0] dec_bjp_imm,\n    output dec_nice,\n    output nice_cmt_off_ilgl_o\n);\n\n    // Internal signal declarations\n    wire [6:0] opcode = i_instr[6:0];\n    wire [2:0] funct3 = i_instr[14:12];\n    wire [6:0] funct7 = i_instr[31:25];\n    wire [4:0] rs1 = i_instr[19:15];\n    wire [4:0] rs2 = i_instr[24:20];\n    wire [4:0] rd = i_instr[11:7];\n    wire [11:0] imm12 = i_instr[31:20];\n    wire [11:0] imm12_I = {{20{i_instr[31]}}, i_instr[31:20]};\n    wire [11:0] imm12_S = {{20{i_instr[31]}}, i_instr[31:25], i_instr[11:7]};\n    wire [12:1] imm13 = {{19{i_instr[31]}}, i_instr[31], i_instr[7], i_instr[30:25], i_instr[11:8], 1'b0};\n    wire [20:1] imm21 = {{11{i_instr[31]}}, i_instr[31], i_instr[19:12], i_instr[20], i_instr[30:21], 1'b0};\n\n    // Decode logic\n    assign dec_rs1x0 = (rs1 == 5'd0);\n    assign dec_rs2x0 = (rs2 == 5'd0);\n    assign dec_rs1en = (opcode == 7'b1100111) || (opcode == 7'b0000011) || (opcode == 7'b0100011);\n    assign dec_rs2en = (opcode == 7'b0100011);\n    assign dec_rdwen = (opcode == 7'b1100111) || (opcode == 7'b0000011);\n    assign dec_rs1idx = rs1;\n    assign dec_rs2idx = rs2;\n    assign dec_rdidx = rd;\n    assign dec_info = {funct7, funct3, opcode};\n    assign dec_imm = (opcode == 7'b1101111) ? imm21 : imm12_I;\n    assign dec_pc = i_pc;\n    assign dec_misalgn = i_misalgn;\n    assign dec_buserr = i_buserr;\n    assign dec_ilegl = (opcode == 7'b0000000) || (opcode == 7'b1111111);\n    assign dec_mulhsu = (funct7 == 7'b0000001) && (funct3 == 3'b010);\n    assign dec_mul = (funct7 == 7'b0000001) && (funct3 == 3'b000);\n    assign dec_div = (funct7 == 7'b0000001) && (funct3 == 3'b100);\n    assign dec_rem = (funct7 == 7'b0000001) && (funct3 == 3'b110);\n    assign dec_divu = (funct7 == 7'b0000001) && (funct3 == 3'b101);\n    assign dec_remu = (funct7 == 7'b0000001) && (funct3 == 3'b111);\n    assign dec_rv32 = (opcode != 7'b0000000) && (opcode != 7'b1111111);\n    assign dec_bjp = (opcode == 7'b1101111) || (opcode == 7'b1100111);\n    assign dec_jal = (opcode == 7'b1101111);\n    assign dec_jalr = (opcode == 7'b1100111);\n    assign dec_bxx = (opcode == 7'b1100011);\n    assign dec_jalr_rs1idx = rs1;\n    assign dec_bjp_imm = imm13;\n    assign dec_nice = `E203_HAS_NICE && (opcode == 7'b0001011);\n    assign nice_cmt_off_ilgl_o = `E203_HAS_NICE && nice_xs_off && (opcode == 7'b0001011);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 17, "code": "module e203_exu_regfile #(\n  parameter E203_RFIDX_WIDTH = 5, // Width of the register index\n  parameter E203_XLEN = 32        // Width of the register data\n)(\n  input  wire                     clk,\n  input  wire                     rst_n,\n  input  wire [E203_RFIDX_WIDTH-1:0] read_src1_idx,\n  input  wire [E203_RFIDX_WIDTH-1:0] read_src2_idx,\n  output wire [E203_XLEN-1:0]     read_src1_dat,\n  output wire [E203_XLEN-1:0]     read_src2_dat,\n  input  wire                     wbck_dest_wen,\n  input  wire [E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n  input  wire [E203_XLEN-1:0]     wbck_dest_dat,\n  output wire [E203_XLEN-1:0]     x1_r,\n  input  wire                     test_mode\n);\n\n`ifdef E203_CFG_REGNUM_IS_32\n  localparam REG_NUM = 32;\n`elsif E203_CFG_REGNUM_IS_16\n  localparam REG_NUM = 16;\n`else\n  localparam REG_NUM = 32; // Default to 32 if not specified\n`endif\n\nreg [E203_XLEN-1:0] regfile [REG_NUM-1:0];\n\n// Read logic\nassign read_src1_dat = (read_src1_idx == 0) ? 0 : regfile[read_src1_idx];\nassign read_src2_dat = (read_src2_idx == 0) ? 0 : regfile[read_src2_idx];\n\n// Write logic\nalways @(posedge clk) begin\n  if (wbck_dest_wen && wbck_dest_idx != 0) begin\n    regfile[wbck_dest_idx] <= wbck_dest_dat;\n  end\nend\n\n// Special register x1 output\nassign x1_r = regfile[1];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 17, "code": "module e203_itcm_ram #(\n  parameter FORCE_X2ZERO = 0,\n  parameter DP = `E203_ITCM_RAM_DP,\n  parameter DW = `E203_ITCM_RAM_DW,\n  parameter MW = `E203_ITCM_RAM_MW,\n  parameter AW = `E203_ITCM_RAM_AW\n)(\n  input wire sd,\n  input wire ds,\n  input wire ls,\n  input wire cs,\n  input wire we,\n  input wire [AW-1:0] addr,\n  input wire [MW-1:0] wem,\n  input wire [DW-1:0] din,\n  input wire rst_n,\n  input wire clk,\n  output wire [DW-1:0] dout\n);\n\n  sirv_gnrl_ram #(\n    .FORCE_X2ZERO(FORCE_X2ZERO),\n    .DP(DP),\n    .DW(DW),\n    .MW(MW),\n    .AW(AW)\n  ) u_sirv_gnrl_ram (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 18, "code": "module e203_itcm_ram #(\n  parameter FORCE_X2ZERO = 0,\n  parameter DP = `E203_ITCM_RAM_DP,\n  parameter DW = `E203_ITCM_RAM_DW,\n  parameter MW = `E203_ITCM_RAM_MW,\n  parameter AW = `E203_ITCM_RAM_AW\n)(\n  input wire sd,\n  input wire ds,\n  input wire ls,\n  input wire cs,\n  input wire we,\n  input wire [AW-1:0] addr,\n  input wire [MW-1:0] wem,\n  input wire [DW-1:0] din,\n  input wire rst_n,\n  input wire clk,\n  output wire [DW-1:0] dout\n);\n\n  // Instantiate the generic RAM module\n  sirv_gnrl_ram #(\n    .FORCE_X2ZERO(FORCE_X2ZERO),\n    .DP(DP),\n    .DW(DW),\n    .MW(MW),\n    .AW(AW)\n  ) u_sirv_gnrl_ram (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 18, "code": "module e203_exu_regfile (\n    input [E203_RFIDX_WIDTH-1:0] read_src1_idx,\n    input [E203_RFIDX_WIDTH-1:0] read_src2_idx,\n    output [E203_XLEN-1:0] read_src1_dat,\n    output [E203_XLEN-1:0] read_src2_dat,\n    input wbck_dest_wen,\n    input [E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n    input [E203_XLEN-1:0] wbck_dest_dat,\n    output [E203_XLEN-1:0] x1_r,\n    input test_mode,\n    input clk,\n    input rst_n\n);\n\n// Register file storage\nreg [E203_XLEN-1:0] regfile [0:E203_RFREG_NUM-1];\n\n// Read logic\nassign read_src1_dat = (read_src1_idx == 0) ? 0 : regfile[read_src1_idx];\nassign read_src2_dat = (read_src2_idx == 0) ? 0 : regfile[read_src2_idx];\n\n// Write logic\nalways @(posedge clk) begin\n    if (wbck_dest_wen && wbck_dest_idx != 0) begin\n        regfile[wbck_dest_idx] <= wbck_dest_dat;\n    end\nend\n\n// Output for register x1\nassign x1_r = regfile[1];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 16, "code": "module e203_irq_sync (\n    input wire clk,\n    input wire rst_n,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire dbg_irq_a,\n    output wire ext_irq_r,\n    output wire sft_irq_r,\n    output wire tmr_irq_r,\n    output wire dbg_irq_r\n);\n\n    // Synchronization instances for each interrupt type\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) u_ext_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(ext_irq_a),\n        .dout(ext_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) u_sft_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(sft_irq_a),\n        .dout(sft_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) u_tmr_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(tmr_irq_a),\n        .dout(tmr_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) u_dbg_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(dbg_irq_a),\n        .dout(dbg_irq_r)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 17, "code": "module e203_irq_sync (\n    input wire clk,\n    input wire rst_n,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire dbg_irq_a,\n    output wire ext_irq_r,\n    output wire sft_irq_r,\n    output wire tmr_irq_r,\n    output wire dbg_irq_r\n);\n\n    // Synchronization instances for each interrupt type\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) ext_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(ext_irq_a),\n        .dout(ext_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) sft_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(sft_irq_a),\n        .dout(sft_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) tmr_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(tmr_irq_a),\n        .dout(tmr_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) dbg_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(dbg_irq_a),\n        .dout(dbg_irq_r)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 18, "code": "module e203_irq_sync (\n    input wire clk,\n    input wire rst_n,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire dbg_irq_a,\n    output wire ext_irq_r,\n    output wire sft_irq_r,\n    output wire tmr_irq_r,\n    output wire dbg_irq_r\n);\n\n    // Synchronization for external interrupt\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) u_ext_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(ext_irq_a),\n        .dout(ext_irq_r)\n    );\n\n    // Synchronization for software interrupt\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) u_sft_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(sft_irq_a),\n        .dout(sft_irq_r)\n    );\n\n    // Synchronization for timer interrupt\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) u_tmr_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(tmr_irq_a),\n        .dout(tmr_irq_r)\n    );\n\n    // Synchronization for debug interrupt\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) u_dbg_irq_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(dbg_irq_a),\n        .dout(dbg_irq_r)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 19, "code": "module e203_itcm_ram #(\n  parameter FORCE_X2ZERO = 0,\n  parameter DP = `E203_ITCM_RAM_DP,\n  parameter DW = `E203_ITCM_RAM_DW,\n  parameter MW = `E203_ITCM_RAM_MW,\n  parameter AW = `E203_ITCM_RAM_AW\n)(\n  input wire sd,\n  input wire ds,\n  input wire ls,\n  input wire cs,\n  input wire we,\n  input wire [AW-1:0] addr,\n  input wire [MW-1:0] wem,\n  input wire [DW-1:0] din,\n  input wire rst_n,\n  input wire clk,\n  output wire [DW-1:0] dout\n);\n\n  sirv_gnrl_ram #(\n    .FORCE_X2ZERO(FORCE_X2ZERO),\n    .DP(DP),\n    .DW(DW),\n    .MW(MW),\n    .AW(AW)\n  ) ram_inst (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 13, "code": "module e203_lsu(\n    input wire commit_mret,\n    input wire commit_trap,\n    input wire excp_active,\n    output wire lsu_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n    output wire [ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_buserr,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [XLEN-1:0] agu_icb_rsp_rdata\n);\n\n    // LSU logic implementation here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 19, "code": "module e203_irq_sync (\n    input wire clk,\n    input wire rst_n,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire dbg_irq_a,\n    output wire ext_irq_r,\n    output wire sft_irq_r,\n    output wire tmr_irq_r,\n    output wire dbg_irq_r\n);\n\n// Synchronization instances for each interrupt type\nsirv_gnrl_sync #(\n    .DP(2),\n    .DW(1)\n) u_ext_sync (\n    .clk(clk),\n    .rst_n(rst_n),\n    .din_a(ext_irq_a),\n    .dout(ext_irq_r)\n);\n\nsirv_gnrl_sync #(\n    .DP(2),\n    .DW(1)\n) u_sft_sync (\n    .clk(clk),\n    .rst_n(rst_n),\n    .din_a(sft_irq_a),\n    .dout(sft_irq_r)\n);\n\nsirv_gnrl_sync #(\n    .DP(2),\n    .DW(1)\n) u_tmr_sync (\n    .clk(clk),\n    .rst_n(rst_n),\n    .din_a(tmr_irq_a),\n    .dout(tmr_irq_r)\n);\n\nsirv_gnrl_sync #(\n    .DP(2),\n    .DW(1)\n) u_dbg_sync (\n    .clk(clk),\n    .rst_n(rst_n),\n    .din_a(dbg_irq_a),\n    .dout(dbg_irq_r)\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 13, "code": "module e203_exu_excp(\n    output commit_trap,\n    output core_wfi,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input amo_wait,\n    input alu_excp_i_valid,\n    input alu_excp_i_ld,\n    input alu_excp_i_stamo,\n    input alu_excp_i_misalgn,\n    input alu_excp_i_buserr,\n    input alu_excp_i_ecall,\n    input alu_excp_i_ebreak,\n    input alu_excp_i_wfi,\n    input alu_excp_i_ifu_misalgn,\n    input alu_excp_i_ifu_buserr,\n    input alu_excp_i_ifu_ilegl,\n    input [E203_PC_SIZE-1:0] alu_excp_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_excp_i_instr,\n    input alu_excp_i_pc_vld,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input longp_excp_i_insterr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input excpirq_flush_ack,\n    output excpirq_flush_req,\n    output nonalu_excpirq_flush_req_raw,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op1,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op2,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input cmt_dret_ena,\n    input cmt_ena,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_badaddr_ena,\n    output cmt_epc_ena,\n    output cmt_cause_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output excp_active,\n    input clk,\n    input rst_n\n);\n    // Implementation of exception handling logic\n    // This is a placeholder for the actual logic\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 19, "code": "module e203_exu_regfile (\n    input [E203_RFIDX_WIDTH-1:0] read_src1_idx,\n    input [E203_RFIDX_WIDTH-1:0] read_src2_idx,\n    output [E203_XLEN-1:0] read_src1_dat,\n    output [E203_XLEN-1:0] read_src2_dat,\n    input wbck_dest_wen,\n    input [E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n    input [E203_XLEN-1:0] wbck_dest_dat,\n    output [E203_XLEN-1:0] x1_r,\n    input test_mode,\n    input clk,\n    input rst_n\n);\n\n// Register file storage\nreg [E203_XLEN-1:0] regfile [0:E203_RFREG_NUM-1];\n\n// Read logic\nassign read_src1_dat = (read_src1_idx == 0) ? 0 : regfile[read_src1_idx];\nassign read_src2_dat = (read_src2_idx == 0) ? 0 : regfile[read_src2_idx];\n\n// Write logic\nalways @(posedge clk) begin\n    if (wbck_dest_wen && wbck_dest_idx != 0) begin\n        regfile[wbck_dest_idx] <= wbck_dest_dat;\n    end\nend\n\n// Output for register x1\nassign x1_r = regfile[1];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 5, "code": "module e203_ifu_ifetch(\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_valid,\n    input wire ifu_req_ready,\n    output wire [E203_PC_SIZE-1:0] ifu_req_pc,\n    output wire ifu_req_seq,\n    output wire ifu_req_seq_rv32,\n    output wire [E203_PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_valid,\n    output wire ifu_rsp_ready,\n    input wire ifu_rsp_err,\n    input wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr,\n    input wire pipe_flush_req,\n    output wire pipe_flush_ack,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    output wire [E203_PC_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    input wire ifu_halt_req,\n    output wire ifu_halt_ack,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu\n);\n    // Implementation of the e203_ifu_ifetch module\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 6, "code": "module e203_ifu_ifetch(\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_valid,\n    input wire ifu_req_ready,\n    output wire [E203_PC_SIZE-1:0] ifu_req_pc,\n    output wire ifu_req_seq,\n    output wire ifu_req_seq_rv32,\n    output wire [E203_PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_valid,\n    output wire ifu_rsp_ready,\n    input wire ifu_rsp_err,\n    input wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr,\n    input wire pipe_flush_req,\n    output wire pipe_flush_ack,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    output wire [E203_PC_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    input wire ifu_halt_req,\n    output wire ifu_halt_ack,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu\n);\n    // Implementation of the instruction fetch logic, pipeline control, and interfaces\n    // This is a placeholder for the actual implementation which would include:\n    // - PC calculation and update logic\n    // - Fetch request and response handling\n    // - Pipeline flush and halt control logic\n    // - Error handling and branch prediction integration\n\n    // Note: The actual implementation details depend on the specific architecture and requirements\n    // of the E203 processor and are beyond the scope of this simple module template.\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 14, "code": "module e203_lsu_ctrl (\n    input wire commit_mret,\n    input wire commit_trap,\n    output wire lsu_ctrl_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] agu_icb_rsp_rdata\n);\n\n    // LSU control logic implementation here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 20, "code": "module e203_exu_regfile #(\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_XLEN = 32\n)(\n  input [E203_RFIDX_WIDTH-1:0] read_src1_idx,\n  input [E203_RFIDX_WIDTH-1:0] read_src2_idx,\n  output [E203_XLEN-1:0] read_src1_dat,\n  output [E203_XLEN-1:0] read_src2_dat,\n  input wbck_dest_wen,\n  input [E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n  input [E203_XLEN-1:0] wbck_dest_dat,\n  output [E203_XLEN-1:0] x1_r,\n  input test_mode,\n  input clk,\n  input rst_n\n);\n\n  // Register file storage\n  reg [E203_XLEN-1:0] regfile [0:(1<<E203_RFIDX_WIDTH)-1];\n\n  // Read logic\n  assign read_src1_dat = (read_src1_idx == 0) ? 0 : regfile[read_src1_idx];\n  assign read_src2_dat = (read_src2_idx == 0) ? 0 : regfile[read_src2_idx];\n\n  // Write logic\n  always @(posedge clk) begin\n    if (wbck_dest_wen && wbck_dest_idx != 0) begin\n      regfile[wbck_dest_idx] <= wbck_dest_dat;\n    end\n  end\n\n  // Special register x1 output\n  assign x1_r = regfile[1];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 15, "code": "module e203_lsu(\n    input wire commit_mret,\n    input wire commit_trap,\n    input wire excp_active,\n    output wire lsu_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n    output wire [ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_buserr,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [XLEN/8-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [XLEN-1:0] agu_icb_rsp_rdata,\n\n    input wire nice_mem_holdup,\n    input wire itcm_region_indic,\n    input wire dtcm_region_indic\n);\n    // LSU logic implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 20, "code": "module e203_itcm_ram #(\n  parameter FORCE_X2ZERO = 0,\n  parameter DP = `E203_ITCM_RAM_DP,\n  parameter DW = `E203_ITCM_RAM_DW,\n  parameter MW = `E203_ITCM_RAM_MW,\n  parameter AW = `E203_ITCM_RAM_AW\n)(\n  input wire sd,\n  input wire ds,\n  input wire ls,\n  input wire cs,\n  input wire we,\n  input wire [AW-1:0] addr,\n  input wire [MW-1:0] wem,\n  input wire [DW-1:0] din,\n  input wire rst_n,\n  input wire clk,\n  output wire [DW-1:0] dout\n);\n\n  sirv_gnrl_ram #(\n    .FORCE_X2ZERO(FORCE_X2ZERO),\n    .DP(DP),\n    .DW(DW),\n    .MW(MW),\n    .AW(AW)\n  ) u_sirv_gnrl_ram (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 19, "code": "module e203_reset_ctrl #(\n    parameter MASTER = 1,\n    parameter RST_SYNC_LEVEL = `E203_ASYNC_FF_LEVELS\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    output reg rst_core,\n    output reg rst_itcm,\n    output reg rst_dtcm,\n    output reg rst_aon\n);\n\n// Internal registers for reset synchronization\nreg [RST_SYNC_LEVEL-1:0] rst_sync_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        rst_sync_reg <= {RST_SYNC_LEVEL{1'b1}};\n    end else begin\n        rst_sync_reg <= {rst_sync_reg[RST_SYNC_LEVEL-2:0], 1'b0};\n    end\nend\n\n// Generate reset outputs based on mode and test_mode\nalways @(*) begin\n    if (test_mode) begin\n        // In test mode, directly use the asynchronous reset\n        rst_core = rst_n;\n        rst_itcm = rst_n;\n        rst_dtcm = rst_n;\n        rst_aon = rst_n;\n    end else if (MASTER == 1) begin\n        // Master mode uses synchronized reset\n        rst_core = rst_sync_reg[RST_SYNC_LEVEL-1];\n        rst_itcm = rst_sync_reg[RST_SYNC_LEVEL-1];\n        rst_dtcm = rst_sync_reg[RST_SYNC_LEVEL-1];\n        rst_aon = rst_sync_reg[RST_SYNC_LEVEL-1];\n    end else begin\n        // Slave mode directly passes the reset signal\n        rst_core = rst_n;\n        rst_itcm = rst_n;\n        rst_dtcm = rst_n;\n        rst_aon = rst_n;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 7, "code": "module e203_ifu_ifetch(\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_valid,\n    input wire ifu_req_ready,\n    output wire [E203_PC_SIZE-1:0] ifu_req_pc,\n    output wire ifu_req_seq,\n    output wire ifu_req_seq_rv32,\n    output wire [E203_PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_valid,\n    output wire ifu_rsp_ready,\n    input wire ifu_rsp_err,\n    input wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr,\n    input wire pipe_flush_req,\n    output wire pipe_flush_ack,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    `ifdef E203_TIMING_BOOST\n    input wire [E203_PC_SIZE-1:0] pipe_flush_pc,\n    `endif\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    input wire ifu_halt_req,\n    output wire ifu_halt_ack,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu\n);\n    // Implementation of the e203_ifu_ifetch module\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 8, "code": "module e203_ifu_ifetch(\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_valid,\n    input wire ifu_req_ready,\n    output wire [E203_PC_SIZE-1:0] ifu_req_pc,\n    output wire ifu_req_seq,\n    output wire ifu_req_seq_rv32,\n    output wire [E203_PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_valid,\n    output wire ifu_rsp_ready,\n    input wire ifu_rsp_err,\n    input wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr,\n    input wire pipe_flush_req,\n    output wire pipe_flush_ack,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    `ifdef E203_TIMING_BOOST\n    input wire [E203_PC_SIZE-1:0] pipe_flush_pc,\n    `endif\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    input wire ifu_halt_req,\n    output wire ifu_halt_ack,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu\n);\n    // Implementation of the e203_ifu_ifetch module\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 9, "code": "module e203_ifu_ifetch(\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_valid,\n    input wire ifu_req_ready,\n    output wire [E203_PC_SIZE-1:0] ifu_req_pc,\n    output wire ifu_req_seq,\n    output wire ifu_req_seq_rv32,\n    output wire [E203_PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_valid,\n    output wire ifu_rsp_ready,\n    input wire ifu_rsp_err,\n    input wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr,\n    input wire pipe_flush_req,\n    output wire pipe_flush_ack,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    `ifdef E203_TIMING_BOOST\n    input wire [E203_PC_SIZE-1:0] pipe_flush_pc,\n    `endif\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    input wire ifu_halt_req,\n    output wire ifu_halt_ack,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu\n);\n    // Implementation of the e203_ifu_ifetch module\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 10, "code": "module e203_ifu_ifetch(\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_valid,\n    input wire ifu_req_ready,\n    output wire [E203_PC_SIZE-1:0] ifu_req_pc,\n    output wire ifu_req_seq,\n    output wire ifu_req_seq_rv32,\n    output wire [E203_PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_valid,\n    output wire ifu_rsp_ready,\n    input wire ifu_rsp_err,\n    input wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr,\n    input wire pipe_flush_req,\n    output wire pipe_flush_ack,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    `ifdef E203_TIMING_BOOST\n    input wire [E203_PC_SIZE-1:0] pipe_flush_pc,\n    `endif\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    input wire ifu_halt_req,\n    output wire ifu_halt_ack,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu\n);\n    // Internal signals and logic implementation here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 20, "code": "module e203_irq_sync (\n    input wire clk,\n    input wire rst_n,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire dbg_irq_a,\n    output wire ext_irq_r,\n    output wire sft_irq_r,\n    output wire tmr_irq_r,\n    output wire dbg_irq_r\n);\n\n    // Synchronization using sirv_gnrl_sync module\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) ext_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(ext_irq_a),\n        .dout(ext_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) sft_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(sft_irq_a),\n        .dout(sft_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) tmr_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(tmr_irq_a),\n        .dout(tmr_irq_r)\n    );\n\n    sirv_gnrl_sync #(\n        .DP(2),\n        .DW(1)\n    ) dbg_sync (\n        .clk(clk),\n        .rst_n(rst_n),\n        .din_a(dbg_irq_a),\n        .dout(dbg_irq_r)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 11, "code": "module e203_ifu_ifetch(\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_valid,\n    input wire ifu_req_ready,\n    output wire [E203_PC_SIZE-1:0] ifu_req_pc,\n    output wire ifu_req_seq,\n    output wire ifu_req_seq_rv32,\n    output wire [E203_PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_valid,\n    output wire ifu_rsp_ready,\n    input wire ifu_rsp_err,\n    input wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr,\n    input wire pipe_flush_req,\n    output wire pipe_flush_ack,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    `ifdef E203_TIMING_BOOST\n    input wire [E203_PC_SIZE-1:0] pipe_flush_pc,\n    `endif\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    input wire ifu_halt_req,\n    output wire ifu_halt_ack,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu\n);\n\n    // Internal signal declarations\n    wire reset_flag_r;\n    wire reset_req_r;\n    wire halt_ack_r;\n    wire dly_flush_r;\n    wire ir_valid_r;\n    wire ir_pc_vld_r;\n    wire ifu_err_r;\n    wire ifu_prdt_taken_r;\n    wire [E203_INSTR_SIZE-1:0] ifu_ir_r;\n    wire [E203_RFIDX_WIDTH-1:0] ir_rs1idx_r;\n    wire [E203_RFIDX_WIDTH-1:0] ir_rs2idx_r;\n    wire [E203_PC_SIZE-1:0] ifu_pc_r;\n    wire [E203_PC_SIZE-1:0] pc_r;\n    wire out_flag_r;\n    wire pc_newpend_r;\n\n    // Implementation of the module's functionality\n    // This is a placeholder for the actual implementation\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 10, "code": "module itcm_controller (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n    input wire ifu2itcm_icb_cmd_valid,\n    input wire [ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] ifu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] ifu2itcm_icb_cmd_wmask,\n    input wire ifu2itcm_icb_rsp_ready,\n    output wire ifu2itcm_icb_cmd_ready,\n    output wire ifu2itcm_icb_rsp_valid,\n    output wire ifu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    output wire itcm_active,\n    output wire itcm_ram_cs,\n    output wire itcm_ram_we,\n    output wire [RAM_AW-1:0] itcm_ram_addr,\n    output wire [RAM_MW-1:0] itcm_ram_wem,\n    output wire [RAM_DW-1:0] itcm_ram_din,\n    input wire [RAM_DW-1:0] itcm_ram_dout,\n    output wire clk_itcm_ram\n);\n\n// Internal signals\nwire [ADDR_WIDTH-1:0] addr;\nwire [DATA_WIDTH-1:0] wdata;\nwire [WMSK_WIDTH-1:0] wmask;\nwire cmd_valid, cmd_read, cmd_ready;\nwire rsp_valid, rsp_ready, rsp_err;\nwire [DATA_WIDTH-1:0] rsp_rdata;\n\n// Assignments\nassign itcm_active = cmd_valid || rsp_valid;\n\n// ICB Command Interface Handling\nassign cmd_valid = ifu2itcm_icb_cmd_valid;\nassign addr = ifu2itcm_icb_cmd_addr;\nassign cmd_read = ifu2itcm_icb_cmd_read;\nassign wdata = ifu2itcm_icb_cmd_wdata;\nassign wmask = ifu2itcm_icb_cmd_wmask;\nassign ifu2itcm_icb_cmd_ready = cmd_ready;\n\n// ICB Response Interface Handling\nassign rsp_ready = ifu2itcm_icb_rsp_ready;\nassign ifu2itcm_icb_rsp_valid = rsp_valid;\nassign ifu2itcm_icb_rsp_err = rsp_err;\nassign ifu2itcm_icb_rsp_rdata = rsp_rdata;\n\n// RAM Interface\nassign itcm_ram_cs = cmd_valid && cmd_ready;\nassign itcm_ram_we = !cmd_read;\nassign itcm_ram_addr = addr[RAM_AW-1:0];\nassign itcm_ram_wem = wmask;\nassign itcm_ram_din = wdata;\nassign rsp_rdata = itcm_ram_dout;\n\n// Clock Gating Control\nassign clk_itcm_ram = clk & ~tcm_cgstop;\n\n// Reset and Clock Handling\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        // Reset logic\n        cmd_ready <= 1'b0;\n        rsp_valid <= 1'b0;\n        rsp_err <= 1'b0;\n    end else begin\n        // Command ready logic\n        cmd_ready <= !cmd_valid || rsp_ready;\n\n        // Response handling\n        rsp_valid <= cmd_valid && cmd_ready && cmd_read;\n        rsp_err <= (addr >= RAM_SIZE); // Example error condition\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 12, "code": "module e203_ifu_ifetch(\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_valid,\n    input wire ifu_req_ready,\n    output wire [E203_PC_SIZE-1:0] ifu_req_pc,\n    output wire ifu_req_seq,\n    output wire ifu_req_seq_rv32,\n    output wire [E203_PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_valid,\n    output wire ifu_rsp_ready,\n    input wire ifu_rsp_err,\n    input wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr,\n    input wire pipe_flush_req,\n    output wire pipe_flush_ack,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    `ifdef E203_TIMING_BOOST\n    input wire [E203_PC_SIZE-1:0] pipe_flush_pc,\n    `endif\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    input wire ifu_halt_req,\n    output wire ifu_halt_ack,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu\n);\n    // Implementation of the e203_ifu_ifetch module logic goes here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 19, "code": "module e203_exu_decode (\n    input [E203_INSTR_SIZE-1:0] i_instr,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_prdt_taken,\n    input i_misalgn,\n    input i_buserr,\n    input i_muldiv_b2b,\n    input dbg_mode,\n    output dec_rs1x0,\n    output dec_rs2x0,\n    output dec_rs1en,\n    output dec_rs2en,\n    output dec_rdwen,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rdidx,\n    output [E203_DECINFO_WIDTH-1:0] dec_info,\n    output [E203_XLEN-1:0] dec_imm,\n    output [E203_PC_SIZE-1:0] dec_pc,\n    output dec_misalgn,\n    output dec_buserr,\n    output dec_ilegl,\n    output dec_mulhsu,\n    output dec_mul,\n    output dec_div,\n    output dec_rem,\n    output dec_divu,\n    output dec_remu,\n    output dec_rv32,\n    output dec_bjp,\n    output dec_jal,\n    output dec_jalr,\n    output dec_bxx,\n    output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    output [E203_XLEN-1:0] dec_bjp_imm,\n    output dec_nice,\n    output nice_cmt_off_ilgl_o\n);\n\n// Decode logic implementation here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 13, "code": "module e203_ifu_ifetch(\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_valid,\n    input wire ifu_req_ready,\n    output wire [E203_PC_SIZE-1:0] ifu_req_pc,\n    output wire ifu_req_seq,\n    output wire ifu_req_seq_rv32,\n    output wire [E203_PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_valid,\n    output wire ifu_rsp_ready,\n    input wire ifu_rsp_err,\n    input wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr,\n    input wire pipe_flush_req,\n    output wire pipe_flush_ack,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    `ifdef E203_TIMING_BOOST\n    input wire [E203_PC_SIZE-1:0] pipe_flush_pc,\n    `endif\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    input wire ifu_halt_req,\n    output wire ifu_halt_ack,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu\n);\n\n    // Internal signal declarations\n    wire reset_flag_r;\n    wire reset_req_r;\n    wire halt_ack_r;\n    wire dly_flush_r;\n    wire ir_valid_r;\n    wire ir_pc_vld_r;\n    wire ifu_err_r;\n    wire ifu_prdt_taken_r;\n    wire ir_muldiv_b2b_r;\n    wire [E203_INSTR_SIZE-1:0] ifu_ir_r;\n    wire [E203_RFIDX_WIDTH-1:0] ir_rs1idx_r;\n    wire [E203_RFIDX_WIDTH-1:0] ir_rs2idx_r;\n    wire [E203_PC_SIZE-1:0] ifu_pc_r;\n    wire [E203_PC_SIZE-1:0] pc_r;\n    wire out_flag_r;\n    wire pc_newpend_r;\n\n    // Implementation of the module's functionality\n    // (This is a placeholder for the actual implementation)\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 14, "code": "module e203_ifu_ifetch(\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_valid,\n    input wire ifu_req_ready,\n    output wire [E203_PC_SIZE-1:0] ifu_req_pc,\n    output wire ifu_req_seq,\n    output wire ifu_req_seq_rv32,\n    output wire [E203_PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_valid,\n    output wire ifu_rsp_ready,\n    input wire ifu_rsp_err,\n    input wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr,\n    input wire pipe_flush_req,\n    output wire pipe_flush_ack,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    input wire ifu_halt_req,\n    output wire ifu_halt_ack,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu\n);\n    // Implementation of the instruction fetch logic, pipeline control, and interfaces\n    // This is a placeholder for the actual logic which would be based on the specifications and architecture.\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 14, "code": "module e203_exu_excp(\n    output commit_trap,\n    output core_wfi,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input amo_wait,\n    input alu_excp_i_valid,\n    input alu_excp_i_ld,\n    input alu_excp_i_stamo,\n    input alu_excp_i_misalgn,\n    input alu_excp_i_buserr,\n    input alu_excp_i_ecall,\n    input alu_excp_i_ebreak,\n    input alu_excp_i_wfi,\n    input alu_excp_i_ifu_misalgn,\n    input alu_excp_i_ifu_buserr,\n    input alu_excp_i_ifu_ilegl,\n    input [E203_PC_SIZE-1:0] alu_excp_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_excp_i_instr,\n    input alu_excp_i_pc_vld,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input longp_excp_i_insterr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input excpirq_flush_ack,\n    output excpirq_flush_req,\n    output nonalu_excpirq_flush_req_raw,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op1,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op2,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input cmt_dret_ena,\n    input cmt_ena,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_badaddr_ena,\n    output cmt_epc_ena,\n    output cmt_cause_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output excp_active,\n    input clk,\n    input rst_n\n);\n    // Implementation of exception handling logic\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 16, "code": "module e203_lsu_ctrl(\n    input wire commit_mret,\n    input wire commit_trap,\n    output wire lsu_ctrl_active,\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] agu_icb_rsp_rdata\n);\n    // LSU control logic implementation here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 17, "code": "module e203_lsu_ctrl(\n    input wire commit_mret,\n    input wire commit_trap,\n    input wire excp_active,\n    output wire lsu_active,\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n    output wire [ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_buserr,\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [XLEN-1:0] agu_icb_rsp_rdata\n);\n    // LSU control logic implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 15, "code": "module e203_exu_excp(\n    output commit_trap,\n    output core_wfi,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input amo_wait,\n    input alu_excp_i_valid,\n    input alu_excp_i_ld,\n    input alu_excp_i_stamo,\n    input alu_excp_i_misalgn,\n    input alu_excp_i_buserr,\n    input alu_excp_i_ecall,\n    input alu_excp_i_ebreak,\n    input alu_excp_i_wfi,\n    input alu_excp_i_ifu_misalgn,\n    input alu_excp_i_ifu_buserr,\n    input alu_excp_i_ifu_ilegl,\n    input [E203_PC_SIZE-1:0] alu_excp_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_excp_i_instr,\n    input alu_excp_i_pc_vld,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input longp_excp_i_insterr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input excpirq_flush_ack,\n    output excpirq_flush_req,\n    output nonalu_excpirq_flush_req_raw,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op1,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op2,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input cmt_dret_ena,\n    input cmt_ena,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_badaddr_ena,\n    output cmt_epc_ena,\n    output cmt_cause_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output excp_active,\n    input clk,\n    input rst_n\n);\n\n// Implementation of exception handling logic\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 18, "code": "module e203_lsu_ctrl(\n    input wire commit_mret,\n    input wire commit_trap,\n    input wire excp_active,\n    output wire lsu_active,\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n    output wire [ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_buserr,\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [XLEN-1:0] agu_icb_rsp_rdata\n);\n    // Implementation of LSU control logic\n\n    // Example of internal signal declarations\n    reg [ADDR_SIZE-1:0] addr_reg;\n    reg [XLEN-1:0] data_reg;\n    reg error_flag;\n    reg valid_flag;\n\n    // Example of combinational logic for address and data handling\n    always @(*) begin\n        if (agu_icb_cmd_valid && agu_icb_cmd_ready) begin\n            addr_reg = agu_icb_cmd_addr;\n            data_reg = agu_icb_cmd_wdata;\n            valid_flag = 1'b1;\n        end else begin\n            valid_flag = 1'b0;\n        end\n    end\n\n    // Example of sequential logic for error handling\n    always @(posedge clk) begin\n        if (reset) begin\n            error_flag <= 1'b0;\n        end else if (agu_icb_cmd_valid && !agu_icb_cmd_ready) begin\n            error_flag <= 1'b1;\n        end else begin\n            error_flag <= 1'b0;\n        end\n    end\n\n    // Output assignments\n    assign lsu_o_valid = valid_flag;\n    assign lsu_o_wbck_wdat = data_reg;\n    assign lsu_o_wbck_itag = agu_icb_cmd_itag;\n    assign lsu_o_wbck_err = error_flag;\n    assign lsu_o_cmt_ld = agu_icb_cmd_read;\n    assign lsu_o_cmt_st = !agu_icb_cmd_read;\n    assign lsu_o_cmt_badaddr = addr_reg;\n    assign lsu_o_cmt_buserr = error_flag;\n\n    // AGU ICB response interface logic\n    assign agu_icb_rsp_valid = valid_flag;\n    assign agu_icb_rsp_err = error_flag;\n    assign agu_icb_rsp_excl_ok = agu_icb_cmd_excl && !error_flag;\n    assign agu_icb_rsp_rdata = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 19, "code": "module e203_lsu(\n    input wire commit_mret,\n    input wire commit_trap,\n    input wire excp_active,\n    output wire lsu_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n    output wire [ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_buserr,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [XLEN-1:0] agu_icb_rsp_rdata,\n\n    input wire nice_mem_holdup,\n    input wire itcm_region_indic,\n    input wire dtcm_region_indic\n);\n    // LSU logic implementation here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 20, "code": "module e203_reset_ctrl #(\n    parameter MASTER = 1,\n    parameter RST_SYNC_LEVEL = `E203_ASYNC_FF_LEVELS\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    output reg rst_core,\n    output reg rst_itcm,\n    output reg rst_dtcm,\n    output reg rst_aon\n);\n\n// Synchronous reset registers\nreg [RST_SYNC_LEVEL-1:0] sync_rst_reg;\n\n// Asynchronous reset signal\nwire async_rst = rst_n;\n\n// Generate synchronized reset signal\ninteger i;\nalways @(posedge clk or negedge async_rst) begin\n    if (!async_rst) begin\n        sync_rst_reg <= {RST_SYNC_LEVEL{1'b1}};\n    end else begin\n        sync_rst_reg[0] <= 1'b0;\n        for (i = 1; i < RST_SYNC_LEVEL; i = i + 1) begin\n            sync_rst_reg[i] <= sync_rst_reg[i-1];\n        end\n    end\nend\n\n// Select reset signal based on mode\nwire sync_rst = sync_rst_reg[RST_SYNC_LEVEL-1];\nwire rst_signal = test_mode ? async_rst : sync_rst;\n\n// Distribute reset signals\nalways @(posedge clk or negedge rst_signal) begin\n    if (!rst_signal) begin\n        rst_core <= 1'b1;\n        rst_itcm <= 1'b1;\n        rst_dtcm <= 1'b1;\n        rst_aon <= 1'b1;\n    end else begin\n        rst_core <= 1'b0;\n        rst_itcm <= 1'b0;\n        rst_dtcm <= 1'b0;\n        rst_aon <= 1'b0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 16, "code": "module e203_ifu_minidec #(\n  parameter E203_INSTR_SIZE = 32,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_XLEN = 32\n)(\n  input [E203_INSTR_SIZE-1:0] instr,\n  output dec_rs1en,\n  output dec_rs2en,\n  output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n  output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n  output dec_mulhsu,\n  output dec_mul,\n  output dec_div,\n  output dec_rem,\n  output dec_divu,\n  output dec_remu,\n  output dec_rv32,\n  output dec_bjp,\n  output dec_jal,\n  output dec_jalr,\n  output dec_bxx,\n  output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  output [E203_XLEN-1:0] dec_bjp_imm\n);\n\n  // Internal signals for decoding logic\n  wire [6:0] opcode = instr[6:0];\n  wire [2:0] funct3 = instr[14:12];\n  wire [6:0] funct7 = instr[31:25];\n\n  // Decode logic for register file access\n  assign dec_rs1en = (opcode == 7'b1100111) || (opcode == 7'b1100011) || (opcode == 7'b0000011) || (opcode == 7'b0100011);\n  assign dec_rs2en = (opcode == 7'b1100011) || (opcode == 7'b0100011);\n  assign dec_rs1idx = instr[19:15];\n  assign dec_rs2idx = instr[24:20];\n\n  // Decode logic for multiplication and division instructions\n  assign dec_mul = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b000);\n  assign dec_mulhsu = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b010);\n  assign dec_div = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b100);\n  assign dec_rem = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b110);\n  assign dec_divu = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b101);\n  assign dec_remu = (opcode == 7'b0110011) && (funct7 == 7'b0000001) && (funct3 == 3'b111);\n\n  // Decode logic for branch and jump instructions\n  assign dec_bjp = (opcode == 7'b1100011) || (opcode == 7'b1101111) || (opcode == 7'b1100111);\n  assign dec_jal = (opcode == 7'b1101111);\n  assign dec_jalr = (opcode == 7'b1100111);\n  assign dec_bxx = (opcode == 7'b1100011);\n  assign dec_jalr_rs1idx = (opcode == 7'b1100111) ? instr[19:15] : 5'b0;\n  assign dec_bjp_imm = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};\n\n  // RV32 instruction set flag\n  assign dec_rv32 = 1'b1;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 16, "code": "module e203_exu_nice(\n    input wire nice_i_xs_off,\n    input wire nice_i_valid,\n    output wire nice_i_ready,\n    input wire [E203_XLEN-1:0] nice_i_instr,\n    input wire [E203_XLEN-1:0] nice_i_rs1,\n    input wire [E203_XLEN-1:0] nice_i_rs2,\n    input wire [E203_ITAG_WIDTH-1:0] nice_i_itag,\n    output wire nice_o_longpipe,\n    output wire nice_o_valid,\n    input wire nice_o_ready,\n    output wire nice_o_itag_valid,\n    input wire nice_o_itag_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire clk,\n    input wire rst_n\n);\n\n// Internal signals\nwire fifo_push, fifo_pop;\nwire [E203_ITAG_WIDTH-1:0] fifo_data_in, fifo_data_out;\nwire fifo_full, fifo_empty;\n\n// FIFO instantiation for instruction tags\nsirv_gnrl_fifo #(\n    .CUT_READY(1),\n    .MSKO(0),\n    .DP(4),\n    .DW(E203_ITAG_WIDTH)\n) itag_fifo (\n    .i_vld(fifo_push),\n    .i_rdy(!fifo_full),\n    .i_dat(fifo_data_in),\n    .o_vld(fifo_pop),\n    .o_rdy(!fifo_empty),\n    .o_dat(fifo_data_out),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// Control logic for pushing to FIFO\nassign fifo_push = nice_i_valid && nice_i_ready && !nice_i_xs_off;\nassign fifo_data_in = nice_i_itag;\n\n// Control logic for popping from FIFO\nassign fifo_pop = nice_rsp_multicyc_valid && nice_rsp_multicyc_ready;\nassign nice_rsp_multicyc_ready = !fifo_empty;\n\n// Output assignment\nassign nice_i_ready = !fifo_full && nice_o_ready && !nice_i_xs_off;\nassign nice_o_valid = nice_i_valid && nice_i_ready;\nassign nice_o_longpipe = !nice_i_xs_off;\nassign nice_o_itag_valid = fifo_pop && nice_o_itag_ready;\nassign nice_o_itag = fifo_data_out;\n\n// Request to custom accelerator\nassign nice_req_valid = nice_i_valid && nice_i_ready && !nice_i_xs_off;\nassign nice_req_instr = nice_i_instr;\nassign nice_req_rs1 = nice_i_rs1;\nassign nice_req_rs2 = nice_i_rs2;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 12, "code": "module e203_ifu_ift2icb (\n    input wire itcm_nohold,\n    input wire ifu_req_valid,\n    input wire [PC_SIZE-1:0] ifu_req_pc,\n    input wire ifu_req_seq,\n    input wire ifu_req_seq_rv32,\n    input wire [PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_ready,\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_ready,\n    output wire ifu_rsp_valid,\n    output wire ifu_rsp_err,\n    output wire [31:0] ifu_rsp_instr,\n    output wire ifu2itcm_icb_cmd_valid,\n    input wire ifu2itcm_icb_cmd_ready,\n    output wire [ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_rsp_valid,\n    output wire ifu2itcm_icb_rsp_ready,\n    input wire ifu2itcm_icb_rsp_err,\n    input wire [ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    output wire ifu2biu_icb_cmd_valid,\n    input wire ifu2biu_icb_cmd_ready,\n    output wire [ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input wire ifu2biu_icb_rsp_valid,\n    output wire ifu2biu_icb_rsp_ready,\n    input wire ifu2biu_icb_rsp_err,\n    input wire [SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata\n);\n\n    // State machine definition\n    localparam ICB_STATE_IDLE = 2'b00;\n    localparam ICB_STATE_1ST = 2'b01;\n    localparam ICB_STATE_WAIT2ND = 2'b10;\n    localparam ICB_STATE_2ND = 2'b11;\n\n    reg [1:0] icb_state;\n    reg [1:0] icb_state_nxt;\n\n    // State transition signals\n    wire state_idle_exit_ena;\n    wire state_1st_exit_ena;\n    wire state_wait2nd_exit_ena;\n    wire state_2nd_exit_ena;\n\n    // Handshake signals\n    wire ifu_req_hsked = ifu_req_valid && ifu_req_ready;\n    wire ifu_icb_cmd_hsked = ifu2itcm_icb_cmd_valid && ifu2itcm_icb_cmd_ready;\n    wire ifu_icb_rsp_hsked = ifu2itcm_icb_rsp_valid && ifu2itcm_icb_rsp_ready;\n\n    // Command and response handling\n    assign ifu2itcm_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && ifu_req_valid;\n    assign ifu2itcm_icb_cmd_addr = ifu_req_pc[ITCM_ADDR_WIDTH-1:0];\n    assign ifu2itcm_icb_rsp_ready = ifu_rsp_ready;\n\n    // Response handling\n    assign ifu_rsp_valid = ifu2itcm_icb_rsp_valid;\n    assign ifu_rsp_err = ifu2itcm_icb_rsp_err;\n    assign ifu_rsp_instr = ifu2itcm_icb_rsp_rdata[31:0];\n\n    // State machine logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            icb_state <= ICB_STATE_IDLE;\n        end else begin\n            icb_state <= icb_state_nxt;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (icb_state)\n            ICB_STATE_IDLE: begin\n                if (ifu_req_hsked)\n                    icb_state_nxt = ICB_STATE_1ST;\n                else\n                    icb_state_nxt = ICB_STATE_IDLE;\n            end\n            ICB_STATE_1ST: begin\n                if (ifu_icb_rsp_hsked)\n                    icb_state_nxt = ICB_STATE_IDLE;\n                else\n                    icb_state_nxt = ICB_STATE_1ST;\n            end\n            default: begin\n                icb_state_nxt = ICB_STATE_IDLE;\n            end\n        endcase\n    end\n\n    // Output logic\n    assign ifu_req_ready = (icb_state == ICB_STATE_IDLE);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 17, "code": "module e203_exu_nice(\n    input wire nice_i_xs_off,\n    input wire nice_i_valid,\n    output wire nice_i_ready,\n    input wire [E203_XLEN-1:0] nice_i_instr,\n    input wire [E203_XLEN-1:0] nice_i_rs1,\n    input wire [E203_XLEN-1:0] nice_i_rs2,\n    input wire [E203_ITAG_WIDTH-1:0] nice_i_itag,\n    output wire nice_o_longpipe,\n    output wire nice_o_valid,\n    input wire nice_o_ready,\n    output wire nice_o_itag_valid,\n    input wire nice_o_itag_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire clk,\n    input wire rst_n\n);\n\n// Internal signals\nwire fifo_push, fifo_pop;\nwire [E203_ITAG_WIDTH-1:0] fifo_data_in, fifo_data_out;\nwire fifo_full, fifo_empty, fifo_valid;\n\n// Instantiate the FIFO for instruction tags\nsirv_gnrl_fifo #(\n    .CUT_READY(1),\n    .DP(4),\n    .DW(E203_ITAG_WIDTH)\n) itag_fifo (\n    .i_vld(fifo_push),\n    .i_rdy(!fifo_full),\n    .i_dat(fifo_data_in),\n    .o_vld(fifo_valid),\n    .o_rdy(fifo_pop),\n    .o_dat(fifo_data_out),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// Control logic for pushing to and popping from FIFO\nassign fifo_push = nice_i_valid & nice_i_ready & !nice_i_xs_off;\nassign fifo_data_in = nice_i_itag;\nassign fifo_pop = nice_rsp_multicyc_valid & nice_o_itag_ready;\n\n// Handling of requests to the accelerator\nassign nice_req_valid = nice_i_valid & !nice_i_xs_off & nice_req_ready;\nassign nice_req_instr = nice_i_instr;\nassign nice_req_rs1 = nice_i_rs1;\nassign nice_req_rs2 = nice_i_rs2;\n\n// Handling responses from the accelerator\nassign nice_rsp_multicyc_ready = !fifo_full;\nassign nice_o_itag_valid = fifo_valid & nice_rsp_multicyc_valid;\nassign nice_o_itag = fifo_data_out;\n\n// Output valid signal handling\nassign nice_o_valid = nice_i_valid & nice_o_ready & !nice_i_xs_off;\n\n// Long pipeline signal\nassign nice_o_longpipe = !nice_i_xs_off;\n\n// Ready signal to accept new instructions\nassign nice_i_ready = !fifo_full & nice_o_ready & nice_req_ready;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 19, "code": "module e203_srams #(\n  parameter E203_ITCM_RAM_AW = 12, // Address width for ITCM\n  parameter E203_ITCM_RAM_DW = 32, // Data width for ITCM\n  parameter E203_ITCM_RAM_MW = 4,  // Mask width for ITCM\n  parameter E203_DTCM_RAM_AW = 12, // Address width for DTCM\n  parameter E203_DTCM_RAM_DW = 32, // Data width for DTCM\n  parameter E203_DTCM_RAM_MW = 4   // Mask width for DTCM\n)(\n  input  wire                     clk_itcm_ram,\n  input  wire                     rst_itcm,\n  input  wire                     itcm_ram_sd,\n  input  wire                     itcm_ram_ds,\n  input  wire                     itcm_ram_ls,\n  input  wire                     itcm_ram_cs,\n  input  wire                     itcm_ram_we,\n  input  wire [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n  input  wire [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n  input  wire [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n  output wire [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n\n  input  wire                     clk_dtcm_ram,\n  input  wire                     rst_dtcm,\n  input  wire                     dtcm_ram_sd,\n  input  wire                     dtcm_ram_ds,\n  input  wire                     dtcm_ram_ls,\n  input  wire                     dtcm_ram_cs,\n  input  wire                     dtcm_ram_we,\n  input  wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n  input  wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n  input  wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n  output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout\n);\n\n`ifdef E203_HAS_ITCM\n  // ITCM Memory Instance\n  ram #(\n    .ADDR_WIDTH(E203_ITCM_RAM_AW),\n    .DATA_WIDTH(E203_ITCM_RAM_DW),\n    .MASK_WIDTH(E203_ITCM_RAM_MW)\n  ) itcm_ram (\n    .clk(clk_itcm_ram),\n    .rst(rst_itcm),\n    .cs(itcm_ram_cs),\n    .we(itcm_ram_we),\n    .addr(itcm_ram_addr),\n    .wem(itcm_ram_wem),\n    .din(itcm_ram_din),\n    .dout(itcm_ram_dout)\n  );\n`endif\n\n`ifdef E203_HAS_DTCM\n  // DTCM Memory Instance\n  ram #(\n    .ADDR_WIDTH(E203_DTCM_RAM_AW),\n    .DATA_WIDTH(E203_DTCM_RAM_DW),\n    .MASK_WIDTH(E203_DTCM_RAM_MW)\n  ) dtcm_ram (\n    .clk(clk_dtcm_ram),\n    .rst(rst_dtcm),\n    .cs(dtcm_ram_cs),\n    .we(dtcm_ram_we),\n    .addr(dtcm_ram_addr),\n    .wem(dtcm_ram_wem),\n    .din(dtcm_ram_din),\n    .dout(dtcm_ram_dout)\n  );\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 14, "code": "module e203_ifu_litebpu #(\n  parameter E203_PC_SIZE = 32,\n  parameter E203_XLEN = 32,\n  parameter E203_RFIDX_WIDTH = 5\n)(\n  input clk,\n  input rst_n,\n  input [E203_PC_SIZE-1:0] pc,\n  input dec_jal,\n  input dec_jalr,\n  input dec_bxx,\n  input [E203_XLEN-1:0] dec_bjp_imm,\n  input [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  input oitf_empty,\n  input ir_empty,\n  input ir_rs1en,\n  input jalr_rs1idx_cam_irrdidx,\n  input dec_i_valid,\n  input ir_valid_clr,\n  input [E203_XLEN-1:0] rf2bpu_x1,\n  input [E203_XLEN-1:0] rf2bpu_rs1,\n  output reg prdt_taken,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op1,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op2,\n  output reg bpu_wait,\n  output reg bpu2rf_rs1_ena\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      prdt_taken <= 1'b0;\n      prdt_pc_add_op1 <= {E203_PC_SIZE{1'b0}};\n      prdt_pc_add_op2 <= {E203_PC_SIZE{1'b0}};\n      bpu_wait <= 1'b0;\n      bpu2rf_rs1_ena <= 1'b0;\n    end else begin\n      // Default assignments\n      prdt_taken <= dec_jal | dec_jalr;\n      prdt_pc_add_op1 <= pc;\n      prdt_pc_add_op2 <= dec_bjp_imm;\n      bpu_wait <= 1'b0;\n      bpu2rf_rs1_ena <= 1'b0;\n\n      if (dec_jal) begin\n        prdt_pc_add_op1 <= pc;\n        prdt_pc_add_op2 <= dec_bjp_imm;\n      end else if (dec_jalr) begin\n        if (dec_jalr_rs1idx == 0) begin\n          prdt_pc_add_op1 <= 0;\n        end else if (dec_jalr_rs1idx == 1) begin\n          prdt_pc_add_op1 <= rf2bpu_x1;\n          bpu_wait <= !oitf_empty; // Wait if OITF is not empty\n        end else begin\n          prdt_pc_add_op1 <= rf2bpu_rs1;\n          bpu_wait <= !ir_empty && ir_rs1en && jalr_rs1idx_cam_irrdidx;\n        end\n        prdt_pc_add_op2 <= dec_bjp_imm;\n      end else if (dec_bxx) begin\n        prdt_taken <= dec_bjp_imm[E203_XLEN-1];\n        prdt_pc_add_op1 <= pc;\n        prdt_pc_add_op2 <= dec_bjp_imm;\n      end\n\n      // Enable rs1 read from BPU to RF\n      if (dec_jalr && (dec_jalr_rs1idx != 0) && (dec_jalr_rs1idx != 1)) begin\n        bpu2rf_rs1_ena <= 1'b1;\n      end\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 18, "code": "module e203_exu_nice (\n    input wire nice_i_xs_off,\n    input wire nice_i_valid,\n    output wire nice_i_ready,\n    input wire [E203_XLEN-1:0] nice_i_instr,\n    input wire [E203_XLEN-1:0] nice_i_rs1,\n    input wire [E203_XLEN-1:0] nice_i_rs2,\n    input wire [E203_ITAG_WIDTH-1:0] nice_i_itag,\n    output wire nice_o_longpipe,\n    output wire nice_o_valid,\n    input wire nice_o_ready,\n    output wire nice_o_itag_valid,\n    input wire nice_o_itag_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire clk,\n    input wire rst_n\n);\n\n  // Internal signals\n  wire fifo_full, fifo_empty;\n  wire [E203_ITAG_WIDTH-1:0] fifo_data_out;\n  wire fifo_push, fifo_pop;\n\n  assign fifo_push = nice_i_valid && nice_i_ready && !nice_i_xs_off;\n  assign fifo_pop = nice_rsp_multicyc_valid && nice_rsp_multicyc_ready;\n\n  // FIFO instantiation for instruction tags\n  sirv_gnrl_fifo #(\n    .CUT_READY(1),\n    .MSKO(0),\n    .DP(4),\n    .DW(E203_ITAG_WIDTH)\n  ) inst_tag_fifo (\n    .i_vld(fifo_push),\n    .i_rdy(nice_i_ready),\n    .i_dat(nice_i_itag),\n    .o_vld(nice_o_itag_valid),\n    .o_rdy(nice_o_itag_ready),\n    .o_dat(fifo_data_out),\n    .clk(clk),\n    .rst_n(rst_n)\n  );\n\n  // Control signals\n  assign nice_o_longpipe = !nice_i_xs_off;\n  assign nice_o_valid = nice_i_valid && nice_i_ready && !nice_i_xs_off;\n  assign nice_req_valid = nice_i_valid && nice_i_ready && !nice_i_xs_off;\n  assign nice_rsp_multicyc_ready = !fifo_full;\n  assign nice_i_ready = !fifo_full && nice_o_ready && nice_req_ready;\n\n  // Data path\n  assign nice_req_instr = nice_i_instr;\n  assign nice_req_rs1 = nice_i_rs1;\n  assign nice_req_rs2 = nice_i_rs2;\n  assign nice_o_itag = fifo_data_out;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 15, "code": "module e203_ifu (\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire itcm_nohold,\n    input wire pipe_flush_req,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    `ifdef E203_TIMING_BOOST\n    input wire [E203_PC_SIZE-1:0] pipe_flush_pc,\n    `endif\n    input wire ifu_halt_req,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire ifu_active,\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    output wire pipe_flush_ack,\n    `ifdef E203_HAS_ITCM\n    input wire ifu2itcm_holdup,\n    input wire [E203_ADDR_SIZE-1:0] itcm_region_indic,\n    output wire ifu2itcm_icb_cmd_valid,\n    input wire ifu2itcm_icb_cmd_ready,\n    output wire [E203_ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_rsp_valid,\n    output wire ifu2itcm_icb_rsp_ready,\n    input wire ifu2itcm_icb_rsp_err,\n    input wire [E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    `endif\n    `ifdef E203_HAS_MEM_ITF\n    output wire ifu2biu_icb_cmd_valid,\n    input wire ifu2biu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input wire ifu2biu_icb_rsp_valid,\n    output wire ifu2biu_icb_rsp_ready,\n    input wire ifu2biu_icb_rsp_err,\n    input wire [E203_SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata,\n    `endif\n    output wire ifu_halt_ack\n);\n\n    // Internal signals and logic for e203_ifu module\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 11, "code": "module itcm_controller (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n    input wire [ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_cmd_valid,\n    input wire ifu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] ifu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] ifu2itcm_icb_cmd_wmask,\n    input wire ifu2itcm_icb_rsp_ready,\n    output wire ifu2itcm_icb_cmd_ready,\n    output wire ifu2itcm_icb_rsp_valid,\n    output wire ifu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    output wire itcm_active,\n    output wire itcm_ram_cs,\n    output wire itcm_ram_we,\n    output wire [RAM_AW-1:0] itcm_ram_addr,\n    output wire [RAM_MW-1:0] itcm_ram_wem,\n    output wire [RAM_DW-1:0] itcm_ram_din,\n    input wire [RAM_DW-1:0] itcm_ram_dout,\n    output wire clk_itcm_ram\n);\n\n    // Internal signals\n    reg [ADDR_WIDTH-1:0] addr_reg;\n    reg [DATA_WIDTH-1:0] wdata_reg;\n    reg [WMSK_WIDTH-1:0] wmask_reg;\n    reg cmd_valid_reg, cmd_read_reg;\n    wire cmd_ready_int;\n    wire rsp_valid_int, rsp_err_int;\n    wire [DATA_WIDTH-1:0] rsp_rdata_int;\n\n    // Command register block\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cmd_valid_reg <= 1'b0;\n        end else if (cmd_ready_int) begin\n            cmd_valid_reg <= ifu2itcm_icb_cmd_valid;\n            cmd_read_reg <= ifu2itcm_icb_cmd_read;\n            addr_reg <= ifu2itcm_icb_cmd_addr;\n            wdata_reg <= ifu2itcm_icb_cmd_wdata;\n            wmask_reg <= ifu2itcm_icb_cmd_wmask;\n        end\n    end\n\n    // Command ready logic\n    assign ifu2itcm_icb_cmd_ready = cmd_ready_int;\n\n    // RAM interface logic\n    assign itcm_ram_cs = cmd_valid_reg;\n    assign itcm_ram_we = !cmd_read_reg;\n    assign itcm_ram_addr = addr_reg[RAM_AW-1:0];\n    assign itcm_ram_wem = wmask_reg;\n    assign itcm_ram_din = wdata_reg;\n\n    // Response logic\n    assign rsp_valid_int = cmd_valid_reg && cmd_read_reg;\n    assign rsp_err_int = 1'b0; // Assuming no errors for simplicity\n    assign rsp_rdata_int = itcm_ram_dout;\n\n    // Response register block\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            ifu2itcm_icb_rsp_valid <= 1'b0;\n            ifu2itcm_icb_rsp_err <= 1'b0;\n            ifu2itcm_icb_rsp_rdata <= {DATA_WIDTH{1'b0}};\n        end else if (ifu2itcm_icb_rsp_ready) begin\n            ifu2itcm_icb_rsp_valid <= rsp_valid_int;\n            ifu2itcm_icb_rsp_err <= rsp_err_int;\n            ifu2itcm_icb_rsp_rdata <= rsp_rdata_int;\n        end\n    end\n\n    // Clock and active signal logic\n    assign clk_itcm_ram = clk;\n    assign itcm_active = cmd_valid_reg || ifu2itcm_icb_rsp_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 15, "code": "module e203_ifu_litebpu #(\n  parameter E203_PC_SIZE = 32,\n  parameter E203_XLEN = 32,\n  parameter E203_RFIDX_WIDTH = 5\n)(\n  input clk,\n  input rst_n,\n  input [E203_PC_SIZE-1:0] pc,\n  input dec_jal,\n  input dec_jalr,\n  input dec_bxx,\n  input [E203_XLEN-1:0] dec_bjp_imm,\n  input [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  input oitf_empty,\n  input ir_empty,\n  input ir_rs1en,\n  input jalr_rs1idx_cam_irrdidx,\n  input dec_i_valid,\n  input ir_valid_clr,\n  input [E203_XLEN-1:0] rf2bpu_x1,\n  input [E203_XLEN-1:0] rf2bpu_rs1,\n  output reg prdt_taken,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op1,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op2,\n  output reg bpu_wait,\n  output reg bpu2rf_rs1_ena\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      prdt_taken <= 0;\n      prdt_pc_add_op1 <= 0;\n      prdt_pc_add_op2 <= 0;\n      bpu_wait <= 0;\n      bpu2rf_rs1_ena <= 0;\n    end else begin\n      // Default values\n      prdt_taken <= 0;\n      prdt_pc_add_op1 <= pc;\n      prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n      bpu_wait <= 0;\n      bpu2rf_rs1_ena <= 0;\n\n      if (dec_i_valid) begin\n        if (dec_jal) begin\n          prdt_taken <= 1;\n          prdt_pc_add_op1 <= pc;\n          prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n        end else if (dec_jalr) begin\n          prdt_taken <= 1;\n          if (dec_jalr_rs1idx == 0) begin\n            prdt_pc_add_op1 <= 0;\n          end else if (dec_jalr_rs1idx == 1) begin\n            prdt_pc_add_op1 <= rf2bpu_x1;\n            if (!oitf_empty || jalr_rs1idx_cam_irrdidx) begin\n              bpu_wait <= 1;\n            end\n          end else begin\n            prdt_pc_add_op1 <= rf2bpu_rs1;\n            if (!ir_empty && ir_rs1en) begin\n              bpu_wait <= 1;\n            end\n          end\n          prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n        end else if (dec_bxx) begin\n          if (dec_bjp_imm[E203_XLEN-1]) begin // Negative offset\n            prdt_taken <= 1;\n          end else begin\n            prdt_taken <= 0;\n          end\n          prdt_pc_add_op1 <= pc;\n          prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n        end\n      end\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 16, "code": "module e203_ifu_litebpu #(\n  parameter E203_PC_SIZE = 32,\n  parameter E203_XLEN = 32,\n  parameter E203_RFIDX_WIDTH = 5\n)(\n  input clk,\n  input rst_n,\n  input [E203_PC_SIZE-1:0] pc,\n  input dec_jal,\n  input dec_jalr,\n  input dec_bxx,\n  input [E203_XLEN-1:0] dec_bjp_imm,\n  input [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  input oitf_empty,\n  input ir_empty,\n  input ir_rs1en,\n  input jalr_rs1idx_cam_irrdidx,\n  input dec_i_valid,\n  input ir_valid_clr,\n  input [E203_XLEN-1:0] rf2bpu_x1,\n  input [E203_XLEN-1:0] rf2bpu_rs1,\n  output reg prdt_taken,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op1,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op2,\n  output reg bpu_wait,\n  output reg bpu2rf_rs1_ena\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      prdt_taken <= 1'b0;\n      prdt_pc_add_op1 <= {E203_PC_SIZE{1'b0}};\n      prdt_pc_add_op2 <= {E203_PC_SIZE{1'b0}};\n      bpu_wait <= 1'b0;\n      bpu2rf_rs1_ena <= 1'b0;\n    end else begin\n      // Default outputs\n      prdt_taken <= 1'b0;\n      prdt_pc_add_op1 <= pc;\n      prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n      bpu_wait <= 1'b0;\n      bpu2rf_rs1_ena <= 1'b0;\n\n      // Handle JAL instruction\n      if (dec_jal) begin\n        prdt_taken <= 1'b1;\n        prdt_pc_add_op1 <= pc;\n        prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n      end\n\n      // Handle JALR instruction\n      if (dec_jalr) begin\n        prdt_taken <= 1'b1;\n        case (dec_jalr_rs1idx)\n          5'd0: prdt_pc_add_op1 <= {E203_PC_SIZE{1'b0}};\n          5'd1: begin\n            prdt_pc_add_op1 <= rf2bpu_x1;\n            if (!oitf_empty || jalr_rs1idx_cam_irrdidx) begin\n              bpu_wait <= 1'b1;\n            end\n          end\n          default: begin\n            prdt_pc_add_op1 <= rf2bpu_rs1;\n            if (!ir_empty && ir_rs1en) begin\n              bpu_wait <= 1'b1;\n            end\n          end\n        endcase\n        prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n      end\n\n      // Handle conditional branch instruction\n      if (dec_bxx) begin\n        prdt_taken <= dec_bjp_imm[E203_XLEN-1];\n        prdt_pc_add_op1 <= pc;\n        prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n      end\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 19, "code": "module e203_exu_nice (\n    input wire nice_i_xs_off,\n    input wire nice_i_valid,\n    output wire nice_i_ready,\n    input wire [E203_XLEN-1:0] nice_i_instr,\n    input wire [E203_XLEN-1:0] nice_i_rs1,\n    input wire [E203_XLEN-1:0] nice_i_rs2,\n    input wire [E203_ITAG_WIDTH-1:0] nice_i_itag,\n    output wire nice_o_longpipe,\n    output wire nice_o_valid,\n    input wire nice_o_ready,\n    output wire nice_o_itag_valid,\n    input wire nice_o_itag_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire clk,\n    input wire rst_n\n);\n\n// Internal signals\nwire fifo_push, fifo_pop;\nwire [E203_ITAG_WIDTH-1:0] fifo_data_in, fifo_data_out;\nwire fifo_full, fifo_empty, fifo_valid;\n\n// Control signals\nassign fifo_push = nice_i_valid && nice_i_ready && !nice_i_xs_off;\nassign fifo_pop = nice_rsp_multicyc_valid && nice_rsp_multicyc_ready;\n\n// FIFO instantiation for instruction tags\nsirv_gnrl_fifo #(\n    .CUT_READY(1),\n    .MSKO(0),\n    .DP(4),\n    .DW(E203_ITAG_WIDTH)\n) itag_fifo (\n    .i_vld(fifo_push),\n    .i_rdy(nice_i_ready),\n    .i_dat(nice_i_itag),\n    .o_vld(fifo_valid),\n    .o_rdy(nice_o_itag_ready),\n    .o_dat(fifo_data_out),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// Output assignments\nassign nice_i_ready = !fifo_full && nice_o_ready && (nice_i_xs_off || nice_req_ready);\nassign nice_o_longpipe = !nice_i_xs_off;\nassign nice_o_valid = nice_i_valid && nice_i_ready;\nassign nice_o_itag_valid = fifo_valid && nice_rsp_multicyc_valid;\nassign nice_o_itag = fifo_data_out;\nassign nice_rsp_multicyc_ready = !fifo_empty;\n\n// Request to accelerator\nassign nice_req_valid = nice_i_valid && nice_i_ready && !nice_i_xs_off;\nassign nice_req_instr = nice_i_instr;\nassign nice_req_rs1 = nice_i_rs1;\nassign nice_req_rs2 = nice_i_rs2;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 12, "code": "module itcm_controller (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n    input wire [ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] ifu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] ifu2itcm_icb_cmd_wmask,\n    input wire ifu2itcm_icb_cmd_valid,\n    output wire ifu2itcm_icb_cmd_ready,\n    output wire [DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    output wire ifu2itcm_icb_rsp_valid,\n    input wire ifu2itcm_icb_rsp_ready,\n    output wire ifu2itcm_icb_rsp_err,\n    output wire itcm_active,\n    output wire itcm_ram_cs,\n    output wire itcm_ram_we,\n    output wire [RAM_AW-1:0] itcm_ram_addr,\n    output wire [RAM_MW-1:0] itcm_ram_wem,\n    output wire [RAM_DW-1:0] itcm_ram_din,\n    input wire [RAM_DW-1:0] itcm_ram_dout,\n    output wire clk_itcm_ram\n);\n\n    // Internal signals\n    reg [DATA_WIDTH-1:0] rdata_reg;\n    reg rsp_valid_reg, cmd_ready_reg, rsp_err_reg;\n    wire cmd_valid, rsp_ready;\n\n    assign cmd_valid = ifu2itcm_icb_cmd_valid && !rsp_valid_reg;\n    assign rsp_ready = ifu2itcm_icb_rsp_ready;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cmd_ready_reg <= 1'b0;\n            rsp_valid_reg <= 1'b0;\n            rsp_err_reg <= 1'b0;\n            rdata_reg <= {DATA_WIDTH{1'b0}};\n        end else begin\n            if (cmd_valid && !cmd_ready_reg) begin\n                cmd_ready_reg <= 1'b1;\n            end else if (cmd_ready_reg && rsp_ready) begin\n                cmd_ready_reg <= 1'b0;\n                rsp_valid_reg <= 1'b1;\n                rsp_err_reg <= 1'b0; // Assume no error for simplicity\n                rdata_reg <= itcm_ram_dout; // Read data from RAM\n            end else if (rsp_valid_reg && !rsp_ready) begin\n                rsp_valid_reg <= 1'b0;\n            end\n        end\n    end\n\n    // RAM interface logic\n    assign itcm_ram_cs = cmd_ready_reg;\n    assign itcm_ram_we = !ifu2itcm_icb_cmd_read && cmd_ready_reg;\n    assign itcm_ram_addr = ifu2itcm_icb_cmd_addr[RAM_AW-1:0];\n    assign itcm_ram_wem = ifu2itcm_icb_cmd_wmask;\n    assign itcm_ram_din = ifu2itcm_icb_cmd_wdata;\n    assign clk_itcm_ram = clk;\n\n    // Outputs\n    assign ifu2itcm_icb_cmd_ready = cmd_ready_reg;\n    assign ifu2itcm_icb_rsp_rdata = rdata_reg;\n    assign ifu2itcm_icb_rsp_valid = rsp_valid_reg;\n    assign ifu2itcm_icb_rsp_err = rsp_err_reg;\n    assign itcm_active = cmd_ready_reg || rsp_valid_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 17, "code": "module e203_ifu_minidec #(\n  parameter E203_INSTR_SIZE = 32,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_XLEN = 32\n)(\n  input [E203_INSTR_SIZE-1:0] instr,\n  output reg dec_rs1en,\n  output reg dec_rs2en,\n  output reg [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n  output reg [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n  output reg dec_mulhsu,\n  output reg dec_mul,\n  output reg dec_div,\n  output reg dec_rem,\n  output reg dec_divu,\n  output reg dec_remu,\n  output reg dec_rv32,\n  output reg dec_bjp,\n  output reg dec_jal,\n  output reg dec_jalr,\n  output reg dec_bxx,\n  output reg [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  output reg [E203_XLEN-1:0] dec_bjp_imm\n);\n\n  // Internal signals for decoding\n  wire [6:0] opcode = instr[6:0];\n  wire [2:0] funct3 = instr[14:12];\n  wire [6:0] funct7 = instr[31:25];\n\n  always @(*) begin\n    // Default assignments\n    dec_rs1en = 1'b0;\n    dec_rs2en = 1'b0;\n    dec_rs1idx = instr[19:15];\n    dec_rs2idx = instr[24:20];\n    dec_mulhsu = 1'b0;\n    dec_mul = 1'b0;\n    dec_div = 1'b0;\n    dec_rem = 1'b0;\n    dec_divu = 1'b0;\n    dec_remu = 1'b0;\n    dec_rv32 = 1'b1; // Assuming RV32\n    dec_bjp = 1'b0;\n    dec_jal = 1'b0;\n    dec_jalr = 1'b0;\n    dec_bxx = 1'b0;\n    dec_jalr_rs1idx = instr[19:15];\n    dec_bjp_imm = {E203_XLEN{1'b0}};\n\n    case (opcode)\n      7'b0110011: begin // R-type\n        dec_rs1en = 1'b1;\n        dec_rs2en = 1'b1;\n        case (funct3)\n          3'b000: begin\n            if (funct7 == 7'b0000001) begin\n              dec_mul = 1'b1; // MUL\n            end\n          end\n          3'b001: begin\n            if (funct7 == 7'b0000001) begin\n              dec_mulhsu = 1'b1; // MULHSU\n            end\n          end\n        endcase\n      end\n      7'b1101111: begin // JAL\n        dec_jal = 1'b1;\n        dec_bjp = 1'b1;\n        dec_bjp_imm = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0};\n      end\n      7'b1100111: begin // JALR\n        dec_jalr = 1'b1;\n        dec_bjp = 1'b1;\n        dec_jalr_rs1idx = instr[19:15];\n      end\n      7'b1100011: begin // B-type\n        dec_bxx = 1'b1;\n        dec_bjp = 1'b1;\n        dec_bjp_imm = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};\n      end\n    endcase\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 18, "code": "module e203_ifu_minidec #(\n  parameter E203_INSTR_SIZE = 32,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_XLEN = 32\n)(\n  input [E203_INSTR_SIZE-1:0] instr,\n  output dec_rs1en,\n  output dec_rs2en,\n  output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n  output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n  output dec_mulhsu,\n  output dec_mul,\n  output dec_div,\n  output dec_rem,\n  output dec_divu,\n  output dec_remu,\n  output dec_rv32,\n  output dec_bjp,\n  output dec_jal,\n  output dec_jalr,\n  output dec_bxx,\n  output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  output [E203_XLEN-1:0] dec_bjp_imm\n);\n\n  // Internal signals for decoding\n  wire [6:0] opcode = instr[6:0];\n  wire [2:0] funct3 = instr[14:12];\n  wire [6:0] funct7 = instr[31:25];\n\n  // Decode logic\n  assign dec_rs1en = (opcode != 7'b0010111) && (opcode != 7'b0110111);\n  assign dec_rs2en = (opcode == 7'b0110011) || (opcode == 7'b1100011);\n  assign dec_rs1idx = instr[19:15];\n  assign dec_rs2idx = instr[24:20];\n  assign dec_mulhsu = (opcode == 7'b0110011) && (funct3 == 3'b010) && (funct7 == 7'b0000001);\n  assign dec_mul = (opcode == 7'b0110011) && (funct3 == 3'b000) && (funct7 == 7'b0000001);\n  assign dec_div = (opcode == 7'b0110011) && (funct3 == 3'b100) && (funct7 == 7'b0000001);\n  assign dec_rem = (opcode == 7'b0110011) && (funct3 == 3'b110) && (funct7 == 7'b0000001);\n  assign dec_divu = (opcode == 7'b0110011) && (funct3 == 3'b101) && (funct7 == 7'b0000001);\n  assign dec_remu = (opcode == 7'b0110011) && (funct3 == 3'b111) && (funct7 == 7'b0000001);\n  assign dec_rv32 = 1'b1; // Assuming RV32 only\n  assign dec_bjp = (opcode == 7'b1101111) || (opcode == 7'b1100111) || (opcode == 7'b1100011);\n  assign dec_jal = (opcode == 7'b1101111);\n  assign dec_jalr = (opcode == 7'b1100111);\n  assign dec_bxx = (opcode == 7'b1100011);\n  assign dec_jalr_rs1idx = instr[19:15];\n  assign dec_bjp_imm = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 20, "code": "module e203_lsu_ctrl(\n    input wire commit_mret,\n    input wire commit_trap,\n    output wire lsu_ctrl_active,\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] agu_icb_rsp_rdata\n);\n    // LSU control logic implementation\n    // This is a placeholder for the actual implementation\n    // which would include the logic to handle the signals\n    // and perform the necessary LSU operations.\n\n    // Example simple pass-through logic for AGU ICB interface\n    assign agu_icb_cmd_ready = agu_icb_rsp_ready;\n    assign agu_icb_rsp_valid = agu_icb_cmd_valid;\n    assign agu_icb_rsp_err = 1'b0; // No error by default\n    assign agu_icb_rsp_excl_ok = agu_icb_cmd_excl; // Directly pass exclusive access flag\n    assign agu_icb_rsp_rdata = agu_icb_cmd_wdata; // Echo write data for simplicity\n\n    // Example write-back logic\n    assign lsu_o_valid = agu_icb_cmd_valid && agu_icb_cmd_ready;\n    assign lsu_o_wbck_wdat = agu_icb_cmd_wdata;\n    assign lsu_o_wbck_itag = agu_icb_cmd_itag;\n    assign lsu_o_wbck_err = 1'b0; // No error by default\n    assign lsu_o_cmt_buserr = 1'b0; // No bus error by default\n    assign lsu_o_cmt_badaddr = agu_icb_cmd_addr;\n    assign lsu_o_cmt_ld = agu_icb_cmd_read;\n    assign lsu_o_cmt_st = !agu_icb_cmd_read;\n\n    // Control active status logic\n    assign lsu_ctrl_active = lsu_o_valid || agu_icb_cmd_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 16, "code": "module e203_exu_disp (\n    input wire wfi_halt_exu_req,\n    output wire wfi_halt_exu_ack,\n    input wire oitf_empty,\n    input wire amo_wait,\n    input wire disp_i_valid,\n    output wire disp_i_ready,\n    input wire disp_i_rs1x0,\n    input wire disp_i_rs2x0,\n    input wire disp_i_rs1en,\n    input wire disp_i_rs2en,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input wire [E203_XLEN-1:0] disp_i_rs1,\n    input wire [E203_XLEN-1:0] disp_i_rs2,\n    input wire disp_i_rdwen,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input wire [E203_DECINFO_WIDTH-1:0] disp_i_info,\n    input wire [E203_XLEN-1:0] disp_i_imm,\n    input wire [E203_PC_SIZE-1:0] disp_i_pc,\n    input wire disp_i_misalgn,\n    input wire disp_i_buserr,\n    input wire disp_i_ilegl,\n    output wire disp_o_alu_valid,\n    input wire disp_o_alu_ready,\n    input wire disp_o_alu_longpipe,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs1,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs2,\n    output wire disp_o_alu_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_o_alu_rdidx,\n    output wire [E203_DECINFO_WIDTH-1:0] disp_o_alu_info,\n    output wire [E203_XLEN-1:0] disp_o_alu_imm,\n    output wire [E203_PC_SIZE-1:0] disp_o_alu_pc,\n    output wire [E203_ITAG_WIDTH-1:0] disp_o_alu_itag,\n    output wire disp_o_alu_misalgn,\n    output wire disp_o_alu_buserr,\n    output wire disp_o_alu_ilegl,\n    input wire oitfrd_match_disprs1,\n    input wire oitfrd_match_disprs2,\n    input wire oitfrd_match_disprs3,\n    input wire oitfrd_match_disprd,\n    input wire [E203_ITAG_WIDTH-1:0] disp_oitf_ptr,\n    output wire disp_oitf_ena,\n    input wire disp_oitf_ready,\n    output wire disp_oitf_rs1fpu,\n    output wire disp_oitf_rs2fpu,\n    output wire disp_oitf_rs3fpu,\n    output wire disp_oitf_rdfpu,\n    output wire disp_oitf_rs1en,\n    output wire disp_oitf_rs2en,\n    output wire disp_oitf_rs3en,\n    output wire disp_oitf_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs2idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs3idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rdidx,\n    output wire [E203_PC_SIZE-1:0] disp_oitf_pc,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Implementation of dispatch logic, dependency checks, and WFI handling\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 17, "code": "module e203_ifu_litebpu #(\n  parameter E203_PC_SIZE = 32,\n  parameter E203_XLEN = 32,\n  parameter E203_RFIDX_WIDTH = 5\n)(\n  input clk,\n  input rst_n,\n  input [E203_PC_SIZE-1:0] pc,\n  input dec_jal,\n  input dec_jalr,\n  input dec_bxx,\n  input [E203_XLEN-1:0] dec_bjp_imm,\n  input [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  input oitf_empty,\n  input ir_empty,\n  input ir_rs1en,\n  input jalr_rs1idx_cam_irrdidx,\n  input dec_i_valid,\n  input ir_valid_clr,\n  input [E203_XLEN-1:0] rf2bpu_x1,\n  input [E203_XLEN-1:0] rf2bpu_rs1,\n  output reg prdt_taken,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op1,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op2,\n  output reg bpu_wait,\n  output reg bpu2rf_rs1_ena\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      prdt_taken <= 0;\n      prdt_pc_add_op1 <= 0;\n      prdt_pc_add_op2 <= 0;\n      bpu_wait <= 0;\n      bpu2rf_rs1_ena <= 0;\n    end else begin\n      // Default values\n      prdt_taken <= 0;\n      prdt_pc_add_op1 <= pc;\n      prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n      bpu_wait <= 0;\n      bpu2rf_rs1_ena <= 0;\n\n      // Prediction logic for JAL and JALR\n      if (dec_jal) begin\n        prdt_taken <= 1;\n        prdt_pc_add_op1 <= pc;\n        prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n      end else if (dec_jalr) begin\n        prdt_taken <= 1;\n        if (dec_jalr_rs1idx == 0) begin\n          prdt_pc_add_op1 <= 0;\n        end else if (dec_jalr_rs1idx == 1) begin\n          prdt_pc_add_op1 <= rf2bpu_x1;\n          if (!oitf_empty || jalr_rs1idx_cam_irrdidx) begin\n            bpu_wait <= 1;\n          end\n        end else begin\n          prdt_pc_add_op1 <= rf2bpu_rs1;\n          if (!oitf_empty || (ir_rs1en && jalr_rs1idx_cam_irrdidx)) begin\n            bpu_wait <= 1;\n          end\n        end\n        prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n      end else if (dec_bxx) begin\n        // Static prediction based on the sign of the offset\n        if (dec_bjp_imm[E203_XLEN-1] == 1'b1) begin\n          prdt_taken <= 1;\n        end else begin\n          prdt_taken <= 0;\n        end\n      end\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 16, "code": "module e203_exu_excp(\n    output commit_trap,\n    output core_wfi,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input amo_wait,\n    input alu_excp_i_valid,\n    input alu_excp_i_ld,\n    input alu_excp_i_stamo,\n    input alu_excp_i_misalgn,\n    input alu_excp_i_buserr,\n    input alu_excp_i_ecall,\n    input alu_excp_i_ebreak,\n    input alu_excp_i_wfi,\n    input alu_excp_i_ifu_misalgn,\n    input alu_excp_i_ifu_buserr,\n    input alu_excp_i_ifu_ilegl,\n    input [E203_PC_SIZE-1:0] alu_excp_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_excp_i_instr,\n    input alu_excp_i_pc_vld,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input longp_excp_i_insterr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input excpirq_flush_ack,\n    output excpirq_flush_req,\n    output nonalu_excpirq_flush_req_raw,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op1,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op2,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input cmt_dret_ena,\n    input cmt_ena,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_badaddr_ena,\n    output cmt_epc_ena,\n    output cmt_cause_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output excp_active,\n    input clk,\n    input rst_n\n);\n\n    // Implementation of exception handling logic\n    // This is a simplified example and needs to be expanded based on actual requirements\n\n    reg core_wfi_reg;\n    assign core_wfi = core_wfi_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            core_wfi_reg <= 1'b0;\n        end else if (alu_excp_i_wfi && cmt_ena && !dbg_mode) begin\n            core_wfi_reg <= 1'b1;\n        end else if (dbg_irq_r || lcl_irq_r || ext_irq_r || sft_irq_r || tmr_irq_r) begin\n            core_wfi_reg <= 1'b0;\n        end\n    end\n\n    assign wfi_halt_ifu_req = alu_excp_i_wfi && cmt_ena && !dbg_mode;\n    assign wfi_halt_exu_req = alu_excp_i_wfi && cmt_ena && !dbg_mode;\n\n    assign excp_active = alu_excp_i_valid || longp_excp_i_valid || dbg_irq_r;\n\n    // More logic to be implemented here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 17, "code": "module e203_exu_excp(\n    output commit_trap,\n    output core_wfi,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input amo_wait,\n    input alu_excp_i_valid,\n    input alu_excp_i_ld,\n    input alu_excp_i_stamo,\n    input alu_excp_i_misalgn,\n    input alu_excp_i_buserr,\n    input alu_excp_i_ecall,\n    input alu_excp_i_ebreak,\n    input alu_excp_i_wfi,\n    input alu_excp_i_ifu_misalgn,\n    input alu_excp_i_ifu_buserr,\n    input alu_excp_i_ifu_ilegl,\n    input [E203_PC_SIZE-1:0] alu_excp_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_excp_i_instr,\n    input alu_excp_i_pc_vld,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input longp_excp_i_insterr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input excpirq_flush_ack,\n    output excpirq_flush_req,\n    output nonalu_excpirq_flush_req_raw,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op1,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op2,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input cmt_dret_ena,\n    input cmt_ena,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_badaddr_ena,\n    output cmt_epc_ena,\n    output cmt_cause_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output excp_active,\n    input clk,\n    input rst_n\n);\n    // Implementation of exception handling logic\n    // This is a placeholder for the actual logic which would be quite complex and involve many submodules and internal signals.\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 15, "code": "module e203_ifu_ifetch(\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_valid,\n    input wire ifu_req_ready,\n    output wire [E203_PC_SIZE-1:0] ifu_req_pc,\n    output wire ifu_req_seq,\n    output wire ifu_req_seq_rv32,\n    output wire [E203_PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_valid,\n    output wire ifu_rsp_ready,\n    input wire ifu_rsp_err,\n    input wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr,\n    input wire pipe_flush_req,\n    output wire pipe_flush_ack,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    `ifdef E203_TIMING_BOOST\n    input wire [E203_PC_SIZE-1:0] pipe_flush_pc,\n    `endif\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    input wire ifu_halt_req,\n    output wire ifu_halt_ack,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu\n);\n    // Internal signal declarations\n    wire reset_flag_r;\n    wire reset_req_r;\n    wire halt_ack_r;\n    wire dly_flush_r;\n    wire ir_valid_r;\n    wire ir_pc_vld_r;\n    wire ifu_err_r;\n    wire ifu_prdt_taken_r;\n    wire ir_muldiv_b2b_r;\n    wire [E203_INSTR_SIZE-1:0] ifu_ir_r;\n    wire [E203_RFIDX_WIDTH-1:0] ir_rs1idx_r;\n    wire [E203_RFIDX_WIDTH-1:0] ir_rs2idx_r;\n    wire [E203_PC_SIZE-1:0] ifu_pc_r;\n    wire [E203_PC_SIZE-1:0] pc_r;\n    wire out_flag_r;\n    wire pc_newpend_r;\n\n    // Implementation of the module's functionality\n    // This is a placeholder for the actual implementation\n    // which would include the logic for instruction fetching,\n    // handling pipeline flushes, branch predictions, etc.\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 20, "code": "module e203_srams (\n    input wire itcm_ram_sd,\n    input wire itcm_ram_ds,\n    input wire itcm_ram_ls,\n    input wire itcm_ram_cs,\n    input wire itcm_ram_we,\n    input wire [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n    input wire [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n    input wire [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n    output wire [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n    input wire clk_itcm_ram,\n    input wire rst_itcm,\n\n    input wire dtcm_ram_sd,\n    input wire dtcm_ram_ds,\n    input wire dtcm_ram_ls,\n    input wire dtcm_ram_cs,\n    input wire dtcm_ram_we,\n    input wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    input wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    input wire clk_dtcm_ram,\n    input wire rst_dtcm\n);\n\n`ifdef E203_HAS_ITCM\n    e203_itcm_ram #(\n        .AW(E203_ITCM_RAM_AW),\n        .MW(E203_ITCM_RAM_MW),\n        .DW(E203_ITCM_RAM_DW)\n    ) u_itcm_ram (\n        .sd(itcm_ram_sd),\n        .ds(itcm_ram_ds),\n        .ls(itcm_ram_ls),\n        .cs(itcm_ram_cs),\n        .we(itcm_ram_we),\n        .addr(itcm_ram_addr),\n        .wem(itcm_ram_wem),\n        .din(itcm_ram_din),\n        .dout(itcm_ram_dout),\n        .clk(clk_itcm_ram),\n        .rst_n(rst_itcm)\n    );\n`endif\n\n`ifdef E203_HAS_DTCM\n    e203_dtcm_ram #(\n        .AW(E203_DTCM_RAM_AW),\n        .MW(E203_DTCM_RAM_MW),\n        .DW(E203_DTCM_RAM_DW)\n    ) u_dtcm_ram (\n        .sd(dtcm_ram_sd),\n        .ds(dtcm_ram_ds),\n        .ls(dtcm_ram_ls),\n        .cs(dtcm_ram_cs),\n        .we(dtcm_ram_we),\n        .addr(dtcm_ram_addr),\n        .wem(dtcm_ram_wem),\n        .din(dtcm_ram_din),\n        .dout(dtcm_ram_dout),\n        .clk(clk_dtcm_ram),\n        .rst_n(rst_dtcm)\n    );\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 18, "code": "module e203_ifu_litebpu #(\n  parameter E203_PC_SIZE = 32,\n  parameter E203_XLEN = 32,\n  parameter E203_RFIDX_WIDTH = 5\n)(\n  input clk,\n  input rst_n,\n  input [E203_PC_SIZE-1:0] pc,\n  input dec_jal,\n  input dec_jalr,\n  input dec_bxx,\n  input [E203_XLEN-1:0] dec_bjp_imm,\n  input [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  input oitf_empty,\n  input ir_empty,\n  input ir_rs1en,\n  input jalr_rs1idx_cam_irrdidx,\n  input dec_i_valid,\n  input ir_valid_clr,\n  input [E203_XLEN-1:0] rf2bpu_x1,\n  input [E203_XLEN-1:0] rf2bpu_rs1,\n  output reg prdt_taken,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op1,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op2,\n  output reg bpu_wait,\n  output reg bpu2rf_rs1_ena\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      prdt_taken <= 0;\n      prdt_pc_add_op1 <= 0;\n      prdt_pc_add_op2 <= 0;\n      bpu_wait <= 0;\n      bpu2rf_rs1_ena <= 0;\n    end else begin\n      // Default values\n      prdt_taken <= 0;\n      prdt_pc_add_op1 <= pc;\n      prdt_pc_add_op2 <= dec_bjp_imm;\n      bpu_wait <= 0;\n      bpu2rf_rs1_ena <= 0;\n\n      if (dec_i_valid) begin\n        if (dec_jal) begin\n          prdt_taken <= 1;\n          prdt_pc_add_op1 <= pc;\n          prdt_pc_add_op2 <= dec_bjp_imm;\n        end else if (dec_jalr) begin\n          prdt_taken <= 1;\n          if (dec_jalr_rs1idx == 0) begin\n            prdt_pc_add_op1 <= 0;\n          end else if (dec_jalr_rs1idx == 1) begin\n            prdt_pc_add_op1 <= rf2bpu_x1;\n            if (!oitf_empty || jalr_rs1idx_cam_irrdidx) begin\n              bpu_wait <= 1;\n            end\n          end else begin\n            prdt_pc_add_op1 <= rf2bpu_rs1;\n            if (!oitf_empty || (ir_rs1en && !ir_empty)) begin\n              bpu_wait <= 1;\n            end\n          end\n          prdt_pc_add_op2 <= dec_bjp_imm;\n        end else if (dec_bxx) begin\n          prdt_taken <= dec_bjp_imm[E203_XLEN-1];\n          prdt_pc_add_op1 <= pc;\n          prdt_pc_add_op2 <= dec_bjp_imm;\n        end\n      end\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 18, "code": "module e203_exu_excp(\n    output commit_trap,\n    output core_wfi,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input amo_wait,\n    input alu_excp_i_valid,\n    input alu_excp_i_ld,\n    input alu_excp_i_stamo,\n    input alu_excp_i_misalgn,\n    input alu_excp_i_buserr,\n    input alu_excp_i_ecall,\n    input alu_excp_i_ebreak,\n    input alu_excp_i_wfi,\n    input alu_excp_i_ifu_misalgn,\n    input alu_excp_i_ifu_buserr,\n    input alu_excp_i_ifu_ilegl,\n    input [E203_PC_SIZE-1:0] alu_excp_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_excp_i_instr,\n    input alu_excp_i_pc_vld,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input longp_excp_i_insterr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input excpirq_flush_ack,\n    output excpirq_flush_req,\n    output nonalu_excpirq_flush_req_raw,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op1,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op2,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input cmt_dret_ena,\n    input cmt_ena,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_badaddr_ena,\n    output cmt_epc_ena,\n    output cmt_cause_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output excp_active,\n    input clk,\n    input rst_n\n);\n    // Implementation of exception handling logic\n    // This is a placeholder for the actual implementation\n    // which would include handling of various exception types,\n    // updating of control status registers, and managing interrupts.\n\n    // Example of handling an ALU exception\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            commit_trap <= 1'b0;\n            core_wfi <= 1'b0;\n            wfi_halt_ifu_req <= 1'b0;\n            wfi_halt_exu_req <= 1'b0;\n        end else begin\n            if (alu_excp_i_valid) begin\n                commit_trap <= 1'b1;\n                // Additional logic to handle specific ALU exceptions\n            end else begin\n                commit_trap <= 1'b0;\n            end\n\n            // Handle WFI state entry\n            if (alu_excp_i_wfi && cmt_ena && !dbg_mode) begin\n                core_wfi <= 1'b1;\n                wfi_halt_ifu_req <= 1'b1;\n                wfi_halt_exu_req <= 1'b1;\n            end else if (wfi_halt_ifu_ack && wfi_halt_exu_ack) begin\n                core_wfi <= 1'b0;\n                wfi_halt_ifu_req <= 1'b0;\n                wfi_halt_exu_req <= 1'b0;\n            end\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 9, "code": "module e203_lsu_ctrl(\n    input wire commit_mret,\n    input wire commit_trap,\n    output wire lsu_ctrl_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    input wire nice_mem_holdup,\n    input wire nice_icb_cmd_valid,\n    output wire nice_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] nice_icb_cmd_addr,\n    input wire nice_icb_cmd_read,\n    input wire [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] nice_icb_cmd_wmask,\n    output wire nice_icb_rsp_valid,\n    input wire nice_icb_rsp_ready,\n    output wire nice_icb_rsp_err,\n    output wire [E203_XLEN-1:0] nice_icb_rsp_rdata,\n\n    output wire dcache_icb_cmd_valid,\n    input wire dcache_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] dcache_icb_cmd_addr,\n    output wire dcache_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dcache_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dcache_icb_cmd_wmask,\n    output wire dcache_icb_cmd_lock,\n    output wire dcache_icb_cmd_excl,\n    output wire [1:0] dcache_icb_cmd_size,\n    input wire dcache_icb_rsp_valid,\n    output wire dcache_icb_rsp_ready,\n    input wire dcache_icb_rsp_err,\n    input wire dcache_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dcache_icb_rsp_rdata,\n\n    output wire dtcm_icb_cmd_valid,\n    input wire dtcm_icb_cmd_ready,\n    output wire [E203_DTCM_ADDR_WIDTH-1:0] dtcm_icb_cmd_addr,\n    output wire dtcm_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dtcm_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dtcm_icb_cmd_wmask,\n    output wire dtcm_icb_cmd_lock,\n    output wire dtcm_icb_cmd_excl,\n    output wire [1:0] dtcm_icb_cmd_size,\n    input wire dtcm_icb_rsp_valid,\n    output wire dtcm_icb_rsp_ready,\n    input wire dtcm_icb_rsp_err,\n    input wire dtcm_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dtcm_icb_rsp_rdata,\n    input wire [E203_ADDR_SIZE-1:0] dtcm_region_indic,\n\n    output wire biu_icb_cmd_valid,\n    input wire biu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,\n    output wire biu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] biu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] biu_icb_cmd_wmask,\n    output wire biu_icb_cmd_lock,\n    output wire biu_icb_cmd_excl,\n    output wire [1:0] biu_icb_cmd_size,\n    input wire biu_icb_rsp_valid,\n    output wire biu_icb_rsp_ready,\n    input wire biu_icb_rsp_err,\n    input wire biu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] biu_icb_rsp_rdata,\n\n    input wire clk,\n    input wire rst_n\n);\n    // Implementation of LSU control logic\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 20, "code": "module e203_exu_nice (\n    input wire nice_i_xs_off,\n    input wire nice_i_valid,\n    output wire nice_i_ready,\n    input wire [E203_XLEN-1:0] nice_i_instr,\n    input wire [E203_XLEN-1:0] nice_i_rs1,\n    input wire [E203_XLEN-1:0] nice_i_rs2,\n    input wire [E203_ITAG_WIDTH-1:0] nice_i_itag,\n    output wire nice_o_longpipe,\n    output wire nice_o_valid,\n    input wire nice_o_ready,\n    output wire nice_o_itag_valid,\n    input wire nice_o_itag_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire clk,\n    input wire rst_n\n);\n\n// Include the E203 defines file\n`include \"e203_defines.v\"\n\n// Internal signals\nreg [E203_ITAG_WIDTH-1:0] itag_fifo [3:0]; // Simple FIFO for instruction tags\ninteger i;\nwire fifo_full, fifo_empty;\nassign fifo_full = (itag_fifo[3] !== {E203_ITAG_WIDTH{1'bX}});\nassign fifo_empty = (itag_fifo[0] === {E203_ITAG_WIDTH{1'bX}});\n\n// FIFO control\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        for (i = 0; i < 4; i = i + 1) begin\n            itag_fifo[i] <= {E203_ITAG_WIDTH{1'b0}};\n        end\n    end\n    else if (nice_i_valid && nice_i_ready) begin\n        // Shift FIFO contents\n        for (i = 3; i > 0; i = i - 1) begin\n            itag_fifo[i] <= itag_fifo[i - 1];\n        end\n        // Insert new tag at the bottom\n        itag_fifo[0] <= nice_i_itag;\n    end\n    else if (nice_rsp_multicyc_valid && nice_rsp_multicyc_ready && !fifo_empty) begin\n        // Shift FIFO contents\n        for (i = 0; i < 3; i = i + 1) begin\n            itag_fifo[i] <= itag_fifo[i + 1];\n        end\n        itag_fifo[3] <= {E203_ITAG_WIDTH{1'b0}};\n    end\nend\n\n// Output assignments\nassign nice_i_ready = !fifo_full && nice_o_ready && !nice_i_xs_off;\nassign nice_o_longpipe = !nice_i_xs_off;\nassign nice_o_valid = nice_i_valid && nice_i_ready;\nassign nice_o_itag_valid = !fifo_empty && nice_rsp_multicyc_valid;\nassign nice_o_itag = itag_fifo[0];\nassign nice_rsp_multicyc_ready = !fifo_empty;\nassign nice_req_valid = nice_i_valid && nice_i_ready && !nice_i_xs_off;\nassign nice_req_instr = nice_i_instr;\nassign nice_req_rs1 = nice_i_rs1;\nassign nice_req_rs2 = nice_i_rs2;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 19, "code": "module e203_ifu_litebpu #(\n  parameter E203_PC_SIZE = 32,\n  parameter E203_XLEN = 32,\n  parameter E203_RFIDX_WIDTH = 5\n)(\n  input clk,\n  input rst_n,\n  input [E203_PC_SIZE-1:0] pc,\n  input dec_jal,\n  input dec_jalr,\n  input dec_bxx,\n  input [E203_XLEN-1:0] dec_bjp_imm,\n  input [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  input oitf_empty,\n  input ir_empty,\n  input ir_rs1en,\n  input jalr_rs1idx_cam_irrdidx,\n  input dec_i_valid,\n  input ir_valid_clr,\n  input [E203_XLEN-1:0] rf2bpu_x1,\n  input [E203_XLEN-1:0] rf2bpu_rs1,\n  output reg prdt_taken,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op1,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op2,\n  output reg bpu_wait,\n  output reg bpu2rf_rs1_ena\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      prdt_taken <= 1'b0;\n      prdt_pc_add_op1 <= {E203_PC_SIZE{1'b0}};\n      prdt_pc_add_op2 <= {E203_PC_SIZE{1'b0}};\n      bpu_wait <= 1'b0;\n      bpu2rf_rs1_ena <= 1'b0;\n    end else begin\n      // Default outputs\n      prdt_taken <= 1'b0;\n      prdt_pc_add_op1 <= pc;\n      prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n      bpu_wait <= 1'b0;\n      bpu2rf_rs1_ena <= 1'b0;\n\n      // Prediction logic\n      if (dec_i_valid) begin\n        if (dec_jal) begin\n          prdt_taken <= 1'b1;\n          prdt_pc_add_op1 <= pc;\n          prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n        end else if (dec_jalr) begin\n          prdt_taken <= 1'b1;\n          if (dec_jalr_rs1idx == 0) begin\n            prdt_pc_add_op1 <= 0;\n          end else if (dec_jalr_rs1idx == 1) begin\n            prdt_pc_add_op1 <= rf2bpu_x1;\n            if (!oitf_empty || jalr_rs1idx_cam_irrdidx) begin\n              bpu_wait <= 1'b1;\n            end\n          end else begin\n            prdt_pc_add_op1 <= rf2bpu_rs1;\n            if (!ir_empty && ir_rs1en) begin\n              bpu_wait <= 1'b1;\n            end\n          end\n          prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n        end else if (dec_bxx) begin\n          if (dec_bjp_imm[E203_XLEN-1]) begin\n            prdt_taken <= 1'b1;\n          end\n          prdt_pc_add_op1 <= pc;\n          prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n        end\n      end\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 10, "code": "module e203_lsu_ctrl (\n    input wire commit_mret,\n    input wire commit_trap,\n    output wire lsu_ctrl_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    input wire nice_mem_holdup,\n    input wire nice_icb_cmd_valid,\n    output wire nice_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] nice_icb_cmd_addr,\n    input wire nice_icb_cmd_read,\n    input wire [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] nice_icb_cmd_wmask,\n    output wire nice_icb_rsp_valid,\n    input wire nice_icb_rsp_ready,\n    output wire nice_icb_rsp_err,\n    output wire [E203_XLEN-1:0] nice_icb_rsp_rdata,\n\n    output wire dcache_icb_cmd_valid,\n    input wire dcache_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] dcache_icb_cmd_addr,\n    output wire dcache_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dcache_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dcache_icb_cmd_wmask,\n    output wire dcache_icb_cmd_lock,\n    output wire dcache_icb_cmd_excl,\n    output wire [1:0] dcache_icb_cmd_size,\n    input wire dcache_icb_rsp_valid,\n    output wire dcache_icb_rsp_ready,\n    input wire dcache_icb_rsp_err,\n    input wire dcache_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dcache_icb_rsp_rdata,\n\n    output wire dtcm_icb_cmd_valid,\n    input wire dtcm_icb_cmd_ready,\n    output wire [E203_DTCM_ADDR_WIDTH-1:0] dtcm_icb_cmd_addr,\n    output wire dtcm_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dtcm_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dtcm_icb_cmd_wmask,\n    output wire dtcm_icb_cmd_lock,\n    output wire dtcm_icb_cmd_excl,\n    output wire [1:0] dtcm_icb_cmd_size,\n    input wire dtcm_icb_rsp_valid,\n    output wire dtcm_icb_rsp_ready,\n    input wire dtcm_icb_rsp_err,\n    input wire dtcm_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dtcm_icb_rsp_rdata,\n    input wire [E203_ADDR_SIZE-1:0] dtcm_region_indic,\n\n    output wire biu_icb_cmd_valid,\n    input wire biu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,\n    output wire biu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] biu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] biu_icb_cmd_wmask,\n    output wire biu_icb_cmd_lock,\n    output wire biu_icb_cmd_excl,\n    output wire [1:0] biu_icb_cmd_size,\n    input wire biu_icb_rsp_valid,\n    output wire biu_icb_rsp_ready,\n    input wire biu_icb_rsp_err,\n    input wire biu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] biu_icb_rsp_rdata\n);\n    // Module implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 16, "code": "module e203_ifu_ifetch(\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_valid,\n    input wire ifu_req_ready,\n    output wire [E203_PC_SIZE-1:0] ifu_req_pc,\n    output wire ifu_req_seq,\n    output wire ifu_req_seq_rv32,\n    output wire [E203_PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_valid,\n    output wire ifu_rsp_ready,\n    input wire ifu_rsp_err,\n    input wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr,\n    input wire pipe_flush_req,\n    output wire pipe_flush_ack,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    output wire [E203_PC_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    input wire ifu_halt_req,\n    output wire ifu_halt_ack,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu\n);\n    // Internal signal declarations\n    reg [E203_PC_SIZE-1:0] pc_reg, pc_next;\n    reg [E203_INSTR_SIZE-1:0] ir_reg, ir_next;\n    reg valid_reg, valid_next;\n    wire flush;\n    wire [E203_PC_SIZE-1:0] pc_increment;\n    wire [E203_PC_SIZE-1:0] pc_new;\n    wire pc_update_cond;\n    wire ifu_req_hsked;\n    wire ifu_rsp_hsked;\n\n    // PC update logic\n    assign pc_increment = (ir_reg[1:0] == 2'b11) ? 4 : 2;\n    assign pc_new = pc_reg + pc_increment;\n    assign pc_update_cond = (ifu_req_ready && ifu_req_valid) || flush;\n    assign ifu_req_hsked = ifu_req_ready && ifu_req_valid;\n    assign ifu_rsp_hsked = ifu_rsp_ready && ifu_rsp_valid;\n\n    // PC register\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            pc_reg <= RESET_VECTOR;\n        else if (pc_update_cond)\n            pc_reg <= pc_new;\n    end\n\n    // Instruction register\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            ir_reg <= {E203_INSTR_SIZE{1'b0}};\n        else if (ifu_rsp_hsked)\n            ir_reg <= ifu_rsp_instr;\n    end\n\n    // Valid register\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_reg <= 1'b0;\n        else\n            valid_reg <= valid_next;\n    end\n\n    // Next state logic for valid register\n    always @(*) begin\n        valid_next = valid_reg;\n        if (ifu_rsp_hsked)\n            valid_next = 1'b1;\n        if (flush)\n            valid_next = 1'b0;\n    end\n\n    // Flush logic\n    assign flush = pipe_flush_req && pipe_flush_ack;\n\n    // Output assignments\n    assign ifu_req_valid = !valid_reg && !flush && (pc_update_cond || !ifu_req_hsked);\n    assign ifu_req_pc = pc_reg;\n    assign ifu_req_seq = 1'b1; // Always sequential in this simple example\n    assign ifu_req_seq_rv32 = (ir_reg[1:0] == 2'b11);\n    assign ifu_req_last_pc = pc_reg;\n    assign ifu_rsp_ready = !valid_reg;\n    assign ifu_o_ir = ir_reg;\n    assign ifu_o_pc = pc_reg;\n    assign ifu_o_pc_vld = valid_reg;\n    assign ifu_o_valid = valid_reg && ifu_o_ready;\n    assign ifu_halt_ack = ifu_halt_req; // Simple example, immediately acknowledge halt\n\n    // Pipeline flush acknowledgment\n    assign pipe_flush_ack = pipe_flush_req; // Simple example, immediately acknowledge flush\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 19, "code": "module e203_ifu_minidec #(\n  parameter E203_INSTR_SIZE = 32,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_XLEN = 32\n)(\n  input [E203_INSTR_SIZE-1:0] instr,\n  output reg dec_rs1en,\n  output reg dec_rs2en,\n  output reg [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n  output reg [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n  output reg dec_mulhsu,\n  output reg dec_mul,\n  output reg dec_div,\n  output reg dec_rem,\n  output reg dec_divu,\n  output reg dec_remu,\n  output reg dec_rv32,\n  output reg dec_bjp,\n  output reg dec_jal,\n  output reg dec_jalr,\n  output reg dec_bxx,\n  output reg [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  output reg [E203_XLEN-1:0] dec_bjp_imm\n);\n\n  // Internal signals for decoding\n  wire [6:0] opcode = instr[6:0];\n  wire [2:0] funct3 = instr[14:12];\n  wire [6:0] funct7 = instr[31:25];\n\n  always @(*) begin\n    // Default assignments\n    dec_rs1en = 1'b0;\n    dec_rs2en = 1'b0;\n    dec_rs1idx = instr[19:15];\n    dec_rs2idx = instr[24:20];\n    dec_mulhsu = 1'b0;\n    dec_mul = 1'b0;\n    dec_div = 1'b0;\n    dec_rem = 1'b0;\n    dec_divu = 1'b0;\n    dec_remu = 1'b0;\n    dec_rv32 = 1'b1; // Assuming RV32\n    dec_bjp = 1'b0;\n    dec_jal = 1'b0;\n    dec_jalr = 1'b0;\n    dec_bxx = 1'b0;\n    dec_jalr_rs1idx = instr[19:15];\n    dec_bjp_imm = {E203_XLEN{1'b0}};\n\n    case (opcode)\n      7'b0110011: begin // R-type\n        dec_rs1en = 1'b1;\n        dec_rs2en = 1'b1;\n        case (funct3)\n          3'b000: begin\n            if (funct7 == 7'b0000001) begin\n              dec_mul = 1'b1; // MUL\n            end\n          end\n          3'b101: begin\n            if (funct7 == 7'b0000001) begin\n              dec_divu = 1'b1; // DIVU\n            end\n          end\n        endcase\n      end\n      7'b1101111: begin // JAL\n        dec_jal = 1'b1;\n        dec_bjp = 1'b1;\n        dec_bjp_imm = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0};\n      end\n      7'b1100111: begin // JALR\n        dec_jalr = 1'b1;\n        dec_bjp = 1'b1;\n        dec_rs1en = 1'b1;\n        dec_bjp_imm = {{20{instr[31]}}, instr[31:20]};\n      end\n      7'b1100011: begin // B-type\n        dec_bxx = 1'b1;\n        dec_bjp = 1'b1;\n        dec_rs1en = 1'b1;\n        dec_rs2en = 1'b1;\n        dec_bjp_imm = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};\n      end\n    endcase\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 20, "code": "module e203_ifu_litebpu #(\n  parameter E203_PC_SIZE = 32,\n  parameter E203_XLEN = 32,\n  parameter E203_RFIDX_WIDTH = 5\n)(\n  input clk,\n  input rst_n,\n  input [E203_PC_SIZE-1:0] pc,\n  input dec_jal,\n  input dec_jalr,\n  input dec_bxx,\n  input [E203_XLEN-1:0] dec_bjp_imm,\n  input [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  input oitf_empty,\n  input ir_empty,\n  input ir_rs1en,\n  input jalr_rs1idx_cam_irrdidx,\n  input dec_i_valid,\n  input ir_valid_clr,\n  input [E203_XLEN-1:0] rf2bpu_x1,\n  input [E203_XLEN-1:0] rf2bpu_rs1,\n  output reg prdt_taken,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op1,\n  output reg [E203_PC_SIZE-1:0] prdt_pc_add_op2,\n  output reg bpu_wait,\n  output reg bpu2rf_rs1_ena\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      prdt_taken <= 1'b0;\n      prdt_pc_add_op1 <= {E203_PC_SIZE{1'b0}};\n      prdt_pc_add_op2 <= {E203_PC_SIZE{1'b0}};\n      bpu_wait <= 1'b0;\n      bpu2rf_rs1_ena <= 1'b0;\n    end else begin\n      // Default values\n      prdt_taken <= 1'b0;\n      prdt_pc_add_op1 <= pc;\n      prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n      bpu_wait <= 1'b0;\n      bpu2rf_rs1_ena <= 1'b0;\n\n      if (dec_i_valid) begin\n        if (dec_jal) begin\n          prdt_taken <= 1'b1;\n          prdt_pc_add_op1 <= pc;\n          prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n        end else if (dec_jalr) begin\n          prdt_taken <= 1'b1;\n          if (dec_jalr_rs1idx == 0) begin\n            prdt_pc_add_op1 <= 0;\n          end else if (dec_jalr_rs1idx == 1) begin\n            prdt_pc_add_op1 <= rf2bpu_x1;\n            if (!oitf_empty || jalr_rs1idx_cam_irrdidx) begin\n              bpu_wait <= 1'b1;\n            end\n          end else begin\n            prdt_pc_add_op1 <= rf2bpu_rs1;\n            if (!ir_empty && ir_rs1en) begin\n              bpu_wait <= 1'b1;\n            end\n          end\n          prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n        end else if (dec_bxx) begin\n          if (dec_bjp_imm[E203_XLEN-1]) begin\n            prdt_taken <= 1'b1;\n          end\n          prdt_pc_add_op1 <= pc;\n          prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n        end\n      end\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 19, "code": "module e203_exu_oitf #(\n  parameter E203_ITAG_WIDTH = 4,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_PC_SIZE = 32,\n  parameter E203_OITF_DEPTH = 16\n)(\n  input clk,\n  input rst_n,\n\n  // Dispatch interface\n  input dis_ena,\n  output reg dis_ready,\n  input [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n  input [E203_PC_SIZE-1:0] disp_i_pc,\n  input disp_i_rdwen,\n  input disp_i_rdfpu,\n\n  // Retirement interface\n  input ret_ena,\n  output reg [E203_RFIDX_WIDTH-1:0] ret_rdidx,\n  output reg [E203_PC_SIZE-1:0] ret_pc,\n  output reg ret_rdwen,\n  output reg ret_rdfpu,\n  output reg oitf_empty,\n\n  // Dependency checking outputs\n  output reg oitfrd_match_disprs1,\n  output reg oitfrd_match_disprs2,\n  output reg oitfrd_match_disprs3,\n  output reg oitfrd_match_disprd\n);\n\n  reg [E203_RFIDX_WIDTH-1:0] rdidx [0:E203_OITF_DEPTH-1];\n  reg [E203_PC_SIZE-1:0] pc [0:E203_OITF_DEPTH-1];\n  reg [E203_OITF_DEPTH-1:0] rdwen;\n  reg [E203_OITF_DEPTH-1:0] rdfpu;\n  reg [E203_ITAG_WIDTH-1:0] dis_ptr, ret_ptr;\n  reg dis_ptr_flag, ret_ptr_flag;\n\n  integer i;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      dis_ptr <= 0;\n      ret_ptr <= 0;\n      dis_ptr_flag <= 0;\n      ret_ptr_flag <= 0;\n      rdwen <= 0;\n      rdfpu <= 0;\n      for (i = 0; i < E203_OITF_DEPTH; i = i + 1) begin\n        rdidx[i] <= 0;\n        pc[i] <= 0;\n      end\n    end else begin\n      if (dis_ena && dis_ready) begin\n        rdidx[dis_ptr] <= disp_i_rdidx;\n        pc[dis_ptr] <= disp_i_pc;\n        rdwen[dis_ptr] <= disp_i_rdwen;\n        rdfpu[dis_ptr] <= disp_i_rdfpu;\n        dis_ptr <= dis_ptr + 1;\n        if (dis_ptr == E203_OITF_DEPTH-1)\n          dis_ptr_flag <= ~dis_ptr_flag;\n      end\n      if (ret_ena && !oitf_empty) begin\n        ret_rdidx <= rdidx[ret_ptr];\n        ret_pc <= pc[ret_ptr];\n        ret_rdwen <= rdwen[ret_ptr];\n        ret_rdfpu <= rdfpu[ret_ptr];\n        rdwen[ret_ptr] <= 0;\n        ret_ptr <= ret_ptr + 1;\n        if (ret_ptr == E203_OITF_DEPTH-1)\n          ret_ptr_flag <= ~ret_ptr_flag;\n      end\n    end\n  end\n\n  always @(*) begin\n    dis_ready = (dis_ptr != ret_ptr) || (dis_ptr_flag != ret_ptr_flag);\n    oitf_empty = (dis_ptr == ret_ptr) && (dis_ptr_flag == ret_ptr_flag);\n    oitfrd_match_disprs1 = 0;\n    oitfrd_match_disprs2 = 0;\n    oitfrd_match_disprs3 = 0;\n    oitfrd_match_disprd = 0;\n    for (i = 0; i < E203_OITF_DEPTH; i = i + 1) begin\n      if (rdwen[i]) begin\n        if (rdidx[i] == disp_i_rs1idx) oitfrd_match_disprs1 = 1;\n        if (rdidx[i] == disp_i_rs2idx) oitfrd_match_disprs2 = 1;\n        if (rdidx[i] == disp_i_rs3idx) oitfrd_match_disprs3 = 1;\n        if (rdidx[i] == disp_i_rdidx) oitfrd_match_disprd = 1;\n      end\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 13, "code": "module itcm_controller #(\n    parameter ADDR_WIDTH = 32,\n    parameter DATA_WIDTH = 64,\n    parameter WMSK_WIDTH = DATA_WIDTH / 8,\n    parameter RAM_AW = 10,\n    parameter RAM_MW = DATA_WIDTH / 8,\n    parameter RAM_DW = DATA_WIDTH\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n\n    // System Interface\n    output wire itcm_active,\n\n    // IFU Interface\n    input wire ifu2itcm_icb_cmd_valid,\n    output wire ifu2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] ifu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] ifu2itcm_icb_cmd_wmask,\n    output wire ifu2itcm_icb_rsp_valid,\n    input wire ifu2itcm_icb_rsp_ready,\n    output wire ifu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n\n    // LSU Interface\n    input wire lsu2itcm_icb_cmd_valid,\n    output wire lsu2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] lsu2itcm_icb_cmd_addr,\n    input wire lsu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] lsu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] lsu2itcm_icb_cmd_wmask,\n    output wire lsu2itcm_icb_rsp_valid,\n    input wire lsu2itcm_icb_rsp_ready,\n    output wire lsu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] lsu2itcm_icb_rsp_rdata,\n\n    // External Interface\n    `ifdef E203_HAS_ITCM_EXTITF\n    input wire ext2itcm_icb_cmd_valid,\n    output wire ext2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input wire ext2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] ext2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] ext2itcm_icb_cmd_wmask,\n    output wire ext2itcm_icb_rsp_valid,\n    input wire ext2itcm_icb_rsp_ready,\n    output wire ext2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] ext2itcm_icb_rsp_rdata,\n    `endif\n\n    // RAM Interface\n    output wire itcm_ram_cs,\n    output wire itcm_ram_we,\n    output wire [RAM_AW-1:0] itcm_ram_addr,\n    output wire [RAM_MW-1:0] itcm_ram_wem,\n    output wire [RAM_DW-1:0] itcm_ram_din,\n    input wire [RAM_DW-1:0] itcm_ram_dout,\n    output wire clk_itcm_ram\n);\n\n    // Internal logic and state machine for handling ITCM access requests\n    // and responses, arbitration between IFU, LSU, and external interface\n    // (if present), and interfacing with the tightly coupled memory (RAM).\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 14, "code": "module itcm_controller #(\n    parameter ADDR_WIDTH = 32,\n    parameter DATA_WIDTH = 64,\n    parameter WMSK_WIDTH = DATA_WIDTH / 8,\n    parameter RAM_AW = 10,\n    parameter RAM_MW = DATA_WIDTH / 8,\n    parameter RAM_DW = DATA_WIDTH\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n\n    // IFU Interface\n    input wire ifu2itcm_icb_cmd_valid,\n    output wire ifu2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] ifu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] ifu2itcm_icb_cmd_wmask,\n    output wire ifu2itcm_icb_rsp_valid,\n    input wire ifu2itcm_icb_rsp_ready,\n    output wire ifu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n\n    // LSU Interface\n    input wire lsu2itcm_icb_cmd_valid,\n    output wire lsu2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] lsu2itcm_icb_cmd_addr,\n    input wire lsu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] lsu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] lsu2itcm_icb_cmd_wmask,\n    output wire lsu2itcm_icb_rsp_valid,\n    input wire lsu2itcm_icb_rsp_ready,\n    output wire lsu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] lsu2itcm_icb_rsp_rdata,\n\n    // RAM Interface\n    output wire itcm_ram_cs,\n    output wire itcm_ram_we,\n    output wire [RAM_AW-1:0] itcm_ram_addr,\n    output wire [RAM_MW-1:0] itcm_ram_wem,\n    output wire [RAM_DW-1:0] itcm_ram_din,\n    input wire [RAM_DW-1:0] itcm_ram_dout,\n    output wire clk_itcm_ram,\n\n    // Status Output\n    output wire itcm_active\n);\n\n    // Internal signals\n    wire [ADDR_WIDTH-1:0] selected_addr;\n    wire [DATA_WIDTH-1:0] selected_wdata;\n    wire [WMSK_WIDTH-1:0] selected_wmask;\n    wire selected_read;\n    wire selected_valid;\n    wire selected_ready;\n    wire [DATA_WIDTH-1:0] selected_rdata;\n    wire selected_rsp_valid;\n    wire selected_rsp_ready;\n    wire selected_rsp_err;\n\n    // Arbitration logic (simplified example)\n    assign selected_valid = ifu2itcm_icb_cmd_valid || lsu2itcm_icb_cmd_valid;\n    assign selected_addr = ifu2itcm_icb_cmd_valid ? ifu2itcm_icb_cmd_addr : lsu2itcm_icb_cmd_addr;\n    assign selected_wdata = ifu2itcm_icb_cmd_valid ? ifu2itcm_icb_cmd_wdata : lsu2itcm_icb_cmd_wdata;\n    assign selected_wmask = ifu2itcm_icb_cmd_valid ? ifu2itcm_icb_cmd_wmask : lsu2itcm_icb_cmd_wmask;\n    assign selected_read = ifu2itcm_icb_cmd_valid ? ifu2itcm_icb_cmd_read : lsu2itcm_icb_cmd_read;\n\n    // RAM interface logic\n    assign itcm_ram_cs = selected_valid && selected_ready;\n    assign itcm_ram_we = !selected_read;\n    assign itcm_ram_addr = selected_addr[RAM_AW-1:0];\n    assign itcm_ram_wem = selected_wmask;\n    assign itcm_ram_din = selected_wdata;\n\n    // Response logic\n    assign selected_rsp_valid = itcm_ram_cs && !selected_read;\n    assign selected_rdata = itcm_ram_dout;\n    assign selected_rsp_err = 0; // Simplified, no error handling\n\n    // Connecting back to IFU and LSU\n    assign ifu2itcm_icb_cmd_ready = selected_ready && ifu2itcm_icb_cmd_valid;\n    assign lsu2itcm_icb_cmd_ready = selected_ready && lsu2itcm_icb_cmd_valid;\n    assign ifu2itcm_icb_rsp_valid = selected_rsp_valid && ifu2itcm_icb_cmd_valid;\n    assign lsu2itcm_icb_rsp_valid = selected_rsp_valid && lsu2itcm_icb_cmd_valid;\n    assign ifu2itcm_icb_rsp_rdata = selected_rdata;\n    assign lsu2itcm_icb_rsp_rdata = selected_rdata;\n    assign ifu2itcm_icb_rsp_err = selected_rsp_err;\n    assign lsu2itcm_icb_rsp_err = selected_rsp_err;\n\n    // Clock and reset\n    assign clk_itcm_ram = clk;\n    assign itcm_active = selected_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 15, "code": "module itcm_controller #(\n    parameter ADDR_WIDTH = 32,\n    parameter DATA_WIDTH = 64,\n    parameter WMSK_WIDTH = DATA_WIDTH / 8,\n    parameter RAM_AW = 10,\n    parameter RAM_MW = DATA_WIDTH / 8,\n    parameter RAM_DW = DATA_WIDTH\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n\n    // System Interface\n    output wire itcm_active,\n\n    // IFU Interface\n    input wire ifu2itcm_icb_cmd_valid,\n    output wire ifu2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] ifu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] ifu2itcm_icb_cmd_wmask,\n    output wire ifu2itcm_icb_rsp_valid,\n    input wire ifu2itcm_icb_rsp_ready,\n    output wire ifu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n\n    // LSU Interface\n    input wire lsu2itcm_icb_cmd_valid,\n    output wire lsu2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] lsu2itcm_icb_cmd_addr,\n    input wire lsu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] lsu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] lsu2itcm_icb_cmd_wmask,\n    output wire lsu2itcm_icb_rsp_valid,\n    input wire lsu2itcm_icb_rsp_ready,\n    output wire lsu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] lsu2itcm_icb_rsp_rdata,\n\n    // RAM Interface\n    output wire itcm_ram_cs,\n    output wire itcm_ram_we,\n    output wire [RAM_AW-1:0] itcm_ram_addr,\n    output wire [RAM_MW-1:0] itcm_ram_wem,\n    output wire [RAM_DW-1:0] itcm_ram_din,\n    input wire [RAM_DW-1:0] itcm_ram_dout,\n    output wire clk_itcm_ram\n);\n\n    // Internal signals\n    wire [ADDR_WIDTH-1:0] selected_addr;\n    wire [DATA_WIDTH-1:0] selected_wdata;\n    wire [WMSK_WIDTH-1:0] selected_wmask;\n    wire selected_read;\n    wire selected_valid;\n    wire selected_ready;\n    wire [DATA_WIDTH-1:0] selected_rdata;\n    wire selected_rsp_valid;\n    wire selected_rsp_ready;\n    wire selected_rsp_err;\n\n    // Arbitration logic (simplified example)\n    assign selected_addr = ifu2itcm_icb_cmd_valid ? ifu2itcm_icb_cmd_addr : lsu2itcm_icb_cmd_addr;\n    assign selected_wdata = ifu2itcm_icb_cmd_valid ? ifu2itcm_icb_cmd_wdata : lsu2itcm_icb_cmd_wdata;\n    assign selected_wmask = ifu2itcm_icb_cmd_valid ? ifu2itcm_icb_cmd_wmask : lsu2itcm_icb_cmd_wmask;\n    assign selected_read = ifu2itcm_icb_cmd_valid ? ifu2itcm_icb_cmd_read : lsu2itcm_icb_cmd_read;\n    assign selected_valid = ifu2itcm_icb_cmd_valid || lsu2itcm_icb_cmd_valid;\n    assign ifu2itcm_icb_cmd_ready = selected_ready && ifu2itcm_icb_cmd_valid;\n    assign lsu2itcm_icb_cmd_ready = selected_ready && lsu2itcm_icb_cmd_valid;\n    assign selected_rsp_ready = ifu2itcm_icb_cmd_valid ? ifu2itcm_icb_rsp_ready : lsu2itcm_icb_rsp_ready;\n\n    // Memory access logic\n    assign itcm_ram_cs = selected_valid && selected_ready;\n    assign itcm_ram_we = !selected_read;\n    assign itcm_ram_addr = selected_addr[RAM_AW+2:3]; // Assuming word-aligned addresses\n    assign itcm_ram_wem = selected_wmask;\n    assign itcm_ram_din = selected_wdata;\n    assign selected_rdata = itcm_ram_dout;\n\n    // Response logic\n    assign selected_rsp_valid = itcm_ram_cs;\n    assign ifu2itcm_icb_rsp_valid = selected_rsp_valid && ifu2itcm_icb_cmd_valid;\n    assign lsu2itcm_icb_rsp_valid = selected_rsp_valid && lsu2itcm_icb_cmd_valid;\n    assign ifu2itcm_icb_rsp_rdata = selected_rdata;\n    assign lsu2itcm_icb_rsp_rdata = selected_rdata;\n    assign ifu2itcm_icb_rsp_err = 0; // Simplified: no error handling\n    assign lsu2itcm_icb_rsp_err = 0; // Simplified: no error handling\n\n    // Clock and reset logic\n    assign clk_itcm_ram = clk; // No gating in this simplified example\n    assign itcm_active = selected_valid; // Indicate activity\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 20, "code": "module e203_ifu_minidec #(\n  parameter E203_INSTR_SIZE = 32,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_XLEN = 32\n)(\n  input [E203_INSTR_SIZE-1:0] instr,\n  output dec_rs1en,\n  output dec_rs2en,\n  output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n  output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n  output dec_mulhsu,\n  output dec_mul,\n  output dec_div,\n  output dec_rem,\n  output dec_divu,\n  output dec_remu,\n  output dec_rv32,\n  output dec_bjp,\n  output dec_jal,\n  output dec_jalr,\n  output dec_bxx,\n  output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  output [E203_XLEN-1:0] dec_bjp_imm\n);\n\n  // Internal signals\n  wire [6:0] opcode;\n  wire [2:0] funct3;\n  wire [6:0] funct7;\n  wire [4:0] rs1;\n  wire [4:0] rs2;\n  wire [4:0] rd;\n\n  assign opcode = instr[6:0];\n  assign funct3 = instr[14:12];\n  assign funct7 = instr[31:25];\n  assign rs1 = instr[19:15];\n  assign rs2 = instr[24:20];\n  assign rd = instr[11:7];\n\n  // Decode logic for register enable signals\n  assign dec_rs1en = (opcode == 7'b1100111) || // JALR\n                     (opcode == 7'b1100011) || // Branches\n                     (opcode == 7'b0000011) || // Loads\n                     (opcode == 7'b0100011) || // Stores\n                     (opcode == 7'b0010011) || // Immediate type\n                     (opcode == 7'b0110011);   // Register type\n\n  assign dec_rs2en = (opcode == 7'b0100011) || // Stores\n                     (opcode == 7'b0110011);   // Register type\n\n  // Decode logic for register indices\n  assign dec_rs1idx = rs1;\n  assign dec_rs2idx = rs2;\n  assign dec_jalr_rs1idx = (opcode == 7'b1100111) ? rs1 : 5'd0;\n\n  // Decode logic for operation type flags\n  assign dec_mulhsu = (opcode == 7'b0110011) && (funct3 == 3'b010) && (funct7 == 7'b0000001);\n  assign dec_mul = (opcode == 7'b0110011) && (funct3 == 3'b000) && (funct7 == 7'b0000001);\n  assign dec_div = (opcode == 7'b0110011) && (funct3 == 3'b100) && (funct7 == 7'b0000001);\n  assign dec_rem = (opcode == 7'b0110011) && (funct3 == 3'b110) && (funct7 == 7'b0000001);\n  assign dec_divu = (opcode == 7'b0110011) && (funct3 == 3'b101) && (funct7 == 7'b0000001);\n  assign dec_remu = (opcode == 7'b0110011) && (funct3 == 3'b111) && (funct7 == 7'b0000001);\n\n  // Decode logic for instruction set flags\n  assign dec_rv32 = 1'b1; // Assuming only RV32 instructions are used\n\n  // Decode logic for branch and jump instructions\n  assign dec_bjp = (opcode == 7'b1100011) || // Branches\n                   (opcode == 7'b1101111) || // JAL\n                   (opcode == 7'b1100111);   // JALR\n\n  assign dec_jal = (opcode == 7'b1101111);\n  assign dec_jalr = (opcode == 7'b1100111);\n  assign dec_bxx = (opcode == 7'b1100011);\n\n  // Immediate extraction for branch/jump instructions\n  assign dec_bjp_imm = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 13, "code": "module e203_ifu_ift2icb (\n    input wire itcm_nohold,\n    input wire ifu_req_valid,\n    input wire [PC_SIZE-1:0] ifu_req_pc,\n    input wire ifu_req_seq,\n    input wire ifu_req_seq_rv32,\n    input wire [PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_ready,\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_ready,\n    output wire ifu_rsp_valid,\n    output wire ifu_rsp_err,\n    output wire [31:0] ifu_rsp_instr,\n    output wire ifu2itcm_icb_cmd_valid,\n    input wire ifu2itcm_icb_cmd_ready,\n    output wire [ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_rsp_valid,\n    output wire ifu2itcm_icb_rsp_ready,\n    input wire ifu2itcm_icb_rsp_err,\n    input wire [ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    output wire ifu2biu_icb_cmd_valid,\n    input wire ifu2biu_icb_cmd_ready,\n    output wire [ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input wire ifu2biu_icb_rsp_valid,\n    output wire ifu2biu_icb_rsp_ready,\n    input wire ifu2biu_icb_rsp_err,\n    input wire [SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata\n);\n\n    // State definitions\n    localparam ICB_STATE_IDLE = 2'b00;\n    localparam ICB_STATE_1ST = 2'b01;\n    localparam ICB_STATE_WAIT2ND = 2'b10;\n    localparam ICB_STATE_2ND = 2'b11;\n\n    // State registers\n    reg [1:0] icb_state;\n    reg [1:0] icb_state_nxt;\n\n    // Control signals\n    wire icb_state_ena;\n    wire state_idle_exit_ena;\n    wire [31:0] ifu_rsp_bypbuf_i_data;\n    wire [31:0] ifu_rsp_bypbuf_o_data;\n    wire ifu_rsp_bypbuf_i_vld;\n    wire ifu_rsp_bypbuf_o_vld;\n    wire ifu_rsp_bypbuf_i_rdy;\n    wire ifu_rsp_bypbuf_o_rdy;\n\n    // Bypass buffer instantiation\n    sirv_gnrl_bypbuf #(\n        .DP(1),\n        .DW(32)\n    ) u_ifu_rsp_bypbuf (\n        .i_vld(ifu_rsp_bypbuf_i_vld),\n        .i_rdy(ifu_rsp_bypbuf_i_rdy),\n        .i_dat(ifu_rsp_bypbuf_i_data),\n        .o_vld(ifu_rsp_bypbuf_o_vld),\n        .o_rdy(ifu_rsp_bypbuf_o_rdy),\n        .o_dat(ifu_rsp_bypbuf_o_data),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\n    // State machine logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            icb_state <= ICB_STATE_IDLE;\n        end else if (icb_state_ena) begin\n            icb_state <= icb_state_nxt;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        icb_state_nxt = icb_state; // Default to hold state\n        case (icb_state)\n            ICB_STATE_IDLE: begin\n                if (ifu_req_valid && ifu_req_ready) begin\n                    icb_state_nxt = ICB_STATE_1ST;\n                end\n            end\n            ICB_STATE_1ST: begin\n                if (ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid) begin\n                    icb_state_nxt = ICB_STATE_IDLE;\n                end\n            end\n            // Additional states and transitions as needed\n        endcase\n    end\n\n    // Output logic\n    assign ifu_req_ready = (icb_state == ICB_STATE_IDLE);\n    assign ifu_rsp_valid = ifu_rsp_bypbuf_o_vld;\n    assign ifu_rsp_err = ifu_rsp_bypbuf_o_data[32];\n    assign ifu_rsp_instr = ifu_rsp_bypbuf_o_data[31:0];\n\n    // ICB command logic\n    assign ifu2itcm_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && (ifu_req_pc < SOME_ITCM_ADDR_LIMIT);\n    assign ifu2itcm_icb_cmd_addr = ifu_req_pc[ITCM_ADDR_WIDTH-1:0];\n    assign ifu2itcm_icb_rsp_ready = (icb_state == ICB_STATE_1ST);\n\n    // More logic as needed based on the detailed design requirements\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 14, "code": "module e203_ifu_ift2icb (\n    input wire itcm_nohold,\n    input wire ifu_req_valid,\n    input wire [PC_SIZE-1:0] ifu_req_pc,\n    input wire ifu_req_seq,\n    input wire ifu_req_seq_rv32,\n    input wire [PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_ready,\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_ready,\n    output wire ifu_rsp_valid,\n    output wire ifu_rsp_err,\n    output wire [31:0] ifu_rsp_instr,\n    output wire ifu2itcm_icb_cmd_valid,\n    input wire ifu2itcm_icb_cmd_ready,\n    output wire [ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_rsp_valid,\n    output wire ifu2itcm_icb_rsp_ready,\n    input wire ifu2itcm_icb_rsp_err,\n    input wire [ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    output wire ifu2biu_icb_cmd_valid,\n    input wire ifu2biu_icb_cmd_ready,\n    output wire [ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input wire ifu2biu_icb_rsp_valid,\n    output wire ifu2biu_icb_rsp_ready,\n    input wire ifu2biu_icb_rsp_err,\n    input wire [SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata\n);\n\n    // State machine definition\n    reg [1:0] icb_state, icb_state_nxt;\n    localparam ICB_STATE_IDLE = 2'b00;\n    localparam ICB_STATE_1ST = 2'b01;\n    localparam ICB_STATE_WAIT2ND = 2'b10;\n    localparam ICB_STATE_2ND = 2'b11;\n\n    // State transition and output logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            icb_state <= ICB_STATE_IDLE;\n        end else begin\n            icb_state <= icb_state_nxt;\n        end\n    end\n\n    always @(*) begin\n        case (icb_state)\n            ICB_STATE_IDLE: begin\n                if (ifu_req_valid && ifu_req_ready)\n                    icb_state_nxt = ICB_STATE_1ST;\n                else\n                    icb_state_nxt = ICB_STATE_IDLE;\n            end\n            ICB_STATE_1ST: begin\n                if (ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid)\n                    icb_state_nxt = ICB_STATE_WAIT2ND;\n                else\n                    icb_state_nxt = ICB_STATE_1ST;\n            end\n            ICB_STATE_WAIT2ND: begin\n                if (ifu2itcm_icb_cmd_ready || ifu2biu_icb_cmd_ready)\n                    icb_state_nxt = ICB_STATE_2ND;\n                else\n                    icb_state_nxt = ICB_STATE_WAIT2ND;\n            end\n            ICB_STATE_2ND: begin\n                if (ifu_rsp_ready)\n                    icb_state_nxt = ICB_STATE_IDLE;\n                else\n                    icb_state_nxt = ICB_STATE_2ND;\n            end\n            default: icb_state_nxt = ICB_STATE_IDLE;\n        endcase\n    end\n\n    // Output logic for command and response interfaces\n    assign ifu_req_ready = (icb_state == ICB_STATE_IDLE);\n    assign ifu_rsp_valid = (icb_state == ICB_STATE_2ND) && (ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid);\n    assign ifu_rsp_err = (icb_state == ICB_STATE_2ND) && (ifu2itcm_icb_rsp_err || ifu2biu_icb_rsp_err);\n    assign ifu_rsp_instr = (icb_state == ICB_STATE_2ND) ? (ifu2itcm_icb_rsp_rdata[31:0] : ifu2biu_icb_rsp_rdata[31:0]);\n\n    // Command generation for ITCM and BIU\n    assign ifu2itcm_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && (ifu_req_pc < `ITCM_ADDR_LIMIT);\n    assign ifu2itcm_icb_cmd_addr = ifu_req_pc[ITCM_ADDR_WIDTH-1:0];\n    assign ifu2biu_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && (ifu_req_pc >= `ITCM_ADDR_LIMIT);\n    assign ifu2biu_icb_cmd_addr = ifu_req_pc[ADDR_SIZE-1:0];\n\n    // Response handling\n    assign ifu2itcm_icb_rsp_ready = (icb_state == ICB_STATE_2ND);\n    assign ifu2biu_icb_rsp_ready = (icb_state == ICB_STATE_2ND);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 15, "code": "module e203_ifu_ift2icb (\n    input wire itcm_nohold,\n    input wire ifu_req_valid,\n    input wire [PC_SIZE-1:0] ifu_req_pc,\n    input wire ifu_req_seq,\n    input wire ifu_req_seq_rv32,\n    input wire [PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_ready,\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_ready,\n    output wire ifu_rsp_valid,\n    output wire ifu_rsp_err,\n    output wire [31:0] ifu_rsp_instr,\n    output wire ifu2itcm_icb_cmd_valid,\n    input wire ifu2itcm_icb_cmd_ready,\n    output wire [ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_rsp_valid,\n    output wire ifu2itcm_icb_rsp_ready,\n    input wire ifu2itcm_icb_rsp_err,\n    input wire [ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    output wire ifu2biu_icb_cmd_valid,\n    input wire ifu2biu_icb_cmd_ready,\n    output wire [ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input wire ifu2biu_icb_rsp_valid,\n    output wire ifu2biu_icb_rsp_ready,\n    input wire ifu2biu_icb_rsp_err,\n    input wire [SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata\n);\n\n    // State definitions\n    localparam ICB_STATE_IDLE = 2'b00;\n    localparam ICB_STATE_1ST = 2'b01;\n    localparam ICB_STATE_WAIT2ND = 2'b10;\n    localparam ICB_STATE_2ND = 2'b11;\n\n    // State registers\n    reg [1:0] icb_state;\n    reg [1:0] icb_state_nxt;\n\n    // Handshake signals\n    wire ifu_req_hsked = ifu_req_valid && ifu_req_ready;\n    wire ifu_icb_cmd_hsked = ifu2itcm_icb_cmd_valid && ifu2itcm_icb_cmd_ready;\n    wire ifu_icb_rsp_hsked = ifu2itcm_icb_rsp_valid && ifu2itcm_icb_rsp_ready;\n    wire i_ifu_rsp_hsked = ifu_rsp_valid && ifu_rsp_ready;\n\n    // Next state logic\n    always @(*) begin\n        case (icb_state)\n            ICB_STATE_IDLE: icb_state_nxt = ifu_req_hsked ? ICB_STATE_1ST : ICB_STATE_IDLE;\n            ICB_STATE_1ST: icb_state_nxt = ifu_icb_rsp_hsked ? ICB_STATE_WAIT2ND : ICB_STATE_1ST;\n            ICB_STATE_WAIT2ND: icb_state_nxt = ifu_icb_cmd_ready ? ICB_STATE_2ND : ICB_STATE_WAIT2ND;\n            ICB_STATE_2ND: icb_state_nxt = i_ifu_rsp_hsked ? ICB_STATE_IDLE : ICB_STATE_2ND;\n            default: icb_state_nxt = ICB_STATE_IDLE;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            icb_state <= ICB_STATE_IDLE;\n        else\n            icb_state <= icb_state_nxt;\n    end\n\n    // Output logic\n    assign ifu_req_ready = (icb_state == ICB_STATE_IDLE);\n    assign ifu_rsp_valid = (icb_state == ICB_STATE_2ND);\n    assign ifu_rsp_err = ifu2itcm_icb_rsp_err;\n    assign ifu_rsp_instr = ifu2itcm_icb_rsp_rdata[31:0];\n\n    // ICB command interface\n    assign ifu2itcm_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && ifu_req_valid;\n    assign ifu2itcm_icb_cmd_addr = ifu_req_pc[ITCM_ADDR_WIDTH-1:0];\n    assign ifu2itcm_icb_rsp_ready = (icb_state == ICB_STATE_1ST);\n\n    // System memory interface\n    assign ifu2biu_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && ifu_req_valid;\n    assign ifu2biu_icb_cmd_addr = ifu_req_pc[ADDR_SIZE-1:0];\n    assign ifu2biu_icb_rsp_ready = (icb_state == ICB_STATE_1ST);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 16, "code": "module e203_ifu(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire itcm_nohold,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input wire pipe_flush_req,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire ifu_active,\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    output wire pipe_flush_ack,\n    input wire ifu_halt_req,\n    output wire ifu_halt_ack,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu\n);\n\n    // Internal signals\n    wire ifu_req_valid;\n    wire [E203_PC_SIZE-1:0] ifu_req_pc;\n    wire ifu_req_seq;\n    wire ifu_req_seq_rv32;\n    wire [E203_PC_SIZE-1:0] ifu_req_last_pc;\n    wire ifu_req_ready;\n    wire ifu_rsp_valid;\n    wire ifu_rsp_err;\n    wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr;\n\n    // Instantiate the instruction fetch module\n    e203_ifu_ifetch ifetch (\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ifu_o_ready(ifu_o_ready),\n        .pipe_flush_req(pipe_flush_req),\n        .pipe_flush_add_op1(pipe_flush_add_op1),\n        .pipe_flush_add_op2(pipe_flush_add_op2),\n        .ifu_halt_req(ifu_halt_req),\n        .oitf_empty(oitf_empty),\n        .rf2ifu_x1(rf2ifu_x1),\n        .rf2ifu_rs1(rf2ifu_rs1),\n        .dec2ifu_rden(dec2ifu_rden),\n        .dec2ifu_rs1en(dec2ifu_rs1en),\n        .dec2ifu_rdidx(dec2ifu_rdidx),\n        .dec2ifu_mulhsu(dec2ifu_mulhsu),\n        .dec2ifu_div(dec2ifu_div),\n        .dec2ifu_rem(dec2ifu_rem),\n        .dec2ifu_divu(dec2ifu_divu),\n        .dec2ifu_remu(dec2ifu_remu),\n        .inspect_pc(inspect_pc),\n        .ifu_req_valid(ifu_req_valid),\n        .ifu_req_pc(ifu_req_pc),\n        .ifu_req_seq(ifu_req_seq),\n        .ifu_req_seq_rv32(ifu_req_seq_rv32),\n        .ifu_req_last_pc(ifu_req_last_pc),\n        .pipe_flush_ack(pipe_flush_ack),\n        .ifu_halt_ack(ifu_halt_ack),\n        .ifu_o_ir(ifu_o_ir),\n        .ifu_o_pc(ifu_o_pc),\n        .ifu_o_pc_vld(ifu_o_pc_vld),\n        .ifu_o_misalgn(ifu_o_misalgn),\n        .ifu_o_buserr(ifu_o_buserr),\n        .ifu_o_rs1idx(ifu_o_rs1idx),\n        .ifu_o_rs2idx(ifu_o_rs2idx),\n        .ifu_o_prdt_taken(ifu_o_prdt_taken),\n        .ifu_o_muldiv_b2b(ifu_o_muldiv_b2b),\n        .ifu_o_valid(ifu_o_valid)\n    );\n\n    // Instantiate the IFT to ICB bridge module\n    e203_ifu_ift2icb ift2icb (\n        .clk(clk),\n        .rst_n(rst_n),\n        .ifu_req_valid(ifu_req_valid),\n        .ifu_req_pc(ifu_req_pc),\n        .ifu_req_seq(ifu_req_seq),\n        .ifu_req_seq_rv32(ifu_req_seq_rv32),\n        .ifu_req_last_pc(ifu_req_last_pc),\n        .ifu_rsp_ready(ifu_o_ready),\n        .itcm_nohold(itcm_nohold),\n        .ifu_req_ready(ifu_req_ready),\n        .ifu_rsp_valid(ifu_rsp_valid),\n        .ifu_rsp_err(ifu_rsp_err),\n        .ifu_rsp_instr(ifu_rsp_instr)\n    );\n\n    // Logic to handle IFU activity status\n    assign ifu_active = ifu_req_valid || ifu_rsp_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 11, "code": "module e203_lsu_ctrl(\n    input wire commit_mret,\n    input wire commit_trap,\n    output wire lsu_ctrl_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    input wire nice_mem_holdup,\n    input wire nice_icb_cmd_valid,\n    output wire nice_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] nice_icb_cmd_addr,\n    input wire nice_icb_cmd_read,\n    input wire [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] nice_icb_cmd_wmask,\n    output wire nice_icb_rsp_valid,\n    input wire nice_icb_rsp_ready,\n    output wire nice_icb_rsp_err,\n    output wire [E203_XLEN-1:0] nice_icb_rsp_rdata,\n\n    output wire dcache_icb_cmd_valid,\n    input wire dcache_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] dcache_icb_cmd_addr,\n    output wire dcache_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dcache_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dcache_icb_cmd_wmask,\n    output wire dcache_icb_cmd_lock,\n    output wire dcache_icb_cmd_excl,\n    output wire [1:0] dcache_icb_cmd_size,\n    input wire dcache_icb_rsp_valid,\n    output wire dcache_icb_rsp_ready,\n    input wire dcache_icb_rsp_err,\n    input wire dcache_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dcache_icb_rsp_rdata,\n\n    output wire dtcm_icb_cmd_valid,\n    input wire dtcm_icb_cmd_ready,\n    output wire [E203_DTCM_ADDR_WIDTH-1:0] dtcm_icb_cmd_addr,\n    output wire dtcm_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dtcm_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dtcm_icb_cmd_wmask,\n    output wire dtcm_icb_cmd_lock,\n    output wire dtcm_icb_cmd_excl,\n    output wire [1:0] dtcm_icb_cmd_size,\n    input wire dtcm_icb_rsp_valid,\n    output wire dtcm_icb_rsp_ready,\n    input wire dtcm_icb_rsp_err,\n    input wire dtcm_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dtcm_icb_rsp_rdata,\n    input wire [E203_ADDR_SIZE-1:0] dtcm_region_indic,\n\n    output wire biu_icb_cmd_valid,\n    input wire biu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,\n    output wire biu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] biu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] biu_icb_cmd_wmask,\n    output wire biu_icb_cmd_lock,\n    output wire biu_icb_cmd_excl,\n    output wire [1:0] biu_icb_cmd_size,\n    input wire biu_icb_rsp_valid,\n    output wire biu_icb_rsp_ready,\n    input wire biu_icb_rsp_err,\n    input wire biu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] biu_icb_rsp_rdata\n);\n    // LSU control logic implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 17, "code": "module e203_ifu(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire itcm_nohold,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire ifu_active,\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    input wire pipe_flush_req,\n    output wire pipe_flush_ack,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input wire ifu_halt_req,\n    output wire ifu_halt_ack,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu\n);\n\n    // Internal signals for submodule connections\n    wire ifu_req_valid;\n    wire [E203_PC_SIZE-1:0] ifu_req_pc;\n    wire ifu_req_seq;\n    wire ifu_req_seq_rv32;\n    wire [E203_PC_SIZE-1:0] ifu_req_last_pc;\n    wire ifu_req_ready;\n    wire ifu_rsp_valid;\n    wire ifu_rsp_err;\n    wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr;\n\n    // Instantiate the IFU fetch module\n    e203_ifu_ifetch ifetch (\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ifu_o_ready(ifu_o_ready),\n        .pipe_flush_req(pipe_flush_req),\n        .pipe_flush_add_op1(pipe_flush_add_op1),\n        .pipe_flush_add_op2(pipe_flush_add_op2),\n        .ifu_halt_req(ifu_halt_req),\n        .oitf_empty(oitf_empty),\n        .rf2ifu_x1(rf2ifu_x1),\n        .rf2ifu_rs1(rf2ifu_rs1),\n        .dec2ifu_rden(dec2ifu_rden),\n        .dec2ifu_rs1en(dec2ifu_rs1en),\n        .dec2ifu_rdidx(dec2ifu_rdidx),\n        .dec2ifu_mulhsu(dec2ifu_mulhsu),\n        .dec2ifu_div(dec2ifu_div),\n        .dec2ifu_rem(dec2ifu_rem),\n        .dec2ifu_divu(dec2ifu_divu),\n        .dec2ifu_remu(dec2ifu_remu),\n        .inspect_pc(inspect_pc),\n        .ifu_req_valid(ifu_req_valid),\n        .ifu_req_pc(ifu_req_pc),\n        .ifu_req_seq(ifu_req_seq),\n        .ifu_req_seq_rv32(ifu_req_seq_rv32),\n        .ifu_req_last_pc(ifu_req_last_pc),\n        .pipe_flush_ack(pipe_flush_ack),\n        .ifu_halt_ack(ifu_halt_ack),\n        .ifu_o_ir(ifu_o_ir),\n        .ifu_o_pc(ifu_o_pc),\n        .ifu_o_pc_vld(ifu_o_pc_vld),\n        .ifu_o_misalgn(ifu_o_misalgn),\n        .ifu_o_buserr(ifu_o_buserr),\n        .ifu_o_rs1idx(ifu_o_rs1idx),\n        .ifu_o_rs2idx(ifu_o_rs2idx),\n        .ifu_o_prdt_taken(ifu_o_prdt_taken),\n        .ifu_o_muldiv_b2b(ifu_o_muldiv_b2b),\n        .ifu_o_valid(ifu_o_valid)\n    );\n\n    // Instantiate the IFT to ICB converter module\n    e203_ifu_ift2icb ift2icb (\n        .clk(clk),\n        .rst_n(rst_n),\n        .ifu_req_valid(ifu_req_valid),\n        .ifu_req_pc(ifu_req_pc),\n        .ifu_req_seq(ifu_req_seq),\n        .ifu_req_seq_rv32(ifu_req_seq_rv32),\n        .ifu_req_last_pc(ifu_req_last_pc),\n        .ifu_rsp_ready(ifu_o_ready),\n        .itcm_nohold(itcm_nohold),\n        .ifu_req_ready(ifu_req_ready),\n        .ifu_rsp_valid(ifu_rsp_valid),\n        .ifu_rsp_err(ifu_rsp_err),\n        .ifu_rsp_instr(ifu_rsp_instr)\n    );\n\n    // Additional logic for IFU activity indicator\n    assign ifu_active = ifu_req_valid || ifu_rsp_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 12, "code": "module e203_lsu_ctrl (\n    input wire commit_mret,\n    input wire commit_trap,\n    output wire lsu_ctrl_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    input wire nice_mem_holdup,\n    input wire nice_icb_cmd_valid,\n    output wire nice_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] nice_icb_cmd_addr,\n    input wire nice_icb_cmd_read,\n    input wire [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] nice_icb_cmd_wmask,\n    output wire nice_icb_rsp_valid,\n    input wire nice_icb_rsp_ready,\n    output wire nice_icb_rsp_err,\n    output wire [E203_XLEN-1:0] nice_icb_rsp_rdata,\n\n    output wire dcache_icb_cmd_valid,\n    input wire dcache_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] dcache_icb_cmd_addr,\n    output wire dcache_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dcache_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dcache_icb_cmd_wmask,\n    output wire dcache_icb_cmd_lock,\n    output wire dcache_icb_cmd_excl,\n    output wire [1:0] dcache_icb_cmd_size,\n    input wire dcache_icb_rsp_valid,\n    output wire dcache_icb_rsp_ready,\n    input wire dcache_icb_rsp_err,\n    input wire dcache_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dcache_icb_rsp_rdata,\n\n    output wire dtcm_icb_cmd_valid,\n    input wire dtcm_icb_cmd_ready,\n    output wire [E203_DTCM_ADDR_WIDTH-1:0] dtcm_icb_cmd_addr,\n    output wire dtcm_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dtcm_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dtcm_icb_cmd_wmask,\n    output wire dtcm_icb_cmd_lock,\n    output wire dtcm_icb_cmd_excl,\n    output wire [1:0] dtcm_icb_cmd_size,\n    input wire dtcm_icb_rsp_valid,\n    output wire dtcm_icb_rsp_ready,\n    input wire dtcm_icb_rsp_err,\n    input wire dtcm_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dtcm_icb_rsp_rdata,\n    input wire [E203_ADDR_SIZE-1:0] dtcm_region_indic,\n\n    output wire biu_icb_cmd_valid,\n    input wire biu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,\n    output wire biu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] biu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] biu_icb_cmd_wmask,\n    output wire biu_icb_cmd_lock,\n    output wire biu_icb_cmd_excl,\n    output wire [1:0] biu_icb_cmd_size,\n    input wire biu_icb_rsp_valid,\n    output wire biu_icb_rsp_ready,\n    input wire biu_icb_rsp_err,\n    input wire biu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] biu_icb_rsp_rdata\n);\n    // Implementation of LSU control logic here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 16, "code": "module e203_ifu_ift2icb (\n    input wire itcm_nohold,\n    input wire ifu_req_valid,\n    input wire [PC_SIZE-1:0] ifu_req_pc,\n    input wire ifu_req_seq,\n    input wire ifu_req_seq_rv32,\n    input wire [PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_ready,\n    input wire clk,\n    input wire rst_n,\n\n    output reg ifu_req_ready,\n    output reg ifu_rsp_valid,\n    output reg ifu_rsp_err,\n    output reg [31:0] ifu_rsp_instr,\n\n    output reg ifu2itcm_icb_cmd_valid,\n    input wire ifu2itcm_icb_cmd_ready,\n    output reg [ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_rsp_valid,\n    output reg ifu2itcm_icb_rsp_ready,\n    input wire ifu2itcm_icb_rsp_err,\n    input wire [ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n\n    output reg ifu2biu_icb_cmd_valid,\n    input wire ifu2biu_icb_cmd_ready,\n    output reg [ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input wire ifu2biu_icb_rsp_valid,\n    output reg ifu2biu_icb_rsp_ready,\n    input wire ifu2biu_icb_rsp_err,\n    input wire [SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata\n);\n\n    // State machine encoding\n    localparam ICB_STATE_IDLE = 2'b00;\n    localparam ICB_STATE_1ST = 2'b01;\n    localparam ICB_STATE_WAIT2ND = 2'b10;\n    localparam ICB_STATE_2ND = 2'b11;\n\n    reg [1:0] icb_state, icb_state_nxt;\n\n    // Handshake signals\n    wire ifu_req_hsked = ifu_req_valid && ifu_req_ready;\n    wire ifu_icb_cmd_hsked = ifu2itcm_icb_cmd_valid && ifu2itcm_icb_cmd_ready;\n    wire ifu_icb_rsp_hsked = ifu2itcm_icb_rsp_valid && ifu2itcm_icb_rsp_ready;\n    wire i_ifu_rsp_hsked = ifu_rsp_valid && ifu_rsp_ready;\n\n    // Next state logic\n    always @(*) begin\n        case (icb_state)\n            ICB_STATE_IDLE: begin\n                if (ifu_req_hsked)\n                    icb_state_nxt = ICB_STATE_1ST;\n                else\n                    icb_state_nxt = ICB_STATE_IDLE;\n            end\n            ICB_STATE_1ST: begin\n                if (ifu_icb_rsp_hsked)\n                    icb_state_nxt = ICB_STATE_WAIT2ND;\n                else\n                    icb_state_nxt = ICB_STATE_1ST;\n            end\n            ICB_STATE_WAIT2ND: begin\n                if (ifu_icb_cmd_ready)\n                    icb_state_nxt = ICB_STATE_2ND;\n                else\n                    icb_state_nxt = ICB_STATE_WAIT2ND;\n            end\n            ICB_STATE_2ND: begin\n                if (i_ifu_rsp_hsked)\n                    icb_state_nxt = ICB_STATE_IDLE;\n                else\n                    icb_state_nxt = ICB_STATE_2ND;\n            end\n            default: icb_state_nxt = ICB_STATE_IDLE;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            icb_state <= ICB_STATE_IDLE;\n        else\n            icb_state <= icb_state_nxt;\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (icb_state == ICB_STATE_1ST && ifu_icb_rsp_hsked) begin\n            ifu_rsp_valid <= 1'b1;\n            ifu_rsp_instr <= ifu2itcm_icb_rsp_rdata[31:0]; // Assuming ITCM_DATA_WIDTH is 32\n            ifu_rsp_err <= ifu2itcm_icb_rsp_err;\n        end\n        else begin\n            ifu_rsp_valid <= 1'b0;\n            ifu_rsp_err <= 1'b0;\n        end\n    end\n\n    // Command generation\n    always @(posedge clk) begin\n        if (icb_state == ICB_STATE_IDLE && ifu_req_hsked) begin\n            ifu2itcm_icb_cmd_valid <= 1'b1;\n            ifu2itcm_icb_cmd_addr <= ifu_req_pc[ITCM_ADDR_WIDTH-1:0];\n        end\n        else if (icb_state == ICB_STATE_WAIT2ND && ifu_icb_cmd_ready) begin\n            ifu2itcm_icb_cmd_valid <= 1'b1;\n            ifu2itcm_icb_cmd_addr <= ifu_req_last_pc[ITCM_ADDR_WIDTH-1:0] + 4; // Example increment\n        end\n        else begin\n            ifu2itcm_icb_cmd_valid <= 1'b0;\n        end\n    end\n\n    // Response handling\n    always @(posedge clk) begin\n        ifu2itcm_icb_rsp_ready <= (icb_state == ICB_STATE_1ST);\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 18, "code": "module e203_ifu(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire itcm_nohold,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input wire pipe_flush_req,\n    input wire ifu_halt_req,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire ifu_active,\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    output wire pipe_flush_ack,\n    input wire ifu2itcm_holdup,\n    input wire [E203_ADDR_SIZE-1:0] itcm_region_indic,\n    output wire ifu2itcm_icb_cmd_valid,\n    input wire ifu2itcm_icb_cmd_ready,\n    output wire [E203_ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_rsp_valid,\n    output wire ifu2itcm_icb_rsp_ready,\n    input wire ifu2itcm_icb_rsp_err,\n    input wire [E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    output wire ifu2biu_icb_cmd_valid,\n    input wire ifu2biu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input wire ifu2biu_icb_rsp_valid,\n    output wire ifu2biu_icb_rsp_ready,\n    input wire ifu2biu_icb_rsp_err,\n    input wire [E203_SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata,\n    output wire ifu_halt_ack\n);\n\n    // Internal signals\n    wire [E203_PC_SIZE-1:0] current_pc;\n    wire fetch_valid;\n    wire [E203_INSTR_SIZE-1:0] fetched_instr;\n    wire fetch_ready;\n    wire fetch_error;\n    wire [E203_PC_SIZE-1:0] next_pc;\n    wire branch_taken;\n\n    // Instantiate IFU Fetch module\n    e203_ifu_ifetch ifetch (\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ifu_o_ready(ifu_o_ready),\n        .pipe_flush_req(pipe_flush_req),\n        .pipe_flush_add_op1(pipe_flush_add_op1),\n        .pipe_flush_add_op2(pipe_flush_add_op2),\n        .ifu_halt_req(ifu_halt_req),\n        .oitf_empty(oitf_empty),\n        .rf2ifu_x1(rf2ifu_x1),\n        .rf2ifu_rs1(rf2ifu_rs1),\n        .dec2ifu_rden(dec2ifu_rden),\n        .dec2ifu_rs1en(dec2ifu_rs1en),\n        .dec2ifu_rdidx(dec2ifu_rdidx),\n        .dec2ifu_mulhsu(dec2ifu_mulhsu),\n        .dec2ifu_div(dec2ifu_div),\n        .dec2ifu_rem(dec2ifu_rem),\n        .dec2ifu_divu(dec2ifu_divu),\n        .dec2ifu_remu(dec2ifu_remu),\n        .inspect_pc(inspect_pc),\n        .ifu_req_valid(fetch_valid),\n        .ifu_req_pc(current_pc),\n        .ifu_req_seq(branch_taken),\n        .ifu_req_last_pc(next_pc),\n        .pipe_flush_ack(pipe_flush_ack),\n        .ifu_halt_ack(ifu_halt_ack),\n        .ifu_o_ir(fetched_instr),\n        .ifu_o_pc(ifu_o_pc),\n        .ifu_o_pc_vld(ifu_o_pc_vld),\n        .ifu_o_misalgn(ifu_o_misalgn),\n        .ifu_o_buserr(ifu_o_buserr),\n        .ifu_o_rs1idx(ifu_o_rs1idx),\n        .ifu_o_rs2idx(ifu_o_rs2idx),\n        .ifu_o_prdt_taken(branch_taken),\n        .ifu_o_muldiv_b2b(ifu_o_muldiv_b2b),\n        .ifu_o_valid(ifu_o_valid)\n    );\n\n    // Instantiate IFU to ICB Interface module\n    e203_ifu_ift2icb ift2icb (\n        .clk(clk),\n        .rst_n(rst_n),\n        .ifu_req_valid(fetch_valid),\n        .ifu_req_pc(current_pc),\n        .ifu_req_seq(branch_taken),\n        .ifu_req_last_pc(next_pc),\n        .ifu_rsp_ready(fetch_ready),\n        .itcm_nohold(itcm_nohold),\n        .itcm_region_indic(itcm_region_indic),\n        .ifu2itcm_icb_cmd_ready(ifu2itcm_icb_cmd_ready),\n        .ifu2itcm_icb_rsp_valid(ifu2itcm_icb_rsp_valid),\n        .ifu2itcm_icb_rsp_err(ifu2itcm_icb_rsp_err),\n        .ifu2itcm_icb_rsp_rdata(ifu2itcm_icb_rsp_rdata),\n        .ifu2biu_icb_cmd_ready(ifu2biu_icb_cmd_ready),\n        .ifu2biu_icb_rsp_valid(ifu2biu_icb_rsp_valid),\n        .ifu2biu_icb_rsp_err(ifu2biu_icb_rsp_err),\n        .ifu2biu_icb_rsp_rdata(ifu2biu_icb_rsp_rdata),\n        .ifu_req_ready(fetch_ready),\n        .ifu_rsp_valid(fetch_valid),\n        .ifu_rsp_err(fetch_error),\n        .ifu_rsp_instr(fetched_instr),\n        .ifu2itcm_icb_cmd_valid(ifu2itcm_icb_cmd_valid),\n        .ifu2itcm_icb_cmd_addr(ifu2itcm_icb_cmd_addr),\n        .ifu2itcm_icb_rsp_ready(ifu2itcm_icb_rsp_ready),\n        .ifu2biu_icb_cmd_valid(ifu2biu_icb_cmd_valid),\n        .ifu2biu_icb_cmd_addr(ifu2biu_icb_cmd_addr),\n        .ifu2biu_icb_rsp_ready(ifu2biu_icb_rsp_ready)\n    );\n\n    // IFU activity indicator\n    assign ifu_active = fetch_valid || ifu_o_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 13, "code": "module e203_lsu_ctrl(\n    input wire commit_mret,\n    input wire commit_trap,\n    output wire lsu_ctrl_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    input wire nice_mem_holdup,\n    input wire nice_icb_cmd_valid,\n    output wire nice_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] nice_icb_cmd_addr,\n    input wire nice_icb_cmd_read,\n    input wire [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] nice_icb_cmd_wmask,\n    output wire nice_icb_rsp_valid,\n    input wire nice_icb_rsp_ready,\n    output wire nice_icb_rsp_err,\n    output wire [E203_XLEN-1:0] nice_icb_rsp_rdata,\n\n    output wire dcache_icb_cmd_valid,\n    input wire dcache_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] dcache_icb_cmd_addr,\n    output wire dcache_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dcache_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dcache_icb_cmd_wmask,\n    output wire dcache_icb_cmd_lock,\n    output wire dcache_icb_cmd_excl,\n    output wire [1:0] dcache_icb_cmd_size,\n    input wire dcache_icb_rsp_valid,\n    output wire dcache_icb_rsp_ready,\n    input wire dcache_icb_rsp_err,\n    input wire dcache_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dcache_icb_rsp_rdata,\n\n    output wire dtcm_icb_cmd_valid,\n    input wire dtcm_icb_cmd_ready,\n    output wire [E203_DTCM_ADDR_WIDTH-1:0] dtcm_icb_cmd_addr,\n    output wire dtcm_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dtcm_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dtcm_icb_cmd_wmask,\n    output wire dtcm_icb_cmd_lock,\n    output wire dtcm_icb_cmd_excl,\n    output wire [1:0] dtcm_icb_cmd_size,\n    input wire dtcm_icb_rsp_valid,\n    output wire dtcm_icb_rsp_ready,\n    input wire dtcm_icb_rsp_err,\n    input wire dtcm_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dtcm_icb_rsp_rdata,\n    input wire [E203_ADDR_SIZE-1:0] dtcm_region_indic,\n\n    output wire biu_icb_cmd_valid,\n    input wire biu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,\n    output wire biu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] biu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] biu_icb_cmd_wmask,\n    output wire biu_icb_cmd_lock,\n    output wire biu_icb_cmd_excl,\n    output wire [1:0] biu_icb_cmd_size,\n    input wire biu_icb_rsp_valid,\n    output wire biu_icb_rsp_ready,\n    input wire biu_icb_rsp_err,\n    input wire biu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] biu_icb_rsp_rdata\n);\n    // Implementation of LSU control logic here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 17, "code": "module e203_exu_disp(\n    input wfi_halt_exu_req,\n    output reg wfi_halt_exu_ack,\n    input oitf_empty,\n    input amo_wait,\n    input disp_i_valid,\n    output reg disp_i_ready,\n    input disp_i_rs1x0,\n    input disp_i_rs2x0,\n    input disp_i_rs1en,\n    input disp_i_rs2en,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input [E203_XLEN-1:0] disp_i_rs1,\n    input [E203_XLEN-1:0] disp_i_rs2,\n    input disp_i_rdwen,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input [E203_DECINFO_WIDTH-1:0] disp_i_info,\n    input [E203_XLEN-1:0] disp_i_imm,\n    input [E203_PC_SIZE-1:0] disp_i_pc,\n    input disp_i_misalgn,\n    input disp_i_buserr,\n    input disp_i_ilegl,\n    output reg disp_o_alu_valid,\n    input disp_o_alu_ready,\n    input disp_o_alu_longpipe,\n    output reg [E203_XLEN-1:0] disp_o_alu_rs1,\n    output reg [E203_XLEN-1:0] disp_o_alu_rs2,\n    output reg disp_o_alu_rdwen,\n    output reg [E203_RFIDX_WIDTH-1:0] disp_o_alu_rdidx,\n    output reg [E203_DECINFO_WIDTH-1:0] disp_o_alu_info,\n    output reg [E203_XLEN-1:0] disp_o_alu_imm,\n    output reg [E203_PC_SIZE-1:0] disp_o_alu_pc,\n    output reg [E203_ITAG_WIDTH-1:0] disp_o_alu_itag,\n    output reg disp_o_alu_misalgn,\n    output reg disp_o_alu_buserr,\n    output reg disp_o_alu_ilegl,\n    input oitfrd_match_disprs1,\n    input oitfrd_match_disprs2,\n    input oitfrd_match_disprs3,\n    input oitfrd_match_disprd,\n    input [E203_ITAG_WIDTH-1:0] disp_oitf_ptr,\n    output reg disp_oitf_ena,\n    input disp_oitf_ready,\n    output reg disp_oitf_rs1fpu,\n    output reg disp_oitf_rs2fpu,\n    output reg disp_oitf_rs3fpu,\n    output reg disp_oitf_rdfpu,\n    output reg disp_oitf_rs1en,\n    output reg disp_oitf_rs2en,\n    output reg disp_oitf_rs3en,\n    output reg disp_oitf_rdwen,\n    output reg [E203_RFIDX_WIDTH-1:0] disp_oitf_rs1idx,\n    output reg [E203_RFIDX_WIDTH-1:0] disp_oitf_rs2idx,\n    output reg [E203_RFIDX_WIDTH-1:0] disp_oitf_rs3idx,\n    output reg [E203_RFIDX_WIDTH-1:0] disp_oitf_rdidx,\n    output reg [E203_PC_SIZE-1:0] disp_oitf_pc,\n    input clk,\n    input rst_n\n);\n\n    always @(*) begin\n        // Default assignments\n        disp_i_ready = 1'b0;\n        disp_o_alu_valid = 1'b0;\n        disp_o_alu_rs1 = disp_i_rs1;\n        disp_o_alu_rs2 = disp_i_rs2;\n        disp_o_alu_rdwen = disp_i_rdwen;\n        disp_o_alu_rdidx = disp_i_rdidx;\n        disp_o_alu_info = disp_i_info;\n        disp_o_alu_imm = disp_i_imm;\n        disp_o_alu_pc = disp_i_pc;\n        disp_o_alu_itag = disp_oitf_ptr;\n        disp_o_alu_misalgn = disp_i_misalgn;\n        disp_o_alu_buserr = disp_i_buserr;\n        disp_o_alu_ilegl = disp_i_ilegl;\n        disp_oitf_ena = 1'b0;\n        disp_oitf_rs1fpu = 1'b0;\n        disp_oitf_rs2fpu = 1'b0;\n        disp_oitf_rs3fpu = 1'b0;\n        disp_oitf_rdfpu = 1'b0;\n        disp_oitf_rs1en = disp_i_rs1en;\n        disp_oitf_rs2en = disp_i_rs2en;\n        disp_oitf_rs3en = 1'b0;\n        disp_oitf_rdwen = disp_i_rdwen;\n        disp_oitf_rs1idx = disp_i_rs1idx;\n        disp_oitf_rs2idx = disp_i_rs2idx;\n        disp_oitf_rs3idx = 0;\n        disp_oitf_rdidx = disp_i_rdidx;\n        disp_oitf_pc = disp_i_pc;\n        wfi_halt_exu_ack = 1'b0;\n\n        // Handle WFI halt request\n        if (wfi_halt_exu_req && oitf_empty && !amo_wait) begin\n            wfi_halt_exu_ack = 1'b1;\n        end\n\n        // Dispatch logic\n        if (disp_i_valid && disp_o_alu_ready && !wfi_halt_exu_req && !amo_wait) begin\n            disp_i_ready = 1'b1;\n            disp_o_alu_valid = 1'b1;\n            disp_oitf_ena = disp_o_alu_longpipe && disp_oitf_ready;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 19, "code": "module e203_exu_excp(\n    input clk,\n    input rst_n,\n    output reg commit_trap,\n    output reg core_wfi,\n    output reg wfi_halt_ifu_req,\n    output reg wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input amo_wait,\n    input alu_excp_i_valid,\n    input alu_excp_i_ld,\n    input alu_excp_i_stamo,\n    input alu_excp_i_misalgn,\n    input alu_excp_i_buserr,\n    input alu_excp_i_ecall,\n    input alu_excp_i_ebreak,\n    input alu_excp_i_wfi,\n    input alu_excp_i_ifu_misalgn,\n    input alu_excp_i_ifu_buserr,\n    input alu_excp_i_ifu_ilegl,\n    input [E203_PC_SIZE-1:0] alu_excp_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_excp_i_instr,\n    input alu_excp_i_pc_vld,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input longp_excp_i_insterr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input excpirq_flush_ack,\n    output reg excpirq_flush_req,\n    output reg nonalu_excpirq_flush_req_raw,\n    output reg [E203_PC_SIZE-1:0] excpirq_flush_add_op1,\n    output reg [E203_PC_SIZE-1:0] excpirq_flush_add_op2,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input cmt_dret_ena,\n    input cmt_ena,\n    output reg [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output reg [E203_PC_SIZE-1:0] cmt_epc,\n    output reg [E203_XLEN-1:0] cmt_cause,\n    output reg cmt_badaddr_ena,\n    output reg cmt_epc_ena,\n    output reg cmt_cause_ena,\n    output reg cmt_status_ena,\n    output reg [E203_PC_SIZE-1:0] cmt_dpc,\n    output reg cmt_dpc_ena,\n    output reg [2:0] cmt_dcause,\n    output reg cmt_dcause_ena,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output reg excp_active\n);\n    // Implementation of exception handling logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            commit_trap <= 1'b0;\n            core_wfi <= 1'b0;\n            wfi_halt_ifu_req <= 1'b0;\n            wfi_halt_exu_req <= 1'b0;\n            excpirq_flush_req <= 1'b0;\n            nonalu_excpirq_flush_req_raw <= 1'b0;\n            excpirq_flush_add_op1 <= {E203_PC_SIZE{1'b0}};\n            excpirq_flush_add_op2 <= {E203_PC_SIZE{1'b0}};\n            cmt_badaddr <= {E203_ADDR_SIZE{1'b0}};\n            cmt_epc <= {E203_PC_SIZE{1'b0}};\n            cmt_cause <= {E203_XLEN{1'b0}};\n            cmt_badaddr_ena <= 1'b0;\n            cmt_epc_ena <= 1'b0;\n            cmt_cause_ena <= 1'b0;\n            cmt_status_ena <= 1'b0;\n            cmt_dpc <= {E203_PC_SIZE{1'b0}};\n            cmt_dpc_ena <= 1'b0;\n            cmt_dcause <= 3'b000;\n            cmt_dcause_ena <= 1'b0;\n            excp_active <= 1'b0;\n        end else begin\n            // Exception handling logic\n            // This is a simplified example and needs to be expanded based on actual requirements\n            if (alu_excp_i_valid) begin\n                excp_active <= 1'b1;\n                cmt_epc <= alu_excp_i_pc;\n                cmt_epc_ena <= 1'b1;\n                if (alu_excp_i_ecall) begin\n                    cmt_cause <= `E203_CAUSE_MACHINE_ECALL;\n                end else if (alu_excp_i_ebreak) begin\n                    cmt_cause <= `E203_CAUSE_BREAKPOINT;\n                end else if (alu_excp_i_misalgn) begin\n                    cmt_cause <= `E203_CAUSE_MISALIGNED_FETCH;\n                end\n                cmt_cause_ena <= 1'b1;\n            end\n            if (core_wfi && (dbg_irq_r || ext_irq_r || sft_irq_r || tmr_irq_r)) begin\n                core_wfi <= 1'b0;\n                wfi_halt_ifu_req <= 1'b0;\n                wfi_halt_exu_req <= 1'b0;\n            end\n            if (alu_excp_i_wfi) begin\n                core_wfi <= 1'b1;\n                wfi_halt_ifu_req <= 1'b1;\n                wfi_halt_exu_req <= 1'b1;\n            end\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 18, "code": "module e203_exu_disp(\n    input wire wfi_halt_exu_req,\n    output wire wfi_halt_exu_ack,\n    input wire oitf_empty,\n    input wire amo_wait,\n    input wire disp_i_valid,\n    output wire disp_i_ready,\n    input wire disp_i_rs1x0,\n    input wire disp_i_rs2x0,\n    input wire disp_i_rs1en,\n    input wire disp_i_rs2en,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input wire [E203_XLEN-1:0] disp_i_rs1,\n    input wire [E203_XLEN-1:0] disp_i_rs2,\n    input wire disp_i_rdwen,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input wire [E203_DECINFO_WIDTH-1:0] disp_i_info,\n    input wire [E203_XLEN-1:0] disp_i_imm,\n    input wire [E203_PC_SIZE-1:0] disp_i_pc,\n    input wire disp_i_misalgn,\n    input wire disp_i_buserr,\n    input wire disp_i_ilegl,\n    output wire disp_o_alu_valid,\n    input wire disp_o_alu_ready,\n    input wire disp_o_alu_longpipe,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs1,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs2,\n    output wire disp_o_alu_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_o_alu_rdidx,\n    output wire [E203_DECINFO_WIDTH-1:0] disp_o_alu_info,\n    output wire [E203_XLEN-1:0] disp_o_alu_imm,\n    output wire [E203_PC_SIZE-1:0] disp_o_alu_pc,\n    output wire [E203_ITAG_WIDTH-1:0] disp_o_alu_itag,\n    output wire disp_o_alu_misalgn,\n    output wire disp_o_alu_buserr,\n    output wire disp_o_alu_ilegl,\n    input wire oitfrd_match_disprs1,\n    input wire oitfrd_match_disprs2,\n    input wire oitfrd_match_disprs3,\n    input wire oitfrd_match_disprd,\n    input wire [E203_ITAG_WIDTH-1:0] disp_oitf_ptr,\n    output wire disp_oitf_ena,\n    input wire disp_oitf_ready,\n    output wire disp_oitf_rs1fpu,\n    output wire disp_oitf_rs2fpu,\n    output wire disp_oitf_rs3fpu,\n    output wire disp_oitf_rdfpu,\n    output wire disp_oitf_rs1en,\n    output wire disp_oitf_rs2en,\n    output wire disp_oitf_rs3en,\n    output wire disp_oitf_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs2idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs3idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rdidx,\n    output wire [E203_PC_SIZE-1:0] disp_oitf_pc,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Implementation of dispatch logic\n    // This is a placeholder for the actual dispatch logic\n    // which would include handling of various input signals\n    // and generation of output signals based on the E203 core's specification.\n\n    assign disp_i_ready = !disp_i_valid || disp_o_alu_ready;\n    assign disp_o_alu_valid = disp_i_valid && disp_o_alu_ready;\n    assign disp_o_alu_rs1 = disp_i_rs1;\n    assign disp_o_alu_rs2 = disp_i_rs2;\n    assign disp_o_alu_rdwen = disp_i_rdwen;\n    assign disp_o_alu_rdidx = disp_i_rdidx;\n    assign disp_o_alu_info = disp_i_info;\n    assign disp_o_alu_imm = disp_i_imm;\n    assign disp_o_alu_pc = disp_i_pc;\n    assign disp_o_alu_itag = disp_oitf_ptr;\n    assign disp_o_alu_misalgn = disp_i_misalgn;\n    assign disp_o_alu_buserr = disp_i_buserr;\n    assign disp_o_alu_ilegl = disp_i_ilegl;\n\n    // WFI handling\n    assign wfi_halt_exu_ack = wfi_halt_exu_req && oitf_empty && !amo_wait;\n\n    // OITF dispatch logic\n    assign disp_oitf_ena = disp_i_valid && disp_o_alu_ready && disp_o_alu_longpipe;\n    assign disp_oitf_rs1fpu = 0; // Assuming no FPU in this example\n    assign disp_oitf_rs2fpu = 0;\n    assign disp_oitf_rs3fpu = 0;\n    assign disp_oitf_rdfpu = 0;\n    assign disp_oitf_rs1en = disp_i_rs1en;\n    assign disp_oitf_rs2en = disp_i_rs2en;\n    assign disp_oitf_rs3en = 0; // Assuming no third operand\n    assign disp_oitf_rdwen = disp_i_rdwen;\n    assign disp_oitf_rs1idx = disp_i_rs1idx;\n    assign disp_oitf_rs2idx = disp_i_rs2idx;\n    assign disp_oitf_rs3idx = 0; // Assuming no third operand\n    assign disp_oitf_rdidx = disp_i_rdidx;\n    assign disp_oitf_pc = disp_i_pc;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 16, "code": "module itcm_controller #(\n    parameter ADDR_WIDTH = 32,\n    parameter DATA_WIDTH = 64,\n    parameter WMSK_WIDTH = DATA_WIDTH / 8,\n    parameter RAM_AW = 10,\n    parameter RAM_MW = WMSK_WIDTH,\n    parameter RAM_DW = DATA_WIDTH\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n\n    // IFU Interface\n    input wire ifu2itcm_icb_cmd_valid,\n    output wire ifu2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] ifu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] ifu2itcm_icb_cmd_wmask,\n    output wire ifu2itcm_icb_rsp_valid,\n    input wire ifu2itcm_icb_rsp_ready,\n    output wire ifu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n\n    // LSU Interface\n    input wire lsu2itcm_icb_cmd_valid,\n    output wire lsu2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] lsu2itcm_icb_cmd_addr,\n    input wire lsu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] lsu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] lsu2itcm_icb_cmd_wmask,\n    output wire lsu2itcm_icb_rsp_valid,\n    input wire lsu2itcm_icb_rsp_ready,\n    output wire lsu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] lsu2itcm_icb_rsp_rdata,\n\n    // RAM Interface\n    output wire itcm_ram_cs,\n    output wire itcm_ram_we,\n    output wire [RAM_AW-1:0] itcm_ram_addr,\n    output wire [RAM_MW-1:0] itcm_ram_wem,\n    output wire [RAM_DW-1:0] itcm_ram_din,\n    input wire [RAM_DW-1:0] itcm_ram_dout,\n    output wire clk_itcm_ram,\n\n    // Status Output\n    output wire itcm_active\n);\n\n    // Internal signals\n    reg [ADDR_WIDTH-1:0] addr_reg;\n    reg [DATA_WIDTH-1:0] wdata_reg;\n    reg [WMSK_WIDTH-1:0] wmask_reg;\n    reg we_reg;\n    reg cs_reg;\n    reg active_reg;\n\n    // Command arbitration logic\n    wire cmd_valid = ifu2itcm_icb_cmd_valid || lsu2itcm_icb_cmd_valid;\n    wire [ADDR_WIDTH-1:0] cmd_addr = ifu2itcm_icb_cmd_valid ? ifu2itcm_icb_cmd_addr : lsu2itcm_icb_cmd_addr;\n    wire cmd_read = ifu2itcm_icb_cmd_valid ? ifu2itcm_icb_cmd_read : lsu2itcm_icb_cmd_read;\n    wire [DATA_WIDTH-1:0] cmd_wdata = ifu2itcm_icb_cmd_valid ? ifu2itcm_icb_cmd_wdata : lsu2itcm_icb_cmd_wdata;\n    wire [WMSK_WIDTH-1:0] cmd_wmask = ifu2itcm_icb_cmd_valid ? ifu2itcm_icb_cmd_wmask : lsu2itcm_icb_cmd_wmask;\n\n    // Response logic\n    assign ifu2itcm_icb_rsp_valid = cs_reg && !cmd_read && ifu2itcm_icb_cmd_valid;\n    assign lsu2itcm_icb_rsp_valid = cs_reg && !cmd_read && lsu2itcm_icb_cmd_valid;\n    assign ifu2itcm_icb_rsp_rdata = itcm_ram_dout;\n    assign lsu2itcm_icb_rsp_rdata = itcm_ram_dout;\n    assign ifu2itcm_icb_rsp_err = 0;\n    assign lsu2itcm_icb_rsp_err = 0;\n\n    // RAM interface logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            addr_reg <= 0;\n            wdata_reg <= 0;\n            wmask_reg <= 0;\n            we_reg <= 0;\n            cs_reg <= 0;\n            active_reg <= 0;\n        end else begin\n            if (cmd_valid) begin\n                addr_reg <= cmd_addr;\n                wdata_reg <= cmd_wdata;\n                wmask_reg <= cmd_wmask;\n                we_reg <= !cmd_read;\n                cs_reg <= 1;\n                active_reg <= 1;\n            end else begin\n                cs_reg <= 0;\n                active_reg <= 0;\n            end\n        end\n    end\n\n    assign itcm_ram_cs = cs_reg;\n    assign itcm_ram_we = we_reg;\n    assign itcm_ram_addr = addr_reg[RAM_AW-1:0];\n    assign itcm_ram_wem = wmask_reg;\n    assign itcm_ram_din = wdata_reg;\n    assign clk_itcm_ram = clk;\n    assign itcm_active = active_reg;\n\n    // Clock gating logic\n    wire clk_gated = clk & ~tcm_cgstop;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 14, "code": "module e203_lsu_ctrl(\n    input wire commit_mret,\n    input wire commit_trap,\n    output wire lsu_ctrl_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    input wire nice_mem_holdup,\n    input wire nice_icb_cmd_valid,\n    output wire nice_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] nice_icb_cmd_addr,\n    input wire nice_icb_cmd_read,\n    input wire [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input wire [E203_XLEN/8-1:0] nice_icb_cmd_wmask,\n    output wire nice_icb_rsp_valid,\n    input wire nice_icb_rsp_ready,\n    output wire nice_icb_rsp_err,\n    output wire [E203_XLEN-1:0] nice_icb_rsp_rdata,\n\n    output wire dcache_icb_cmd_valid,\n    input wire dcache_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] dcache_icb_cmd_addr,\n    output wire dcache_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dcache_icb_cmd_wdata,\n    output wire [E203_XLEN/8-1:0] dcache_icb_cmd_wmask,\n    output wire dcache_icb_cmd_lock,\n    output wire dcache_icb_cmd_excl,\n    output wire [1:0] dcache_icb_cmd_size,\n    input wire dcache_icb_rsp_valid,\n    output wire dcache_icb_rsp_ready,\n    input wire dcache_icb_rsp_err,\n    input wire dcache_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dcache_icb_rsp_rdata,\n\n    output wire dtcm_icb_cmd_valid,\n    input wire dtcm_icb_cmd_ready,\n    output wire [E203_DTCM_ADDR_WIDTH-1:0] dtcm_icb_cmd_addr,\n    output wire dtcm_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dtcm_icb_cmd_wdata,\n    output wire [E203_XLEN/8-1:0] dtcm_icb_cmd_wmask,\n    output wire dtcm_icb_cmd_lock,\n    output wire dtcm_icb_cmd_excl,\n    output wire [1:0] dtcm_icb_cmd_size,\n    input wire dtcm_icb_rsp_valid,\n    output wire dtcm_icb_rsp_ready,\n    input wire dtcm_icb_rsp_err,\n    input wire dtcm_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dtcm_icb_rsp_rdata,\n    input wire [E203_ADDR_SIZE-1:0] dtcm_region_indic,\n\n    output wire biu_icb_cmd_valid,\n    input wire biu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,\n    output wire biu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] biu_icb_cmd_wdata,\n    output wire [E203_XLEN/8-1:0] biu_icb_cmd_wmask,\n    output wire biu_icb_cmd_lock,\n    output wire biu_icb_cmd_excl,\n    output wire [1:0] biu_icb_cmd_size,\n    input wire biu_icb_rsp_valid,\n    output wire biu_icb_rsp_ready,\n    input wire biu_icb_rsp_err,\n    input wire biu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] biu_icb_rsp_rdata\n);\n    // Module implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 15, "code": "module e203_lsu_ctrl(\n    input wire commit_mret,\n    input wire commit_trap,\n    output wire lsu_ctrl_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    input wire nice_mem_holdup,\n    input wire nice_icb_cmd_valid,\n    output wire nice_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] nice_icb_cmd_addr,\n    input wire nice_icb_cmd_read,\n    input wire [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] nice_icb_cmd_wmask,\n    output wire nice_icb_rsp_valid,\n    input wire nice_icb_rsp_ready,\n    output wire nice_icb_rsp_err,\n    output wire [E203_XLEN-1:0] nice_icb_rsp_rdata,\n\n    output wire dcache_icb_cmd_valid,\n    input wire dcache_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] dcache_icb_cmd_addr,\n    output wire dcache_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dcache_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dcache_icb_cmd_wmask,\n    output wire dcache_icb_cmd_lock,\n    output wire dcache_icb_cmd_excl,\n    output wire [1:0] dcache_icb_cmd_size,\n    input wire dcache_icb_rsp_valid,\n    output wire dcache_icb_rsp_ready,\n    input wire dcache_icb_rsp_err,\n    input wire dcache_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dcache_icb_rsp_rdata,\n\n    output wire dtcm_icb_cmd_valid,\n    input wire dtcm_icb_cmd_ready,\n    output wire [E203_DTCM_ADDR_WIDTH-1:0] dtcm_icb_cmd_addr,\n    output wire dtcm_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dtcm_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dtcm_icb_cmd_wmask,\n    output wire dtcm_icb_cmd_lock,\n    output wire dtcm_icb_cmd_excl,\n    output wire [1:0] dtcm_icb_cmd_size,\n    input wire dtcm_icb_rsp_valid,\n    output wire dtcm_icb_rsp_ready,\n    input wire dtcm_icb_rsp_err,\n    input wire dtcm_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dtcm_icb_rsp_rdata,\n    input wire [E203_ADDR_SIZE-1:0] dtcm_region_indic,\n\n    output wire biu_icb_cmd_valid,\n    input wire biu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,\n    output wire biu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] biu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] biu_icb_cmd_wmask,\n    output wire biu_icb_cmd_lock,\n    output wire biu_icb_cmd_excl,\n    output wire [1:0] biu_icb_cmd_size,\n    input wire biu_icb_rsp_valid,\n    output wire biu_icb_rsp_ready,\n    input wire biu_icb_rsp_err,\n    input wire biu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] biu_icb_rsp_rdata\n);\n    // Implementation of LSU control logic here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 19, "code": "module e203_ifu(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire itcm_nohold,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input wire pipe_flush_req,\n    input wire ifu_halt_req,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire ifu_active,\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    output wire pipe_flush_ack\n);\n\n    // Internal signals\n    wire ifu_req_valid;\n    wire [E203_PC_SIZE-1:0] ifu_req_pc;\n    wire ifu_req_seq;\n    wire ifu_req_seq_rv32;\n    wire [E203_PC_SIZE-1:0] ifu_req_last_pc;\n    wire ifu_halt_ack;\n    wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr;\n    wire ifu_rsp_valid;\n    wire ifu_rsp_err;\n    wire ifu_req_ready;\n    wire ifu_rsp_ready;\n\n    // Instantiate the instruction fetch module\n    e203_ifu_ifetch ifetch(\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .ifu_o_ready(ifu_o_ready),\n        .pipe_flush_req(pipe_flush_req),\n        .pipe_flush_add_op1(pipe_flush_add_op1),\n        .pipe_flush_add_op2(pipe_flush_add_op2),\n        .ifu_halt_req(ifu_halt_req),\n        .oitf_empty(oitf_empty),\n        .rf2ifu_x1(rf2ifu_x1),\n        .rf2ifu_rs1(rf2ifu_rs1),\n        .dec2ifu_rden(dec2ifu_rden),\n        .dec2ifu_rs1en(dec2ifu_rs1en),\n        .dec2ifu_rdidx(dec2ifu_rdidx),\n        .dec2ifu_mulhsu(dec2ifu_mulhsu),\n        .dec2ifu_div(dec2ifu_div),\n        .dec2ifu_rem(dec2ifu_rem),\n        .dec2ifu_divu(dec2ifu_divu),\n        .dec2ifu_remu(dec2ifu_remu),\n        .inspect_pc(inspect_pc),\n        .ifu_req_valid(ifu_req_valid),\n        .ifu_req_pc(ifu_req_pc),\n        .ifu_req_seq(ifu_req_seq),\n        .ifu_req_seq_rv32(ifu_req_seq_rv32),\n        .ifu_req_last_pc(ifu_req_last_pc),\n        .pipe_flush_ack(pipe_flush_ack),\n        .ifu_halt_ack(ifu_halt_ack),\n        .ifu_o_ir(ifu_o_ir),\n        .ifu_o_pc(ifu_o_pc),\n        .ifu_o_pc_vld(ifu_o_pc_vld),\n        .ifu_o_misalgn(ifu_o_misalgn),\n        .ifu_o_buserr(ifu_o_buserr),\n        .ifu_o_rs1idx(ifu_o_rs1idx),\n        .ifu_o_rs2idx(ifu_o_rs2idx),\n        .ifu_o_prdt_taken(ifu_o_prdt_taken),\n        .ifu_o_muldiv_b2b(ifu_o_muldiv_b2b),\n        .ifu_o_valid(ifu_o_valid)\n    );\n\n    // Instantiate the bus interface converter\n    e203_ifu_ift2icb ift2icb(\n        .clk(clk),\n        .rst_n(rst_n),\n        .ifu_req_valid(ifu_req_valid),\n        .ifu_req_pc(ifu_req_pc),\n        .ifu_req_seq(ifu_req_seq),\n        .ifu_req_seq_rv32(ifu_req_seq_rv32),\n        .ifu_req_last_pc(ifu_req_last_pc),\n        .ifu_rsp_ready(ifu_rsp_ready),\n        .itcm_nohold(itcm_nohold),\n        .ifu_req_ready(ifu_req_ready),\n        .ifu_rsp_valid(ifu_rsp_valid),\n        .ifu_rsp_err(ifu_rsp_err),\n        .ifu_rsp_instr(ifu_rsp_instr)\n    );\n\n    assign ifu_active = ifu_req_valid || ifu_rsp_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 16, "code": "module e203_lsu_ctrl(\n    input wire commit_mret,\n    input wire commit_trap,\n    output wire lsu_ctrl_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    input wire nice_mem_holdup,\n    input wire nice_icb_cmd_valid,\n    output wire nice_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] nice_icb_cmd_addr,\n    input wire nice_icb_cmd_read,\n    input wire [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] nice_icb_cmd_wmask,\n    output wire nice_icb_rsp_valid,\n    input wire nice_icb_rsp_ready,\n    output wire nice_icb_rsp_err,\n    output wire [E203_XLEN-1:0] nice_icb_rsp_rdata,\n\n    output wire dcache_icb_cmd_valid,\n    input wire dcache_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] dcache_icb_cmd_addr,\n    output wire dcache_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dcache_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dcache_icb_cmd_wmask,\n    output wire dcache_icb_cmd_lock,\n    output wire dcache_icb_cmd_excl,\n    output wire [1:0] dcache_icb_cmd_size,\n    input wire dcache_icb_rsp_valid,\n    output wire dcache_icb_rsp_ready,\n    input wire dcache_icb_rsp_err,\n    input wire dcache_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dcache_icb_rsp_rdata,\n\n    output wire dtcm_icb_cmd_valid,\n    input wire dtcm_icb_cmd_ready,\n    output wire [E203_DTCM_ADDR_WIDTH-1:0] dtcm_icb_cmd_addr,\n    output wire dtcm_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dtcm_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dtcm_icb_cmd_wmask,\n    output wire dtcm_icb_cmd_lock,\n    output wire dtcm_icb_cmd_excl,\n    output wire [1:0] dtcm_icb_cmd_size,\n    input wire dtcm_icb_rsp_valid,\n    output wire dtcm_icb_rsp_ready,\n    input wire dtcm_icb_rsp_err,\n    input wire dtcm_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dtcm_icb_rsp_rdata,\n    input wire [E203_ADDR_SIZE-1:0] dtcm_region_indic,\n\n    output wire biu_icb_cmd_valid,\n    input wire biu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,\n    output wire biu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] biu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] biu_icb_cmd_wmask,\n    output wire biu_icb_cmd_lock,\n    output wire biu_icb_cmd_excl,\n    output wire [1:0] biu_icb_cmd_size,\n    input wire biu_icb_rsp_valid,\n    output wire biu_icb_rsp_ready,\n    input wire biu_icb_rsp_err,\n    input wire biu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] biu_icb_rsp_rdata\n);\n    // Module implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 17, "code": "module e203_lsu_ctrl(\n    input wire commit_mret,\n    input wire commit_trap,\n    output wire lsu_ctrl_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    input wire nice_mem_holdup,\n    input wire nice_icb_cmd_valid,\n    output wire nice_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] nice_icb_cmd_addr,\n    input wire nice_icb_cmd_read,\n    input wire [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] nice_icb_cmd_wmask,\n    output wire nice_icb_rsp_valid,\n    input wire nice_icb_rsp_ready,\n    output wire nice_icb_rsp_err,\n    output wire [E203_XLEN-1:0] nice_icb_rsp_rdata,\n\n    output wire dcache_icb_cmd_valid,\n    input wire dcache_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] dcache_icb_cmd_addr,\n    output wire dcache_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dcache_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dcache_icb_cmd_wmask,\n    output wire dcache_icb_cmd_lock,\n    output wire dcache_icb_cmd_excl,\n    output wire [1:0] dcache_icb_cmd_size,\n    input wire dcache_icb_rsp_valid,\n    output wire dcache_icb_rsp_ready,\n    input wire dcache_icb_rsp_err,\n    input wire dcache_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dcache_icb_rsp_rdata,\n\n    output wire dtcm_icb_cmd_valid,\n    input wire dtcm_icb_cmd_ready,\n    output wire [E203_DTCM_ADDR_WIDTH-1:0] dtcm_icb_cmd_addr,\n    output wire dtcm_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dtcm_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dtcm_icb_cmd_wmask,\n    output wire dtcm_icb_cmd_lock,\n    output wire dtcm_icb_cmd_excl,\n    output wire [1:0] dtcm_icb_cmd_size,\n    input wire dtcm_icb_rsp_valid,\n    output wire dtcm_icb_rsp_ready,\n    input wire dtcm_icb_rsp_err,\n    input wire dtcm_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dtcm_icb_rsp_rdata,\n    input wire [E203_ADDR_SIZE-1:0] dtcm_region_indic,\n\n    output wire biu_icb_cmd_valid,\n    input wire biu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,\n    output wire biu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] biu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] biu_icb_cmd_wmask,\n    output wire biu_icb_cmd_lock,\n    output wire biu_icb_cmd_excl,\n    output wire [1:0] biu_icb_cmd_size,\n    input wire biu_icb_rsp_valid,\n    output wire biu_icb_rsp_ready,\n    input wire biu_icb_rsp_err,\n    input wire biu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] biu_icb_rsp_rdata\n);\n    // Module implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 17, "code": "module itcm_controller #(\n    parameter ADDR_WIDTH = 32,\n    parameter DATA_WIDTH = 64,\n    parameter WMSK_WIDTH = DATA_WIDTH / 8,\n    parameter RAM_AW = 10,\n    parameter RAM_MW = DATA_WIDTH / 8,\n    parameter RAM_DW = DATA_WIDTH\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n\n    // IFU Interface\n    input wire ifu2itcm_icb_cmd_valid,\n    output wire ifu2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] ifu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] ifu2itcm_icb_cmd_wmask,\n    output wire ifu2itcm_icb_rsp_valid,\n    input wire ifu2itcm_icb_rsp_ready,\n    output wire ifu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n\n    // LSU Interface\n    input wire lsu2itcm_icb_cmd_valid,\n    output wire lsu2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] lsu2itcm_icb_cmd_addr,\n    input wire lsu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] lsu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] lsu2itcm_icb_cmd_wmask,\n    output wire lsu2itcm_icb_rsp_valid,\n    input wire lsu2itcm_icb_rsp_ready,\n    output wire lsu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] lsu2itcm_icb_rsp_rdata,\n\n    // RAM Interface\n    output wire itcm_ram_cs,\n    output wire itcm_ram_we,\n    output wire [RAM_AW-1:0] itcm_ram_addr,\n    output wire [RAM_MW-1:0] itcm_ram_wem,\n    output wire [RAM_DW-1:0] itcm_ram_din,\n    input wire [RAM_DW-1:0] itcm_ram_dout,\n    output wire clk_itcm_ram,\n\n    // Status Output\n    output wire itcm_active\n);\n\n    // Internal signals\n    reg [ADDR_WIDTH-1:0] addr_reg;\n    reg [DATA_WIDTH-1:0] wdata_reg;\n    reg [WMSK_WIDTH-1:0] wmask_reg;\n    reg we_reg;\n    reg cs_reg;\n    wire ready_signal;\n    wire valid_signal;\n\n    // Command arbitration logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            addr_reg <= 0;\n            wdata_reg <= 0;\n            wmask_reg <= 0;\n            we_reg <= 0;\n            cs_reg <= 0;\n        end else begin\n            if (ifu2itcm_icb_cmd_valid && ifu2itcm_icb_cmd_ready) begin\n                addr_reg <= ifu2itcm_icb_cmd_addr;\n                wdata_reg <= ifu2itcm_icb_cmd_wdata;\n                wmask_reg <= ifu2itcm_icb_cmd_wmask;\n                we_reg <= !ifu2itcm_icb_cmd_read;\n                cs_reg <= 1;\n            end else if (lsu2itcm_icb_cmd_valid && lsu2itcm_icb_cmd_ready) begin\n                addr_reg <= lsu2itcm_icb_cmd_addr;\n                wdata_reg <= lsu2itcm_icb_cmd_wdata;\n                wmask_reg <= lsu2itcm_icb_cmd_wmask;\n                we_reg <= !lsu2itcm_icb_cmd_read;\n                cs_reg <= 1;\n            end else begin\n                cs_reg <= 0;\n            end\n        end\n    end\n\n    // Response logic\n    assign ifu2itcm_icb_rsp_valid = cs_reg && ifu2itcm_icb_cmd_read;\n    assign ifu2itcm_icb_rsp_rdata = itcm_ram_dout;\n    assign ifu2itcm_icb_rsp_err = 0; // Assuming no errors for simplicity\n\n    assign lsu2itcm_icb_rsp_valid = cs_reg && lsu2itcm_icb_cmd_read;\n    assign lsu2itcm_icb_rsp_rdata = itcm_ram_dout;\n    assign lsu2itcm_icb_rsp_err = 0; // Assuming no errors for simplicity\n\n    // RAM interface connections\n    assign itcm_ram_cs = cs_reg;\n    assign itcm_ram_we = we_reg;\n    assign itcm_ram_addr = addr_reg[RAM_AW-1:0]; // Assuming address alignment\n    assign itcm_ram_wem = wmask_reg;\n    assign itcm_ram_din = wdata_reg;\n\n    // Clock output (could be gated based on activity)\n    assign clk_itcm_ram = clk;\n\n    // Activity status\n    assign itcm_active = cs_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 20, "code": "module e203_exu_alu(\n    input wire i_valid,\n    output wire i_ready,\n    output wire i_longpipe,\n    output wire nice_csr_valid,\n    input wire nice_csr_ready,\n    output wire [31:0] nice_csr_addr,\n    output wire nice_csr_wr,\n    output wire [31:0] nice_csr_wdata,\n    input wire [31:0] nice_csr_rdata,\n    input wire nice_xs_off,\n    output wire amo_wait,\n    input wire oitf_empty,\n    input wire [E203_ITAG_WIDTH-1:0] i_itag,\n    input wire [E203_XLEN-1:0] i_rs1,\n    input wire [E203_XLEN-1:0] i_rs2,\n    input wire [E203_XLEN-1:0] i_imm,\n    input wire [E203_DECINFO_WIDTH-1:0] i_info,\n    input wire [E203_PC_SIZE-1:0] i_pc,\n    input wire [E203_INSTR_SIZE-1:0] i_instr,\n    input wire i_pc_vld,\n    input wire [E203_RFIDX_WIDTH-1:0] i_rdidx,\n    input wire i_rdwen,\n    input wire i_ilegl,\n    input wire i_buserr,\n    input wire i_misalgn,\n    input wire flush_req,\n    input wire flush_pulse,\n    output wire cmt_o_valid,\n    input wire cmt_o_ready,\n    output wire cmt_o_pc_vld,\n    output wire [E203_PC_SIZE-1:0] cmt_o_pc,\n    output wire [E203_INSTR_SIZE-1:0] cmt_o_instr,\n    output wire [E203_XLEN-1:0] cmt_o_imm,\n    output wire cmt_o_rv32,\n    output wire cmt_o_bjp,\n    output wire cmt_o_mret,\n    output wire cmt_o_dret,\n    output wire cmt_o_ecall,\n    output wire cmt_o_ebreak,\n    output wire cmt_o_fencei,\n    output wire cmt_o_wfi,\n    output wire cmt_o_ifu_misalgn,\n    output wire cmt_o_ifu_buserr,\n    output wire cmt_o_ifu_ilegl,\n    output wire cmt_o_bjp_prdt,\n    output wire cmt_o_bjp_rslv,\n    output wire cmt_o_misalgn,\n    output wire cmt_o_ld,\n    output wire cmt_o_stamo,\n    output wire cmt_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] cmt_o_badaddr,\n    output wire wbck_o_valid,\n    input wire wbck_o_ready,\n    output wire [E203_XLEN-1:0] wbck_o_wdat,\n    output wire [E203_RFIDX_WIDTH-1:0] wbck_o_rdidx,\n    input wire mdv_nob2b,\n    output wire csr_ena,\n    output wire csr_wr_en,\n    output wire csr_rd_en,\n    output wire [11:0] csr_idx,\n    input wire nonflush_cmt_ena,\n    input wire csr_access_ilgl,\n    input wire [E203_XLEN-1:0] read_csr_dat,\n    output wire [E203_XLEN-1:0] wbck_csr_dat,\n    output wire agu_icb_cmd_valid,\n    input wire agu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output wire agu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    output wire [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    output wire agu_icb_cmd_lock,\n    output wire agu_icb_cmd_excl,\n    output wire [1:0] agu_icb_cmd_size,\n    output wire agu_icb_cmd_back2agu,\n    output wire agu_icb_cmd_usign,\n    output wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input wire agu_icb_rsp_valid,\n    output wire agu_icb_rsp_ready,\n    input wire agu_icb_rsp_err,\n    input wire agu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    output wire nice_req_valid,\n    input wire nice_req_ready,\n    output wire [E203_XLEN-1:0] nice_req_instr,\n    output wire [E203_XLEN-1:0] nice_req_rs1,\n    output wire [E203_XLEN-1:0] nice_req_rs2,\n    input wire nice_rsp_multicyc_valid,\n    output wire nice_rsp_multicyc_ready,\n    output wire nice_longp_wbck_valid,\n    input wire nice_longp_wbck_ready,\n    output wire [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input wire i_nice_cmt_off_ilgl,\n    input wire clk,\n    input wire rst_n\n);\n    // Module implementation here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 17, "code": "module e203_ifu_ifetch(\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_valid,\n    input wire ifu_req_ready,\n    output wire [E203_PC_SIZE-1:0] ifu_req_pc,\n    output wire ifu_req_seq,\n    output wire ifu_req_seq_rv32,\n    output wire [E203_PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_valid,\n    output wire ifu_rsp_ready,\n    input wire ifu_rsp_err,\n    input wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr,\n    input wire pipe_flush_req,\n    output wire pipe_flush_ack,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    `ifdef E203_TIMING_BOOST\n    input wire [E203_PC_SIZE-1:0] pipe_flush_pc,\n    `endif\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    input wire ifu_halt_req,\n    output wire ifu_halt_ack,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu\n);\n    // Internal signal declarations\n    wire reset_flag_r;\n    wire reset_req_r;\n    wire halt_ack_r;\n    wire dly_flush_r;\n    wire ir_valid_r;\n    wire ir_pc_vld_r;\n    wire ifu_err_r;\n    wire ifu_prdt_taken_r;\n    wire ir_muldiv_b2b_r;\n    wire [E203_INSTR_SIZE-1:0] ifu_ir_r;\n    wire [E203_RFIDX_WIDTH-1:0] ir_rs1idx_r;\n    wire [E203_RFIDX_WIDTH-1:0] ir_rs2idx_r;\n    wire [E203_PC_SIZE-1:0] ifu_pc_r;\n    wire [E203_PC_SIZE-1:0] pc_r;\n    wire out_flag_r;\n    wire pc_newpend_r;\n\n    // Implementation of the module's functionality\n    // Reset control logic\n    sirv_gnrl_dffrs #(.DW(1)) reset_flag_dffrs (\n        .dnxt(1'b0),\n        .qout(reset_flag_r),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\n    // Halt control logic\n    sirv_gnrl_dfflr #(.DW(1)) halt_ack_dfflr (\n        .lden(halt_ack_ena),\n        .dnxt(halt_ack_nxt),\n        .qout(halt_ack_r),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\n    // Fetch request and response handling\n    assign ifu_req_valid = (ifu_new_req | ifu_reset_req | pipe_flush_req_real | ifetch_replay_req) & new_req_condi;\n    assign ifu_rsp_ready = ifu_rsp2ir_ready;\n\n    // Pipeline flush control\n    sirv_gnrl_dfflr #(.DW(1)) dly_flush_dfflr (\n        .lden(dly_flush_ena),\n        .dnxt(dly_flush_nxt),\n        .qout(dly_flush_r),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\n    // Instruction register control\n    sirv_gnrl_dfflr #(.DW(E203_INSTR_SIZE)) ifu_ir_dfflr (\n        .lden(ir_valid_set),\n        .dnxt(ifu_rsp_instr),\n        .qout(ifu_ir_r),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\n    // Program counter control\n    sirv_gnrl_dfflr #(.DW(E203_PC_SIZE)) pc_dfflr (\n        .lden(pc_ena),\n        .dnxt(pc_nxt),\n        .qout(pc_r),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\n    // Output interface to execution unit\n    assign ifu_o_ir = ifu_ir_r;\n    assign ifu_o_pc = ifu_pc_r;\n    assign ifu_o_pc_vld = ir_pc_vld_r;\n    assign ifu_o_rs1idx = ir_rs1idx_r;\n    assign ifu_o_rs2idx = ir_rs2idx_r;\n    assign ifu_o_prdt_taken = ifu_prdt_taken_r;\n    assign ifu_o_misalgn = 1'b0; // Assuming no misalignment for simplicity\n    assign ifu_o_buserr = ifu_err_r;\n    assign ifu_o_muldiv_b2b = ir_muldiv_b2b_r;\n    assign ifu_o_valid = ir_valid_r;\n    assign ifu_o_ready = ifu_o_ready;\n\n    // Halt acknowledgment output\n    assign ifu_halt_ack = halt_ack_r;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 20, "code": "module e203_exu_oitf #(\n  parameter E203_ITAG_WIDTH = 4,\n  parameter E203_RFIDX_WIDTH = 5,\n  parameter E203_PC_SIZE = 32,\n  parameter E203_OITF_DEPTH = 8\n)(\n  input  wire                     clk,\n  input  wire                     rst_n,\n\n  output wire                     dis_ready,\n  input  wire                     dis_ena,\n  input  wire                     ret_ena,\n\n  output wire [E203_ITAG_WIDTH-1:0] dis_ptr,\n  output wire [E203_ITAG_WIDTH-1:0] ret_ptr,\n  output wire [E203_RFIDX_WIDTH-1:0] ret_rdidx,\n  output wire                     ret_rdwen,\n  output wire                     ret_rdfpu,\n  output wire [E203_PC_SIZE-1:0]  ret_pc,\n\n  input  wire                     disp_i_rs1en,\n  input  wire                     disp_i_rs2en,\n  input  wire                     disp_i_rs3en,\n  input  wire                     disp_i_rdwen,\n  input  wire                     disp_i_rs1fpu,\n  input  wire                     disp_i_rs2fpu,\n  input  wire                     disp_i_rs3fpu,\n  input  wire                     disp_i_rdfpu,\n  input  wire [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n  input  wire [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n  input  wire [E203_RFIDX_WIDTH-1:0] disp_i_rs3idx,\n  input  wire [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n  input  wire [E203_PC_SIZE-1:0]  disp_i_pc,\n\n  output wire                     oitfrd_match_disprs1,\n  output wire                     oitfrd_match_disprs2,\n  output wire                     oitfrd_match_disprs3,\n  output wire                     oitfrd_match_disprd,\n  output wire                     oitf_empty\n);\n\n  // Internal Registers\n  reg [E203_RFIDX_WIDTH-1:0] rdidx [E203_OITF_DEPTH-1:0];\n  reg [E203_PC_SIZE-1:0]     pc [E203_OITF_DEPTH-1:0];\n  reg                        rdwen [E203_OITF_DEPTH-1:0];\n  reg                        rdfpu [E203_OITF_DEPTH-1:0];\n  reg [E203_ITAG_WIDTH-1:0]  wr_ptr;\n  reg [E203_ITAG_WIDTH-1:0]  rd_ptr;\n  reg                        full;\n  reg                        empty;\n\n  // Pointer Logic\n  wire ptr_match = (wr_ptr == rd_ptr);\n  assign oitf_empty = empty;\n  assign dis_ready = !full;\n\n  // Dispatch Logic\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      wr_ptr <= {E203_ITAG_WIDTH{1'b0}};\n      full <= 1'b0;\n    end else if (dis_ena && dis_ready) begin\n      rdidx[wr_ptr] <= disp_i_rdidx;\n      pc[wr_ptr] <= disp_i_pc;\n      rdwen[wr_ptr] <= disp_i_rdwen;\n      rdfpu[wr_ptr] <= disp_i_rdfpu;\n      wr_ptr <= wr_ptr + 1'b1;\n      full <= (wr_ptr + 1'b1 == rd_ptr);\n    end\n  end\n\n  // Retirement Logic\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      rd_ptr <= {E203_ITAG_WIDTH{1'b0}};\n      empty <= 1'b1;\n    end else if (ret_ena && !oitf_empty) begin\n      rd_ptr <= rd_ptr + 1'b1;\n      empty <= (rd_ptr + 1'b1 == wr_ptr);\n    end\n  end\n\n  // Output Assignments\n  assign dis_ptr = wr_ptr;\n  assign ret_ptr = rd_ptr;\n  assign ret_rdidx = rdidx[rd_ptr];\n  assign ret_rdwen = rdwen[rd_ptr];\n  assign ret_rdfpu = rdfpu[rd_ptr];\n  assign ret_pc = pc[rd_ptr];\n\n  // Dependency Checking Logic\n  integer i;\n  always @(*) begin\n    oitfrd_match_disprs1 = 1'b0;\n    oitfrd_match_disprs2 = 1'b0;\n    oitfrd_match_disprs3 = 1'b0;\n    oitfrd_match_disprd = 1'b0;\n    for (i = 0; i < E203_OITF_DEPTH; i = i + 1) begin\n      if (rdwen[i]) begin\n        if (disp_i_rs1en && disp_i_rs1idx == rdidx[i] && disp_i_rs1fpu == rdfpu[i])\n          oitfrd_match_disprs1 = 1'b1;\n        if (disp_i_rs2en && disp_i_rs2idx == rdidx[i] && disp_i_rs2fpu == rdfpu[i])\n          oitfrd_match_disprs2 = 1'b1;\n        if (disp_i_rs3en && disp_i_rs3idx == rdidx[i] && disp_i_rs3fpu == rdfpu[i])\n          oitfrd_match_disprs3 = 1'b1;\n        if (disp_i_rdwen && disp_i_rdidx == rdidx[i] && disp_i_rdfpu == rdfpu[i])\n          oitfrd_match_disprd = 1'b1;\n      end\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 20, "code": "module e203_ifu(\n    input wire clk,\n    input wire rst_n,\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire itcm_nohold,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input wire pipe_flush_req,\n    input wire ifu_halt_req,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu,\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire ifu_active,\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    output wire pipe_flush_ack,\n    input wire ifu2itcm_icb_cmd_ready,\n    input wire ifu2itcm_icb_rsp_valid,\n    input wire ifu2itcm_icb_rsp_err,\n    input wire [E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    output wire ifu2itcm_icb_cmd_valid,\n    output wire [E203_ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    output wire ifu2itcm_icb_rsp_ready,\n    input wire ifu2biu_icb_cmd_ready,\n    input wire ifu2biu_icb_rsp_valid,\n    input wire ifu2biu_icb_rsp_err,\n    input wire [E203_SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata,\n    output wire ifu2biu_icb_cmd_valid,\n    output wire [E203_ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    output wire ifu2biu_icb_rsp_ready,\n    output wire ifu_halt_ack\n);\n\n    // Internal signals\n    wire [E203_PC_SIZE-1:0] next_pc;\n    wire [E203_INSTR_SIZE-1:0] fetched_instr;\n    wire fetch_valid;\n    wire fetch_ready;\n    wire [E203_PC_SIZE-1:0] current_pc;\n    wire [E203_PC_SIZE-1:0] flush_pc;\n    wire flush_ack;\n    wire halt_ack;\n    wire [E203_PC_SIZE-1:0] ifetch_pc;\n    wire ifetch_valid;\n    wire ifetch_ready;\n\n    // Instantiate the instruction fetch module\n    e203_ifu_ifetch ifetch (\n        .clk(clk),\n        .rst_n(rst_n),\n        .pc_rtvec(pc_rtvec),\n        .pipe_flush_add_op1(pipe_flush_add_op1),\n        .pipe_flush_add_op2(pipe_flush_add_op2),\n        .pipe_flush_req(pipe_flush_req),\n        .ifu_halt_req(ifu_halt_req),\n        .oitf_empty(oitf_empty),\n        .rf2ifu_x1(rf2ifu_x1),\n        .rf2ifu_rs1(rf2ifu_rs1),\n        .dec2ifu_rs1en(dec2ifu_rs1en),\n        .dec2ifu_rden(dec2ifu_rden),\n        .dec2ifu_rdidx(dec2ifu_rdidx),\n        .dec2ifu_mulhsu(dec2ifu_mulhsu),\n        .dec2ifu_div(dec2ifu_div),\n        .dec2ifu_rem(dec2ifu_rem),\n        .dec2ifu_divu(dec2ifu_divu),\n        .dec2ifu_remu(dec2ifu_remu),\n        .inspect_pc(inspect_pc),\n        .ifu_active(ifu_active),\n        .ifu_o_ir(ifu_o_ir),\n        .ifu_o_pc(ifu_o_pc),\n        .ifu_o_pc_vld(ifu_o_pc_vld),\n        .ifu_o_misalgn(ifu_o_misalgn),\n        .ifu_o_buserr(ifu_o_buserr),\n        .ifu_o_rs1idx(ifu_o_rs1idx),\n        .ifu_o_rs2idx(ifu_o_rs2idx),\n        .ifu_o_prdt_taken(ifu_o_prdt_taken),\n        .ifu_o_muldiv_b2b(ifu_o_muldiv_b2b),\n        .ifu_o_valid(ifu_o_valid),\n        .ifu_o_ready(ifu_o_ready),\n        .pipe_flush_ack(pipe_flush_ack),\n        .ifu_halt_ack(ifu_halt_ack)\n    );\n\n    // Instantiate the IFT to ICB bridge module\n    e203_ifu_ift2icb ift2icb (\n        .clk(clk),\n        .rst_n(rst_n),\n        .ifu_req_valid(fetch_valid),\n        .ifu_req_ready(fetch_ready),\n        .ifu_req_pc(current_pc),\n        .ifu_rsp_valid(ifetch_valid),\n        .ifu_rsp_ready(ifetch_ready),\n        .ifu_rsp_instr(fetched_instr),\n        .itcm_nohold(itcm_nohold),\n        .ifu2itcm_icb_cmd_ready(ifu2itcm_icb_cmd_ready),\n        .ifu2itcm_icb_rsp_valid(ifu2itcm_icb_rsp_valid),\n        .ifu2itcm_icb_rsp_err(ifu2itcm_icb_rsp_err),\n        .ifu2itcm_icb_rsp_rdata(ifu2itcm_icb_rsp_rdata),\n        .ifu2itcm_icb_cmd_valid(ifu2itcm_icb_cmd_valid),\n        .ifu2itcm_icb_cmd_addr(ifu2itcm_icb_cmd_addr),\n        .ifu2itcm_icb_rsp_ready(ifu2itcm_icb_rsp_ready),\n        .ifu2biu_icb_cmd_ready(ifu2biu_icb_cmd_ready),\n        .ifu2biu_icb_rsp_valid(ifu2biu_icb_rsp_valid),\n        .ifu2biu_icb_rsp_err(ifu2biu_icb_rsp_err),\n        .ifu2biu_icb_rsp_rdata(ifu2biu_icb_rsp_rdata),\n        .ifu2biu_icb_cmd_valid(ifu2biu_icb_cmd_valid),\n        .ifu2biu_icb_cmd_addr(ifu2biu_icb_cmd_addr),\n        .ifu2biu_icb_rsp_ready(ifu2biu_icb_rsp_ready)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 19, "code": "module e203_exu_disp(\n    input wire wfi_halt_exu_req,\n    output wire wfi_halt_exu_ack,\n    input wire oitf_empty,\n    input wire amo_wait,\n    input wire disp_i_valid,\n    output wire disp_i_ready,\n    input wire disp_i_rs1x0,\n    input wire disp_i_rs2x0,\n    input wire disp_i_rs1en,\n    input wire disp_i_rs2en,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input wire [E203_XLEN-1:0] disp_i_rs1,\n    input wire [E203_XLEN-1:0] disp_i_rs2,\n    input wire disp_i_rdwen,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input wire [E203_DECINFO_WIDTH-1:0] disp_i_info,\n    input wire [E203_XLEN-1:0] disp_i_imm,\n    input wire [E203_PC_SIZE-1:0] disp_i_pc,\n    input wire disp_i_misalgn,\n    input wire disp_i_buserr,\n    input wire disp_i_ilegl,\n    output wire disp_o_alu_valid,\n    input wire disp_o_alu_ready,\n    input wire disp_o_alu_longpipe,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs1,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs2,\n    output wire disp_o_alu_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_o_alu_rdidx,\n    output wire [E203_DECINFO_WIDTH-1:0] disp_o_alu_info,\n    output wire [E203_XLEN-1:0] disp_o_alu_imm,\n    output wire [E203_PC_SIZE-1:0] disp_o_alu_pc,\n    output wire [E203_ITAG_WIDTH-1:0] disp_o_alu_itag,\n    output wire disp_o_alu_misalgn,\n    output wire disp_o_alu_buserr,\n    output wire disp_o_alu_ilegl,\n    input wire oitfrd_match_disprs1,\n    input wire oitfrd_match_disprs2,\n    input wire oitfrd_match_disprs3,\n    input wire oitfrd_match_disprd,\n    input wire [E203_ITAG_WIDTH-1:0] disp_oitf_ptr,\n    output wire disp_oitf_ena,\n    input wire disp_oitf_ready,\n    output wire disp_oitf_rs1fpu,\n    output wire disp_oitf_rs2fpu,\n    output wire disp_oitf_rs3fpu,\n    output wire disp_oitf_rdfpu,\n    output wire disp_oitf_rs1en,\n    output wire disp_oitf_rs2en,\n    output wire disp_oitf_rs3en,\n    output wire disp_oitf_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs2idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs3idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rdidx,\n    output wire [E203_PC_SIZE-1:0] disp_oitf_pc,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Implementation of dispatch logic, dependency checks, and WFI handling\n    // This is a placeholder for the actual logic which would be quite complex\n    // and would typically involve a state machine or combinational logic\n    // to manage instruction dispatching based on the inputs and the state of\n    // the execution units and OITF.\n\n    assign disp_i_ready = !amo_wait && oitf_empty && disp_o_alu_ready;\n    assign disp_o_alu_valid = disp_i_valid && disp_i_ready;\n    assign disp_o_alu_rs1 = disp_i_rs1;\n    assign disp_o_alu_rs2 = disp_i_rs2;\n    assign disp_o_alu_rdwen = disp_i_rdwen;\n    assign disp_o_alu_rdidx = disp_i_rdidx;\n    assign disp_o_alu_info = disp_i_info;\n    assign disp_o_alu_imm = disp_i_imm;\n    assign disp_o_alu_pc = disp_i_pc;\n    assign disp_o_alu_itag = disp_oitf_ptr;\n    assign disp_o_alu_misalgn = disp_i_misalgn;\n    assign disp_o_alu_buserr = disp_i_buserr;\n    assign disp_o_alu_ilegl = disp_i_ilegl;\n\n    // OITF dispatch logic\n    assign disp_oitf_ena = disp_o_alu_valid && disp_o_alu_longpipe && disp_oitf_ready;\n    assign disp_oitf_rs1fpu = 0; // Assuming no FPU in this configuration\n    assign disp_oitf_rs2fpu = 0;\n    assign disp_oitf_rs3fpu = 0;\n    assign disp_oitf_rdfpu = 0;\n    assign disp_oitf_rs1en = disp_i_rs1en;\n    assign disp_oitf_rs2en = disp_i_rs2en;\n    assign disp_oitf_rs3en = 0; // Assuming no third operand\n    assign disp_oitf_rdwen = disp_i_rdwen;\n    assign disp_oitf_rs1idx = disp_i_rs1idx;\n    assign disp_oitf_rs2idx = disp_i_rs2idx;\n    assign disp_oitf_rs3idx = 0; // Assuming no third operand\n    assign disp_oitf_rdidx = disp_i_rdidx;\n    assign disp_oitf_pc = disp_i_pc;\n\n    // WFI handling\n    assign wfi_halt_exu_ack = wfi_halt_exu_req && oitf_empty && !amo_wait;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 18, "code": "module itcm_controller #(\n    parameter ADDR_WIDTH = 32,\n    parameter DATA_WIDTH = 64,\n    parameter WMSK_WIDTH = DATA_WIDTH / 8,\n    parameter RAM_AW = 10,\n    parameter RAM_MW = WMSK_WIDTH,\n    parameter RAM_DW = DATA_WIDTH\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n\n    // System Interface\n    output wire itcm_active,\n\n    // IFU Interface\n    input wire ifu2itcm_icb_cmd_valid,\n    output wire ifu2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] ifu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] ifu2itcm_icb_cmd_wmask,\n    output wire ifu2itcm_icb_rsp_valid,\n    input wire ifu2itcm_icb_rsp_ready,\n    output wire ifu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n\n    // LSU Interface\n    input wire lsu2itcm_icb_cmd_valid,\n    output wire lsu2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] lsu2itcm_icb_cmd_addr,\n    input wire lsu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] lsu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] lsu2itcm_icb_cmd_wmask,\n    output wire lsu2itcm_icb_rsp_valid,\n    input wire lsu2itcm_icb_rsp_ready,\n    output wire lsu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] lsu2itcm_icb_rsp_rdata,\n\n    // RAM Interface\n    output wire itcm_ram_cs,\n    output wire itcm_ram_we,\n    output wire [RAM_AW-1:0] itcm_ram_addr,\n    output wire [RAM_MW-1:0] itcm_ram_wem,\n    output wire [RAM_DW-1:0] itcm_ram_din,\n    input wire [RAM_DW-1:0] itcm_ram_dout,\n    output wire clk_itcm_ram\n);\n\n    // Internal signals\n    wire select_ifu, select_lsu;\n    wire [ADDR_WIDTH-1:0] selected_addr;\n    wire [DATA_WIDTH-1:0] selected_wdata;\n    wire [WMSK_WIDTH-1:0] selected_wmask;\n    wire selected_we;\n    reg itcm_active_reg;\n\n    // Arbitration logic (simple round-robin for example)\n    assign select_ifu = ifu2itcm_icb_cmd_valid && !lsu2itcm_icb_cmd_valid;\n    assign select_lsu = lsu2itcm_icb_cmd_valid;\n\n    assign selected_addr = select_ifu ? ifu2itcm_icb_cmd_addr : lsu2itcm_icb_cmd_addr;\n    assign selected_wdata = select_ifu ? ifu2itcm_icb_cmd_wdata : lsu2itcm_icb_cmd_wdata;\n    assign selected_wmask = select_ifu ? ifu2itcm_icb_cmd_wmask : lsu2itcm_icb_cmd_wmask;\n    assign selected_we = select_ifu ? !ifu2itcm_icb_cmd_read : !lsu2itcm_icb_cmd_read;\n\n    // RAM interface logic\n    assign itcm_ram_cs = select_ifu || select_lsu;\n    assign itcm_ram_we = selected_we;\n    assign itcm_ram_addr = selected_addr[RAM_AW-1:0];\n    assign itcm_ram_wem = selected_wmask;\n    assign itcm_ram_din = selected_wdata;\n\n    // Clock gating logic\n    assign clk_itcm_ram = clk & ~tcm_cgstop;\n\n    // Active status logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            itcm_active_reg <= 1'b0;\n        else\n            itcm_active_reg <= itcm_ram_cs;\n    end\n\n    assign itcm_active = itcm_active_reg;\n\n    // Response logic\n    assign ifu2itcm_icb_rsp_valid = select_ifu & itcm_ram_cs;\n    assign lsu2itcm_icb_rsp_valid = select_lsu & itcm_ram_cs;\n    assign ifu2itcm_icb_rsp_rdata = itcm_ram_dout;\n    assign lsu2itcm_icb_rsp_rdata = itcm_ram_dout;\n    assign ifu2itcm_icb_rsp_err = 1'b0; // Assuming no errors for simplicity\n    assign lsu2itcm_icb_rsp_err = 1'b0; // Assuming no errors for simplicity\n\n    // Ready signals\n    assign ifu2itcm_icb_cmd_ready = ~itcm_ram_cs;\n    assign lsu2itcm_icb_cmd_ready = ~itcm_ram_cs;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 17, "code": "module e203_ifu_ift2icb (\n    input wire itcm_nohold,\n    input wire ifu_req_valid,\n    input wire [PC_SIZE-1:0] ifu_req_pc,\n    input wire ifu_req_seq,\n    input wire ifu_req_seq_rv32,\n    input wire [PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_ready,\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_ready,\n    output wire ifu_rsp_valid,\n    output wire ifu_rsp_err,\n    output wire [31:0] ifu_rsp_instr,\n    output wire ifu2itcm_icb_cmd_valid,\n    input wire ifu2itcm_icb_cmd_ready,\n    output wire [ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_rsp_valid,\n    output wire ifu2itcm_icb_rsp_ready,\n    input wire ifu2itcm_icb_rsp_err,\n    input wire [ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    output wire ifu2biu_icb_cmd_valid,\n    input wire ifu2biu_icb_cmd_ready,\n    output wire [ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input wire ifu2biu_icb_rsp_valid,\n    output wire ifu2biu_icb_rsp_ready,\n    input wire ifu2biu_icb_rsp_err,\n    input wire [SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata\n);\n\n    // State Definitions\n    localparam ICB_STATE_IDLE = 2'b00;\n    localparam ICB_STATE_1ST = 2'b01;\n    localparam ICB_STATE_WAIT2ND = 2'b10;\n    localparam ICB_STATE_2ND = 2'b11;\n\n    // State Registers\n    reg [1:0] icb_state;\n    reg [1:0] icb_state_nxt;\n\n    // Handshake signals\n    wire ifu_req_hsked = ifu_req_valid && ifu_req_ready;\n    wire ifu_icb_cmd_hsked = ifu2itcm_icb_cmd_valid && ifu2itcm_icb_cmd_ready;\n    wire ifu_icb_rsp_hsked = ifu2itcm_icb_rsp_valid && ifu2itcm_icb_rsp_ready;\n\n    // Next state logic\n    always @(*) begin\n        case (icb_state)\n            ICB_STATE_IDLE: begin\n                if (ifu_req_hsked)\n                    icb_state_nxt = ICB_STATE_1ST;\n                else\n                    icb_state_nxt = ICB_STATE_IDLE;\n            end\n            ICB_STATE_1ST: begin\n                if (ifu_icb_rsp_hsked)\n                    icb_state_nxt = ICB_STATE_WAIT2ND;\n                else\n                    icb_state_nxt = ICB_STATE_1ST;\n            end\n            ICB_STATE_WAIT2ND: begin\n                if (ifu_icb_cmd_ready)\n                    icb_state_nxt = ICB_STATE_2ND;\n                else\n                    icb_state_nxt = ICB_STATE_WAIT2ND;\n            end\n            ICB_STATE_2ND: begin\n                if (ifu_icb_rsp_hsked)\n                    icb_state_nxt = ICB_STATE_IDLE;\n                else\n                    icb_state_nxt = ICB_STATE_2ND;\n            end\n            default: icb_state_nxt = ICB_STATE_IDLE;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            icb_state <= ICB_STATE_IDLE;\n        else\n            icb_state <= icb_state_nxt;\n    end\n\n    // Output logic\n    assign ifu_req_ready = (icb_state == ICB_STATE_IDLE);\n    assign ifu_rsp_valid = (icb_state == ICB_STATE_2ND) && ifu2itcm_icb_rsp_valid;\n    assign ifu_rsp_err = ifu2itcm_icb_rsp_err;\n    assign ifu_rsp_instr = ifu2itcm_icb_rsp_rdata[31:0];\n\n    assign ifu2itcm_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && ifu_req_valid;\n    assign ifu2itcm_icb_cmd_addr = ifu_req_pc[ITCM_ADDR_WIDTH-1:0];\n    assign ifu2itcm_icb_rsp_ready = (icb_state == ICB_STATE_2ND);\n\n    assign ifu2biu_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && ifu_req_valid && !itcm_nohold;\n    assign ifu2biu_icb_cmd_addr = ifu_req_pc[ADDR_SIZE-1:0];\n    assign ifu2biu_icb_rsp_ready = (icb_state == ICB_STATE_2ND);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 20, "code": "module e203_exu_longpwbck (\n    input wire lsu_wbck_i_valid,\n    output wire lsu_wbck_i_ready,\n    input wire [E203_XLEN-1:0] lsu_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] lsu_wbck_i_itag,\n    input wire lsu_wbck_i_err,\n    input wire lsu_cmt_i_buserr,\n    input wire [E203_ADDR_SIZE-1:0] lsu_cmt_i_badaddr,\n    input wire lsu_cmt_i_ld,\n    input wire lsu_cmt_i_st,\n    output wire longp_wbck_o_valid,\n    input wire longp_wbck_o_ready,\n    output wire [E203_FLEN-1:0] longp_wbck_o_wdat,\n    output wire [4:0] longp_wbck_o_flags,\n    output wire [E203_RFIDX_WIDTH-1:0] longp_wbck_o_rdidx,\n    output wire longp_wbck_o_rdfpu,\n    output wire longp_excp_o_valid,\n    input wire longp_excp_o_ready,\n    output wire longp_excp_o_insterr,\n    output wire longp_excp_o_ld,\n    output wire longp_excp_o_st,\n    output wire longp_excp_o_buserr,\n    output wire [E203_ADDR_SIZE-1:0] longp_excp_o_badaddr,\n    output wire [E203_PC_SIZE-1:0] longp_excp_o_pc,\n    input wire oitf_empty,\n    input wire [E203_ITAG_WIDTH-1:0] oitf_ret_ptr,\n    input wire [E203_RFIDX_WIDTH-1:0] oitf_ret_rdidx,\n    input wire [E203_PC_SIZE-1:0] oitf_ret_pc,\n    input wire oitf_ret_rdwen,\n    input wire oitf_ret_rdfpu,\n    output wire oitf_ret_ena,\n    input wire clk,\n    input wire rst_n\n`ifdef E203_HAS_NICE\n    , input wire nice_longp_wbck_i_valid,\n    output wire nice_longp_wbck_i_ready,\n    input wire [E203_XLEN-1:0] nice_longp_wbck_i_wdat,\n    input wire [E203_ITAG_WIDTH-1:0] nice_longp_wbck_i_itag,\n    input wire nice_longp_wbck_i_err\n`endif\n);\n\n    // Internal signals for arbitration and control logic\n    wire wbck_need, excp_need, wbck_ready, excp_ready;\n    wire [E203_ITAG_WIDTH-1:0] current_itag;\n    wire [E203_RFIDX_WIDTH-1:0] current_rdidx;\n    wire [E203_PC_SIZE-1:0] current_pc;\n    wire current_rdfpu;\n    wire valid_wbck, valid_excp;\n    wire [E203_XLEN-1:0] wbck_data;\n    wire [4:0] wbck_flags;\n    wire wbck_err, excp_err;\n\n    // Control logic for write-back and exception needs\n    assign wbck_need = (lsu_wbck_i_valid && !lsu_wbck_i_err) `ifdef E203_HAS_NICE || (nice_longp_wbck_i_valid && !nice_longp_wbck_i_err) `endif;\n    assign excp_need = (lsu_wbck_i_valid && lsu_wbck_i_err) `ifdef E203_HAS_NICE || (nice_longp_wbck_i_valid && nice_longp_wbck_i_err) `endif;\n\n    // Arbitration logic\n    assign current_itag = (lsu_wbck_i_valid) ? lsu_wbck_i_itag : `ifdef E203_HAS_NICE nice_longp_wbck_i_itag `else 0 `endif;\n    assign current_rdidx = (lsu_wbck_i_valid) ? oitf_ret_rdidx : `ifdef E203_HAS_NICE oitf_ret_rdidx `else 0 `endif;\n    assign current_pc = (lsu_wbck_i_valid) ? oitf_ret_pc : `ifdef E203_HAS_NICE oitf_ret_pc `else 0 `endif;\n    assign current_rdfpu = (lsu_wbck_i_valid) ? oitf_ret_rdfpu : `ifdef E203_HAS_NICE oitf_ret_rdfpu `else 0 `endif;\n\n    // Ready and valid signals for write-back and exception paths\n    assign wbck_ready = longp_wbck_o_ready && (wbck_need || !excp_need);\n    assign excp_ready = longp_excp_o_ready && (excp_need || !wbck_need);\n\n    // Output assignments\n    assign lsu_wbck_i_ready = wbck_ready && excp_ready;\n    assign longp_wbck_o_valid = wbck_need && wbck_ready;\n    assign longp_wbck_o_wdat = wbck_data;\n    assign longp_wbck_o_flags = wbck_flags;\n    assign longp_wbck_o_rdidx = current_rdidx;\n    assign longp_wbck_o_rdfpu = current_rdfpu;\n    assign longp_excp_o_valid = excp_need && excp_ready;\n    assign longp_excp_o_insterr = wbck_err;\n    assign longp_excp_o_ld = lsu_cmt_i_ld;\n    assign longp_excp_o_st = lsu_cmt_i_st;\n    assign longp_excp_o_buserr = lsu_cmt_i_buserr;\n    assign longp_excp_o_badaddr = lsu_cmt_i_badaddr;\n    assign longp_excp_o_pc = current_pc;\n\n    // OITF control\n    assign oitf_ret_ena = lsu_wbck_i_ready && lsu_wbck_i_valid;\n\n`ifdef E203_HAS_NICE\n    assign nice_longp_wbck_i_ready = wbck_ready && excp_ready;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 18, "code": "module e203_ifu_ift2icb (\n    input wire itcm_nohold,\n    input wire ifu_req_valid,\n    input wire [PC_SIZE-1:0] ifu_req_pc,\n    input wire ifu_req_seq,\n    input wire ifu_req_seq_rv32,\n    input wire [PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_ready,\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_ready,\n    output wire ifu_rsp_valid,\n    output wire ifu_rsp_err,\n    output wire [31:0] ifu_rsp_instr,\n    output wire ifu2itcm_icb_cmd_valid,\n    input wire ifu2itcm_icb_cmd_ready,\n    output wire [ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_rsp_valid,\n    output wire ifu2itcm_icb_rsp_ready,\n    input wire ifu2itcm_icb_rsp_err,\n    input wire [ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    output wire ifu2biu_icb_cmd_valid,\n    input wire ifu2biu_icb_cmd_ready,\n    output wire [ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input wire ifu2biu_icb_rsp_valid,\n    output wire ifu2biu_icb_rsp_ready,\n    input wire ifu2biu_icb_rsp_err,\n    input wire [SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata\n);\n\n    // State machine definition\n    reg [1:0] icb_state, icb_state_nxt;\n    localparam ICB_STATE_IDLE = 2'b00;\n    localparam ICB_STATE_1ST = 2'b01;\n    localparam ICB_STATE_WAIT2ND = 2'b10;\n    localparam ICB_STATE_2ND = 2'b11;\n\n    // State transition logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            icb_state <= ICB_STATE_IDLE;\n        else\n            icb_state <= icb_state_nxt;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (icb_state)\n            ICB_STATE_IDLE: begin\n                if (ifu_req_valid)\n                    icb_state_nxt = ICB_STATE_1ST;\n                else\n                    icb_state_nxt = ICB_STATE_IDLE;\n            end\n            ICB_STATE_1ST: begin\n                if (ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid)\n                    icb_state_nxt = ifu_req_valid ? ICB_STATE_1ST : ICB_STATE_IDLE;\n                else\n                    icb_state_nxt = ICB_STATE_WAIT2ND;\n            end\n            ICB_STATE_WAIT2ND: begin\n                if (ifu2itcm_icb_cmd_ready || ifu2biu_icb_cmd_ready)\n                    icb_state_nxt = ICB_STATE_2ND;\n                else\n                    icb_state_nxt = ICB_STATE_WAIT2ND;\n            end\n            ICB_STATE_2ND: begin\n                if (ifu_rsp_ready)\n                    icb_state_nxt = ifu_req_valid ? ICB_STATE_1ST : ICB_STATE_IDLE;\n                else\n                    icb_state_nxt = ICB_STATE_2ND;\n            end\n            default: icb_state_nxt = ICB_STATE_IDLE;\n        endcase\n    end\n\n    // Output logic\n    assign ifu_req_ready = (icb_state == ICB_STATE_IDLE);\n    assign ifu_rsp_valid = (icb_state == ICB_STATE_2ND) && (ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid);\n    assign ifu_rsp_err = (icb_state == ICB_STATE_2ND) && (ifu2itcm_icb_rsp_err || ifu2biu_icb_rsp_err);\n    assign ifu_rsp_instr = (icb_state == ICB_STATE_2ND) ? (ifu2itcm_icb_rsp_valid ? ifu2itcm_icb_rsp_rdata : ifu2biu_icb_rsp_rdata) : 32'h0;\n\n    // ITCM and BIU command logic\n    assign ifu2itcm_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && ifu_req_valid && (ifu_req_pc < `ITCM_ADDR_LIMIT);\n    assign ifu2itcm_icb_cmd_addr = ifu_req_pc;\n    assign ifu2itcm_icb_rsp_ready = (icb_state == ICB_STATE_2ND);\n\n    assign ifu2biu_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && ifu_req_valid && (ifu_req_pc >= `ITCM_ADDR_LIMIT);\n    assign ifu2biu_icb_cmd_addr = ifu_req_pc;\n    assign ifu2biu_icb_rsp_ready = (icb_state == ICB_STATE_2ND);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 18, "code": "module e203_ifu_ifetch(\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_valid,\n    input wire ifu_req_ready,\n    output wire [E203_PC_SIZE-1:0] ifu_req_pc,\n    output wire ifu_req_seq,\n    output wire ifu_req_seq_rv32,\n    output wire [E203_PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_valid,\n    output wire ifu_rsp_ready,\n    input wire ifu_rsp_err,\n    input wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr,\n    input wire pipe_flush_req,\n    output wire pipe_flush_ack,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    `ifdef E203_TIMING_BOOST\n    input wire [E203_PC_SIZE-1:0] pipe_flush_pc,\n    `endif\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    input wire ifu_halt_req,\n    output wire ifu_halt_ack,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu\n);\n    // Internal signal declarations\n    wire reset_flag_r;\n    wire reset_req_r;\n    wire halt_ack_r;\n    wire dly_flush_r;\n    wire ir_valid_r;\n    wire ir_pc_vld_r;\n    wire ifu_err_r;\n    wire ifu_prdt_taken_r;\n    wire [31:16] ifu_hi_ir_r;\n    wire [15:0] ifu_lo_ir_r;\n    wire [E203_RFIDX_WIDTH-1:0] ir_rs1idx_r;\n    wire [E203_RFIDX_WIDTH-1:0] ir_rs2idx_r;\n    wire [E203_PC_SIZE-1:0] ifu_pc_r;\n    wire out_flag_r;\n    wire pc_newpend_r;\n\n    // Implementation of the internal logic\n    // Reset control logic\n    sirv_gnrl_dffrs #(.DW(1)) reset_flag_dffrs (\n        .dnxt(1'b0),\n        .qout(reset_flag_r),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\n    // Halt control logic\n    sirv_gnrl_dfflr #(.DW(1)) halt_ack_dfflr (\n        .lden(halt_ack_ena),\n        .dnxt(halt_ack_nxt),\n        .qout(halt_ack_r),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\n    // Fetch request and response handling\n    assign ifu_req_valid = (ifu_new_req | ifu_reset_req | pipe_flush_req_real | ifetch_replay_req) & new_req_condi;\n    assign ifu_rsp_ready = ifu_rsp2ir_ready;\n\n    // Pipeline flush control\n    sirv_gnrl_dfflr #(.DW(1)) dly_flush_dfflr (\n        .lden(dly_flush_ena),\n        .dnxt(dly_flush_nxt),\n        .qout(dly_flush_r),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\n    // Instruction register control\n    sirv_gnrl_dfflr #(.DW(1)) ir_valid_dfflr (\n        .lden(ir_valid_ena),\n        .dnxt(ir_valid_nxt),\n        .qout(ir_valid_r),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\n    // Program counter control\n    sirv_gnrl_dfflr #(.DW(E203_PC_SIZE)) pc_dfflr (\n        .lden(pc_ena),\n        .dnxt(pc_nxt),\n        .qout(ifu_pc_r),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\n    // Output interface\n    assign ifu_o_ir = {ifu_hi_ir_r, ifu_lo_ir_r};\n    assign ifu_o_pc = ifu_pc_r;\n    assign ifu_o_pc_vld = ir_pc_vld_r;\n    assign ifu_o_rs1idx = ir_rs1idx_r;\n    assign ifu_o_rs2idx = ir_rs2idx_r;\n    assign ifu_o_prdt_taken = ifu_prdt_taken_r;\n    assign ifu_o_misalgn = 1'b0; // Assuming no misalignment in RV32C\n    assign ifu_o_buserr = ifu_err_r;\n    assign ifu_o_muldiv_b2b = ifu_muldiv_b2b_r;\n    assign ifu_o_valid = ir_valid_r;\n    assign ifu_halt_ack = halt_ack_r;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 20, "code": "module e203_exu_disp (\n    input wire wfi_halt_exu_req,\n    output wire wfi_halt_exu_ack,\n    input wire oitf_empty,\n    input wire amo_wait,\n    input wire disp_i_valid,\n    output wire disp_i_ready,\n    input wire disp_i_rs1x0,\n    input wire disp_i_rs2x0,\n    input wire disp_i_rs1en,\n    input wire disp_i_rs2en,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input wire [E203_XLEN-1:0] disp_i_rs1,\n    input wire [E203_XLEN-1:0] disp_i_rs2,\n    input wire disp_i_rdwen,\n    input wire [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input wire [E203_DECINFO_WIDTH-1:0] disp_i_info,\n    input wire [E203_XLEN-1:0] disp_i_imm,\n    input wire [E203_PC_SIZE-1:0] disp_i_pc,\n    input wire disp_i_misalgn,\n    input wire disp_i_buserr,\n    input wire disp_i_ilegl,\n    output wire disp_o_alu_valid,\n    input wire disp_o_alu_ready,\n    input wire disp_o_alu_longpipe,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs1,\n    output wire [E203_XLEN-1:0] disp_o_alu_rs2,\n    output wire disp_o_alu_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_o_alu_rdidx,\n    output wire [E203_DECINFO_WIDTH-1:0] disp_o_alu_info,\n    output wire [E203_XLEN-1:0] disp_o_alu_imm,\n    output wire [E203_PC_SIZE-1:0] disp_o_alu_pc,\n    output wire [E203_ITAG_WIDTH-1:0] disp_o_alu_itag,\n    output wire disp_o_alu_misalgn,\n    output wire disp_o_alu_buserr,\n    output wire disp_o_alu_ilegl,\n    input wire oitfrd_match_disprs1,\n    input wire oitfrd_match_disprs2,\n    input wire oitfrd_match_disprs3,\n    input wire oitfrd_match_disprd,\n    input wire [E203_ITAG_WIDTH-1:0] disp_oitf_ptr,\n    output wire disp_oitf_ena,\n    input wire disp_oitf_ready,\n    output wire disp_oitf_rs1fpu,\n    output wire disp_oitf_rs2fpu,\n    output wire disp_oitf_rs3fpu,\n    output wire disp_oitf_rdfpu,\n    output wire disp_oitf_rs1en,\n    output wire disp_oitf_rs2en,\n    output wire disp_oitf_rs3en,\n    output wire disp_oitf_rdwen,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs2idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs3idx,\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rdidx,\n    output wire [E203_PC_SIZE-1:0] disp_oitf_pc,\n    input wire clk,\n    input wire rst_n\n);\n\n    // Implementation of the dispatch logic\n    // This is a simplified example and needs to be expanded based on actual requirements\n\n    assign disp_i_ready = !disp_o_alu_longpipe && disp_oitf_ready && !amo_wait && !wfi_halt_exu_req;\n    assign disp_o_alu_valid = disp_i_valid && disp_i_ready;\n    assign disp_o_alu_rs1 = disp_i_rs1x0 ? 0 : disp_i_rs1;\n    assign disp_o_alu_rs2 = disp_i_rs2x0 ? 0 : disp_i_rs2;\n    assign disp_o_alu_rdwen = disp_i_rdwen;\n    assign disp_o_alu_rdidx = disp_i_rdidx;\n    assign disp_o_alu_info = disp_i_info;\n    assign disp_o_alu_imm = disp_i_imm;\n    assign disp_o_alu_pc = disp_i_pc;\n    assign disp_o_alu_itag = disp_oitf_ptr;\n    assign disp_o_alu_misalgn = disp_i_misalgn;\n    assign disp_o_alu_buserr = disp_i_buserr;\n    assign disp_o_alu_ilegl = disp_i_ilegl;\n\n    assign disp_oitf_ena = disp_o_alu_valid && disp_o_alu_longpipe;\n    assign disp_oitf_rs1fpu = 0; // Assuming no FPU in this example\n    assign disp_oitf_rs2fpu = 0;\n    assign disp_oitf_rs3fpu = 0;\n    assign disp_oitf_rdfpu = 0;\n    assign disp_oitf_rs1en = disp_i_rs1en;\n    assign disp_oitf_rs2en = disp_i_rs2en;\n    assign disp_oitf_rs3en = 0; // Assuming no third operand\n    assign disp_oitf_rdwen = disp_i_rdwen;\n    assign disp_oitf_rs1idx = disp_i_rs1idx;\n    assign disp_oitf_rs2idx = disp_i_rs2idx;\n    assign disp_oitf_rs3idx = 0; // Assuming no third operand\n    assign disp_oitf_rdidx = disp_i_rdidx;\n    assign disp_oitf_pc = disp_i_pc;\n\n    assign wfi_halt_exu_ack = wfi_halt_exu_req && oitf_empty && !amo_wait;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 18, "code": "module e203_lsu_ctrl(\n    input wire commit_mret,\n    input wire commit_trap,\n    output wire lsu_ctrl_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    input wire nice_mem_holdup,\n    input wire nice_icb_cmd_valid,\n    output wire nice_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] nice_icb_cmd_addr,\n    input wire nice_icb_cmd_read,\n    input wire [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] nice_icb_cmd_wmask,\n    output wire nice_icb_rsp_valid,\n    input wire nice_icb_rsp_ready,\n    output wire nice_icb_rsp_err,\n    output wire [E203_XLEN-1:0] nice_icb_rsp_rdata,\n\n    output wire dcache_icb_cmd_valid,\n    input wire dcache_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] dcache_icb_cmd_addr,\n    output wire dcache_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dcache_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dcache_icb_cmd_wmask,\n    output wire dcache_icb_cmd_lock,\n    output wire dcache_icb_cmd_excl,\n    output wire [1:0] dcache_icb_cmd_size,\n    input wire dcache_icb_rsp_valid,\n    output wire dcache_icb_rsp_ready,\n    input wire dcache_icb_rsp_err,\n    input wire dcache_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dcache_icb_rsp_rdata,\n\n    output wire dtcm_icb_cmd_valid,\n    input wire dtcm_icb_cmd_ready,\n    output wire [E203_DTCM_ADDR_WIDTH-1:0] dtcm_icb_cmd_addr,\n    output wire dtcm_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dtcm_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dtcm_icb_cmd_wmask,\n    output wire dtcm_icb_cmd_lock,\n    output wire dtcm_icb_cmd_excl,\n    output wire [1:0] dtcm_icb_cmd_size,\n    input wire dtcm_icb_rsp_valid,\n    output wire dtcm_icb_rsp_ready,\n    input wire dtcm_icb_rsp_err,\n    input wire dtcm_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dtcm_icb_rsp_rdata,\n    input wire [E203_ADDR_SIZE-1:0] dtcm_region_indic,\n\n    output wire biu_icb_cmd_valid,\n    input wire biu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,\n    output wire biu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] biu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] biu_icb_cmd_wmask,\n    output wire biu_icb_cmd_lock,\n    output wire biu_icb_cmd_excl,\n    output wire [1:0] biu_icb_cmd_size,\n    input wire biu_icb_rsp_valid,\n    output wire biu_icb_rsp_ready,\n    input wire biu_icb_rsp_err,\n    input wire biu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] biu_icb_rsp_rdata\n);\n    // LSU control logic here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 20, "code": "module e203_exu_excp(\n    output commit_trap,\n    output core_wfi,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input amo_wait,\n    input alu_excp_i_valid,\n    input alu_excp_i_ld,\n    input alu_excp_i_stamo,\n    input alu_excp_i_misalgn,\n    input alu_excp_i_buserr,\n    input alu_excp_i_ecall,\n    input alu_excp_i_ebreak,\n    input alu_excp_i_wfi,\n    input alu_excp_i_ifu_misalgn,\n    input alu_excp_i_ifu_buserr,\n    input alu_excp_i_ifu_ilegl,\n    input [E203_PC_SIZE-1:0] alu_excp_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_excp_i_instr,\n    input alu_excp_i_pc_vld,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input longp_excp_i_insterr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input excpirq_flush_ack,\n    output excpirq_flush_req,\n    output nonalu_excpirq_flush_req_raw,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op1,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op2,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input cmt_dret_ena,\n    input cmt_ena,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_badaddr_ena,\n    output cmt_epc_ena,\n    output cmt_cause_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output excp_active,\n    input clk,\n    input rst_n\n);\n\n    // Internal signal declarations\n    reg [E203_PC_SIZE-1:0] excp_pc;\n    reg excp_active_reg;\n    wire flush_pipeline;\n    wire [E203_XLEN-1:0] cause_value;\n    wire [E203_ADDR_SIZE-1:0] badaddr_value;\n\n    // Exception and interrupt handling logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            excp_active_reg <= 1'b0;\n            excp_pc <= {E203_PC_SIZE{1'b0}};\n        end else begin\n            if (flush_pipeline) begin\n                excp_active_reg <= 1'b1;\n                excp_pc <= csr_mtvec_r; // Start execution from mtvec base address\n            end else begin\n                excp_active_reg <= 1'b0;\n            end\n        end\n    end\n\n    assign flush_pipeline = alu_excp_i_valid | longp_excp_i_valid | dbg_irq_r;\n    assign excp_active = excp_active_reg;\n    assign commit_trap = excp_active_reg;\n\n    // Calculate cause and bad address\n    assign cause_value = (alu_excp_i_valid) ? {E203_XLEN-5{1'b0}, alu_excp_i_ecall, alu_excp_i_ebreak, alu_excp_i_misalgn, alu_excp_i_buserr} : \n                         (longp_excp_i_valid) ? {E203_XLEN-5{1'b0}, longp_excp_i_ld, longp_excp_i_st, longp_excp_i_buserr, longp_excp_i_insterr} : \n                         {E203_XLEN{1'b0}};\n\n    assign badaddr_value = (alu_excp_i_valid) ? alu_excp_i_pc : \n                           (longp_excp_i_valid) ? longp_excp_i_badaddr : \n                           {E203_ADDR_SIZE{1'b0}};\n\n    // Outputs\n    assign cmt_cause = cause_value;\n    assign cmt_badaddr = badaddr_value;\n    assign cmt_epc = excp_pc;\n    assign cmt_cause_ena = flush_pipeline;\n    assign cmt_badaddr_ena = flush_pipeline;\n    assign cmt_epc_ena = flush_pipeline;\n\n    // WFI handling\n    assign core_wfi = alu_excp_i_wfi & ~flush_pipeline;\n    assign wfi_halt_ifu_req = alu_excp_i_wfi;\n    assign wfi_halt_exu_req = alu_excp_i_wfi;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 19, "code": "module e203_ifu_ift2icb (\n    input wire itcm_nohold,\n    input wire ifu_req_valid,\n    input wire [PC_SIZE-1:0] ifu_req_pc,\n    input wire ifu_req_seq,\n    input wire ifu_req_seq_rv32,\n    input wire [PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_ready,\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_ready,\n    output wire ifu_rsp_valid,\n    output wire ifu_rsp_err,\n    output wire [31:0] ifu_rsp_instr,\n    output wire ifu2itcm_icb_cmd_valid,\n    input wire ifu2itcm_icb_cmd_ready,\n    output wire [ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_rsp_valid,\n    output wire ifu2itcm_icb_rsp_ready,\n    input wire ifu2itcm_icb_rsp_err,\n    input wire [ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    output wire ifu2biu_icb_cmd_valid,\n    input wire ifu2biu_icb_cmd_ready,\n    output wire [ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input wire ifu2biu_icb_rsp_valid,\n    output wire ifu2biu_icb_rsp_ready,\n    input wire ifu2biu_icb_rsp_err,\n    input wire [SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata\n);\n\n    // State machine definition\n    localparam ICB_STATE_IDLE = 2'b00;\n    localparam ICB_STATE_1ST = 2'b01;\n    localparam ICB_STATE_WAIT2ND = 2'b10;\n    localparam ICB_STATE_2ND = 2'b11;\n\n    reg [1:0] icb_state, icb_state_nxt;\n    wire icb_state_ena;\n    wire state_idle_exit_ena;\n\n    // Handshake signals\n    wire ifu_req_hsked = ifu_req_valid && ifu_req_ready;\n    wire ifu_icb_cmd_hsked = ifu2itcm_icb_cmd_valid && ifu2itcm_icb_cmd_ready;\n    wire ifu_icb_rsp_hsked = ifu2itcm_icb_rsp_valid && ifu2itcm_icb_rsp_ready;\n    wire i_ifu_rsp_hsked = ifu_rsp_valid && ifu_rsp_ready;\n\n    // State transition logic\n    always @(*) begin\n        case (icb_state)\n            ICB_STATE_IDLE: begin\n                if (state_idle_exit_ena)\n                    icb_state_nxt = ICB_STATE_1ST;\n                else\n                    icb_state_nxt = ICB_STATE_IDLE;\n            end\n            ICB_STATE_1ST: begin\n                if (ifu_icb_rsp_hsked)\n                    icb_state_nxt = ICB_STATE_WAIT2ND;\n                else\n                    icb_state_nxt = ICB_STATE_1ST;\n            end\n            ICB_STATE_WAIT2ND: begin\n                if (ifu_icb_cmd_ready)\n                    icb_state_nxt = ICB_STATE_2ND;\n                else\n                    icb_state_nxt = ICB_STATE_WAIT2ND;\n            end\n            ICB_STATE_2ND: begin\n                if (i_ifu_rsp_hsked)\n                    icb_state_nxt = ICB_STATE_IDLE;\n                else\n                    icb_state_nxt = ICB_STATE_2ND;\n            end\n            default: icb_state_nxt = ICB_STATE_IDLE;\n        endcase\n    end\n\n    // State update control\n    assign icb_state_ena = (icb_state != icb_state_nxt);\n\n    // State register\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            icb_state <= ICB_STATE_IDLE;\n        else if (icb_state_ena)\n            icb_state <= icb_state_nxt;\n    end\n\n    // Output logic\n    assign ifu_req_ready = (icb_state == ICB_STATE_IDLE);\n    assign ifu_rsp_valid = (icb_state == ICB_STATE_2ND);\n    assign ifu_rsp_err = ifu2itcm_icb_rsp_err;\n    assign ifu_rsp_instr = ifu2itcm_icb_rsp_rdata[31:0];\n\n    // ICB command interface\n    assign ifu2itcm_icb_cmd_valid = (icb_state == ICB_STATE_1ST);\n    assign ifu2itcm_icb_cmd_addr = ifu_req_pc[ITCM_ADDR_WIDTH-1:0];\n    assign ifu2itcm_icb_rsp_ready = (icb_state == ICB_STATE_1ST);\n\n    // ICB response interface\n    assign ifu2biu_icb_cmd_valid = (icb_state == ICB_STATE_1ST);\n    assign ifu2biu_icb_cmd_addr = ifu_req_pc[ADDR_SIZE-1:0];\n    assign ifu2biu_icb_rsp_ready = (icb_state == ICB_STATE_1ST);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 19, "code": "module e203_lsu_ctrl(\n    input wire commit_mret,\n    input wire commit_trap,\n    output wire lsu_ctrl_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    input wire nice_mem_holdup,\n    input wire nice_icb_cmd_valid,\n    output wire nice_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] nice_icb_cmd_addr,\n    input wire nice_icb_cmd_read,\n    input wire [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] nice_icb_cmd_wmask,\n    output wire nice_icb_rsp_valid,\n    input wire nice_icb_rsp_ready,\n    output wire nice_icb_rsp_err,\n    output wire [E203_XLEN-1:0] nice_icb_rsp_rdata,\n\n    output wire dcache_icb_cmd_valid,\n    input wire dcache_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] dcache_icb_cmd_addr,\n    output wire dcache_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dcache_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dcache_icb_cmd_wmask,\n    output wire dcache_icb_cmd_lock,\n    output wire dcache_icb_cmd_excl,\n    output wire [1:0] dcache_icb_cmd_size,\n    input wire dcache_icb_rsp_valid,\n    output wire dcache_icb_rsp_ready,\n    input wire dcache_icb_rsp_err,\n    input wire dcache_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dcache_icb_rsp_rdata,\n\n    output wire dtcm_icb_cmd_valid,\n    input wire dtcm_icb_cmd_ready,\n    output wire [E203_DTCM_ADDR_WIDTH-1:0] dtcm_icb_cmd_addr,\n    output wire dtcm_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dtcm_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dtcm_icb_cmd_wmask,\n    output wire dtcm_icb_cmd_lock,\n    output wire dtcm_icb_cmd_excl,\n    output wire [1:0] dtcm_icb_cmd_size,\n    input wire dtcm_icb_rsp_valid,\n    output wire dtcm_icb_rsp_ready,\n    input wire dtcm_icb_rsp_err,\n    input wire dtcm_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dtcm_icb_rsp_rdata,\n    input wire [E203_ADDR_SIZE-1:0] dtcm_region_indic,\n\n    output wire biu_icb_cmd_valid,\n    input wire biu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,\n    output wire biu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] biu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] biu_icb_cmd_wmask,\n    output wire biu_icb_cmd_lock,\n    output wire biu_icb_cmd_excl,\n    output wire [1:0] biu_icb_cmd_size,\n    input wire biu_icb_rsp_valid,\n    output wire biu_icb_rsp_ready,\n    input wire biu_icb_rsp_err,\n    input wire biu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] biu_icb_rsp_rdata\n);\n    // LSU control logic here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 20, "code": "module e203_lsu_ctrl(\n    input wire commit_mret,\n    input wire commit_trap,\n    output wire lsu_ctrl_active,\n\n    output wire lsu_o_valid,\n    input wire lsu_o_ready,\n    output wire [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output wire [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output wire lsu_o_wbck_err,\n    output wire lsu_o_cmt_buserr,\n    output wire [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output wire lsu_o_cmt_ld,\n    output wire lsu_o_cmt_st,\n\n    input wire agu_icb_cmd_valid,\n    output wire agu_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input wire agu_icb_cmd_read,\n    input wire [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] agu_icb_cmd_wmask,\n    input wire agu_icb_cmd_lock,\n    input wire agu_icb_cmd_excl,\n    input wire [1:0] agu_icb_cmd_size,\n    input wire agu_icb_cmd_back2agu,\n    input wire agu_icb_cmd_usign,\n    input wire [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n\n    output wire agu_icb_rsp_valid,\n    input wire agu_icb_rsp_ready,\n    output wire agu_icb_rsp_err,\n    output wire agu_icb_rsp_excl_ok,\n    output wire [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    input wire nice_mem_holdup,\n    input wire nice_icb_cmd_valid,\n    output wire nice_icb_cmd_ready,\n    input wire [E203_ADDR_SIZE-1:0] nice_icb_cmd_addr,\n    input wire nice_icb_cmd_read,\n    input wire [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input wire [(E203_XLEN/8)-1:0] nice_icb_cmd_wmask,\n    output wire nice_icb_rsp_valid,\n    input wire nice_icb_rsp_ready,\n    output wire nice_icb_rsp_err,\n    output wire [E203_XLEN-1:0] nice_icb_rsp_rdata,\n\n    output wire dcache_icb_cmd_valid,\n    input wire dcache_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] dcache_icb_cmd_addr,\n    output wire dcache_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dcache_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dcache_icb_cmd_wmask,\n    output wire dcache_icb_cmd_lock,\n    output wire dcache_icb_cmd_excl,\n    output wire [1:0] dcache_icb_cmd_size,\n    input wire dcache_icb_rsp_valid,\n    output wire dcache_icb_rsp_ready,\n    input wire dcache_icb_rsp_err,\n    input wire dcache_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dcache_icb_rsp_rdata,\n\n    output wire dtcm_icb_cmd_valid,\n    input wire dtcm_icb_cmd_ready,\n    output wire [E203_DTCM_ADDR_WIDTH-1:0] dtcm_icb_cmd_addr,\n    output wire dtcm_icb_cmd_read,\n    output wire [E203_XLEN-1:0] dtcm_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] dtcm_icb_cmd_wmask,\n    output wire dtcm_icb_cmd_lock,\n    output wire dtcm_icb_cmd_excl,\n    output wire [1:0] dtcm_icb_cmd_size,\n    input wire dtcm_icb_rsp_valid,\n    output wire dtcm_icb_rsp_ready,\n    input wire dtcm_icb_rsp_err,\n    input wire dtcm_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] dtcm_icb_rsp_rdata,\n    input wire [E203_ADDR_SIZE-1:0] dtcm_region_indic,\n\n    output wire biu_icb_cmd_valid,\n    input wire biu_icb_cmd_ready,\n    output wire [E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,\n    output wire biu_icb_cmd_read,\n    output wire [E203_XLEN-1:0] biu_icb_cmd_wdata,\n    output wire [(E203_XLEN/8)-1:0] biu_icb_cmd_wmask,\n    output wire biu_icb_cmd_lock,\n    output wire biu_icb_cmd_excl,\n    output wire [1:0] biu_icb_cmd_size,\n    input wire biu_icb_rsp_valid,\n    output wire biu_icb_rsp_ready,\n    input wire biu_icb_rsp_err,\n    input wire biu_icb_rsp_excl_ok,\n    input wire [E203_XLEN-1:0] biu_icb_rsp_rdata\n);\n    // Implementation of LSU control logic here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 20, "code": "module e203_ifu_ift2icb (\n    input wire itcm_nohold,\n    input wire ifu_req_valid,\n    input wire [PC_SIZE-1:0] ifu_req_pc,\n    input wire ifu_req_seq,\n    input wire ifu_req_seq_rv32,\n    input wire [PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_ready,\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_ready,\n    output wire ifu_rsp_valid,\n    output wire ifu_rsp_err,\n    output wire [31:0] ifu_rsp_instr,\n    output wire ifu2itcm_icb_cmd_valid,\n    input wire ifu2itcm_icb_cmd_ready,\n    output wire [ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_rsp_valid,\n    output wire ifu2itcm_icb_rsp_ready,\n    input wire ifu2itcm_icb_rsp_err,\n    input wire [ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    output wire ifu2biu_icb_cmd_valid,\n    input wire ifu2biu_icb_cmd_ready,\n    output wire [ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input wire ifu2biu_icb_rsp_valid,\n    output wire ifu2biu_icb_rsp_ready,\n    input wire ifu2biu_icb_rsp_err,\n    input wire [SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata\n);\n\n    // State definitions\n    localparam ICB_STATE_IDLE = 2'b00;\n    localparam ICB_STATE_1ST = 2'b01;\n    localparam ICB_STATE_WAIT2ND = 2'b10;\n    localparam ICB_STATE_2ND = 2'b11;\n\n    // State registers\n    reg [1:0] icb_state;\n    reg [1:0] icb_state_nxt;\n\n    // State transition and output logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            icb_state <= ICB_STATE_IDLE;\n        end else begin\n            icb_state <= icb_state_nxt;\n        end\n    end\n\n    always @(*) begin\n        case (icb_state)\n            ICB_STATE_IDLE: begin\n                if (ifu_req_valid && ifu_req_ready) begin\n                    icb_state_nxt = ICB_STATE_1ST;\n                end else begin\n                    icb_state_nxt = ICB_STATE_IDLE;\n                end\n            end\n            ICB_STATE_1ST: begin\n                if (ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid) begin\n                    icb_state_nxt = ICB_STATE_WAIT2ND;\n                end else begin\n                    icb_state_nxt = ICB_STATE_1ST;\n                end\n            end\n            ICB_STATE_WAIT2ND: begin\n                if (ifu2itcm_icb_cmd_ready || ifu2biu_icb_cmd_ready) begin\n                    icb_state_nxt = ICB_STATE_2ND;\n                end else begin\n                    icb_state_nxt = ICB_STATE_WAIT2ND;\n                end\n            end\n            ICB_STATE_2ND: begin\n                if (ifu_rsp_ready) begin\n                    icb_state_nxt = ICB_STATE_IDLE;\n                end else begin\n                    icb_state_nxt = ICB_STATE_2ND;\n                end\n            end\n            default: begin\n                icb_state_nxt = ICB_STATE_IDLE;\n            end\n        endcase\n    end\n\n    // Output logic for ICB commands and responses\n    assign ifu_req_ready = (icb_state == ICB_STATE_IDLE);\n    assign ifu_rsp_valid = (icb_state == ICB_STATE_2ND) && (ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid);\n    assign ifu_rsp_err = (icb_state == ICB_STATE_2ND) && (ifu2itcm_icb_rsp_err || ifu2biu_icb_rsp_err);\n    assign ifu_rsp_instr = (icb_state == ICB_STATE_2ND) ? (ifu2itcm_icb_rsp_rdata[31:0] : ifu2biu_icb_rsp_rdata[31:0]);\n\n    // ICB command generation\n    assign ifu2itcm_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && (ifu_req_pc < `ITCM_ADDR_RANGE);\n    assign ifu2itcm_icb_cmd_addr = ifu_req_pc[ITCM_ADDR_WIDTH-1:0];\n    assign ifu2biu_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && (ifu_req_pc >= `ITCM_ADDR_RANGE);\n    assign ifu2biu_icb_cmd_addr = ifu_req_pc[ADDR_SIZE-1:0];\n\n    // ICB response handling\n    assign ifu2itcm_icb_rsp_ready = (icb_state == ICB_STATE_2ND);\n    assign ifu2biu_icb_rsp_ready = (icb_state == ICB_STATE_2ND);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 19, "code": "module itcm_controller #(\n    parameter ADDR_WIDTH = 32,\n    parameter DATA_WIDTH = 64,\n    parameter WMSK_WIDTH = DATA_WIDTH / 8,\n    parameter RAM_AW = 10,\n    parameter RAM_MW = DATA_WIDTH / 8,\n    parameter RAM_DW = DATA_WIDTH\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n\n    // IFU Interface\n    input wire ifu2itcm_icb_cmd_valid,\n    output wire ifu2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] ifu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] ifu2itcm_icb_cmd_wmask,\n    output wire ifu2itcm_icb_rsp_valid,\n    input wire ifu2itcm_icb_rsp_ready,\n    output wire ifu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n\n    // LSU Interface\n    input wire lsu2itcm_icb_cmd_valid,\n    output wire lsu2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] lsu2itcm_icb_cmd_addr,\n    input wire lsu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] lsu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] lsu2itcm_icb_cmd_wmask,\n    output wire lsu2itcm_icb_rsp_valid,\n    input wire lsu2itcm_icb_rsp_ready,\n    output wire lsu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] lsu2itcm_icb_rsp_rdata,\n\n    // External Interface\n    `ifdef E203_HAS_ITCM_EXTITF\n    input wire ext2itcm_icb_cmd_valid,\n    output wire ext2itcm_icb_cmd_ready,\n    input wire [ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input wire ext2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] ext2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] ext2itcm_icb_cmd_wmask,\n    output wire ext2itcm_icb_rsp_valid,\n    input wire ext2itcm_icb_rsp_ready,\n    output wire ext2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] ext2itcm_icb_rsp_rdata,\n    `endif\n\n    // RAM Interface\n    output wire itcm_ram_cs,\n    output wire itcm_ram_we,\n    output wire [RAM_AW-1:0] itcm_ram_addr,\n    output wire [RAM_MW-1:0] itcm_ram_wem,\n    output wire [RAM_DW-1:0] itcm_ram_din,\n    input wire [RAM_DW-1:0] itcm_ram_dout,\n    output wire clk_itcm_ram,\n\n    // Status Output\n    output wire itcm_active\n);\n\n    // Internal signals\n    wire [ADDR_WIDTH-1:0] selected_addr;\n    wire [DATA_WIDTH-1:0] selected_wdata;\n    wire [WMSK_WIDTH-1:0] selected_wmask;\n    wire selected_read;\n    wire selected_valid;\n    wire selected_ready;\n    wire selected_rsp_valid;\n    wire selected_rsp_ready;\n    wire selected_rsp_err;\n    wire [DATA_WIDTH-1:0] selected_rsp_rdata;\n\n    // Arbitration logic (simplified example)\n    assign ifu2itcm_icb_cmd_ready = !lsu2itcm_icb_cmd_valid && !ext2itcm_icb_cmd_valid;\n    assign lsu2itcm_icb_cmd_ready = !ifu2itcm_icb_cmd_valid && !ext2itcm_icb_cmd_valid;\n    `ifdef E203_HAS_ITCM_EXTITF\n    assign ext2itcm_icb_cmd_ready = !ifu2itcm_icb_cmd_valid && !lsu2itcm_icb_cmd_valid;\n    `endif\n\n    // Select active interface\n    always @(*) begin\n        if (lsu2itcm_icb_cmd_valid) begin\n            selected_addr = lsu2itcm_icb_cmd_addr;\n            selected_wdata = lsu2itcm_icb_cmd_wdata;\n            selected_wmask = lsu2itcm_icb_cmd_wmask;\n            selected_read = lsu2itcm_icb_cmd_read;\n            selected_valid = lsu2itcm_icb_cmd_valid;\n            selected_ready = lsu2itcm_icb_cmd_ready;\n            selected_rsp_valid = lsu2itcm_icb_rsp_valid;\n            selected_rsp_ready = lsu2itcm_icb_rsp_ready;\n            selected_rsp_err = lsu2itcm_icb_rsp_err;\n            selected_rsp_rdata = lsu2itcm_icb_rsp_rdata;\n        end else if (ifu2itcm_icb_cmd_valid) begin\n            selected_addr = ifu2itcm_icb_cmd_addr;\n            selected_wdata = ifu2itcm_icb_cmd_wdata;\n            selected_wmask = ifu2itcm_icb_cmd_wmask;\n            selected_read = ifu2itcm_icb_cmd_read;\n            selected_valid = ifu2itcm_icb_cmd_valid;\n            selected_ready = ifu2itcm_icb_cmd_ready;\n            selected_rsp_valid = ifu2itcm_icb_rsp_valid;\n            selected_rsp_ready = ifu2itcm_icb_rsp_ready;\n            selected_rsp_err = ifu2itcm_icb_rsp_err;\n            selected_rsp_rdata = ifu2itcm_icb_rsp_rdata;\n        end\n        `ifdef E203_HAS_ITCM_EXTITF\n        else if (ext2itcm_icb_cmd_valid) begin\n            selected_addr = ext2itcm_icb_cmd_addr;\n            selected_wdata = ext2itcm_icb_cmd_wdata;\n            selected_wmask = ext2itcm_icb_cmd_wmask;\n            selected_read = ext2itcm_icb_cmd_read;\n            selected_valid = ext2itcm_icb_cmd_valid;\n            selected_ready = ext2itcm_icb_cmd_ready;\n            selected_rsp_valid = ext2itcm_icb_rsp_valid;\n            selected_rsp_ready = ext2itcm_icb_rsp_ready;\n            selected_rsp_err = ext2itcm_icb_rsp_err;\n            selected_rsp_rdata = ext2itcm_icb_rsp_rdata;\n        end\n        `endif\n    end\n\n    // Connect to RAM\n    assign itcm_ram_cs = selected_valid && selected_ready;\n    assign itcm_ram_we = !selected_read;\n    assign itcm_ram_addr = selected_addr[RAM_AW-1:0];\n    assign itcm_ram_wem = selected_wmask;\n    assign itcm_ram_din = selected_wdata;\n    assign clk_itcm_ram = clk;\n\n    // Read data handling\n    assign selected_rsp_rdata = itcm_ram_dout;\n\n    // Active status\n    assign itcm_active = selected_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 20, "code": "module e203_exu_decode (\n    input [E203_INSTR_SIZE-1:0] i_instr,\n    input [E203_PC_SIZE-1:0] i_pc,\n    input i_prdt_taken,\n    input i_misalgn,\n    input i_buserr,\n    input i_muldiv_b2b,\n    input dbg_mode,\n    output dec_rs1x0,\n    output dec_rs2x0,\n    output dec_rs1en,\n    output dec_rs2en,\n    output dec_rdwen,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rdidx,\n    output [E203_DECINFO_WIDTH-1:0] dec_info,\n    output [E203_XLEN-1:0] dec_imm,\n    output [E203_PC_SIZE-1:0] dec_pc,\n    output dec_misalgn,\n    output dec_buserr,\n    output dec_ilegl,\n    output dec_mulhsu,\n    output dec_mul,\n    output dec_div,\n    output dec_rem,\n    output dec_divu,\n    output dec_remu,\n    output dec_rv32,\n    output dec_bjp,\n    output dec_jal,\n    output dec_jalr,\n    output dec_bxx,\n    output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    output [E203_XLEN-1:0] dec_bjp_imm,\n    output dec_nice,\n    output nice_cmt_off_ilgl_o\n);\n\n    // Internal signals for decoding logic\n    wire [6:0] opcode = i_instr[6:0];\n    wire [2:0] funct3 = i_instr[14:12];\n    wire [6:0] funct7 = i_instr[31:25];\n    wire [4:0] rs1 = i_instr[19:15];\n    wire [4:0] rs2 = i_instr[24:20];\n    wire [4:0] rd = i_instr[11:7];\n    wire [11:0] imm12 = i_instr[31:20];\n    wire [11:0] imm12_I = {{20{imm12[11]}}, imm12};\n    wire [11:0] imm12_S = {{20{i_instr[31]}}, i_instr[31:25], i_instr[11:7]};\n    wire [12:0] imm13 = {{19{i_instr[31]}}, i_instr[31], i_instr[7], i_instr[30:25], i_instr[11:8], 1'b0};\n\n    // Decode logic for different types of instructions\n    assign dec_rs1x0 = (rs1 == 5'b00000);\n    assign dec_rs2x0 = (rs2 == 5'b00000);\n    assign dec_rs1en = (opcode == 7'b0110011) || (opcode == 7'b0010011); // R-type or I-type\n    assign dec_rs2en = (opcode == 7'b0110011); // R-type\n    assign dec_rdwen = (rd != 5'b00000);\n    assign dec_rs1idx = rs1;\n    assign dec_rs2idx = rs2;\n    assign dec_rdidx = rd;\n    assign dec_imm = imm12_I;\n    assign dec_pc = i_pc;\n    assign dec_misalgn = i_misalgn;\n    assign dec_buserr = i_buserr;\n    assign dec_ilegl = (opcode == 7'b0000000) || (opcode == 7'b1111111); // Example illegal condition\n    assign dec_mulhsu = (funct7 == 7'b0000001) && (funct3 == 3'b010);\n    assign dec_mul = (funct7 == 7'b0000001) && (funct3 == 3'b000);\n    assign dec_div = (funct7 == 7'b0000001) && (funct3 == 3'b100);\n    assign dec_rem = (funct7 == 7'b0000001) && (funct3 == 3'b110);\n    assign dec_divu = (funct7 == 7'b0000001) && (funct3 == 3'b101);\n    assign dec_remu = (funct7 == 7'b0000001) && (funct3 == 3'b111);\n    assign dec_rv32 = (i_instr[1:0] == 2'b11);\n    assign dec_bjp = (opcode == 7'b1101111) || (opcode == 7'b1100111) || (opcode == 7'b1100011);\n    assign dec_jal = (opcode == 7'b1101111);\n    assign dec_jalr = (opcode == 7'b1100111);\n    assign dec_bxx = (opcode == 7'b1100011);\n    assign dec_jalr_rs1idx = rs1;\n    assign dec_bjp_imm = imm13;\n\n    // Optional NICE extension\n    `ifdef E203_HAS_NICE\n    assign dec_nice = (opcode == 7'b0001011); // Example custom opcode for NICE\n    assign nice_cmt_off_ilgl_o = dec_nice && !nice_xs_off;\n    `else\n    assign dec_nice = 1'b0;\n    assign nice_cmt_off_ilgl_o = 1'b0;\n    `endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 19, "code": "module e203_ifu_ifetch(\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_valid,\n    input wire ifu_req_ready,\n    output wire [E203_PC_SIZE-1:0] ifu_req_pc,\n    output wire ifu_req_seq,\n    output wire ifu_req_seq_rv32,\n    output wire [E203_PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_valid,\n    output wire ifu_rsp_ready,\n    input wire ifu_rsp_err,\n    input wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr,\n    input wire pipe_flush_req,\n    output wire pipe_flush_ack,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    output wire ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    input wire ifu_halt_req,\n    output wire ifu_halt_ack,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu\n);\n\n    // Internal signals\n    reg [E203_PC_SIZE-1:0] pc_reg, pc_next;\n    reg [E203_INSTR_SIZE-1:0] ir_reg, ir_next;\n    reg valid_reg, valid_next;\n    reg [E203_RFIDX_WIDTH-1:0] rs1idx_reg, rs2idx_reg;\n    reg prdt_taken_reg, misalgn_reg, buserr_reg, muldiv_b2b_reg;\n    reg halt_ack_reg, halt_ack_next;\n\n    // Fetch logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            pc_reg <= {E203_PC_SIZE{1'b0}};\n            ir_reg <= {E203_INSTR_SIZE{1'b0}};\n            valid_reg <= 1'b0;\n            rs1idx_reg <= {E203_RFIDX_WIDTH{1'b0}};\n            rs2idx_reg <= {E203_RFIDX_WIDTH{1'b0}};\n            prdt_taken_reg <= 1'b0;\n            misalgn_reg <= 1'b0;\n            buserr_reg <= 1'b0;\n            muldiv_b2b_reg <= 1'b0;\n            halt_ack_reg <= 1'b0;\n        end else begin\n            pc_reg <= pc_next;\n            ir_reg <= ir_next;\n            valid_reg <= valid_next;\n            rs1idx_reg <= rs1idx_next;\n            rs2idx_reg <= rs2idx_next;\n            prdt_taken_reg <= prdt_taken_next;\n            misalgn_reg <= misalgn_next;\n            buserr_reg <= buserr_next;\n            muldiv_b2b_reg <= muldiv_b2b_next;\n            halt_ack_reg <= halt_ack_next;\n        end\n    end\n\n    // Next state logic\n    always @* begin\n        pc_next = pc_reg;\n        ir_next = ir_reg;\n        valid_next = valid_reg;\n        rs1idx_next = rs1idx_reg;\n        rs2idx_next = rs2idx_reg;\n        prdt_taken_next = prdt_taken_reg;\n        misalgn_next = misalgn_reg;\n        buserr_next = buserr_reg;\n        muldiv_b2b_next = muldiv_b2b_reg;\n        halt_ack_next = halt_ack_reg;\n\n        if (ifu_req_ready && ifu_req_valid) begin\n            pc_next = ifu_req_pc;\n            valid_next = 1'b1;\n        end\n\n        if (ifu_rsp_ready && ifu_rsp_valid) begin\n            ir_next = ifu_rsp_instr;\n            rs1idx_next = dec2ifu_rs1idx;\n            rs2idx_next = dec2ifu_rs2idx;\n            prdt_taken_next = ifu_o_prdt_taken;\n            misalgn_next = ifu_o_misalgn;\n            buserr_next = ifu_o_buserr;\n            muldiv_b2b_next = ifu_o_muldiv_b2b;\n        end\n\n        if (pipe_flush_req) begin\n            valid_next = 1'b0;\n            halt_ack_next = 1'b1;\n        end else if (!ifu_halt_req) begin\n            halt_ack_next = 1'b0;\n        end\n    end\n\n    // Output assignments\n    assign ifu_req_valid = valid_reg && !halt_ack_reg;\n    assign ifu_req_pc = pc_reg;\n    assign ifu_req_seq = 1'b1; // Assuming always sequential for simplicity\n    assign ifu_req_seq_rv32 = 1'b1; // Assuming always RV32 for simplicity\n    assign ifu_req_last_pc = pc_reg;\n    assign ifu_rsp_ready = !valid_reg || ifu_o_ready;\n    assign ifu_o_ir = ir_reg;\n    assign ifu_o_pc = pc_reg;\n    assign ifu_o_pc_vld = valid_reg;\n    assign ifu_o_rs1idx = rs1idx_reg;\n    assign ifu_o_rs2idx = rs2idx_reg;\n    assign ifu_o_prdt_taken = prdt_taken_reg;\n    assign ifu_o_misalgn = misalgn_reg;\n    assign ifu_o_buserr = buserr_reg;\n    assign ifu_o_muldiv_b2b = muldiv_b2b_reg;\n    assign ifu_o_valid = valid_reg;\n    assign ifu_halt_ack = halt_ack_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 20, "code": "module e203_ifu_ifetch(\n    input wire clk,\n    input wire rst_n,\n    output wire ifu_req_valid,\n    input wire ifu_req_ready,\n    output wire [E203_PC_SIZE-1:0] ifu_req_pc,\n    output wire ifu_req_seq,\n    output wire ifu_req_seq_rv32,\n    output wire [E203_PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_valid,\n    output wire ifu_rsp_ready,\n    input wire ifu_rsp_err,\n    input wire [E203_INSTR_SIZE-1:0] ifu_rsp_instr,\n    input wire pipe_flush_req,\n    output wire pipe_flush_ack,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    output wire [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n    input wire ifu_halt_req,\n    output wire ifu_halt_ack,\n    input wire oitf_empty,\n    input wire [E203_XLEN-1:0] rf2ifu_x1,\n    input wire [E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu\n);\n\n    // Internal signals\n    reg [E203_PC_SIZE-1:0] pc_reg, pc_next;\n    reg [E203_INSTR_SIZE-1:0] ir_reg, ir_next;\n    reg valid_reg, valid_next;\n    reg [E203_PC_SIZE-1:0] last_pc_reg, last_pc_next;\n    reg error_reg, error_next;\n    reg halt_ack_reg, halt_ack_next;\n    reg flush_ack_reg, flush_ack_next;\n    reg [E203_RFIDX_WIDTH-1:0] rs1idx_reg, rs1idx_next;\n    reg [E203_RFIDX_WIDTH-1:0] rs2idx_reg, rs2idx_next;\n    reg prdt_taken_reg, prdt_taken_next;\n    reg misalign_reg, misalign_next;\n    reg buserr_reg, buserr_next;\n    reg muldiv_b2b_reg, muldiv_b2b_next;\n    reg ifu_o_valid_reg, ifu_o_valid_next;\n\n    // Fetch logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            pc_reg <= 0;\n            ir_reg <= 0;\n            valid_reg <= 0;\n            last_pc_reg <= 0;\n            error_reg <= 0;\n            halt_ack_reg <= 0;\n            flush_ack_reg <= 0;\n            rs1idx_reg <= 0;\n            rs2idx_reg <= 0;\n            prdt_taken_reg <= 0;\n            misalign_reg <= 0;\n            buserr_reg <= 0;\n            muldiv_b2b_reg <= 0;\n            ifu_o_valid_reg <= 0;\n        end else begin\n            pc_reg <= pc_next;\n            ir_reg <= ir_next;\n            valid_reg <= valid_next;\n            last_pc_reg <= last_pc_next;\n            error_reg <= error_next;\n            halt_ack_reg <= halt_ack_next;\n            flush_ack_reg <= flush_ack_next;\n            rs1idx_reg <= rs1idx_next;\n            rs2idx_reg <= rs2idx_next;\n            prdt_taken_reg <= prdt_taken_next;\n            misalign_reg <= misalign_next;\n            buserr_reg <= buserr_next;\n            muldiv_b2b_reg <= muldiv_b2b_next;\n            ifu_o_valid_reg <= ifu_o_valid_next;\n        end\n    end\n\n    // Output assignments\n    assign ifu_req_valid = valid_reg;\n    assign ifu_req_pc = pc_reg;\n    assign ifu_req_last_pc = last_pc_reg;\n    assign ifu_rsp_ready = !valid_reg;\n    assign ifu_o_ir = ir_reg;\n    assign ifu_o_pc = pc_reg;\n    assign ifu_o_pc_vld = valid_reg;\n    assign ifu_o_rs1idx = rs1idx_reg;\n    assign ifu_o_rs2idx = rs2idx_reg;\n    assign ifu_o_prdt_taken = prdt_taken_reg;\n    assign ifu_o_misalgn = misalign_reg;\n    assign ifu_o_buserr = buserr_reg;\n    assign ifu_o_muldiv_b2b = muldiv_b2b_reg;\n    assign ifu_o_valid = ifu_o_valid_reg;\n    assign ifu_halt_ack = halt_ack_reg;\n    assign pipe_flush_ack = flush_ack_reg;\n\n    // Next state logic\n    always @* begin\n        pc_next = pc_reg;\n        ir_next = ir_reg;\n        valid_next = valid_reg;\n        last_pc_next = last_pc_reg;\n        error_next = error_reg;\n        halt_ack_next = halt_ack_reg;\n        flush_ack_next = flush_ack_reg;\n        rs1idx_next = rs1idx_reg;\n        rs2idx_next = rs2idx_reg;\n        prdt_taken_next = prdt_taken_reg;\n        misalign_next = misalign_reg;\n        buserr_next = buserr_reg;\n        muldiv_b2b_next = muldiv_b2b_reg;\n        ifu_o_valid_next = ifu_o_valid_reg;\n\n        if (ifu_req_ready && ifu_req_valid) begin\n            pc_next = pc_reg + 4; // Simple sequential fetch\n        end\n\n        if (ifu_rsp_valid && ifu_rsp_ready) begin\n            ir_next = ifu_rsp_instr;\n            valid_next = 1;\n            last_pc_next = pc_reg;\n        end\n\n        if (pipe_flush_req) begin\n            flush_ack_next = 1;\n            pc_next = pipe_flush_add_op1; // Example flush logic\n        end else begin\n            flush_ack_next = 0;\n        end\n\n        if (ifu_halt_req) begin\n            halt_ack_next = 1;\n        end else begin\n            halt_ack_next = 0;\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 20, "code": "module itcm_controller (\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n    input wire tcm_cgstop,\n    input wire [ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input wire ifu2itcm_icb_cmd_valid,\n    input wire ifu2itcm_icb_cmd_read,\n    input wire [DATA_WIDTH-1:0] ifu2itcm_icb_cmd_wdata,\n    input wire [WMSK_WIDTH-1:0] ifu2itcm_icb_cmd_wmask,\n    input wire ifu2itcm_icb_rsp_ready,\n    output wire ifu2itcm_icb_cmd_ready,\n    output wire ifu2itcm_icb_rsp_valid,\n    output wire ifu2itcm_icb_rsp_err,\n    output wire [DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n    output wire itcm_active,\n    output wire itcm_ram_cs,\n    output wire itcm_ram_we,\n    output wire [RAM_AW-1:0] itcm_ram_addr,\n    output wire [RAM_MW-1:0] itcm_ram_wem,\n    output wire [RAM_DW-1:0] itcm_ram_din,\n    input wire [RAM_DW-1:0] itcm_ram_dout,\n    output wire clk_itcm_ram\n);\n\n    // Internal signals\n    wire lsu2itcm_icb_cmd_valid, lsu2itcm_icb_cmd_read;\n    wire [ADDR_WIDTH-1:0] lsu2itcm_icb_cmd_addr;\n    wire [DATA_WIDTH-1:0] lsu2itcm_icb_cmd_wdata;\n    wire [WMSK_WIDTH-1:0] lsu2itcm_icb_cmd_wmask;\n    wire lsu2itcm_icb_rsp_ready;\n    wire lsu2itcm_icb_cmd_ready, lsu2itcm_icb_rsp_valid, lsu2itcm_icb_rsp_err;\n    wire [DATA_WIDTH-1:0] lsu2itcm_icb_rsp_rdata;\n\n    // Assuming external interface is similar to LSU and IFU\n    `ifdef E203_HAS_ITCM_EXTITF\n    wire ext2itcm_icb_cmd_valid, ext2itcm_icb_cmd_read;\n    wire [ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr;\n    wire [DATA_WIDTH-1:0] ext2itcm_icb_cmd_wdata;\n    wire [WMSK_WIDTH-1:0] ext2itcm_icb_cmd_wmask;\n    wire ext2itcm_icb_rsp_ready;\n    wire ext2itcm_icb_cmd_ready, ext2itcm_icb_rsp_valid, ext2itcm_icb_rsp_err;\n    wire [DATA_WIDTH-1:0] ext2itcm_icb_rsp_rdata;\n    `endif\n\n    // Arbiter instance\n    sirv_gnrl_icb_arbt #(\n        .AW(ADDR_WIDTH),\n        .DW(DATA_WIDTH),\n        .USR_W(1),\n        .ARBT_SCHEME(0), // Priority based\n        .FIFO_OUTS_NUM(1),\n        .FIFO_CUT_READY(0),\n        .ARBT_NUM(3),\n        .ALLOW_0CYCL_RSP(1),\n        .ARBT_PTR_W(2)\n    ) u_arbiter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .i_bus_icb_cmd_valid({lsu2itcm_icb_cmd_valid, ifu2itcm_icb_cmd_valid, ext2itcm_icb_cmd_valid}),\n        .i_bus_icb_cmd_ready({lsu2itcm_icb_cmd_ready, ifu2itcm_icb_cmd_ready, ext2itcm_icb_cmd_ready}),\n        .i_bus_icb_cmd_addr({lsu2itcm_icb_cmd_addr, ifu2itcm_icb_cmd_addr, ext2itcm_icb_cmd_addr}),\n        .i_bus_icb_cmd_read({lsu2itcm_icb_cmd_read, ifu2itcm_icb_cmd_read, ext2itcm_icb_cmd_read}),\n        .i_bus_icb_cmd_wdata({lsu2itcm_icb_cmd_wdata, ifu2itcm_icb_cmd_wdata, ext2itcm_icb_cmd_wdata}),\n        .i_bus_icb_cmd_wmask({lsu2itcm_icb_cmd_wmask, ifu2itcm_icb_cmd_wmask, ext2itcm_icb_cmd_wmask}),\n        .i_bus_icb_rsp_valid({lsu2itcm_icb_rsp_valid, ifu2itcm_icb_rsp_valid, ext2itcm_icb_rsp_valid}),\n        .i_bus_icb_rsp_ready({lsu2itcm_icb_rsp_ready, ifu2itcm_icb_rsp_ready, ext2itcm_icb_rsp_ready}),\n        .i_bus_icb_rsp_rdata({lsu2itcm_icb_rsp_rdata, ifu2itcm_icb_rsp_rdata, ext2itcm_icb_rsp_rdata}),\n        .i_bus_icb_rsp_err({lsu2itcm_icb_rsp_err, ifu2itcm_icb_rsp_err, ext2itcm_icb_rsp_err}),\n        .o_icb_cmd_valid(),\n        .o_icb_cmd_ready(),\n        .o_icb_cmd_addr(),\n        .o_icb_cmd_read(),\n        .o_icb_cmd_wdata(),\n        .o_icb_cmd_wmask(),\n        .o_icb_rsp_valid(),\n        .o_icb_rsp_ready(),\n        .o_icb_rsp_rdata(),\n        .o_icb_rsp_err()\n    );\n\n    // SRAM controller instance\n    sirv_sram_icb_ctrl #(\n        .DW(DATA_WIDTH),\n        .MW(WMSK_WIDTH),\n        .AW(ADDR_WIDTH),\n        .AW_LSB(3),\n        .USR_W(3)\n    ) u_sram_ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .i_icb_cmd_valid(),\n        .i_icb_cmd_ready(),\n        .i_icb_cmd_read(),\n        .i_icb_cmd_addr(),\n        .i_icb_cmd_wdata(),\n        .i_icb_cmd_wmask(),\n        .i_icb_cmd_usr(),\n        .i_icb_rsp_valid(),\n        .i_icb_rsp_ready(),\n        .i_icb_rsp_rdata(),\n        .i_icb_rsp_usr(),\n        .ram_cs(itcm_ram_cs),\n        .ram_we(itcm_ram_we),\n        .ram_addr(itcm_ram_addr),\n        .ram_wem(itcm_ram_wem),\n        .ram_din(itcm_ram_din),\n        .ram_dout(itcm_ram_dout),\n        .clk_ram(clk_itcm_ram),\n        .sram_ctrl_active(itcm_active),\n        .tcm_cgstop(tcm_cgstop),\n        .test_mode(test_mode)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
