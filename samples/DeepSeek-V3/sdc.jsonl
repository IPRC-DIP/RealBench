{"task": "sd_clock_divider", "codeid": 1, "code": "module sd_clock_divider (\n    input CLK,\n    input [7:0] DIVIDER,\n    input RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'b0;\n        SD_CLK <= 1'b0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            counter <= 8'b0;\n            SD_CLK <= ~SD_CLK;\n        end else begin\n            counter <= counter + 1'b1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 1, "code": "module sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        CRC[0] <= inv;\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[6:1] <= CRC[5:0];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 2, "code": "module sd_clock_divider (\n    input CLK,\n    input [7:0] DIVIDER,\n    input RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'b0;\n        SD_CLK <= 1'b0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            counter <= 8'b0;\n            SD_CLK <= ~SD_CLK;\n        end else begin\n            counter <= counter + 1'b1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 2, "code": "module sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        CRC[0] <= inv;\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[6:1] <= CRC[5:0];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 3, "code": "module sd_clock_divider (\n    input CLK,\n    input [7:0] DIVIDER,\n    input RST,\n    output SD_CLK\n);\n\nreg [7:0] counter;\nreg sd_clk_reg;\n\nassign SD_CLK = sd_clk_reg;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'b0;\n        sd_clk_reg <= 1'b0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            counter <= 8'b0;\n            sd_clk_reg <= ~sd_clk_reg;\n        end else begin\n            counter <= counter + 1'b1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 3, "code": "module sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        CRC[0] <= inv;\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[6:1] <= CRC[5:0];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 4, "code": "module sd_clock_divider (\n    input CLK,\n    input [7:0] DIVIDER,\n    input RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'b0;\n        SD_CLK <= 1'b0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            counter <= 8'b0;\n            SD_CLK <= ~SD_CLK;\n        end else begin\n            counter <= counter + 1'b1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 5, "code": "module sd_clock_divider (\n    input CLK,\n    input [7:0] DIVIDER,\n    input RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'b0;\n        SD_CLK <= 1'b0;\n    end\n    else begin\n        if (counter >= DIVIDER) begin\n            counter <= 8'b0;\n            SD_CLK <= ~SD_CLK;\n        end\n        else begin\n            counter <= counter + 1'b1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 6, "code": "module sd_clock_divider (\n    input CLK,\n    input [7:0] DIVIDER,\n    input RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'b0;\n        SD_CLK <= 1'b0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            counter <= 8'b0;\n            SD_CLK <= ~SD_CLK;\n        end else begin\n            counter <= counter + 1'b1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 7, "code": "module sd_clock_divider (\n    input CLK,\n    input [7:0] DIVIDER,\n    input RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'b0;\n        SD_CLK <= 1'b0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            counter <= 8'b0;\n            SD_CLK <= ~SD_CLK;\n        end else begin\n            counter <= counter + 1'b1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 1, "code": "module sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'b0;\n    end\n    else if (Enable) begin\n        CRC[15:1] <= CRC[14:0];\n        CRC[12] <= CRC[11] ^ inv;\n        CRC[5] <= CRC[4] ^ inv;\n        CRC[0] <= inv;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 4, "code": "module sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end\n    else if (Enable) begin\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 5, "code": "module sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end\n    else if (Enable) begin\n        CRC[0] <= inv;\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[6:1] <= CRC[5:0];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 6, "code": "module sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end\n    else if (Enable) begin\n        CRC[0] <= inv;\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[6:1] <= CRC[5:0];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 8, "code": "module sd_clock_divider (\n    input CLK,\n    input [7:0] DIVIDER,\n    input RST,\n    output SD_CLK\n);\n\nreg [7:0] counter;\nreg sd_clk_reg;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'b0;\n        sd_clk_reg <= 1'b0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            counter <= 8'b0;\n            sd_clk_reg <= ~sd_clk_reg;\n        end else begin\n            counter <= counter + 1'b1;\n        end\n    end\nend\n\n`ifdef SIM\nassign SD_CLK = CLK;\n`elsif ACTEL\nwire SD_CLK_O;\nassign SD_CLK_O = sd_clk_reg;\n// CLKINT instantiation would go here for ACTEL implementation\n`else\nassign SD_CLK = sd_clk_reg;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 9, "code": "module sd_clock_divider (\n    input CLK,\n    input [7:0] DIVIDER,\n    input RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'b0;\n        SD_CLK <= 1'b0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            counter <= 8'b0;\n            SD_CLK <= ~SD_CLK;\n        end else begin\n            counter <= counter + 1'b1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 7, "code": "module sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end\n    else if (Enable) begin\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 10, "code": "module sd_clock_divider (\n    input CLK,\n    input [7:0] DIVIDER,\n    input RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'b0;\n        SD_CLK <= 1'b0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            counter <= 8'b0;\n            SD_CLK <= ~SD_CLK;\n        end else begin\n            counter <= counter + 1'b1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 8, "code": "module sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 9, "code": "module sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end\n    else if (Enable) begin\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 10, "code": "module sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end\n    else if (Enable) begin\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 11, "code": "module sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end\n    else if (Enable) begin\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 11, "code": "module sd_clock_divider (\n    input CLK,\n    input [7:0] DIVIDER,\n    input RST,\n    output SD_CLK\n);\n\nreg [7:0] counter;\nreg sd_clk_reg;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'b0;\n        sd_clk_reg <= 1'b0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            counter <= 8'b0;\n            sd_clk_reg <= ~sd_clk_reg;\n        end else begin\n            counter <= counter + 1'b1;\n        end\n    end\nend\n\n`ifdef SIM\nassign SD_CLK = CLK;\n`elsif ACTEL\nwire SD_CLK_O;\nassign SD_CLK_O = sd_clk_reg;\nCLKINT clkint_inst (.A(SD_CLK_O), .Y(SD_CLK));\n`else\nassign SD_CLK = sd_clk_reg;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 12, "code": "module sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end\n    else if (Enable) begin\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 2, "code": "module sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'h0000;\n    end else if (Enable) begin\n        CRC[15] <= CRC[14];\n        CRC[14] <= CRC[13];\n        CRC[13] <= CRC[12];\n        CRC[12] <= CRC[11] ^ inv;\n        CRC[11] <= CRC[10];\n        CRC[10] <= CRC[9];\n        CRC[9]  <= CRC[8];\n        CRC[8]  <= CRC[7];\n        CRC[7]  <= CRC[6];\n        CRC[6]  <= CRC[5];\n        CRC[5]  <= CRC[4] ^ inv;\n        CRC[4]  <= CRC[3];\n        CRC[3]  <= CRC[2];\n        CRC[2]  <= CRC[1];\n        CRC[1]  <= CRC[0];\n        CRC[0]  <= inv;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 3, "code": "module sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'b0;\n    end else if (Enable) begin\n        CRC[15] <= CRC[14];\n        CRC[14] <= CRC[13];\n        CRC[13] <= CRC[12];\n        CRC[12] <= CRC[11] ^ inv;\n        CRC[11] <= CRC[10];\n        CRC[10] <= CRC[9];\n        CRC[9]  <= CRC[8];\n        CRC[8]  <= CRC[7];\n        CRC[7]  <= CRC[6];\n        CRC[6]  <= CRC[5];\n        CRC[5]  <= CRC[4] ^ inv;\n        CRC[4]  <= CRC[3];\n        CRC[3]  <= CRC[2];\n        CRC[2]  <= CRC[1];\n        CRC[1]  <= CRC[0];\n        CRC[0]  <= inv;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 13, "code": "module sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end\n    else if (Enable) begin\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 14, "code": "module sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end\n    else if (Enable) begin\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 12, "code": "module sd_clock_divider (\n    input CLK,\n    input [7:0] DIVIDER,\n    input RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'b0;\n        SD_CLK <= 1'b0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            counter <= 8'b0;\n            SD_CLK <= ~SD_CLK;\n        end else begin\n            counter <= counter + 1'b1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 4, "code": "module sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'b0;\n    end else if (Enable) begin\n        CRC[15] <= CRC[14];\n        CRC[14] <= CRC[13];\n        CRC[13] <= CRC[12];\n        CRC[12] <= CRC[11] ^ inv;\n        CRC[11] <= CRC[10];\n        CRC[10] <= CRC[9];\n        CRC[9]  <= CRC[8];\n        CRC[8]  <= CRC[7];\n        CRC[7]  <= CRC[6];\n        CRC[6]  <= CRC[5];\n        CRC[5]  <= CRC[4] ^ inv;\n        CRC[4]  <= CRC[3];\n        CRC[3]  <= CRC[2];\n        CRC[2]  <= CRC[1];\n        CRC[1]  <= CRC[0];\n        CRC[0]  <= inv;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 13, "code": "module sd_clock_divider (\n    input CLK,\n    input [7:0] DIVIDER,\n    input RST,\n    output SD_CLK\n);\n\nreg [7:0] counter;\nreg sd_clk_reg;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'b0;\n        sd_clk_reg <= 1'b0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            counter <= 8'b0;\n            sd_clk_reg <= ~sd_clk_reg;\n        end else begin\n            counter <= counter + 1'b1;\n        end\n    end\nend\n\n`ifdef SIM\nassign SD_CLK = CLK;\n`else\n`ifdef ACTEL\nwire SD_CLK_O;\nassign SD_CLK_O = sd_clk_reg;\nCLKINT clkint_inst (.A(SD_CLK_O), .Y(SD_CLK));\n`else\nassign SD_CLK = sd_clk_reg;\n`endif\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 5, "code": "module sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'b0;\n    end\n    else if (Enable) begin\n        CRC[15] <= CRC[14];\n        CRC[14] <= CRC[13];\n        CRC[13] <= CRC[12];\n        CRC[12] <= CRC[11] ^ inv;\n        CRC[11] <= CRC[10];\n        CRC[10] <= CRC[9];\n        CRC[9]  <= CRC[8];\n        CRC[8]  <= CRC[7];\n        CRC[7]  <= CRC[6];\n        CRC[6]  <= CRC[5];\n        CRC[5]  <= CRC[4] ^ inv;\n        CRC[4]  <= CRC[3];\n        CRC[3]  <= CRC[2];\n        CRC[2]  <= CRC[1];\n        CRC[1]  <= CRC[0];\n        CRC[0]  <= inv;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 14, "code": "module sd_clock_divider (\n    input CLK,\n    input [7:0] DIVIDER,\n    input RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'b0;\n        SD_CLK <= 1'b0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            counter <= 8'b0;\n            SD_CLK <= ~SD_CLK;\n        end else begin\n            counter <= counter + 1'b1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 6, "code": "module sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'b0;\n    end\n    else if (Enable) begin\n        CRC[15] <= CRC[14];\n        CRC[14] <= CRC[13];\n        CRC[13] <= CRC[12];\n        CRC[12] <= CRC[11] ^ inv;\n        CRC[11] <= CRC[10];\n        CRC[10] <= CRC[9];\n        CRC[9]  <= CRC[8];\n        CRC[8]  <= CRC[7];\n        CRC[7]  <= CRC[6];\n        CRC[6]  <= CRC[5];\n        CRC[5]  <= CRC[4] ^ inv;\n        CRC[4]  <= CRC[3];\n        CRC[3]  <= CRC[2];\n        CRC[2]  <= CRC[1];\n        CRC[1]  <= CRC[0];\n        CRC[0]  <= inv;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 15, "code": "module sd_clock_divider (\n    input CLK,\n    input [7:0] DIVIDER,\n    input RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'b0;\n        SD_CLK <= 1'b0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            counter <= 8'b0;\n            SD_CLK <= ~SD_CLK;\n        end else begin\n            counter <= counter + 1'b1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 15, "code": "module sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end\n    else if (Enable) begin\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 16, "code": "module sd_clock_divider (\n    input CLK,\n    input [7:0] DIVIDER,\n    input RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'b0;\n        SD_CLK <= 1'b0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            counter <= 8'b0;\n            SD_CLK <= ~SD_CLK;\n        end else begin\n            counter <= counter + 1'b1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 7, "code": "module sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'b0;\n    end else if (Enable) begin\n        CRC[15] <= CRC[14];\n        CRC[14] <= CRC[13];\n        CRC[13] <= CRC[12];\n        CRC[12] <= CRC[11] ^ inv;\n        CRC[11] <= CRC[10];\n        CRC[10] <= CRC[9];\n        CRC[9]  <= CRC[8];\n        CRC[8]  <= CRC[7];\n        CRC[7]  <= CRC[6];\n        CRC[6]  <= CRC[5];\n        CRC[5]  <= CRC[4] ^ inv;\n        CRC[4]  <= CRC[3];\n        CRC[3]  <= CRC[2];\n        CRC[2]  <= CRC[1];\n        CRC[1]  <= CRC[0];\n        CRC[0]  <= inv;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 8, "code": "module sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'b0;\n    end\n    else if (Enable) begin\n        CRC[15] <= CRC[14];\n        CRC[14] <= CRC[13];\n        CRC[13] <= CRC[12];\n        CRC[12] <= CRC[11] ^ inv;\n        CRC[11] <= CRC[10];\n        CRC[10] <= CRC[9];\n        CRC[9]  <= CRC[8];\n        CRC[8]  <= CRC[7];\n        CRC[7]  <= CRC[6];\n        CRC[6]  <= CRC[5];\n        CRC[5]  <= CRC[4] ^ inv;\n        CRC[4]  <= CRC[3];\n        CRC[3]  <= CRC[2];\n        CRC[2]  <= CRC[1];\n        CRC[1]  <= CRC[0];\n        CRC[0]  <= inv;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 9, "code": "module sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'h0000;\n    end\n    else if (Enable) begin\n        CRC[15] <= CRC[14];\n        CRC[14] <= CRC[13];\n        CRC[13] <= CRC[12];\n        CRC[12] <= CRC[11] ^ inv;\n        CRC[11] <= CRC[10];\n        CRC[10] <= CRC[9];\n        CRC[9]  <= CRC[8];\n        CRC[8]  <= CRC[7];\n        CRC[7]  <= CRC[6];\n        CRC[6]  <= CRC[5];\n        CRC[5]  <= CRC[4] ^ inv;\n        CRC[4]  <= CRC[3];\n        CRC[3]  <= CRC[2];\n        CRC[2]  <= CRC[1];\n        CRC[1]  <= CRC[0];\n        CRC[0]  <= inv;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 16, "code": "module sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end\n    else if (Enable) begin\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 17, "code": "module sd_clock_divider (\n    input CLK,\n    input [7:0] DIVIDER,\n    input RST,\n    output SD_CLK\n);\n\nreg [7:0] counter;\nreg sd_clk_reg;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'b0;\n        sd_clk_reg <= 1'b0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            counter <= 8'b0;\n            sd_clk_reg <= ~sd_clk_reg;\n        end else begin\n            counter <= counter + 1'b1;\n        end\n    end\nend\n\n`ifdef SIM\nassign SD_CLK = CLK;\n`else\n`ifdef ACTEL\nwire SD_CLK_O;\nassign SD_CLK_O = sd_clk_reg;\nCLKINT clkint_inst (.A(SD_CLK_O), .Y(SD_CLK));\n`else\nassign SD_CLK = sd_clk_reg;\n`endif\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 18, "code": "module sd_clock_divider (\n    input CLK,\n    input [7:0] DIVIDER,\n    input RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'b0;\n        SD_CLK <= 1'b0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            counter <= 8'b0;\n            SD_CLK <= ~SD_CLK;\n        end else begin\n            counter <= counter + 1'b1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 17, "code": "module sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 19, "code": "module sd_clock_divider (\n    input CLK,\n    input [7:0] DIVIDER,\n    input RST,\n    output SD_CLK\n);\n\nreg [7:0] counter;\nreg sd_clk_reg;\n\n`ifdef SIM\nassign SD_CLK = CLK;\n`else\n`ifdef ACTEL\nwire SD_CLK_O;\nassign SD_CLK_O = sd_clk_reg;\nCLKINT clkint_inst (.A(SD_CLK_O), .Y(SD_CLK));\n`else\nassign SD_CLK = sd_clk_reg;\n`endif\n`endif\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'b0;\n        sd_clk_reg <= 1'b0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            counter <= 8'b0;\n            sd_clk_reg <= ~sd_clk_reg;\n        end else begin\n            counter <= counter + 1'b1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 10, "code": "module sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'b0;\n    end else if (Enable) begin\n        CRC[15] <= CRC[14];\n        CRC[14] <= CRC[13];\n        CRC[13] <= CRC[12];\n        CRC[12] <= CRC[11] ^ inv;\n        CRC[11] <= CRC[10];\n        CRC[10] <= CRC[9];\n        CRC[9]  <= CRC[8];\n        CRC[8]  <= CRC[7];\n        CRC[7]  <= CRC[6];\n        CRC[6]  <= CRC[5];\n        CRC[5]  <= CRC[4] ^ inv;\n        CRC[4]  <= CRC[3];\n        CRC[3]  <= CRC[2];\n        CRC[2]  <= CRC[1];\n        CRC[1]  <= CRC[0];\n        CRC[0]  <= inv;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 11, "code": "module sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'h0000;\n    end\n    else if (Enable) begin\n        CRC[15] <= CRC[14];\n        CRC[14] <= CRC[13];\n        CRC[13] <= CRC[12];\n        CRC[12] <= CRC[11] ^ inv;\n        CRC[11] <= CRC[10];\n        CRC[10] <= CRC[9];\n        CRC[9]  <= CRC[8];\n        CRC[8]  <= CRC[7];\n        CRC[7]  <= CRC[6];\n        CRC[6]  <= CRC[5];\n        CRC[5]  <= CRC[4] ^ inv;\n        CRC[4]  <= CRC[3];\n        CRC[3]  <= CRC[2];\n        CRC[2]  <= CRC[1];\n        CRC[1]  <= CRC[0];\n        CRC[0]  <= inv;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 18, "code": "module sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end\n    else if (Enable) begin\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 12, "code": "module sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'h0000;\n    end\n    else if (Enable) begin\n        CRC[15] <= CRC[14];\n        CRC[14] <= CRC[13];\n        CRC[13] <= CRC[12];\n        CRC[12] <= CRC[11] ^ inv;\n        CRC[11] <= CRC[10];\n        CRC[10] <= CRC[9];\n        CRC[9]  <= CRC[8];\n        CRC[8]  <= CRC[7];\n        CRC[7]  <= CRC[6];\n        CRC[6]  <= CRC[5];\n        CRC[5]  <= CRC[4] ^ inv;\n        CRC[4]  <= CRC[3];\n        CRC[3]  <= CRC[2];\n        CRC[2]  <= CRC[1];\n        CRC[1]  <= CRC[0];\n        CRC[0]  <= inv;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 13, "code": "module sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'b0;\n    end else if (Enable) begin\n        CRC[15] <= CRC[14];\n        CRC[14] <= CRC[13];\n        CRC[13] <= CRC[12];\n        CRC[12] <= CRC[11] ^ inv;\n        CRC[11] <= CRC[10];\n        CRC[10] <= CRC[9];\n        CRC[9]  <= CRC[8];\n        CRC[8]  <= CRC[7];\n        CRC[7]  <= CRC[6];\n        CRC[6]  <= CRC[5];\n        CRC[5]  <= CRC[4] ^ inv;\n        CRC[4]  <= CRC[3];\n        CRC[3]  <= CRC[2];\n        CRC[2]  <= CRC[1];\n        CRC[1]  <= CRC[0];\n        CRC[0]  <= inv;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 14, "code": "module sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'b0;\n    end\n    else if (Enable) begin\n        CRC[15] <= CRC[14];\n        CRC[14] <= CRC[13];\n        CRC[13] <= CRC[12];\n        CRC[12] <= CRC[11] ^ inv;\n        CRC[11] <= CRC[10];\n        CRC[10] <= CRC[9];\n        CRC[9]  <= CRC[8];\n        CRC[8]  <= CRC[7];\n        CRC[7]  <= CRC[6];\n        CRC[6]  <= CRC[5];\n        CRC[5]  <= CRC[4] ^ inv;\n        CRC[4]  <= CRC[3];\n        CRC[3]  <= CRC[2];\n        CRC[2]  <= CRC[1];\n        CRC[1]  <= CRC[0];\n        CRC[0]  <= inv;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 15, "code": "module sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'h0000;\n    end else if (Enable) begin\n        CRC[15] <= CRC[14];\n        CRC[14] <= CRC[13];\n        CRC[13] <= CRC[12];\n        CRC[12] <= CRC[11] ^ inv;\n        CRC[11] <= CRC[10];\n        CRC[10] <= CRC[9];\n        CRC[9]  <= CRC[8];\n        CRC[8]  <= CRC[7];\n        CRC[7]  <= CRC[6];\n        CRC[6]  <= CRC[5];\n        CRC[5]  <= CRC[4] ^ inv;\n        CRC[4]  <= CRC[3];\n        CRC[3]  <= CRC[2];\n        CRC[2]  <= CRC[1];\n        CRC[1]  <= CRC[0];\n        CRC[0]  <= inv;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 1, "code": "module sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    input wire rclk,\n    output wire full,\n    output wire empty,\n    output wire [1:0] mem_empt,\n    input wire rst\n);\n\nparameter FIFO_RX_MEM_DEPTH = 16; // Example value, should be defined in sd_defines.v\nparameter FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH) + 1;\n\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_next = adr_i + 1'b1;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o_next = adr_o + 1'b1;\n\n// Full and empty flags\nassign full = (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] == adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]) && \n              (adr_i[FIFO_RX_MEM_ADR_SIZE-1] != adr_o[FIFO_RX_MEM_ADR_SIZE-1]);\nassign empty = (adr_i == adr_o);\nassign mem_empt = (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) >> 5; // Approximate empty space\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n    end else if (wr) begin\n        case (we)\n            8'h1: tmp[3:0] <= d;\n            8'h2: tmp[7:4] <= d;\n            8'h4: tmp[11:8] <= d;\n            8'h8: tmp[15:12] <= d;\n            8'h10: tmp[19:16] <= d;\n            8'h20: tmp[23:20] <= d;\n            8'h40: tmp[27:24] <= d;\n            8'h80: begin\n                tmp[31:28] <= d;\n                ft <= 1;\n            end\n        endcase\n        \n        if (we == 8'h80) begin\n            if (!full) begin\n                ram[adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]] <= tmp;\n                adr_i <= adr_i_next;\n            end\n            we <= 8'h1;\n            ft <= 0;\n        end else begin\n            we <= we << 1;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]];\n        adr_o <= adr_o_next;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 1, "code": "module sd_fifo_tx_filler (\n    input         clk,\n    input         rst,\n    output [31:0] m_wb_adr_o,\n    output        m_wb_we_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    input         en,\n    input  [31:0] adr,\n    input         sd_clk,\n    output [31:0] dat_o,\n    input         rd,\n    output        empty,\n    output        fe\n);\n\n    // Internal registers\n    reg [8:0]  offset;\n    reg [8:0]  we;\n    reg [31:0] din;\n    reg        wr_tx;\n    reg        reset_tx_fifo;\n    reg        first;\n    reg        ackd;\n    reg        delay;\n\n    // Wishbone signals\n    assign m_wb_we_o = 1'b0;  // Always read\n    assign m_wb_cti_o = 3'b000;\n    assign m_wb_bte_o = 2'b00;\n    assign m_wb_adr_o = adr + {23'b0, offset};\n\n    // FIFO instance\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .rclk(sd_clk),\n        .rst(rst | reset_tx_fifo)\n    );\n\n    // State machine\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all registers\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b1;\n            delay <= 1'b0;\n            \n            // Reset Wishbone signals\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n        end else begin\n            // Default values\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b0;\n            delay <= 1'b0;\n            \n            if (en) begin\n                // Module enabled\n                if (!fe && !m_wb_ack_i && ackd) begin\n                    // Start new Wishbone transaction\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    first <= 1'b0;\n                end\n                \n                if (m_wb_ack_i) begin\n                    // Wishbone acknowledged\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                \n                if (delay) begin\n                    // Delay state\n                    offset <= offset + 1'b1;\n                    ackd <= ~ackd;\n                    wr_tx <= 1'b0;\n                end\n            end else begin\n                // Module disabled\n                offset <= 9'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                reset_tx_fifo <= 1'b1;\n                first <= 1'b1;\n                ackd <= 1'b1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 16, "code": "module sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'b0;\n    end\n    else if (Enable) begin\n        CRC[15] <= CRC[14];\n        CRC[14] <= CRC[13];\n        CRC[13] <= CRC[12];\n        CRC[12] <= CRC[11] ^ inv;\n        CRC[11] <= CRC[10];\n        CRC[10] <= CRC[9];\n        CRC[9]  <= CRC[8];\n        CRC[8]  <= CRC[7];\n        CRC[7]  <= CRC[6];\n        CRC[6]  <= CRC[5];\n        CRC[5]  <= CRC[4] ^ inv;\n        CRC[4]  <= CRC[3];\n        CRC[3]  <= CRC[2];\n        CRC[2]  <= CRC[1];\n        CRC[1]  <= CRC[0];\n        CRC[0]  <= inv;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 2, "code": "module sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    input wire rclk,\n    output wire full,\n    output wire empty,\n    output wire [1:0] mem_empt,\n    input wire rst\n);\n\nparameter FIFO_RX_MEM_DEPTH = 16; // Example value, should match sd_defines.v\nparameter FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH) + 1;\n\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_next = adr_i + 1;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o_next = adr_o + 1;\n\n// Full and empty flags\nassign full = (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] == adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]) && \n              (adr_i[FIFO_RX_MEM_ADR_SIZE-1] != adr_o[FIFO_RX_MEM_ADR_SIZE-1]);\nassign empty = (adr_i == adr_o);\nassign mem_empt = (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) >> 2; // Approximate empty space\n\n// Write clock domain\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n    end else begin\n        if (wr && !full) begin\n            case (we)\n                8'h1: tmp[3:0] <= d;\n                8'h2: tmp[7:4] <= d;\n                8'h4: tmp[11:8] <= d;\n                8'h8: tmp[15:12] <= d;\n                8'h10: tmp[19:16] <= d;\n                8'h20: tmp[23:20] <= d;\n                8'h40: tmp[27:24] <= d;\n                8'h80: tmp[31:28] <= d;\n            endcase\n            \n            if (we == 8'h80) begin\n                ram[adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]] <= tmp;\n                adr_i <= adr_i_next;\n                we <= 8'h1;\n                ft <= 1;\n            end else begin\n                we <= we << 1;\n                ft <= 0;\n            end\n        end\n    end\nend\n\n// Read clock domain\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else begin\n        if (rd && !empty) begin\n            q <= ram[adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]];\n            adr_o <= adr_o_next;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 3, "code": "module sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    input wire rclk,\n    output wire full,\n    output wire empty,\n    output wire [1:0] mem_empt,\n    input wire rst\n);\n\nparameter FIFO_RX_MEM_DEPTH = 16; // Example value, should be defined in sd_defines.v\nparameter FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH) + 1;\n\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_next = adr_i + 1'b1;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o_next = adr_o + 1'b1;\n\n// Full and empty flags\nassign full = (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] == adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]) && \n              (adr_i[FIFO_RX_MEM_ADR_SIZE-1] != adr_o[FIFO_RX_MEM_ADR_SIZE-1]);\nassign empty = (adr_i == adr_o);\nassign mem_empt = (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) >> 2; // Approximate empty space in words\n\n// Write clock domain\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n    end else if (wr) begin\n        case (we)\n            8'h1: begin\n                tmp[3:0] <= d;\n                we <= 8'h2;\n            end\n            8'h2: begin\n                tmp[7:4] <= d;\n                we <= 8'h4;\n            end\n            8'h4: begin\n                tmp[11:8] <= d;\n                we <= 8'h8;\n            end\n            8'h8: begin\n                tmp[15:12] <= d;\n                we <= 8'h10;\n            end\n            8'h10: begin\n                tmp[19:16] <= d;\n                we <= 8'h20;\n            end\n            8'h20: begin\n                tmp[23:20] <= d;\n                we <= 8'h40;\n            end\n            8'h40: begin\n                tmp[27:24] <= d;\n                we <= 8'h80;\n            end\n            8'h80: begin\n                tmp[31:28] <= d;\n                we <= 8'h1;\n                ram[adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]] <= tmp;\n                adr_i <= adr_i_next;\n                ft <= 1;\n            end\n            default: we <= 8'h1;\n        endcase\n    end\nend\n\n// Read clock domain\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]];\n        adr_o <= adr_o_next;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 17, "code": "module sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'b0;\n    end\n    else if (Enable) begin\n        CRC[15] <= CRC[14];\n        CRC[14] <= CRC[13];\n        CRC[13] <= CRC[12];\n        CRC[12] <= CRC[11] ^ inv;\n        CRC[11] <= CRC[10];\n        CRC[10] <= CRC[9];\n        CRC[9]  <= CRC[8];\n        CRC[8]  <= CRC[7];\n        CRC[7]  <= CRC[6];\n        CRC[6]  <= CRC[5];\n        CRC[5]  <= CRC[4] ^ inv;\n        CRC[4]  <= CRC[3];\n        CRC[3]  <= CRC[2];\n        CRC[2]  <= CRC[1];\n        CRC[1]  <= CRC[0];\n        CRC[0]  <= inv;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 2, "code": "module sd_fifo_tx_filler (\n    input         clk,\n    input         rst,\n    output [31:0] m_wb_adr_o,\n    output        m_wb_we_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    input         en,\n    input  [31:0] adr,\n    input         sd_clk,\n    output [31:0] dat_o,\n    input         rd,\n    output        empty,\n    output        fe\n);\n\n    // Internal registers\n    reg [8:0]  offset;\n    reg [8:0]  we;\n    reg [31:0] din;\n    reg        wr_tx;\n    reg        reset_tx_fifo;\n    reg        first;\n    reg        ackd;\n    reg        delay;\n\n    // Wishbone signals\n    assign m_wb_we_o = 1'b0;  // Always read operations\n    assign m_wb_cti_o = 3'b000;\n    assign m_wb_bte_o = 2'b00;\n    assign m_wb_adr_o = adr + {offset, 2'b00};  // Word addressing\n\n    // FIFO signals\n    wire full;\n    assign fe = full;\n\n    // State machine\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all registers\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b1;\n            delay <= 1'b0;\n            \n            // Reset Wishbone signals\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n        end else begin\n            if (en) begin\n                reset_tx_fifo <= 1'b0;\n                \n                // Wishbone transaction control\n                if (~full && ~m_wb_ack_i && ackd) begin\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    first <= 1'b0;\n                end\n                \n                // Handle Wishbone acknowledge\n                if (m_wb_ack_i) begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                \n                // Delay handling\n                if (delay) begin\n                    offset <= offset + 1'b1;\n                    ackd <= ~ackd;\n                    wr_tx <= 1'b0;\n                    delay <= 1'b0;\n                end\n            end else begin\n                // Disabled state\n                reset_tx_fifo <= 1'b1;\n                offset <= 9'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                m_wb_we_o <= 1'b0;\n                wr_tx <= 1'b0;\n                first <= 1'b1;\n            end\n        end\n    end\n\n    // Instantiate TX FIFO\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(sd_clk),\n        .rst(rst | reset_tx_fifo)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 4, "code": "module sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    input wire rclk,\n    output wire full,\n    output wire empty,\n    output wire [1:0] mem_empt,\n    input wire rst\n);\n\nparameter FIFO_RX_MEM_DEPTH = 16; // Example value, should be defined in sd_defines.v\nparameter FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH) + 1;\n\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_next = adr_i + 1;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o_next = adr_o + 1;\n\n// Full and empty flags\nassign full = (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] == adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]) && \n              (adr_i[FIFO_RX_MEM_ADR_SIZE-1] != adr_o[FIFO_RX_MEM_ADR_SIZE-1]);\nassign empty = (adr_i == adr_o);\nassign mem_empt = (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) >> 2; // Approximate empty space in words\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n    end else if (wr && !full) begin\n        case (we)\n            8'h1: begin\n                tmp[3:0] <= d;\n                we <= 8'h2;\n            end\n            8'h2: begin\n                tmp[7:4] <= d;\n                we <= 8'h4;\n            end\n            8'h4: begin\n                tmp[11:8] <= d;\n                we <= 8'h8;\n            end\n            8'h8: begin\n                tmp[15:12] <= d;\n                we <= 8'h10;\n            end\n            8'h10: begin\n                tmp[19:16] <= d;\n                we <= 8'h20;\n            end\n            8'h20: begin\n                tmp[23:20] <= d;\n                we <= 8'h40;\n            end\n            8'h40: begin\n                tmp[27:24] <= d;\n                we <= 8'h80;\n            end\n            8'h80: begin\n                tmp[31:28] <= d;\n                we <= 8'h1;\n                ram[adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]] <= tmp;\n                adr_i <= adr_i_next;\n                ft <= 1;\n            end\n            default: we <= 8'h1;\n        endcase\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]];\n        adr_o <= adr_o_next;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 20, "code": "module sd_clock_divider (\n    input CLK,\n    input [7:0] DIVIDER,\n    input RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'd0;\n        SD_CLK <= 1'b0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            counter <= 8'd0;\n            SD_CLK <= ~SD_CLK;\n        end else begin\n            counter <= counter + 8'd1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 1, "code": "module sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    input wire rclk,\n    output wire full,\n    output wire empty,\n    output wire [5:0] mem_empt,\n    input wire rst\n);\n\n// Memory array\nreg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n\n// Pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i; // Write pointer\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o; // Read pointer\n\n// Synchronizers for cross-clock domain signals\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_sync1, adr_i_sync2;\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_sync1, adr_o_sync2;\n\n// Write clock domain logic\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n    end else if (wr && !full) begin\n        ram[adr_i[FIFO_TX_MEM_ADR_SIZE-2:0]] <= d;\n        adr_i <= adr_i + 1;\n    end\nend\n\n// Read clock domain logic\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o[FIFO_TX_MEM_ADR_SIZE-2:0]];\n        adr_o <= adr_o + 1;\n    end\nend\n\n// Synchronize write pointer to read clock domain\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_i_sync1 <= 0;\n        adr_i_sync2 <= 0;\n    end else begin\n        adr_i_sync1 <= adr_i;\n        adr_i_sync2 <= adr_i_sync1;\n    end\nend\n\n// Synchronize read pointer to write clock domain\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_o_sync1 <= 0;\n        adr_o_sync2 <= 0;\n    end else begin\n        adr_o_sync1 <= adr_o;\n        adr_o_sync2 <= adr_o_sync1;\n    end\nend\n\n// Full and empty generation\nassign empty = (adr_i_sync2 == adr_o);\nassign full = ((adr_i[FIFO_TX_MEM_ADR_SIZE-1] != adr_o_sync2[FIFO_TX_MEM_ADR_SIZE-1]) && \n              (adr_i[FIFO_TX_MEM_ADR_SIZE-2:0] == adr_o_sync2[FIFO_TX_MEM_ADR_SIZE-2:0]));\n\n// FIFO occupancy calculation\nassign mem_empt = (adr_i - adr_o_sync2);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input                       clk,\n    input                       rst,\n    input                       we_m,\n    input   [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output  [BD_WIDTH-1:0]      free_bd,\n    input                       re_s,\n    output                      ack_o_s,\n    input                       a_cmp,\n    output  [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Internal registers and wires\nreg [BD_WIDTH-1:0] m_wr_pnt;\nreg [BD_WIDTH-1:0] s_rd_pnt;\nreg [BD_WIDTH-1:0] free_bd_reg;\nreg [1:0]          wr_cnt;\nreg [1:0]          rd_cnt;\nreg                new_bw;\nreg                last_a_cmp;\nreg                ack_o_s_reg;\n\n// Memory for buffer descriptors\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n\n// Assign outputs\nassign free_bd  = free_bd_reg;\nassign ack_o_s  = ack_o_s_reg;\nassign dat_out_s = bd_mem[s_rd_pnt];\n\n// Write pointer increment\nwire [BD_WIDTH-1:0] next_wr_pnt = (m_wr_pnt == BD_SIZE-1) ? 0 : m_wr_pnt + 1;\n\n// Read pointer increment\nwire [BD_WIDTH-1:0] next_rd_pnt = (s_rd_pnt == BD_SIZE-1) ? 0 : s_rd_pnt + 1;\n\n// Free BD counter operations\nwire free_bd_inc = a_cmp && !last_a_cmp;\nwire free_bd_dec = new_bw;\n\n// Initialize and update free_bd counter\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        free_bd_reg <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n    end else begin\n        case ({free_bd_inc, free_bd_dec})\n            2'b01: free_bd_reg <= free_bd_reg - 1;\n            2'b10: free_bd_reg <= free_bd_reg + 1;\n            default: free_bd_reg <= free_bd_reg;\n        endcase\n    end\nend\n\n// Write operation\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        wr_cnt <= 0;\n        new_bw <= 0;\n    end else if (we_m && (free_bd_reg > 0)) begin\n        bd_mem[m_wr_pnt] <= dat_in_m;\n        \n        if (RAM_MEM_WIDTH == 32) begin\n            // 32-bit mode: one write completes a BD\n            m_wr_pnt <= next_wr_pnt;\n            new_bw <= 1;\n            wr_cnt <= 0;\n        end else begin\n            // 16-bit mode: four writes complete a BD\n            if (wr_cnt == 3) begin\n                m_wr_pnt <= next_wr_pnt;\n                new_bw <= 1;\n                wr_cnt <= 0;\n            end else begin\n                m_wr_pnt <= next_wr_pnt;\n                new_bw <= 0;\n                wr_cnt <= wr_cnt + 1;\n            end\n        end\n    end else begin\n        new_bw <= 0;\n    end\nend\n\n// Read operation\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        s_rd_pnt <= 0;\n        rd_cnt <= 0;\n        ack_o_s_reg <= 0;\n    end else if (re_s) begin\n        if (RAM_MEM_WIDTH == 32) begin\n            // 32-bit mode: one read gets complete BD\n            s_rd_pnt <= next_rd_pnt;\n            ack_o_s_reg <= 1;\n            rd_cnt <= 0;\n        end else begin\n            // 16-bit mode: four reads get complete BD\n            s_rd_pnt <= next_rd_pnt;\n            ack_o_s_reg <= 1;\n            if (rd_cnt == 3) begin\n                rd_cnt <= 0;\n            end else begin\n                rd_cnt <= rd_cnt + 1;\n            end\n        end\n    end else begin\n        ack_o_s_reg <= 0;\n    end\nend\n\n// a_cmp edge detection\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        last_a_cmp <= 0;\n    end else begin\n        last_a_cmp <= a_cmp;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 2, "code": "module sd_bd (\n    input  wire                     clk,\n    input  wire                     rst,\n    input  wire                     we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0]      free_bd,\n    input  wire                     re_s,\n    output wire                     ack_o_s,\n    input  wire                     a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\nparameter BD_WIDTH = 8;\nparameter BD_SIZE = 255;\nparameter RAM_MEM_WIDTH = 32;\n\nreg [BD_WIDTH-1:0] m_wr_pnt;\nreg [BD_WIDTH-1:0] s_rd_pnt;\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\nreg [BD_WIDTH-1:0] free_bd_cnt;\nreg new_bw;\nreg last_a_cmp;\n\n// Write operation\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        free_bd_cnt <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n        new_bw <= 0;\n    end else begin\n        if (we_m && (free_bd_cnt > 0)) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= m_wr_pnt + 1;\n            if (RAM_MEM_WIDTH == 32) begin\n                new_bw <= 1;\n                free_bd_cnt <= free_bd_cnt - 1;\n            end else begin\n                if (m_wr_pnt[1:0] == 2'b11) begin\n                    new_bw <= 1;\n                    free_bd_cnt <= free_bd_cnt - 1;\n                end else begin\n                    new_bw <= 0;\n                end\n            end\n        end else begin\n            new_bw <= 0;\n        end\n    end\nend\n\n// Read operation\nreg [1:0] read_cnt;\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        s_rd_pnt <= 0;\n        ack_o_s <= 0;\n        read_cnt <= 0;\n    end else begin\n        if (re_s) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= s_rd_pnt + 1;\n            if (RAM_MEM_WIDTH == 16) begin\n                ack_o_s <= 1;\n                if (s_rd_pnt[1:0] == 2'b11) begin\n                    read_cnt <= read_cnt + 1;\n                end\n            end else begin\n                ack_o_s <= (s_rd_pnt[0]) ? 1 : 0;\n            end\n        end else begin\n            ack_o_s <= 0;\n        end\n    end\nend\n\n// Release BD operation\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        last_a_cmp <= 0;\n        free_bd_cnt <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n    end else begin\n        last_a_cmp <= a_cmp;\n        if (RAM_MEM_WIDTH == 16) begin\n            if (a_cmp && !last_a_cmp) begin\n                free_bd_cnt <= free_bd_cnt + 1;\n            end\n        end else begin\n            if (a_cmp) begin\n                free_bd_cnt <= free_bd_cnt + 1;\n            end\n        end\n    end\nend\n\nassign free_bd = free_bd_cnt;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 3, "code": "module sd_bd (\n    input  wire                     clk,\n    input  wire                     rst,\n    input  wire                     we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0]      free_bd,\n    input  wire                     re_s,\n    output wire                     ack_o_s,\n    input  wire                     a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\nparameter BD_WIDTH = 8;\nparameter RAM_MEM_WIDTH = 32;\n\nreg [BD_WIDTH-1:0] m_wr_pnt;\nreg [BD_WIDTH-1:0] s_rd_pnt;\nreg [BD_WIDTH-1:0] free_bd_cnt;\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n\nreg [1:0] wr_cnt;\nreg [1:0] rd_cnt;\nreg new_bw;\nreg last_a_cmp;\n\nwire [RAM_MEM_WIDTH-1:0] wr_data;\nwire [RAM_MEM_WIDTH-1:0] rd_data;\n\n// Write data handling\ngenerate\nif (RAM_MEM_WIDTH == 32) begin\n    assign wr_data = dat_in_m;\nend else begin // 16-bit mode\n    assign wr_data = {bd_mem[m_wr_pnt][31:16], dat_in_m};\nend\nendgenerate\n\n// Read data handling\nassign dat_out_s = (RAM_MEM_WIDTH == 32) ? bd_mem[s_rd_pnt] : \n                   (rd_cnt[0]) ? bd_mem[s_rd_pnt][31:16] : bd_mem[s_rd_pnt][15:0];\n\n// Acknowledge signal\nassign ack_o_s = (RAM_MEM_WIDTH == 32) ? re_s : (re_s & rd_cnt[0]);\n\n// Free BD counter\nassign free_bd = free_bd_cnt;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        free_bd_cnt <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n        wr_cnt <= 0;\n        rd_cnt <= 0;\n        new_bw <= 0;\n        last_a_cmp <= 0;\n    end else begin\n        last_a_cmp <= a_cmp;\n        \n        // Write operation\n        if (we_m) begin\n            if (RAM_MEM_WIDTH == 32) begin\n                bd_mem[m_wr_pnt] <= wr_data;\n                m_wr_pnt <= m_wr_pnt + 1;\n                if (wr_cnt == 1) begin\n                    free_bd_cnt <= free_bd_cnt - 1;\n                    new_bw <= 1;\n                end\n                wr_cnt <= wr_cnt + 1;\n            end else begin // 16-bit mode\n                bd_mem[m_wr_pnt] <= wr_data;\n                if (wr_cnt == 3) begin\n                    m_wr_pnt <= m_wr_pnt + 1;\n                    free_bd_cnt <= free_bd_cnt - 1;\n                    new_bw <= 1;\n                end\n                wr_cnt <= wr_cnt + 1;\n            end\n        end else begin\n            new_bw <= 0;\n        end\n        \n        // Read operation\n        if (re_s) begin\n            if (RAM_MEM_WIDTH == 32) begin\n                if (rd_cnt == 1) begin\n                    s_rd_pnt <= s_rd_pnt + 1;\n                end\n                rd_cnt <= rd_cnt + 1;\n            end else begin // 16-bit mode\n                if (rd_cnt == 3) begin\n                    s_rd_pnt <= s_rd_pnt + 1;\n                end\n                rd_cnt <= rd_cnt + 1;\n            end\n        end\n        \n        // Release BD on a_cmp rising edge\n        if (a_cmp && !last_a_cmp) begin\n            free_bd_cnt <= free_bd_cnt + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 3, "code": "module sd_fifo_tx_filler (\n    input         clk,\n    input         rst,\n    output [31:0] m_wb_adr_o,\n    output        m_wb_we_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    input         en,\n    input  [31:0] adr,\n    input         sd_clk,\n    output [31:0] dat_o,\n    input         rd,\n    output        empty,\n    output        fe\n);\n\n    // Internal registers\n    reg [8:0]  offset;\n    reg [8:0]  we;\n    reg [31:0] din;\n    reg        wr_tx;\n    reg        reset_tx_fifo;\n    reg        first;\n    reg        ackd;\n    reg        delay;\n\n    // Wishbone signals\n    assign m_wb_we_o = 1'b0;  // Always read\n    assign m_wb_cti_o = 3'b000;\n    assign m_wb_bte_o = 2'b00;\n    \n    // Address calculation\n    assign m_wb_adr_o = adr + {23'b0, offset};\n\n    // FIFO instance\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .rclk(sd_clk),\n        .rst(rst | reset_tx_fifo)\n    );\n\n    // Main state machine\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all registers\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b1;\n            delay <= 1'b0;\n            \n            // Reset Wishbone signals\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n        end else begin\n            // Default values\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b0;\n            \n            if (en) begin\n                // Module is enabled\n                if (!fe && !m_wb_ack_i && ackd) begin\n                    // Start Wishbone transaction\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    ackd <= 1'b0;\n                end\n                \n                if (m_wb_ack_i) begin\n                    // Wishbone acknowledged\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                \n                if (delay) begin\n                    // Delay state for timing\n                    offset <= offset + 1'b1;\n                    ackd <= ~ackd;\n                    wr_tx <= 1'b0;\n                    delay <= 1'b0;\n                end\n            end else begin\n                // Module is disabled\n                offset <= 9'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                reset_tx_fifo <= 1'b1;\n                ackd <= 1'b1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 5, "code": "module sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    input wire rclk,\n    output wire full,\n    output wire empty,\n    output wire [1:0] mem_empt,\n    input wire rst\n);\n\nparameter FIFO_RX_MEM_DEPTH = 16; // Example value, should be defined in sd_defines.v\nparameter FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH) + 1;\n\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_next = adr_i + 1;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o_next = adr_o + 1;\n\n// Full and empty flags\nassign full = (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] == adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]) && \n              (adr_i[FIFO_RX_MEM_ADR_SIZE-1] != adr_o[FIFO_RX_MEM_ADR_SIZE-1]);\nassign empty = (adr_i == adr_o);\nassign mem_empt = (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) >> 2; // Approximate empty space in words\n\n// Write operation (wclk domain)\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n    end else if (wr && !full) begin\n        case (we)\n            8'h1: tmp[3:0] <= d;\n            8'h2: tmp[7:4] <= d;\n            8'h4: tmp[11:8] <= d;\n            8'h8: tmp[15:12] <= d;\n            8'h10: tmp[19:16] <= d;\n            8'h20: tmp[23:20] <= d;\n            8'h40: tmp[27:24] <= d;\n            8'h80: tmp[31:28] <= d;\n        endcase\n        \n        if (we == 8'h80) begin\n            ram[adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]] <= tmp;\n            adr_i <= adr_i_next;\n            we <= 8'h1;\n            ft <= 1;\n        end else begin\n            we <= we << 1;\n            ft <= 0;\n        end\n    end\nend\n\n// Read operation (rclk domain)\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]];\n        adr_o <= adr_o_next;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 18, "code": "module sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'b0;\n    end\n    else if (Enable) begin\n        CRC[15] <= CRC[14];\n        CRC[14] <= CRC[13];\n        CRC[13] <= CRC[12];\n        CRC[12] <= CRC[11] ^ inv;\n        CRC[11] <= CRC[10];\n        CRC[10] <= CRC[9];\n        CRC[9]  <= CRC[8];\n        CRC[8]  <= CRC[7];\n        CRC[7]  <= CRC[6];\n        CRC[6]  <= CRC[5];\n        CRC[5]  <= CRC[4] ^ inv;\n        CRC[4]  <= CRC[3];\n        CRC[3]  <= CRC[2];\n        CRC[2]  <= CRC[1];\n        CRC[1]  <= CRC[0];\n        CRC[0]  <= inv;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 4, "code": "module sd_bd (\n    input  wire                     clk,\n    input  wire                     rst,\n    input  wire                     we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0]      free_bd,\n    input  wire                     re_s,\n    output wire                     ack_o_s,\n    input  wire                     a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Local parameters\nlocalparam BD_MEM_DEPTH = 1 << BD_WIDTH;\n\n// Internal registers\nreg [BD_WIDTH-1:0] m_wr_pnt;\nreg [BD_WIDTH-1:0] s_rd_pnt;\nreg [BD_WIDTH-1:0] free_bd_cnt;\nreg [1:0]          wr_cnt;\nreg [1:0]          rd_cnt;\nreg                new_bw;\nreg                last_a_cmp;\nreg                ack_o_s_reg;\n\n// Memory array\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_MEM_DEPTH-1];\n\n// Assign outputs\nassign free_bd = free_bd_cnt;\nassign ack_o_s = ack_o_s_reg;\nassign dat_out_s = bd_mem[s_rd_pnt];\n\n// Write process\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        wr_cnt <= 0;\n        new_bw <= 0;\n    end else begin\n        new_bw <= 0;\n        \n        if (we_m && (free_bd_cnt > 0)) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= m_wr_pnt + 1;\n            \n            if (RAM_MEM_WIDTH == 32) begin\n                if (wr_cnt == 1) begin\n                    new_bw <= 1;\n                    wr_cnt <= 0;\n                end else begin\n                    wr_cnt <= wr_cnt + 1;\n                end\n            end else if (RAM_MEM_WIDTH == 16) begin\n                if (wr_cnt == 3) begin\n                    new_bw <= 1;\n                    wr_cnt <= 0;\n                end else begin\n                    wr_cnt <= wr_cnt + 1;\n                end\n            end\n        end\n    end\nend\n\n// Read process\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        s_rd_pnt <= 0;\n        rd_cnt <= 0;\n        ack_o_s_reg <= 0;\n    end else begin\n        ack_o_s_reg <= 0;\n        \n        if (re_s) begin\n            s_rd_pnt <= s_rd_pnt + 1;\n            \n            if (RAM_MEM_WIDTH == 32) begin\n                if (rd_cnt == 1) begin\n                    rd_cnt <= 0;\n                end else begin\n                    rd_cnt <= rd_cnt + 1;\n                end\n            end else if (RAM_MEM_WIDTH == 16) begin\n                ack_o_s_reg <= 1;\n                if (rd_cnt == 3) begin\n                    rd_cnt <= 0;\n                end else begin\n                    rd_cnt <= rd_cnt + 1;\n                end\n            end\n        end\n    end\nend\n\n// Free BD counter management\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        free_bd_cnt <= (RAM_MEM_WIDTH == 32) ? (BD_MEM_DEPTH >> 1) : (BD_MEM_DEPTH >> 2);\n        last_a_cmp <= 0;\n    end else begin\n        last_a_cmp <= a_cmp;\n        \n        // Increment free_bd on a_cmp rising edge\n        if (a_cmp && !last_a_cmp) begin\n            free_bd_cnt <= free_bd_cnt + 1;\n        end\n        // Decrement free_bd when new BD is written\n        else if (new_bw) begin\n            free_bd_cnt <= free_bd_cnt - 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 1, "code": "module sd_fifo_rx_filler (\n    input clk,\n    input rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input en,\n    input [31:0] adr,\n    input sd_clk,\n    input [3:0] dat_i,\n    input wr,\n    output full,\n    output empty\n);\n\n// Parameters\nparameter MEM_OFFSET = 4; // Default memory offset between words\n\n// Internal registers\nreg [8:0] offset;\nreg wb_free;\nreg reset_rx_fifo;\nreg rd;\n\n// FIFO signals\nwire [31:0] dat_o;\nwire [1:0] mem_empt;\n\n// State machine\nreg [1:0] state;\nlocalparam IDLE = 2'b00;\nlocalparam READ_FIFO = 2'b01;\nlocalparam WB_WRITE = 2'b10;\n\n// RX FIFO instance\nsd_rx_fifo rx_fifo (\n    .d(dat_i),\n    .wr(wr),\n    .wclk(sd_clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(full),\n    .empty(empty),\n    .mem_empt(mem_empt),\n    .rclk(clk),\n    .rst(rst | reset_rx_fifo)\n);\n\n// Main state machine\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all control signals\n        m_wb_adr_o <= 32'b0;\n        m_wb_we_o <= 1'b0;\n        m_wb_dat_o <= 32'b0;\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n        m_wb_cti_o <= 3'b0;\n        m_wb_bte_o <= 2'b0;\n        offset <= 9'b0;\n        wb_free <= 1'b1;\n        reset_rx_fifo <= 1'b1;\n        rd <= 1'b0;\n        state <= IDLE;\n    end else begin\n        case (state)\n            IDLE: begin\n                if (!en) begin\n                    // Module disabled\n                    reset_rx_fifo <= 1'b1;\n                    rd <= 1'b0;\n                    offset <= 9'b0;\n                    wb_free <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    m_wb_we_o <= 1'b0;\n                end else begin\n                    // Module enabled\n                    reset_rx_fifo <= 1'b0;\n                    \n                    if (!empty && wb_free) begin\n                        // Start reading from FIFO\n                        rd <= 1'b1;\n                        state <= READ_FIFO;\n                    end\n                end\n            end\n            \n            READ_FIFO: begin\n                // FIFO data is now available\n                rd <= 1'b0;\n                m_wb_dat_o <= dat_o;\n                m_wb_adr_o <= adr + offset;\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                wb_free <= 1'b0;\n                state <= WB_WRITE;\n            end\n            \n            WB_WRITE: begin\n                if (m_wb_ack_i) begin\n                    // Wishbone transaction complete\n                    m_wb_we_o <= 1'b0;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    offset <= offset + MEM_OFFSET;\n                    wb_free <= 1'b1;\n                    state <= IDLE;\n                end\n            end\n            \n            default: state <= IDLE;\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 5, "code": "module sd_bd (\n    input  wire                     clk,\n    input  wire                     rst,\n    input  wire                     we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0]      free_bd,\n    input  wire                     re_s,\n    output wire                     ack_o_s,\n    input  wire                     a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\nparameter BD_WIDTH = 8;\nparameter BD_SIZE = 255;\nparameter RAM_MEM_WIDTH = 32;\n\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\nreg [BD_WIDTH-1:0]      m_wr_pnt;\nreg [BD_WIDTH-1:0]      s_rd_pnt;\nreg [BD_WIDTH-1:0]      free_bd_cnt;\nreg [1:0]               wr_cnt;\nreg [1:0]               rd_cnt;\nreg                     new_bw;\nreg                     last_a_cmp;\nreg                     ack_o_s_reg;\n\nwire                    a_cmp_rise;\n\nassign free_bd = free_bd_cnt;\nassign ack_o_s = ack_o_s_reg;\nassign a_cmp_rise = a_cmp & ~last_a_cmp;\n\n// Initialize the module\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        wr_cnt <= 0;\n        rd_cnt <= 0;\n        new_bw <= 0;\n        last_a_cmp <= 0;\n        ack_o_s_reg <= 0;\n        \n        if (RAM_MEM_WIDTH == 32)\n            free_bd_cnt <= BD_SIZE >> 1;\n        else\n            free_bd_cnt <= BD_SIZE >> 2;\n    end\n    else begin\n        last_a_cmp <= a_cmp;\n        \n        // Write operation\n        if (we_m && (free_bd_cnt > 0)) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= m_wr_pnt + 1;\n            \n            if (RAM_MEM_WIDTH == 32) begin\n                wr_cnt <= wr_cnt + 1;\n                if (wr_cnt == 1) begin\n                    new_bw <= 1;\n                    free_bd_cnt <= free_bd_cnt - 1;\n                    wr_cnt <= 0;\n                end\n                else begin\n                    new_bw <= 0;\n                end\n            end\n            else begin // 16-bit mode\n                wr_cnt <= wr_cnt + 1;\n                if (wr_cnt == 3) begin\n                    new_bw <= 1;\n                    free_bd_cnt <= free_bd_cnt - 1;\n                    wr_cnt <= 0;\n                end\n                else begin\n                    new_bw <= 0;\n                end\n            end\n        end\n        else begin\n            new_bw <= 0;\n        end\n        \n        // Read operation\n        if (re_s) begin\n            if (RAM_MEM_WIDTH == 32) begin\n                rd_cnt <= rd_cnt + 1;\n                ack_o_s_reg <= (rd_cnt == 1);\n                if (rd_cnt == 1) begin\n                    s_rd_pnt <= s_rd_pnt + 1;\n                    rd_cnt <= 0;\n                end\n            end\n            else begin // 16-bit mode\n                rd_cnt <= rd_cnt + 1;\n                ack_o_s_reg <= 1;\n                if (rd_cnt == 3) begin\n                    s_rd_pnt <= s_rd_pnt + 1;\n                    rd_cnt <= 0;\n                end\n            end\n        end\n        else begin\n            ack_o_s_reg <= 0;\n        end\n        \n        // Release BD on operation completion\n        if (a_cmp_rise) begin\n            free_bd_cnt <= free_bd_cnt + 1;\n        end\n    end\nend\n\nassign dat_out_s = bd_mem[s_rd_pnt];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 2, "code": "module sd_fifo_rx_filler (\n    input  wire         clk,\n    input  wire         rst,\n    output wire [31:0]  m_wb_adr_o,\n    output wire         m_wb_we_o,\n    output wire [31:0]  m_wb_dat_o,\n    output wire         m_wb_cyc_o,\n    output wire         m_wb_stb_o,\n    input  wire         m_wb_ack_i,\n    output wire [2:0]   m_wb_cti_o,\n    output wire [1:0]   m_wb_bte_o,\n    input  wire         en,\n    input  wire [31:0]  adr,\n    input  wire         sd_clk,\n    input  wire [3:0]   dat_i,\n    input  wire         wr,\n    output wire         full,\n    output wire         empty\n);\n\n    // Parameters\n    parameter MEM_OFFSET = 4;  // Address offset between words\n\n    // Internal signals\n    reg [8:0]  offset;\n    reg        wb_free;\n    reg        reset_rx_fifo;\n    reg        rd;\n    wire [31:0] dat_o;\n    wire [1:0]  mem_empt;\n\n    // State machine states\n    localparam IDLE     = 2'b00;\n    localparam READ_FIFO = 2'b01;\n    localparam WB_WRITE = 2'b10;\n    \n    reg [1:0] state;\n\n    // Instantiate RX FIFO\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .mem_empt(mem_empt),\n        .rclk(clk),\n        .rst(rst | reset_rx_fifo)\n    );\n\n    // Wishbone outputs\n    assign m_wb_adr_o = adr + {23'b0, offset};\n    assign m_wb_dat_o = dat_o;\n    assign m_wb_we_o  = 1'b1;\n    assign m_wb_cyc_o = (state == WB_WRITE);\n    assign m_wb_stb_o = (state == WB_WRITE);\n    assign m_wb_cti_o = 3'b000;  // Classic cycle\n    assign m_wb_bte_o = 2'b00;   // Linear burst\n\n    // State machine\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n        end else begin\n            if (!en) begin\n                state <= IDLE;\n                offset <= 9'b0;\n                wb_free <= 1'b1;\n                reset_rx_fifo <= 1'b1;\n                rd <= 1'b0;\n            end else begin\n                reset_rx_fifo <= 1'b0;\n                \n                case (state)\n                    IDLE: begin\n                        rd <= 1'b0;\n                        if (!empty && wb_free) begin\n                            rd <= 1'b1;\n                            state <= READ_FIFO;\n                        end\n                    end\n                    \n                    READ_FIFO: begin\n                        state <= WB_WRITE;\n                        wb_free <= 1'b0;\n                    end\n                    \n                    WB_WRITE: begin\n                        if (m_wb_ack_i) begin\n                            offset <= offset + MEM_OFFSET;\n                            wb_free <= 1'b1;\n                            rd <= 1'b0;\n                            state <= IDLE;\n                        end\n                    end\n                    \n                    default: state <= IDLE;\n                endcase\n            end\n        end\n    end\n\nendmodule\n\nmodule sd_rx_fifo (\n    input  wire [3:0]  d,\n    input  wire        wr,\n    input  wire        wclk,\n    output wire [31:0] q,\n    input  wire        rd,\n    output wire        full,\n    output wire        empty,\n    output wire [1:0]  mem_empt,\n    input  wire        rclk,\n    input  wire        rst\n);\n\n    // FIFO implementation would go here\n    // This is a placeholder for the actual FIFO implementation\n    \n    assign q = 32'b0;\n    assign full = 1'b0;\n    assign empty = 1'b1;\n    assign mem_empt = 2'b11;\n    \nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 3, "code": "module sd_fifo_rx_filler (\n    input  wire         clk,\n    input  wire         rst,\n    output reg  [31:0]  m_wb_adr_o,\n    output reg          m_wb_we_o,\n    output reg  [31:0]  m_wb_dat_o,\n    output reg          m_wb_cyc_o,\n    output reg          m_wb_stb_o,\n    input  wire         m_wb_ack_i,\n    output wire [2:0]   m_wb_cti_o,\n    output wire [2:0]   m_wb_bte_o,\n    input  wire         en,\n    input  wire [31:0]  adr,\n    input  wire         sd_clk,\n    input  wire [3:0]   dat_i,\n    input  wire         wr,\n    output wire         full,\n    output wire         empty\n);\n\n// Local parameters\nparameter MEM_OFFSET = 4; // Address increment per word (32-bit)\n\n// Internal registers\nreg [8:0]  offset;\nreg        wb_free;\nreg        reset_rx_fifo;\nreg        rd;\n\n// FIFO signals\nwire [31:0] dat_o;\nwire [1:0]  mem_empt;\n\n// State machine\nreg [1:0] state;\nparameter IDLE      = 2'b00;\nparameter READ_FIFO = 2'b01;\nparameter WB_WRITE  = 2'b10;\n\n// FIFO instance\nsd_rx_fifo rx_fifo (\n    .d(dat_i),\n    .wr(wr),\n    .wclk(sd_clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(full),\n    .empty(empty),\n    .mem_empt(mem_empt),\n    .rclk(clk),\n    .rst(rst | reset_rx_fifo)\n);\n\n// Wishbone signals\nassign m_wb_cti_o = 3'b000; // Classic cycle\nassign m_wb_bte_o = 2'b00;  // Linear burst\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all control signals\n        m_wb_adr_o <= 32'b0;\n        m_wb_we_o <= 1'b0;\n        m_wb_dat_o <= 32'b0;\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n        offset <= 9'b0;\n        wb_free <= 1'b1;\n        reset_rx_fifo <= 1'b1;\n        rd <= 1'b0;\n        state <= IDLE;\n    end else begin\n        case (state)\n            IDLE: begin\n                if (en) begin\n                    reset_rx_fifo <= 1'b0;\n                    if (!empty && wb_free) begin\n                        rd <= 1'b1;\n                        state <= READ_FIFO;\n                    end\n                end else begin\n                    // Disabled state\n                    reset_rx_fifo <= 1'b1;\n                    offset <= 9'b0;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    m_wb_we_o <= 1'b0;\n                    wb_free <= 1'b1;\n                    rd <= 1'b0;\n                end\n            end\n            \n            READ_FIFO: begin\n                // Data should be available now\n                m_wb_adr_o <= adr + offset;\n                m_wb_dat_o <= dat_o;\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                wb_free <= 1'b0;\n                rd <= 1'b0;\n                state <= WB_WRITE;\n            end\n            \n            WB_WRITE: begin\n                if (m_wb_ack_i) begin\n                    // Transaction complete\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    m_wb_we_o <= 1'b0;\n                    offset <= offset + MEM_OFFSET;\n                    wb_free <= 1'b1;\n                    state <= IDLE;\n                end\n            end\n            \n            default: state <= IDLE;\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 4, "code": "module sd_fifo_tx_filler (\n    input clk,\n    input rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    input [31:0] m_wb_dat_i,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [2:0] m_wb_bte_o,\n    input en,\n    input [31:0] adr,\n    input sd_clk,\n    output [31:0] dat_o,\n    input rd,\n    output empty,\n    output fe\n);\n\n// Internal registers\nreg [8:0] offset;\nreg [8:0] we;\nreg [31:0] din;\nreg wr_tx;\nreg reset_tx_fifo;\nreg first;\nreg ackd;\nreg delay;\n\n// FIFO instance\nsd_tx_fifo tx_fifo (\n    .d(din),\n    .wr(wr_tx),\n    .wclk(clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(fe),\n    .empty(empty),\n    .rclk(sd_clk),\n    .rst(rst | reset_tx_fifo)\n);\n\n// Main state machine\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all registers\n        m_wb_adr_o <= 32'b0;\n        m_wb_we_o <= 1'b0;\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n        m_wb_cti_o <= 3'b0;\n        m_wb_bte_o <= 2'b0;\n        offset <= 9'b0;\n        we <= 9'b0;\n        din <= 32'b0;\n        wr_tx <= 1'b0;\n        reset_tx_fifo <= 1'b1;\n        first <= 1'b1;\n        ackd <= 1'b1;\n        delay <= 1'b0;\n    end else begin\n        // Default values\n        wr_tx <= 1'b0;\n        reset_tx_fifo <= 1'b0;\n        \n        if (en) begin\n            // Module is enabled\n            if (first) begin\n                // First operation after enable\n                m_wb_adr_o <= adr;\n                first <= 1'b0;\n                reset_tx_fifo <= 1'b1;\n            end else if (!fe && !m_wb_ack_i && ackd) begin\n                // Start Wishbone transaction\n                m_wb_adr_o <= adr + {offset, 2'b00};\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                m_wb_we_o <= 1'b0;\n                m_wb_cti_o <= 3'b001; // Incrementing burst\n                m_wb_bte_o <= 2'b00;  // Linear burst\n                ackd <= 1'b0;\n            end\n            \n            if (m_wb_ack_i) begin\n                // Wishbone acknowledge\n                din <= m_wb_dat_i;\n                wr_tx <= 1'b1;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                m_wb_we_o <= 1'b0;\n                delay <= 1'b1;\n            end\n            \n            if (delay) begin\n                // Delay state for timing\n                offset <= offset + 1;\n                ackd <= ~ackd;\n                wr_tx <= 1'b0;\n                delay <= 1'b0;\n            end\n        end else begin\n            // Module is disabled\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_we_o <= 1'b0;\n            offset <= 9'b0;\n            first <= 1'b1;\n            reset_tx_fifo <= 1'b1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 6, "code": "module sd_bd (\n    input  wire                     clk,\n    input  wire                     rst,\n    input  wire                     we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0]      free_bd,\n    input  wire                     re_s,\n    output wire                     ack_o_s,\n    input  wire                     a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\nparameter BD_SIZE = 1 << BD_WIDTH;\n\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\nreg [BD_WIDTH-1:0]      m_wr_pnt;\nreg [BD_WIDTH-1:0]      s_rd_pnt;\nreg [BD_WIDTH-1:0]      free_bd_cnt;\nreg                     new_bw;\nreg                     last_a_cmp;\nreg [1:0]               wr_cnt;\nreg [1:0]               rd_cnt;\n\nassign free_bd = free_bd_cnt;\nassign dat_out_s = bd_mem[s_rd_pnt];\n\n`ifdef RAM_MEM_WIDTH_16\n    assign ack_o_s = re_s;\n`else\n    assign ack_o_s = re_s & (rd_cnt == 1);\n`endif\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        new_bw <= 0;\n        wr_cnt <= 0;\n        rd_cnt <= 0;\n        last_a_cmp <= 0;\n        `ifdef RAM_MEM_WIDTH_16\n            free_bd_cnt <= BD_SIZE >> 2;\n        `else\n            free_bd_cnt <= BD_SIZE >> 1;\n        `endif\n    end else begin\n        last_a_cmp <= a_cmp;\n        \n        // Write operation\n        if (we_m && (free_bd_cnt != 0)) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= m_wr_pnt + 1;\n            wr_cnt <= wr_cnt + 1;\n            \n            `ifdef RAM_MEM_WIDTH_16\n                if (wr_cnt == 3) begin\n                    new_bw <= 1;\n                    free_bd_cnt <= free_bd_cnt - 1;\n                    wr_cnt <= 0;\n                end else begin\n                    new_bw <= 0;\n                end\n            `else\n                if (wr_cnt == 1) begin\n                    new_bw <= 1;\n                    free_bd_cnt <= free_bd_cnt - 1;\n                    wr_cnt <= 0;\n                end else begin\n                    new_bw <= 0;\n                end\n            `endif\n        end else begin\n            new_bw <= 0;\n        end\n        \n        // Read operation\n        if (re_s) begin\n            s_rd_pnt <= s_rd_pnt + 1;\n            `ifdef RAM_MEM_WIDTH_16\n                rd_cnt <= rd_cnt + 1;\n                if (rd_cnt == 3) begin\n                    rd_cnt <= 0;\n                end\n            `else\n                rd_cnt <= rd_cnt + 1;\n                if (rd_cnt == 1) begin\n                    rd_cnt <= 0;\n                end\n            `endif\n        end\n        \n        // Release BD on a_cmp rising edge\n        if (a_cmp && !last_a_cmp) begin\n            free_bd_cnt <= free_bd_cnt + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 19, "code": "module sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC[15] <= CRC[14];\n            CRC[14] <= CRC[13];\n            CRC[13] <= CRC[12];\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[11] <= CRC[10];\n            CRC[10] <= CRC[9];\n            CRC[9]  <= CRC[8];\n            CRC[8]  <= CRC[7];\n            CRC[7]  <= CRC[6];\n            CRC[6]  <= CRC[5];\n            CRC[5]  <= CRC[4] ^ inv;\n            CRC[4]  <= CRC[3];\n            CRC[3]  <= CRC[2];\n            CRC[2]  <= CRC[1];\n            CRC[1]  <= CRC[0];\n            CRC[0]  <= inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input                       clk,\n    input                       rst,\n    input                       we_m,\n    input   [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output  [BD_WIDTH-1:0]      free_bd,\n    input                       re_s,\n    output                      ack_o_s,\n    input                       a_cmp,\n    output  [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    // Internal registers\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] free_bd_cnt;\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n    \n    // Write control signals\n    reg [1:0] wr_cnt;\n    reg new_bw;\n    \n    // Read control signals\n    reg [1:0] rd_cnt;\n    \n    // Completion detection\n    reg last_a_cmp;\n    wire a_cmp_rise;\n    \n    // Mode dependent parameters\n    localparam WR_CNT_MAX = (RAM_MEM_WIDTH == 32) ? 1 : 3;\n    localparam RD_CNT_MAX = (RAM_MEM_WIDTH == 32) ? 1 : 3;\n    localparam INIT_FREE_BD = (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n    \n    // Assign outputs\n    assign free_bd = free_bd_cnt;\n    assign ack_o_s = (RAM_MEM_WIDTH == 16) ? re_s : (rd_cnt == RD_CNT_MAX);\n    assign dat_out_s = bd_mem[s_rd_pnt];\n    assign a_cmp_rise = a_cmp & ~last_a_cmp;\n    \n    // Write process\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wr_pnt <= {BD_WIDTH{1'b0}};\n            wr_cnt <= 2'b00;\n            new_bw <= 1'b0;\n        end else if (we_m && (free_bd_cnt > 0)) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= m_wr_pnt + 1'b1;\n            \n            if (wr_cnt == WR_CNT_MAX) begin\n                wr_cnt <= 2'b00;\n                new_bw <= 1'b1;\n            end else begin\n                wr_cnt <= wr_cnt + 1'b1;\n                new_bw <= 1'b0;\n            end\n        end else begin\n            new_bw <= 1'b0;\n        end\n    end\n    \n    // Read process\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            s_rd_pnt <= {BD_WIDTH{1'b0}};\n            rd_cnt <= 2'b00;\n        end else if (re_s) begin\n            s_rd_pnt <= s_rd_pnt + 1'b1;\n            \n            if (rd_cnt == RD_CNT_MAX) begin\n                rd_cnt <= 2'b00;\n            end else begin\n                rd_cnt <= rd_cnt + 1'b1;\n            end\n        end\n    end\n    \n    // Free BD counter management\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd_cnt <= INIT_FREE_BD;\n            last_a_cmp <= 1'b0;\n        end else begin\n            last_a_cmp <= a_cmp;\n            \n            if (new_bw) begin\n                free_bd_cnt <= free_bd_cnt - 1'b1;\n            end else if (a_cmp_rise) begin\n                free_bd_cnt <= free_bd_cnt + 1'b1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 6, "code": "module sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    input wire rclk,\n    output wire full,\n    output wire empty,\n    output wire [1:0] mem_empt,\n    input wire rst\n);\n\nparameter FIFO_RX_MEM_DEPTH = 16; // Example depth, should be defined in sd_defines.v\nparameter FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH) + 1;\n\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_next = adr_i + 1'b1;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o_next = adr_o + 1'b1;\n\n// Full and empty flags\nassign full = (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] == adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]) && \n              (adr_i[FIFO_RX_MEM_ADR_SIZE-1] != adr_o[FIFO_RX_MEM_ADR_SIZE-1]);\nassign empty = (adr_i == adr_o);\nassign mem_empt = (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) >> 2; // Approximate empty space in words\n\n// Write operation (wclk domain)\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        we <= 8'h1;\n        tmp <= 32'h0;\n        ft <= 1'b0;\n    end else begin\n        if (wr && !full) begin\n            case (we)\n                8'h1: begin tmp[3:0] <= d; we <= 8'h3; end\n                8'h3: begin tmp[7:4] <= d; we <= 8'h7; end\n                8'h7: begin tmp[11:8] <= d; we <= 8'hf; end\n                8'hf: begin tmp[15:12] <= d; we <= 8'h1f; end\n                8'h1f: begin tmp[19:16] <= d; we <= 8'h3f; end\n                8'h3f: begin tmp[23:20] <= d; we <= 8'h7f; end\n                8'h7f: begin tmp[27:24] <= d; we <= 8'hff; end\n                8'hff: begin \n                    tmp[31:28] <= d; \n                    ram[adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]] <= tmp;\n                    adr_i <= adr_i_next;\n                    we <= 8'h1;\n                    ft <= 1'b1;\n                end\n                default: we <= 8'h1;\n            endcase\n        end\n    end\nend\n\n// Read operation (rclk domain)\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 32'h0;\n    end else begin\n        if (rd && !empty) begin\n            q <= ram[adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]];\n            adr_o <= adr_o_next;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 8, "code": "module sd_bd (\n    input  wire                     clk,\n    input  wire                     rst,\n    input  wire                     we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0]      free_bd,\n    input  wire                     re_s,\n    output wire                     ack_o_s,\n    input  wire                     a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    // Parameters\n    parameter BD_WIDTH = 8;\n    parameter RAM_MEM_WIDTH = 32;\n    parameter BD_SIZE = 255;\n\n    // Internal registers\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] free_bd_reg;\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n    reg new_bw;\n    reg last_a_cmp;\n    reg ack_o_s_reg;\n    \n    // Counters for multi-cycle operations\n    reg [1:0] wr_cnt;\n    reg [1:0] rd_cnt;\n\n    // Assign outputs\n    assign free_bd = free_bd_reg;\n    assign ack_o_s = ack_o_s_reg;\n    assign dat_out_s = bd_mem[s_rd_pnt];\n\n    // Initialization\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            wr_cnt <= 0;\n            rd_cnt <= 0;\n            new_bw <= 0;\n            last_a_cmp <= 0;\n            ack_o_s_reg <= 0;\n            \n            // Initialize free_bd based on RAM_MEM_WIDTH\n            if (RAM_MEM_WIDTH == 32)\n                free_bd_reg <= BD_SIZE >> 1;\n            else if (RAM_MEM_WIDTH == 16)\n                free_bd_reg <= BD_SIZE >> 2;\n            else\n                free_bd_reg <= BD_SIZE;\n        end\n    end\n\n    // Write Buffer Descriptor\n    always @(posedge clk) begin\n        if (we_m && (free_bd_reg > 0)) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= m_wr_pnt + 1;\n            \n            if (RAM_MEM_WIDTH == 32) begin\n                // 32-bit mode: one write completes a BD\n                if (wr_cnt == 1) begin\n                    new_bw <= 1;\n                    free_bd_reg <= free_bd_reg - 1;\n                    wr_cnt <= 0;\n                end else begin\n                    new_bw <= 0;\n                    wr_cnt <= wr_cnt + 1;\n                end\n            end\n            else if (RAM_MEM_WIDTH == 16) begin\n                // 16-bit mode: four writes complete a BD\n                if (wr_cnt == 3) begin\n                    new_bw <= 1;\n                    free_bd_reg <= free_bd_reg - 1;\n                    wr_cnt <= 0;\n                end else begin\n                    new_bw <= 0;\n                    wr_cnt <= wr_cnt + 1;\n                end\n            end\n        end else begin\n            new_bw <= 0;\n        end\n    end\n\n    // Read Buffer Descriptor\n    always @(posedge clk) begin\n        if (re_s) begin\n            s_rd_pnt <= s_rd_pnt + 1;\n            \n            if (RAM_MEM_WIDTH == 32) begin\n                // 32-bit mode: two reads complete a BD\n                if (rd_cnt == 1) begin\n                    ack_o_s_reg <= 1;\n                    rd_cnt <= 0;\n                end else begin\n                    ack_o_s_reg <= 0;\n                    rd_cnt <= rd_cnt + 1;\n                end\n            end\n            else if (RAM_MEM_WIDTH == 16) begin\n                // 16-bit mode: four reads complete a BD\n                if (rd_cnt == 3) begin\n                    ack_o_s_reg <= 1;\n                    rd_cnt <= 0;\n                end else begin\n                    ack_o_s_reg <= 1; // Acknowledge each read in 16-bit mode\n                    rd_cnt <= rd_cnt + 1;\n                end\n            end\n        end else begin\n            ack_o_s_reg <= 0;\n        end\n    end\n\n    // Release Buffer Descriptor\n    always @(posedge clk) begin\n        last_a_cmp <= a_cmp;\n        \n        if (a_cmp && !last_a_cmp) begin\n            free_bd_reg <= free_bd_reg + 1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 19, "code": "module sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end\n    else if (Enable) begin\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 7, "code": "module sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    input wire rclk,\n    output wire full,\n    output wire empty,\n    output wire [1:0] mem_empt,\n    input wire rst\n);\n\nparameter FIFO_RX_MEM_DEPTH = 16; // Example value, should be defined in sd_defines.v\nparameter FIFO_RX_MEM_ADR_SIZE = 5; // log2(FIFO_RX_MEM_DEPTH) + 1\n\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_next = adr_i + 1;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o_next = adr_o + 1;\n\n// Full and empty flags\nassign full = (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] == adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]) && \n              (adr_i[FIFO_RX_MEM_ADR_SIZE-1] != adr_o[FIFO_RX_MEM_ADR_SIZE-1]);\nassign empty = (adr_i == adr_o);\nassign mem_empt = (adr_i[FIFO_RX_MEM_ADR_SIZE-1] == adr_o[FIFO_RX_MEM_ADR_SIZE-1]) ? \n                  (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] - adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]) : \n                  (FIFO_RX_MEM_DEPTH - adr_o[FIFO_RX_MEM_ADR_SIZE-2:0] + adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]);\n\n// Write operation (wclk domain)\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n    end else begin\n        if (wr && !full) begin\n            case (we)\n                8'h1: begin\n                    tmp[3:0] <= d;\n                    we <= 8'h2;\n                end\n                8'h2: begin\n                    tmp[7:4] <= d;\n                    we <= 8'h4;\n                end\n                8'h4: begin\n                    tmp[11:8] <= d;\n                    we <= 8'h8;\n                end\n                8'h8: begin\n                    tmp[15:12] <= d;\n                    we <= 8'h10;\n                end\n                8'h10: begin\n                    tmp[19:16] <= d;\n                    we <= 8'h20;\n                end\n                8'h20: begin\n                    tmp[23:20] <= d;\n                    we <= 8'h40;\n                end\n                8'h40: begin\n                    tmp[27:24] <= d;\n                    we <= 8'h80;\n                end\n                8'h80: begin\n                    tmp[31:28] <= d;\n                    we <= 8'h1;\n                    ft <= 1;\n                end\n                default: we <= 8'h1;\n            endcase\n        end\n        \n        if (ft) begin\n            ram[adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]] <= tmp;\n            adr_i <= adr_i_next;\n            ft <= 0;\n        end\n    end\nend\n\n// Read operation (rclk domain)\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else begin\n        if (rd && !empty) begin\n            q <= ram[adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]];\n            adr_o <= adr_o_next;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 5, "code": "module sd_fifo_tx_filler (\n    input clk,\n    input rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    input [31:0] m_wb_dat_i,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input m_wb_ack_i,\n    output [2:0] m_wb_cti_o,\n    output [1:0] m_wb_bte_o,\n    input en,\n    input [31:0] adr,\n    input sd_clk,\n    output [31:0] dat_o,\n    input rd,\n    output empty,\n    output fe\n);\n\n    // Internal registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Wishbone signals\n    assign m_wb_cti_o = 3'b000;  // Classic cycle\n    assign m_wb_bte_o = 2'b00;   // Linear burst\n\n    // FIFO instance\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .rclk(sd_clk),\n        .rst(rst | reset_tx_fifo)\n    );\n\n    // Main state machine\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all registers\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b1;\n            delay <= 1'b0;\n        end else begin\n            // Default values\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b0;\n\n            if (en) begin\n                if (first) begin\n                    // First transaction after enable\n                    m_wb_adr_o <= adr;\n                    first <= 1'b0;\n                end\n\n                if (!fe && !m_wb_ack_i && ackd) begin\n                    // Start Wishbone transaction\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                    ackd <= 1'b0;\n                end\n\n                if (m_wb_ack_i) begin\n                    // Wishbone acknowledged\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    m_wb_we_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n\n                if (delay) begin\n                    // Delay state for timing\n                    offset <= offset + 1;\n                    m_wb_adr_o <= adr + {offset + 1, 2'b00};\n                    ackd <= ~ackd;\n                    wr_tx <= 1'b0;\n                    delay <= 1'b0;\n                end\n            end else begin\n                // Disabled state\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                m_wb_we_o <= 1'b0;\n                offset <= 9'b0;\n                reset_tx_fifo <= 1'b1;\n                first <= 1'b1;\n                ackd <= 1'b1;\n                delay <= 1'b0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 9, "code": "module sd_bd (\n    input  wire                     clk,\n    input  wire                     rst,\n    input  wire                     we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0]      free_bd,\n    input  wire                     re_s,\n    output reg                      ack_o_s,\n    input  wire                     a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n`include \"sd_defines.v\"\n\n// Internal registers\nreg [BD_WIDTH-1:0] m_wr_pnt;\nreg [BD_WIDTH-1:0] s_rd_pnt;\nreg [BD_WIDTH-1:0] free_bd_cnt;\nreg [1:0]          wr_cnt;\nreg [1:0]          rd_cnt;\nreg                new_bw;\nreg                last_a_cmp;\n\n// Memory for buffer descriptors\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n\n// Assign outputs\nassign free_bd = free_bd_cnt;\nassign dat_out_s = bd_mem[s_rd_pnt];\n\n// Write operation\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        wr_cnt <= 0;\n        new_bw <= 0;\n    end else begin\n        new_bw <= 0;\n        if (we_m && (free_bd_cnt > 0)) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= m_wr_pnt + 1;\n            \n            if (RAM_MEM_WIDTH == 32) begin\n                if (wr_cnt == 1) begin\n                    new_bw <= 1;\n                    wr_cnt <= 0;\n                end else begin\n                    wr_cnt <= wr_cnt + 1;\n                end\n            end else if (RAM_MEM_WIDTH == 16) begin\n                if (wr_cnt == 3) begin\n                    new_bw <= 1;\n                    wr_cnt <= 0;\n                end else begin\n                    wr_cnt <= wr_cnt + 1;\n                end\n            end\n        end\n    end\nend\n\n// Read operation\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        s_rd_pnt <= 0;\n        rd_cnt <= 0;\n        ack_o_s <= 0;\n    end else begin\n        ack_o_s <= 0;\n        if (re_s) begin\n            s_rd_pnt <= s_rd_pnt + 1;\n            \n            if (RAM_MEM_WIDTH == 32) begin\n                if (rd_cnt == 1) begin\n                    rd_cnt <= 0;\n                end else begin\n                    rd_cnt <= rd_cnt + 1;\n                end\n            end else if (RAM_MEM_WIDTH == 16) begin\n                ack_o_s <= 1;\n                if (rd_cnt == 3) begin\n                    rd_cnt <= 0;\n                end else begin\n                    rd_cnt <= rd_cnt + 1;\n                end\n            end\n        end\n    end\nend\n\n// Free BD counter management\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        free_bd_cnt <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n        last_a_cmp <= 0;\n    end else begin\n        last_a_cmp <= a_cmp;\n        \n        // Handle BD release\n        if (a_cmp && !last_a_cmp) begin\n            free_bd_cnt <= free_bd_cnt + 1;\n        end\n        \n        // Handle BD allocation\n        if (new_bw) begin\n            free_bd_cnt <= free_bd_cnt - 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 10, "code": "module sd_bd (\n    input  wire                     clk,\n    input  wire                     rst,\n    input  wire                     we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0]      free_bd,\n    input  wire                     re_s,\n    output reg                      ack_o_s,\n    input  wire                     a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\nparameter BD_WIDTH = 8;\nparameter BD_SIZE = 255;\nparameter RAM_MEM_WIDTH = 32;\n\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\nreg [BD_WIDTH-1:0]      m_wr_pnt;\nreg [BD_WIDTH-1:0]      s_rd_pnt;\nreg [BD_WIDTH-1:0]      free_bd_cnt;\nreg [1:0]               wr_cnt;\nreg [1:0]               rd_cnt;\nreg                     new_bw;\nreg                     last_a_cmp;\n\nwire [RAM_MEM_WIDTH-1:0] dat_out_s_int;\n\n// Free BD output\nassign free_bd = free_bd_cnt;\n\n// Memory read\nassign dat_out_s = bd_mem[s_rd_pnt];\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all registers\n        m_wr_pnt     <= 0;\n        s_rd_pnt     <= 0;\n        free_bd_cnt  <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n        wr_cnt       <= 0;\n        rd_cnt       <= 0;\n        new_bw       <= 0;\n        ack_o_s      <= 0;\n        last_a_cmp   <= 0;\n    end else begin\n        // Handle write operations\n        if (we_m && (free_bd_cnt > 0)) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= m_wr_pnt + 1;\n            \n            if (RAM_MEM_WIDTH == 32) begin\n                // 32-bit mode: one write completes one BD\n                if (wr_cnt == 1) begin\n                    new_bw <= 1;\n                    free_bd_cnt <= free_bd_cnt - 1;\n                    wr_cnt <= 0;\n                end else begin\n                    wr_cnt <= wr_cnt + 1;\n                end\n            end else begin\n                // 16-bit mode: four writes complete one BD\n                if (wr_cnt == 3) begin\n                    new_bw <= 1;\n                    free_bd_cnt <= free_bd_cnt - 1;\n                    wr_cnt <= 0;\n                end else begin\n                    wr_cnt <= wr_cnt + 1;\n                end\n            end\n        end else begin\n            new_bw <= 0;\n        end\n\n        // Handle read operations\n        if (re_s) begin\n            s_rd_pnt <= s_rd_pnt + 1;\n            \n            if (RAM_MEM_WIDTH == 32) begin\n                // 32-bit mode: two reads complete one BD\n                if (rd_cnt == 1) begin\n                    ack_o_s <= 1;\n                    rd_cnt <= 0;\n                end else begin\n                    rd_cnt <= rd_cnt + 1;\n                end\n            end else begin\n                // 16-bit mode: always ack for each read\n                ack_o_s <= 1;\n                if (rd_cnt == 3) begin\n                    rd_cnt <= 0;\n                end else begin\n                    rd_cnt <= rd_cnt + 1;\n                end\n            end\n        end else begin\n            ack_o_s <= 0;\n        end\n\n        // Handle BD release\n        last_a_cmp <= a_cmp;\n        if (a_cmp && !last_a_cmp) begin\n            free_bd_cnt <= free_bd_cnt + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 4, "code": "module sd_fifo_rx_filler (\n    input  wire         clk,\n    input  wire         rst,\n    output reg  [31:0]  m_wb_adr_o,\n    output reg          m_wb_we_o,\n    output reg  [31:0]  m_wb_dat_o,\n    output reg          m_wb_cyc_o,\n    output reg          m_wb_stb_o,\n    input  wire         m_wb_ack_i,\n    output wire [2:0]   m_wb_cti_o,\n    output wire [2:0]   m_wb_bte_o,\n    input  wire         en,\n    input  wire [31:0]  adr,\n    input  wire         sd_clk,\n    input  wire [3:0]   dat_i,\n    input  wire         wr,\n    output wire         full,\n    output wire         empty\n);\n\n    // Internal registers\n    reg [8:0]  offset;\n    reg        wb_free;\n    reg        reset_rx_fifo;\n    reg        rd;\n    \n    // FIFO signals\n    wire [31:0] dat_o;\n    wire [1:0]  mem_empt;\n    \n    // State machine\n    reg [1:0] state;\n    localparam IDLE   = 2'b00;\n    localparam READ   = 2'b01;\n    localparam WRITE  = 2'b10;\n    \n    // FIFO instance\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .mem_empt(mem_empt),\n        .rclk(clk),\n        .rst(rst | reset_rx_fifo)\n    );\n    \n    // Wishbone signals\n    assign m_wb_cti_o = 3'b000;  // Classic cycle\n    assign m_wb_bte_o = 2'b00;   // Linear burst\n    \n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all registers\n            state <= IDLE;\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            \n            // Reset Wishbone signals\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n        end else begin\n            if (!en) begin\n                // Disabled state handling\n                state <= IDLE;\n                offset <= 9'b0;\n                wb_free <= 1'b1;\n                reset_rx_fifo <= 1'b1;\n                rd <= 1'b0;\n                \n                m_wb_adr_o <= 32'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_dat_o <= 32'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n            end else begin\n                // Enabled operation\n                reset_rx_fifo <= 1'b0;\n                \n                case (state)\n                    IDLE: begin\n                        if (!empty && wb_free) begin\n                            // Prepare for read\n                            rd <= 1'b1;\n                            state <= READ;\n                        end\n                    end\n                    \n                    READ: begin\n                        // Data should be available now\n                        m_wb_adr_o <= adr + offset;\n                        m_wb_dat_o <= dat_o;\n                        m_wb_we_o <= 1'b1;\n                        m_wb_cyc_o <= 1'b1;\n                        m_wb_stb_o <= 1'b1;\n                        wb_free <= 1'b0;\n                        rd <= 1'b0;\n                        state <= WRITE;\n                    end\n                    \n                    WRITE: begin\n                        if (m_wb_ack_i) begin\n                            // Transaction complete\n                            m_wb_we_o <= 1'b0;\n                            m_wb_cyc_o <= 1'b0;\n                            m_wb_stb_o <= 1'b0;\n                            wb_free <= 1'b1;\n                            \n                            // Update address offset\n                            offset <= offset + `MEM_OFFSET;\n                            \n                            state <= IDLE;\n                        end\n                    end\n                endcase\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 6, "code": "module sd_fifo_tx_filler (\n    input         clk,\n    input         rst,\n    output [31:0] m_wb_adr_o,\n    output        m_wb_we_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    input         en,\n    input  [31:0] adr,\n    input         sd_clk,\n    output [31:0] dat_o,\n    input         rd,\n    output        empty,\n    output        fe\n);\n\n    // Internal registers\n    reg [8:0]  offset;\n    reg [8:0]  we;\n    reg [31:0] din;\n    reg        wr_tx;\n    reg        reset_tx_fifo;\n    reg        first;\n    reg        ackd;\n    reg        delay;\n\n    // Wishbone signals\n    assign m_wb_we_o = 1'b0;  // Always read operations\n    assign m_wb_cti_o = 3'b000;\n    assign m_wb_bte_o = 2'b00;\n    assign m_wb_adr_o = adr + {offset, 2'b00};  // Byte address to word address\n\n    // FIFO instance\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .rclk(sd_clk),\n        .rst(rst | reset_tx_fifo)\n    );\n\n    // Main state machine\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all registers\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b1;\n            delay <= 1'b0;\n            \n            // Reset Wishbone signals\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n        end else begin\n            // Default values\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b0;\n            delay <= 1'b0;\n            \n            if (en) begin\n                // Module enabled\n                if (~fe && ~m_wb_ack_i && ackd) begin\n                    // Start new Wishbone transaction\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    first <= 1'b0;\n                end\n                \n                if (m_wb_ack_i) begin\n                    // Wishbone acknowledge received\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                \n                if (delay) begin\n                    // Delay state for timing\n                    offset <= offset + 1'b1;\n                    ackd <= ~ackd;\n                    delay <= 1'b0;\n                end\n            end else begin\n                // Module disabled\n                offset <= 9'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                reset_tx_fifo <= 1'b1;\n                first <= 1'b1;\n                ackd <= 1'b1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 8, "code": "module sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    input wire rclk,\n    output wire full,\n    output wire empty,\n    output wire [1:0] mem_empt,\n    input wire rst\n);\n\nparameter FIFO_RX_MEM_DEPTH = 16; // Example depth, should be defined in sd_defines.v\nparameter FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH) + 1;\n\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_next = adr_i + 1;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o_next = adr_o + 1;\n\n// Full and empty flags\nassign full = (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] == adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]) && \n              (adr_i[FIFO_RX_MEM_ADR_SIZE-1] != adr_o[FIFO_RX_MEM_ADR_SIZE-1]);\nassign empty = (adr_i == adr_o);\nassign mem_empt = (adr_i[FIFO_RX_MEM_ADR_SIZE-1] == adr_o[FIFO_RX_MEM_ADR_SIZE-1]) ? \n                  (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] - adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]) : \n                  (FIFO_RX_MEM_DEPTH - adr_o[FIFO_RX_MEM_ADR_SIZE-2:0] + adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]);\n\n// Write operation (wclk domain)\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n    end else begin\n        if (wr && !full) begin\n            case (we)\n                8'h1: tmp[3:0] <= d;\n                8'h2: tmp[7:4] <= d;\n                8'h4: tmp[11:8] <= d;\n                8'h8: tmp[15:12] <= d;\n                8'h10: tmp[19:16] <= d;\n                8'h20: tmp[23:20] <= d;\n                8'h40: tmp[27:24] <= d;\n                8'h80: tmp[31:28] <= d;\n                default: tmp <= tmp;\n            endcase\n            \n            if (we == 8'h80) begin\n                ram[adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]] <= tmp;\n                adr_i <= adr_i_next;\n                we <= 8'h1;\n                ft <= 1;\n            end else begin\n                we <= we << 1;\n                ft <= 0;\n            end\n        end\n    end\nend\n\n// Read operation (rclk domain)\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else begin\n        if (rd && !empty) begin\n            q <= ram[adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]];\n            adr_o <= adr_o_next;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 7, "code": "module sd_fifo_tx_filler (\n    input               clk,\n    input               rst,\n    output reg [31:0]   m_wb_adr_o,\n    output reg          m_wb_we_o,\n    input      [31:0]   m_wb_dat_i,\n    output reg          m_wb_cyc_o,\n    output reg          m_wb_stb_o,\n    input               m_wb_ack_i,\n    output reg [2:0]    m_wb_cti_o,\n    output reg [2:0]    m_wb_bte_o,\n    input               en,\n    input      [31:0]   adr,\n    input               sd_clk,\n    output     [31:0]   dat_o,\n    input               rd,\n    output              empty,\n    output              fe\n);\n\n    // Internal registers\n    reg [8:0]  offset;\n    reg [8:0]  we;\n    reg [31:0] din;\n    reg        wr_tx;\n    reg        reset_tx_fifo;\n    reg        first;\n    reg        ackd;\n    reg        delay;\n\n    // FIFO instance\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .rclk(sd_clk),\n        .rst(rst | reset_tx_fifo)\n    );\n\n    // Wishbone transaction control\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o   <= 32'b0;\n            m_wb_we_o    <= 1'b0;\n            m_wb_cyc_o   <= 1'b0;\n            m_wb_stb_o   <= 1'b0;\n            m_wb_cti_o   <= 3'b0;\n            m_wb_bte_o   <= 2'b0;\n            offset       <= 9'b0;\n            we           <= 9'b0;\n            din          <= 32'b0;\n            wr_tx        <= 1'b0;\n            reset_tx_fifo<= 1'b1;\n            first        <= 1'b1;\n            ackd         <= 1'b1;\n            delay        <= 1'b0;\n        end else begin\n            // Default values\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b0;\n            \n            if (en) begin\n                if (first) begin\n                    // First transaction after enable\n                    m_wb_adr_o <= adr;\n                    m_wb_we_o  <= 1'b0;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_cti_o <= 3'b001; // Incrementing burst\n                    m_wb_bte_o <= 2'b00;  // Linear burst\n                    first <= 1'b0;\n                end else if (!fe && !m_wb_ack_i && ackd) begin\n                    // Start new Wishbone transaction\n                    m_wb_adr_o <= adr + {offset, 2'b00};\n                    m_wb_we_o  <= 1'b0;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                end\n                \n                if (m_wb_ack_i) begin\n                    // Wishbone transaction acknowledged\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                \n                if (delay) begin\n                    // Delay state for timing\n                    offset <= offset + 1;\n                    ackd <= ~ackd;\n                    wr_tx <= 1'b0;\n                    delay <= 1'b0;\n                end\n            end else begin\n                // Module disabled\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                m_wb_we_o  <= 1'b0;\n                offset <= 9'b0;\n                reset_tx_fifo <= 1'b1;\n                first <= 1'b1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 9, "code": "module sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    input wire rclk,\n    output wire full,\n    output wire empty,\n    output wire [1:0] mem_empt,\n    input wire rst\n);\n\nparameter FIFO_RX_MEM_DEPTH = 16; // Example value, should be defined in sd_defines.v\nparameter FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH) + 1;\n\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_next = adr_i + 1'b1;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o_next = adr_o + 1'b1;\n\n// Full and empty flags\nassign full = (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] == adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]) && \n              (adr_i[FIFO_RX_MEM_ADR_SIZE-1] != adr_o[FIFO_RX_MEM_ADR_SIZE-1]);\nassign empty = (adr_i == adr_o);\nassign mem_empt = (adr_i[FIFO_RX_MEM_ADR_SIZE-1] == adr_o[FIFO_RX_MEM_ADR_SIZE-1]) ? \n                  (FIFO_RX_MEM_DEPTH - (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] - adr_o[FIFO_RX_MEM_ADR_SIZE-2:0])) : \n                  (adr_o[FIFO_RX_MEM_ADR_SIZE-2:0] - adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]);\n\n// Write operation (wclk domain)\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n    end else begin\n        if (wr && !full) begin\n            case (we)\n                8'h1: begin\n                    tmp[3:0] <= d;\n                    we <= 8'h2;\n                end\n                8'h2: begin\n                    tmp[7:4] <= d;\n                    we <= 8'h4;\n                end\n                8'h4: begin\n                    tmp[11:8] <= d;\n                    we <= 8'h8;\n                end\n                8'h8: begin\n                    tmp[15:12] <= d;\n                    we <= 8'h10;\n                end\n                8'h10: begin\n                    tmp[19:16] <= d;\n                    we <= 8'h20;\n                end\n                8'h20: begin\n                    tmp[23:20] <= d;\n                    we <= 8'h40;\n                end\n                8'h40: begin\n                    tmp[27:24] <= d;\n                    we <= 8'h80;\n                end\n                8'h80: begin\n                    tmp[31:28] <= d;\n                    we <= 8'h1;\n                    ft <= 1;\n                end\n                default: we <= 8'h1;\n            endcase\n            \n            if (ft) begin\n                ram[adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]] <= tmp;\n                adr_i <= adr_i_next;\n                ft <= 0;\n            end\n        end\n    end\nend\n\n// Read operation (rclk domain)\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else begin\n        if (rd && !empty) begin\n            q <= ram[adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]];\n            adr_o <= adr_o_next;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 5, "code": "module sd_fifo_rx_filler (\n    input               clk,\n    input               rst,\n    output reg [31:0]   m_wb_adr_o,\n    output reg          m_wb_we_o,\n    output reg [31:0]   m_wb_dat_o,\n    output reg          m_wb_cyc_o,\n    output reg          m_wb_stb_o,\n    input               m_wb_ack_i,\n    output reg [2:0]    m_wb_cti_o,\n    output reg [2:0]    m_wb_bte_o,\n    input               en,\n    input [31:0]        adr,\n    input               sd_clk,\n    input [3:0]         dat_i,\n    input               wr,\n    output              full,\n    output              empty\n);\n\n// Parameters\nparameter MEM_OFFSET = 4;  // Address increment per word\n\n// Internal signals\nwire [31:0] dat_o;\nwire        mem_empt;\nreg         rd;\nreg         wb_free;\nreg         reset_rx_fifo;\nreg [8:0]   offset;\n\n// State machine\nreg [1:0] state;\nlocalparam IDLE     = 2'b00;\nlocalparam READ_FIFO = 2'b01;\nlocalparam WB_WRITE = 2'b10;\n\n// RX FIFO instance\nsd_rx_fifo rx_fifo (\n    .d(dat_i),\n    .wr(wr),\n    .wclk(sd_clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(full),\n    .empty(empty),\n    .mem_empt(mem_empt),\n    .rclk(clk),\n    .rst(rst | reset_rx_fifo)\n);\n\n// State machine and control logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all control signals\n        state <= IDLE;\n        m_wb_we_o <= 1'b0;\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n        m_wb_cti_o <= 3'b0;\n        m_wb_bte_o <= 2'b0;\n        m_wb_dat_o <= 32'b0;\n        m_wb_adr_o <= 32'b0;\n        rd <= 1'b0;\n        wb_free <= 1'b1;\n        reset_rx_fifo <= 1'b1;\n        offset <= 9'b0;\n    end else begin\n        if (!en) begin\n            // Disabled state\n            state <= IDLE;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            rd <= 1'b0;\n            reset_rx_fifo <= 1'b1;\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n        end else begin\n            reset_rx_fifo <= 1'b0;\n            \n            case (state)\n                IDLE: begin\n                    if (!empty && wb_free) begin\n                        // Start FIFO read\n                        rd <= 1'b1;\n                        state <= READ_FIFO;\n                    end\n                end\n                \n                READ_FIFO: begin\n                    // Wait one cycle for FIFO data to be available\n                    rd <= 1'b0;\n                    m_wb_dat_o <= dat_o;\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_we_o <= 1'b1;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_cti_o <= 3'b000;  // Classic cycle\n                    m_wb_bte_o <= 2'b00;   // Linear burst\n                    wb_free <= 1'b0;\n                    state <= WB_WRITE;\n                end\n                \n                WB_WRITE: begin\n                    if (m_wb_ack_i) begin\n                        // Transaction complete\n                        m_wb_we_o <= 1'b0;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        offset <= offset + MEM_OFFSET;\n                        wb_free <= 1'b1;\n                        state <= IDLE;\n                    end\n                end\n                \n                default: state <= IDLE;\n            endcase\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 20, "code": "module sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        CRC[0] <= inv;\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[6:1] <= CRC[5:0];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 10, "code": "module sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    output wire full,\n    output wire empty,\n    output wire [1:0] mem_empt,\n    input wire rclk,\n    input wire rst\n);\n\nparameter FIFO_RX_MEM_DEPTH = 16; // Example value, should be defined in sd_defines.v\nparameter FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH) + 1;\n\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_gray, adr_o_gray;\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_gray_sync, adr_o_gray_sync;\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_gray_sync_r, adr_o_gray_sync_r;\n\n// Binary to Gray code conversion\nfunction [FIFO_RX_MEM_ADR_SIZE-1:0] bin2gray;\n    input [FIFO_RX_MEM_ADR_SIZE-1:0] bin;\n    begin\n        bin2gray = bin ^ (bin >> 1);\n    end\nendfunction\n\n// Gray code to binary conversion\nfunction [FIFO_RX_MEM_ADR_SIZE-1:0] gray2bin;\n    input [FIFO_RX_MEM_ADR_SIZE-1:0] gray;\n    integer i;\n    begin\n        gray2bin[FIFO_RX_MEM_ADR_SIZE-1] = gray[FIFO_RX_MEM_ADR_SIZE-1];\n        for (i = FIFO_RX_MEM_ADR_SIZE-2; i >= 0; i = i-1)\n            gray2bin[i] = gray2bin[i+1] ^ gray[i];\n    end\nendfunction\n\n// Generate Gray codes\nassign adr_i_gray = bin2gray(adr_i);\nassign adr_o_gray = bin2gray(adr_o);\n\n// Synchronize Gray codes between clock domains\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_i_gray_sync <= 0;\n        adr_i_gray_sync_r <= 0;\n    end else begin\n        adr_i_gray_sync <= adr_i_gray;\n        adr_i_gray_sync_r <= adr_i_gray_sync;\n    end\nend\n\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_o_gray_sync <= 0;\n        adr_o_gray_sync_r <= 0;\n    end else begin\n        adr_o_gray_sync <= adr_o_gray;\n        adr_o_gray_sync_r <= adr_o_gray_sync;\n    end\nend\n\n// Full and empty flags\nassign full = (adr_i[FIFO_RX_MEM_ADR_SIZE-1] != adr_o_sync[FIFO_RX_MEM_ADR_SIZE-1]) &&\n              (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] == adr_o_sync[FIFO_RX_MEM_ADR_SIZE-2:0]);\n\nassign empty = (adr_i_sync == adr_o);\n\n// Memory empty space calculation\nassign mem_empt = (adr_i_sync - adr_o) >> 2; // Divide by 4 since we accumulate 4-bit words\n\n// Write pointer synchronization\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_sync = gray2bin(adr_i_gray_sync_r);\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o_sync = gray2bin(adr_o_gray_sync_r);\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n    end else if (wr) begin\n        case (we)\n            8'h1: begin\n                tmp[3:0] <= d;\n                we <= 8'h2;\n            end\n            8'h2: begin\n                tmp[7:4] <= d;\n                we <= 8'h4;\n            end\n            8'h4: begin\n                tmp[11:8] <= d;\n                we <= 8'h8;\n            end\n            8'h8: begin\n                tmp[15:12] <= d;\n                we <= 8'h10;\n            end\n            8'h10: begin\n                tmp[19:16] <= d;\n                we <= 8'h20;\n            end\n            8'h20: begin\n                tmp[23:20] <= d;\n                we <= 8'h40;\n            end\n            8'h40: begin\n                tmp[27:24] <= d;\n                we <= 8'h80;\n            end\n            8'h80: begin\n                tmp[31:28] <= d;\n                we <= 8'h1;\n                ft <= 1;\n            end\n            default: we <= 8'h1;\n        endcase\n        \n        if (ft) begin\n            ram[adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]] <= tmp;\n            adr_i <= adr_i + 1;\n            ft <= 0;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]];\n        adr_o <= adr_o + 1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 8, "code": "module sd_fifo_tx_filler (\n    input         clk,\n    input         rst,\n    output [31:0] m_wb_adr_o,\n    output        m_wb_we_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    input         en,\n    input  [31:0] adr,\n    input         sd_clk,\n    output [31:0] dat_o,\n    input         rd,\n    output        empty,\n    output        fe\n);\n\n    // Internal registers\n    reg [8:0]  offset;\n    reg [8:0]  we;\n    reg [31:0] din;\n    reg        wr_tx;\n    reg        reset_tx_fifo;\n    reg        first;\n    reg        ackd;\n    reg        delay;\n\n    // Wishbone signals\n    assign m_wb_we_o = 1'b0;  // Always read operations\n    assign m_wb_cti_o = 3'b000; // Classic cycle\n    assign m_wb_bte_o = 2'b00; // Linear burst\n\n    // FIFO signals\n    wire full;\n    wire [5:0] mem_empt;\n\n    // Instantiate the TX FIFO\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .mem_empt(mem_empt),\n        .rclk(sd_clk),\n        .rst(rst | reset_tx_fifo)\n    );\n\n    assign fe = full;\n\n    // Wishbone address output\n    assign m_wb_adr_o = adr + {offset, 2'b00}; // Word addressing\n\n    // Wishbone control signals\n    assign m_wb_cyc_o = en & ~fe & ~m_wb_ack_i & ackd;\n    assign m_wb_stb_o = en & ~fe & ~m_wb_ack_i & ackd;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all registers\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b1;\n            delay <= 1'b0;\n        end else begin\n            // Default values\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b0;\n\n            if (en) begin\n                if (m_wb_ack_i) begin\n                    // Data received from Wishbone\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    delay <= 1'b1;\n                end else if (delay) begin\n                    // Post-acknowledge processing\n                    offset <= offset + 1'b1;\n                    ackd <= ~ackd;\n                    delay <= 1'b0;\n                end\n            end else begin\n                // Module disabled\n                offset <= 9'b0;\n                reset_tx_fifo <= 1'b1;\n                ackd <= 1'b1;\n            end\n        end\n    end\n\nendmodule\n\nmodule sd_tx_fifo (\n    input  [31:0] d,\n    input         wr,\n    input         wclk,\n    output [31:0] q,\n    input         rd,\n    output        full,\n    output        empty,\n    output [5:0]  mem_empt,\n    input         rclk,\n    input         rst\n);\n    // Implementation of TX FIFO would go here\n    // This is a placeholder for the actual FIFO implementation\n    reg [31:0] mem [0:63]; // Example with 64 entries\n    reg [5:0] wptr, rptr;\n    reg [5:0] count;\n\n    assign full = (count == 6'd63);\n    assign empty = (count == 6'd0);\n    assign mem_empt = count;\n    assign q = mem[rptr[5:0]];\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            wptr <= 6'b0;\n        end else if (wr && !full) begin\n            mem[wptr[5:0]] <= d;\n            wptr <= wptr + 1'b1;\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            rptr <= 6'b0;\n        end else if (rd && !empty) begin\n            rptr <= rptr + 1'b1;\n        end\n    end\n\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            count <= 6'b0;\n        end else begin\n            case ({wr && !full, rd && !empty})\n                2'b01: count <= count - 1'b1;\n                2'b10: count <= count + 1'b1;\n                default: count <= count;\n            endcase\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 11, "code": "module sd_bd (\n    input  wire                     clk,\n    input  wire                     rst,\n    input  wire                     we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0]      free_bd,\n    input  wire                     re_s,\n    output wire                     ack_o_s,\n    input  wire                     a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\nparameter BD_WIDTH = 8;\nparameter BD_SIZE = 255;\nparameter RAM_MEM_WIDTH = 32;\nparameter RAM_MEM_WIDTH_16 = 0;\n\nreg [BD_WIDTH-1:0] free_bd_cnt;\nreg [BD_WIDTH-1:0] m_wr_pnt;\nreg [BD_WIDTH-1:0] s_rd_pnt;\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\nreg new_bw;\nreg last_a_cmp;\nreg [1:0] wr_cnt;\nreg [1:0] rd_cnt;\nreg ack_o_s_reg;\n\nassign free_bd = free_bd_cnt;\nassign ack_o_s = ack_o_s_reg;\nassign dat_out_s = bd_mem[s_rd_pnt];\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        free_bd_cnt <= (RAM_MEM_WIDTH_16) ? (BD_SIZE >> 2) : (BD_SIZE >> 1);\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        new_bw <= 0;\n        last_a_cmp <= 0;\n        wr_cnt <= 0;\n        rd_cnt <= 0;\n        ack_o_s_reg <= 0;\n    end else begin\n        last_a_cmp <= a_cmp;\n        \n        // Write operation\n        if (we_m && (free_bd_cnt > 0)) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= m_wr_pnt + 1;\n            \n            if (RAM_MEM_WIDTH_16) begin\n                wr_cnt <= wr_cnt + 1;\n                if (wr_cnt == 3) begin\n                    new_bw <= 1;\n                    free_bd_cnt <= free_bd_cnt - 1;\n                    wr_cnt <= 0;\n                end else begin\n                    new_bw <= 0;\n                end\n            end else begin\n                wr_cnt <= wr_cnt + 1;\n                if (wr_cnt == 1) begin\n                    new_bw <= 1;\n                    free_bd_cnt <= free_bd_cnt - 1;\n                    wr_cnt <= 0;\n                end else begin\n                    new_bw <= 0;\n                end\n            end\n        end else begin\n            new_bw <= 0;\n        end\n        \n        // Read operation\n        if (re_s) begin\n            s_rd_pnt <= s_rd_pnt + 1;\n            \n            if (RAM_MEM_WIDTH_16) begin\n                rd_cnt <= rd_cnt + 1;\n                ack_o_s_reg <= 1;\n                if (rd_cnt == 3) begin\n                    rd_cnt <= 0;\n                end\n            end else begin\n                rd_cnt <= rd_cnt + 1;\n                if (rd_cnt == 1) begin\n                    rd_cnt <= 0;\n                end\n            end\n        end else begin\n            ack_o_s_reg <= 0;\n        end\n        \n        // Release BD on a_cmp rising edge\n        if (a_cmp && !last_a_cmp) begin\n            free_bd_cnt <= free_bd_cnt + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input                       clk,\n    input                       rst,\n    input                       we_m,\n    input      [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0]   free_bd,\n    input                       re_s,\n    output reg                  ack_o_s,\n    input                       a_cmp,\n    output     [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Internal registers and wires\nreg [BD_WIDTH-1:0] m_wr_pnt;    // Write pointer\nreg [BD_WIDTH-1:0] s_rd_pnt;    // Read pointer\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1]; // BD memory\nreg [1:0] wr_cnt;               // Write counter\nreg [1:0] rd_cnt;               // Read counter\nreg new_bw;                     // New BD written flag\nreg last_a_cmp;                 // Last a_cmp value for edge detection\n\n// Output assignment\nassign dat_out_s = bd_mem[s_rd_pnt];\n\n// Free BD counter update\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Initialize free_bd based on mode\n        `ifdef RAM_MEM_WIDTH_16\n        free_bd <= BD_SIZE >> 2; // 16-bit mode: 1/4 of BD_SIZE\n        `else\n        free_bd <= BD_SIZE >> 1; // 32-bit mode: 1/2 of BD_SIZE\n        `endif\n    end else begin\n        // Update free_bd based on operations\n        if (new_bw && !(a_cmp && !last_a_cmp)) begin\n            free_bd <= free_bd - 1'b1;\n        end else if (!new_bw && (a_cmp && !last_a_cmp)) begin\n            free_bd <= free_bd + 1'b1;\n        end\n    end\nend\n\n// Write operation\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= {BD_WIDTH{1'b0}};\n        wr_cnt <= 2'b00;\n        new_bw <= 1'b0;\n    end else begin\n        new_bw <= 1'b0;\n        if (we_m && (free_bd > 0)) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= m_wr_pnt + 1'b1;\n            `ifdef RAM_MEM_WIDTH_16\n            // 16-bit mode: 4 writes per BD\n            if (wr_cnt == 2'b11) begin\n                wr_cnt <= 2'b00;\n                new_bw <= 1'b1;\n            end else begin\n                wr_cnt <= wr_cnt + 1'b1;\n            end\n            `else\n            // 32-bit mode: 2 writes per BD\n            if (wr_cnt == 2'b01) begin\n                wr_cnt <= 2'b00;\n                new_bw <= 1'b1;\n            end else begin\n                wr_cnt <= wr_cnt + 1'b1;\n            end\n            `endif\n        end\n    end\nend\n\n// Read operation\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        s_rd_pnt <= {BD_WIDTH{1'b0}};\n        rd_cnt <= 2'b00;\n        ack_o_s <= 1'b0;\n    end else begin\n        ack_o_s <= 1'b0;\n        if (re_s) begin\n            s_rd_pnt <= s_rd_pnt + 1'b1;\n            `ifdef RAM_MEM_WIDTH_16\n            // 16-bit mode: 4 reads per BD\n            if (rd_cnt == 2'b11) begin\n                rd_cnt <= 2'b00;\n            end else begin\n                rd_cnt <= rd_cnt + 1'b1;\n            end\n            ack_o_s <= 1'b1;\n            `else\n            // 32-bit mode: 2 reads per BD\n            if (rd_cnt == 2'b01) begin\n                rd_cnt <= 2'b00;\n            end else begin\n                rd_cnt <= rd_cnt + 1'b1;\n            end\n            `endif\n        end\n    end\nend\n\n// a_cmp edge detection\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        last_a_cmp <= 1'b0;\n    end else begin\n        last_a_cmp <= a_cmp;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 6, "code": "module sd_fifo_rx_filler (\n    input  wire         clk,\n    input  wire         rst,\n    output reg  [31:0]  m_wb_adr_o,\n    output reg          m_wb_we_o,\n    output reg  [31:0]  m_wb_dat_o,\n    output reg          m_wb_cyc_o,\n    output reg          m_wb_stb_o,\n    input  wire         m_wb_ack_i,\n    output wire [2:0]   m_wb_cti_o,\n    output wire [2:0]   m_wb_bte_o,\n    input  wire         en,\n    input  wire [31:0]  adr,\n    input  wire         sd_clk,\n    input  wire [3:0]   dat_i,\n    input  wire         wr,\n    output wire         full,\n    output wire         empty\n);\n\n// Local parameters\nlocalparam [1:0] IDLE = 2'b00;\nlocalparam [1:0] READ_FIFO = 2'b01;\nlocalparam [1:0] WB_WRITE = 2'b10;\n\n// Internal registers\nreg [1:0] state;\nreg [1:0] next_state;\nreg [8:0] offset;\nreg       wb_free;\nreg       reset_rx_fifo;\nreg       rd;\n\n// FIFO signals\nwire [31:0] dat_o;\nwire [1:0]  mem_empt;\n\n// Wishbone signals\nassign m_wb_cti_o = 3'b000;  // Classic cycle\nassign m_wb_bte_o = 2'b00;   // Linear burst\n\n// FIFO instance\nsd_rx_fifo rx_fifo (\n    .d(dat_i),\n    .wr(wr),\n    .wclk(sd_clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(full),\n    .empty(empty),\n    .mem_empt(mem_empt),\n    .rclk(clk),\n    .rst(rst | reset_rx_fifo)\n);\n\n// State machine\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (en && !empty && wb_free) begin\n                next_state = READ_FIFO;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        READ_FIFO: begin\n            next_state = WB_WRITE;\n        end\n        WB_WRITE: begin\n            if (m_wb_ack_i) begin\n                next_state = IDLE;\n            end else begin\n                next_state = WB_WRITE;\n            end\n        end\n        default: begin\n            next_state = IDLE;\n        end\n    endcase\nend\n\n// Output logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wb_adr_o <= 32'h0;\n        m_wb_dat_o <= 32'h0;\n        m_wb_we_o <= 1'b0;\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n        offset <= 9'h0;\n        wb_free <= 1'b1;\n        reset_rx_fifo <= 1'b1;\n        rd <= 1'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                rd <= 1'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                \n                if (!en) begin\n                    reset_rx_fifo <= 1'b1;\n                    offset <= 9'h0;\n                    wb_free <= 1'b1;\n                end else begin\n                    reset_rx_fifo <= 1'b0;\n                end\n            end\n            READ_FIFO: begin\n                rd <= 1'b1;\n                m_wb_dat_o <= dat_o;\n                m_wb_adr_o <= adr + offset;\n                wb_free <= 1'b0;\n            end\n            WB_WRITE: begin\n                rd <= 1'b0;\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                \n                if (m_wb_ack_i) begin\n                    offset <= offset + `MEM_OFFSET;\n                    wb_free <= 1'b1;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 2, "code": "module sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    input wire rclk,\n    output wire full,\n    output wire empty,\n    output wire [5:0] mem_empt,\n    input wire rst\n);\n\nparameter FIFO_TX_MEM_DEPTH = 64; // Example depth, should match sd_defines.v\nparameter FIFO_TX_MEM_ADR_SIZE = 7; // log2(FIFO_TX_MEM_DEPTH)+1\n\nreg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray, adr_o_gray;\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray_sync, adr_o_gray_sync;\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_sync, adr_o_sync;\n\n// Write pointer management\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        adr_i_gray <= 0;\n    end else if (wr && !full) begin\n        ram[adr_i[FIFO_TX_MEM_ADR_SIZE-2:0]] <= d;\n        adr_i <= adr_i + 1;\n        adr_i_gray <= (adr_i + 1) ^ ((adr_i + 1) >> 1);\n    end\nend\n\n// Read pointer management\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        adr_o_gray <= 0;\n        q <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o[FIFO_TX_MEM_ADR_SIZE-2:0]];\n        adr_o <= adr_o + 1;\n        adr_o_gray <= (adr_o + 1) ^ ((adr_o + 1) >> 1);\n    end\nend\n\n// Synchronize write pointer to read clock domain\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_i_gray_sync <= 0;\n        adr_i_sync <= 0;\n    end else begin\n        adr_i_gray_sync <= adr_i_gray;\n        // Convert gray code back to binary\n        adr_i_sync[FIFO_TX_MEM_ADR_SIZE-1] = adr_i_gray_sync[FIFO_TX_MEM_ADR_SIZE-1];\n        for (integer i = FIFO_TX_MEM_ADR_SIZE-2; i >= 0; i = i-1)\n            adr_i_sync[i] = adr_i_sync[i+1] ^ adr_i_gray_sync[i];\n    end\nend\n\n// Synchronize read pointer to write clock domain\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_o_gray_sync <= 0;\n        adr_o_sync <= 0;\n    end else begin\n        adr_o_gray_sync <= adr_o_gray;\n        // Convert gray code back to binary\n        adr_o_sync[FIFO_TX_MEM_ADR_SIZE-1] = adr_o_gray_sync[FIFO_TX_MEM_ADR_SIZE-1];\n        for (integer i = FIFO_TX_MEM_ADR_SIZE-2; i >= 0; i = i-1)\n            adr_o_sync[i] = adr_o_sync[i+1] ^ adr_o_gray_sync[i];\n    end\nend\n\n// Generate FIFO status flags\nassign empty = (adr_i_sync == adr_o);\nassign full = ((adr_i[FIFO_TX_MEM_ADR_SIZE-1] != adr_o_sync[FIFO_TX_MEM_ADR_SIZE-1]) && \n              (adr_i[FIFO_TX_MEM_ADR_SIZE-2:0] == adr_o_sync[FIFO_TX_MEM_ADR_SIZE-2:0]));\n\n// Calculate FIFO occupancy (mem_empt)\nassign mem_empt = (adr_i_sync - adr_o) & {FIFO_TX_MEM_ADR_SIZE{1'b1}};\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 3, "code": "module sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt,\n    input wire rclk,\n    input wire rst\n);\n\n// Memory array\nreg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n\n// Pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;  // Write pointer\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;  // Read pointer\n\n// Gray code pointers for clock domain crossing\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray;\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_gray;\n\n// Synchronized pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray_sync1, adr_i_gray_sync2;\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_gray_sync1, adr_o_gray_sync2;\n\n// Binary pointers after synchronization\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_sync;\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_sync;\n\n// Convert binary to gray code\nfunction [FIFO_TX_MEM_ADR_SIZE-1:0] bin2gray;\n    input [FIFO_TX_MEM_ADR_SIZE-1:0] bin;\n    begin\n        bin2gray = bin ^ (bin >> 1);\n    end\nendfunction\n\n// Convert gray code to binary\nfunction [FIFO_TX_MEM_ADR_SIZE-1:0] gray2bin;\n    input [FIFO_TX_MEM_ADR_SIZE-1:0] gray;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] bin;\n    integer i;\n    begin\n        bin[FIFO_TX_MEM_ADR_SIZE-1] = gray[FIFO_TX_MEM_ADR_SIZE-1];\n        for (i = FIFO_TX_MEM_ADR_SIZE-2; i >= 0; i = i - 1)\n            bin[i] = bin[i+1] ^ gray[i];\n        gray2bin = bin;\n    end\nendfunction\n\n// Write clock domain logic\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        adr_i_gray <= 0;\n    end else begin\n        if (wr && !full) begin\n            ram[adr_i[FIFO_TX_MEM_ADR_SIZE-2:0]] <= d;\n            adr_i <= adr_i + 1;\n            adr_i_gray <= bin2gray(adr_i + 1);\n        end\n    end\nend\n\n// Read clock domain logic\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        adr_o_gray <= 0;\n        q <= 0;\n    end else begin\n        if (rd && !empty) begin\n            q <= ram[adr_o[FIFO_TX_MEM_ADR_SIZE-2:0]];\n            adr_o <= adr_o + 1;\n            adr_o_gray <= bin2gray(adr_o + 1);\n        end\n    end\nend\n\n// Synchronize write pointer to read clock domain\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_i_gray_sync1 <= 0;\n        adr_i_gray_sync2 <= 0;\n        adr_i_sync <= 0;\n    end else begin\n        adr_i_gray_sync1 <= adr_i_gray;\n        adr_i_gray_sync2 <= adr_i_gray_sync1;\n        adr_i_sync <= gray2bin(adr_i_gray_sync2);\n    end\nend\n\n// Synchronize read pointer to write clock domain\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_o_gray_sync1 <= 0;\n        adr_o_gray_sync2 <= 0;\n        adr_o_sync <= 0;\n    end else begin\n        adr_o_gray_sync1 <= adr_o_gray;\n        adr_o_gray_sync2 <= adr_o_gray_sync1;\n        adr_o_sync <= gray2bin(adr_o_gray_sync2);\n    end\nend\n\n// Generate full and empty flags\nalways @(*) begin\n    // Full flag (write clock domain)\n    full = (adr_i[FIFO_TX_MEM_ADR_SIZE-2:0] == adr_o_sync[FIFO_TX_MEM_ADR_SIZE-2:0]) &&\n           (adr_i[FIFO_TX_MEM_ADR_SIZE-1] != adr_o_sync[FIFO_TX_MEM_ADR_SIZE-1]);\n    \n    // Empty flag (read clock domain)\n    empty = (adr_i_sync == adr_o);\n    \n    // FIFO occupancy (read clock domain)\n    mem_empt = (adr_i_sync - adr_o) & {FIFO_TX_MEM_ADR_SIZE{1'b1}};\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 4, "code": "module sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    input wire rclk,\n    output wire full,\n    output wire empty,\n    output wire [5:0] mem_empt,\n    input wire rst\n);\n\nparameter FIFO_TX_MEM_DEPTH = 32; // Example value, should come from sd_defines.v\nparameter FIFO_TX_MEM_ADR_SIZE = 6; // log2(FIFO_TX_MEM_DEPTH)+1\n\nreg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray, adr_o_gray;\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray_sync, adr_o_gray_sync;\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_sync, adr_o_sync;\n\n// Write pointer management (wclk domain)\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        adr_i_gray <= 0;\n    end else if (wr && !full) begin\n        ram[adr_i[FIFO_TX_MEM_ADR_SIZE-2:0]] <= d;\n        adr_i <= adr_i + 1;\n        adr_i_gray <= (adr_i + 1) ^ ((adr_i + 1) >> 1);\n    end\nend\n\n// Read pointer management (rclk domain)\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        adr_o_gray <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o[FIFO_TX_MEM_ADR_SIZE-2:0]];\n        adr_o <= adr_o + 1;\n        adr_o_gray <= (adr_o + 1) ^ ((adr_o + 1) >> 1);\n    end\nend\n\n// Synchronize read pointer to write clock domain\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_o_gray_sync <= 0;\n        adr_o_sync <= 0;\n    end else begin\n        adr_o_gray_sync <= adr_o_gray;\n        // Convert gray code back to binary\n        adr_o_sync[FIFO_TX_MEM_ADR_SIZE-1] = adr_o_gray_sync[FIFO_TX_MEM_ADR_SIZE-1];\n        for (integer i = FIFO_TX_MEM_ADR_SIZE-2; i >= 0; i = i-1)\n            adr_o_sync[i] = adr_o_sync[i+1] ^ adr_o_gray_sync[i];\n    end\nend\n\n// Synchronize write pointer to read clock domain\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_i_gray_sync <= 0;\n        adr_i_sync <= 0;\n    end else begin\n        adr_i_gray_sync <= adr_i_gray;\n        // Convert gray code back to binary\n        adr_i_sync[FIFO_TX_MEM_ADR_SIZE-1] = adr_i_gray_sync[FIFO_TX_MEM_ADR_SIZE-1];\n        for (integer i = FIFO_TX_MEM_ADR_SIZE-2; i >= 0; i = i-1)\n            adr_i_sync[i] = adr_i_sync[i+1] ^ adr_i_gray_sync[i];\n    end\nend\n\n// Full and empty generation\nassign full = (adr_i[FIFO_TX_MEM_ADR_SIZE-2:0] == adr_o_sync[FIFO_TX_MEM_ADR_SIZE-2:0]) && \n              (adr_i[FIFO_TX_MEM_ADR_SIZE-1] != adr_o_sync[FIFO_TX_MEM_ADR_SIZE-1]);\n\nassign empty = (adr_i_sync == adr_o);\n\n// FIFO occupancy calculation\nassign mem_empt = adr_i - adr_o_sync;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 11, "code": "module sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    input wire rclk,\n    output wire full,\n    output wire empty,\n    output wire [1:0] mem_empt,\n    input wire rst\n);\n\nparameter FIFO_RX_MEM_DEPTH = 16; // Example value, should be defined in sd_defines.v\nparameter FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH) + 1;\n\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_next = adr_i + 1;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o_next = adr_o + 1;\n\n// Full and empty flags\nassign full = (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] == adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]) && \n              (adr_i[FIFO_RX_MEM_ADR_SIZE-1] != adr_o[FIFO_RX_MEM_ADR_SIZE-1]);\nassign empty = (adr_i == adr_o);\nassign mem_empt = (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) >> 5; // Approximate empty space\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        we <= 8'h1;\n        tmp <= 32'h0;\n        ft <= 1'b0;\n    end else if (wr && !full) begin\n        case (we)\n            8'h1: begin tmp[3:0] <= d; we <= 8'h2; end\n            8'h2: begin tmp[7:4] <= d; we <= 8'h4; end\n            8'h4: begin tmp[11:8] <= d; we <= 8'h8; end\n            8'h8: begin tmp[15:12] <= d; we <= 8'h10; end\n            8'h10: begin tmp[19:16] <= d; we <= 8'h20; end\n            8'h20: begin tmp[23:20] <= d; we <= 8'h40; end\n            8'h40: begin tmp[27:24] <= d; we <= 8'h80; end\n            8'h80: begin \n                tmp[31:28] <= d; \n                ram[adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]] <= tmp;\n                adr_i <= adr_i_next;\n                we <= 8'h1;\n                ft <= 1'b1;\n            end\n            default: we <= 8'h1;\n        endcase\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 32'h0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]];\n        adr_o <= adr_o_next;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 5, "code": "module sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    input wire rclk,\n    output wire full,\n    output wire empty,\n    output wire [5:0] mem_empt,\n    input wire rst\n);\n\n    // Memory array\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    \n    // Write pointer and synchronized read pointer\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray_rclk1;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray_rclk2;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_rclk;\n    \n    // Read pointer and synchronized write pointer\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_gray_wclk1;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_gray_wclk2;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_wclk;\n    \n    // Convert binary to gray code\n    function [FIFO_TX_MEM_ADR_SIZE-1:0] bin2gray;\n        input [FIFO_TX_MEM_ADR_SIZE-1:0] bin;\n        begin\n            bin2gray = bin ^ (bin >> 1);\n        end\n    endfunction\n    \n    // Convert gray code to binary\n    function [FIFO_TX_MEM_ADR_SIZE-1:0] gray2bin;\n        input [FIFO_TX_MEM_ADR_SIZE-1:0] gray;\n        integer i;\n        begin\n            gray2bin[FIFO_TX_MEM_ADR_SIZE-1] = gray[FIFO_TX_MEM_ADR_SIZE-1];\n            for (i = FIFO_TX_MEM_ADR_SIZE-2; i >= 0; i = i-1)\n                gray2bin[i] = gray2bin[i+1] ^ gray[i];\n        end\n    endfunction\n    \n    // Write clock domain logic\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            adr_i_gray <= 0;\n        end else begin\n            if (wr && !full) begin\n                ram[adr_i[FIFO_TX_MEM_ADR_SIZE-2:0]] <= d;\n                adr_i <= adr_i + 1;\n                adr_i_gray <= bin2gray(adr_i + 1);\n            end\n        end\n    end\n    \n    // Synchronize read pointer to write clock domain\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_o_gray_wclk1 <= 0;\n            adr_o_gray_wclk2 <= 0;\n            adr_o_wclk <= 0;\n        end else begin\n            adr_o_gray_wclk1 <= adr_o_gray;\n            adr_o_gray_wclk2 <= adr_o_gray_wclk1;\n            adr_o_wclk <= gray2bin(adr_o_gray_wclk2);\n        end\n    end\n    \n    // Read clock domain logic\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            adr_o_gray <= 0;\n            q <= 0;\n        end else begin\n            if (rd && !empty) begin\n                q <= ram[adr_o[FIFO_TX_MEM_ADR_SIZE-2:0]];\n                adr_o <= adr_o + 1;\n                adr_o_gray <= bin2gray(adr_o + 1);\n            end\n        end\n    end\n    \n    // Synchronize write pointer to read clock domain\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_i_gray_rclk1 <= 0;\n            adr_i_gray_rclk2 <= 0;\n            adr_i_rclk <= 0;\n        end else begin\n            adr_i_gray_rclk1 <= adr_i_gray;\n            adr_i_gray_rclk2 <= adr_i_gray_rclk1;\n            adr_i_rclk <= gray2bin(adr_i_gray_rclk2);\n        end\n    end\n    \n    // Generate FIFO status signals\n    assign empty = (adr_i_rclk == adr_o);\n    assign full = ((adr_i[FIFO_TX_MEM_ADR_SIZE-1] != adr_o_wclk[FIFO_TX_MEM_ADR_SIZE-1]) && \n                  (adr_i[FIFO_TX_MEM_ADR_SIZE-2:0] == adr_o_wclk[FIFO_TX_MEM_ADR_SIZE-2:0]));\n    \n    // Calculate FIFO occupancy (mem_empt)\n    assign mem_empt = (adr_i_rclk - adr_o) & 6'h3F;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 9, "code": "module sd_fifo_tx_filler (\n    input         clk,\n    input         rst,\n    output [31:0] m_wb_adr_o,\n    output        m_wb_we_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    input         en,\n    input  [31:0] adr,\n    input         sd_clk,\n    output [31:0] dat_o,\n    input         rd,\n    output        empty,\n    output        fe\n);\n\n    // Internal registers\n    reg [8:0]  offset;\n    reg [8:0]  we;\n    reg [31:0] din;\n    reg        wr_tx;\n    reg        reset_tx_fifo;\n    reg        first;\n    reg        ackd;\n    reg        delay;\n\n    // Wishbone outputs\n    assign m_wb_we_o = 1'b0;  // Always read\n    assign m_wb_cti_o = 3'b000;\n    assign m_wb_bte_o = 2'b00;\n    assign m_wb_adr_o = adr + {offset, 2'b00};  // Word addressing\n\n    // FIFO instance\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .rclk(sd_clk),\n        .rst(rst | reset_tx_fifo)\n    );\n\n    // Main state machine\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all registers\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b1;\n            delay <= 1'b0;\n            \n            // Reset Wishbone signals\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n        end else begin\n            // Default values\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b0;\n            delay <= 1'b0;\n            \n            if (en) begin\n                // Module is enabled\n                if (~fe && ackd && ~m_wb_ack_i) begin\n                    // Start new Wishbone transaction\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    first <= 1'b0;\n                end\n                \n                if (m_wb_ack_i) begin\n                    // Wishbone transaction acknowledged\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                \n                if (delay) begin\n                    // Post-acknowledge processing\n                    offset <= offset + 1'b1;\n                    ackd <= ~ackd;\n                    delay <= 1'b0;\n                end\n            end else begin\n                // Module is disabled\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                offset <= 9'b0;\n                reset_tx_fifo <= 1'b1;\n                first <= 1'b1;\n                ackd <= 1'b1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 6, "code": "module sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    input wire rclk,\n    output wire full,\n    output wire empty,\n    output wire [5:0] mem_empt,\n    input wire rst\n);\n\n    // Memory array\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    \n    // Pointers\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    \n    // Gray code pointers for clock domain crossing\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray, adr_o_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray_sync, adr_o_gray_sync;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray_sync_r, adr_o_gray_sync_r;\n    \n    // Status signals\n    reg full_reg, empty_reg;\n    reg [5:0] mem_empt_reg;\n    \n    // Binary to Gray conversion\n    function [FIFO_TX_MEM_ADR_SIZE-1:0] bin2gray;\n        input [FIFO_TX_MEM_ADR_SIZE-1:0] bin;\n        begin\n            bin2gray = bin ^ (bin >> 1);\n        end\n    endfunction\n    \n    // Gray to Binary conversion\n    function [FIFO_TX_MEM_ADR_SIZE-1:0] gray2bin;\n        input [FIFO_TX_MEM_ADR_SIZE-1:0] gray;\n        reg [FIFO_TX_MEM_ADR_SIZE-1:0] bin;\n        integer i;\n        begin\n            bin[FIFO_TX_MEM_ADR_SIZE-1] = gray[FIFO_TX_MEM_ADR_SIZE-1];\n            for (i = FIFO_TX_MEM_ADR_SIZE-2; i >= 0; i = i-1)\n                bin[i] = bin[i+1] ^ gray[i];\n            gray2bin = bin;\n        end\n    endfunction\n    \n    // Write clock domain logic\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            adr_i_gray <= 0;\n        end else begin\n            if (wr && !full) begin\n                ram[adr_i[FIFO_TX_MEM_ADR_SIZE-2:0]] <= d;\n                adr_i <= adr_i + 1;\n                adr_i_gray <= bin2gray(adr_i + 1);\n            end\n        end\n    end\n    \n    // Read clock domain logic\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            adr_o_gray <= 0;\n            q <= 0;\n        end else begin\n            if (rd && !empty) begin\n                q <= ram[adr_o[FIFO_TX_MEM_ADR_SIZE-2:0]];\n                adr_o <= adr_o + 1;\n                adr_o_gray <= bin2gray(adr_o + 1);\n            end\n        end\n    end\n    \n    // Synchronize write pointer to read clock domain\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_i_gray_sync <= 0;\n            adr_i_gray_sync_r <= 0;\n        end else begin\n            adr_i_gray_sync <= adr_i_gray;\n            adr_i_gray_sync_r <= adr_i_gray_sync;\n        end\n    end\n    \n    // Synchronize read pointer to write clock domain\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_o_gray_sync <= 0;\n            adr_o_gray_sync_r <= 0;\n        end else begin\n            adr_o_gray_sync <= adr_o_gray;\n            adr_o_gray_sync_r <= adr_o_gray_sync;\n        end\n    end\n    \n    // Generate full signal in write clock domain\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            full_reg <= 0;\n        end else begin\n            full_reg <= ((adr_i[FIFO_TX_MEM_ADR_SIZE-2:0] == gray2bin(adr_o_gray_sync_r)[FIFO_TX_MEM_ADR_SIZE-2:0]) &&\n                        (adr_i[FIFO_TX_MEM_ADR_SIZE-1] != gray2bin(adr_o_gray_sync_r)[FIFO_TX_MEM_ADR_SIZE-1]));\n        end\n    end\n    \n    // Generate empty signal in read clock domain\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            empty_reg <= 1;\n        end else begin\n            empty_reg <= (gray2bin(adr_i_gray_sync_r) == adr_o);\n        end\n    end\n    \n    // Calculate memory occupancy\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            mem_empt_reg <= 0;\n        end else begin\n            mem_empt_reg <= gray2bin(adr_i_gray_sync_r) - adr_o;\n        end\n    end\n    \n    assign full = full_reg;\n    assign empty = empty_reg;\n    assign mem_empt = mem_empt_reg[5:0];\n    \nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 13, "code": "module sd_bd (\n    input  wire                     clk,\n    input  wire                     rst,\n    input  wire                     we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0]      free_bd,\n    input  wire                     re_s,\n    output wire                     ack_o_s,\n    input  wire                     a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\nparameter BD_WIDTH = 8;\nparameter RAM_MEM_WIDTH = 32;\nparameter BD_SIZE = 256;\n\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\nreg [BD_WIDTH-1:0]      m_wr_pnt;\nreg [BD_WIDTH-1:0]      s_rd_pnt;\nreg [BD_WIDTH-1:0]      free_bd_cnt;\nreg [1:0]               wr_cnt;\nreg [1:0]               rd_cnt;\nreg                     new_bw;\nreg                     last_a_cmp;\nreg                     ack_o_s_reg;\n\nwire [RAM_MEM_WIDTH-1:0] full_bd;\nreg  [RAM_MEM_WIDTH-1:0] dat_out_s_reg;\n\nassign free_bd = free_bd_cnt;\nassign ack_o_s = ack_o_s_reg;\nassign dat_out_s = dat_out_s_reg;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        free_bd_cnt <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n        wr_cnt <= 0;\n        rd_cnt <= 0;\n        new_bw <= 0;\n        last_a_cmp <= 0;\n        ack_o_s_reg <= 0;\n        dat_out_s_reg <= 0;\n    end else begin\n        // Handle a_cmp signal for releasing BD\n        last_a_cmp <= a_cmp;\n        if (a_cmp && !last_a_cmp) begin\n            free_bd_cnt <= free_bd_cnt + 1;\n        end\n\n        // Write BD operation\n        if (we_m && (free_bd_cnt > 0)) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= m_wr_pnt + 1;\n            \n            if (RAM_MEM_WIDTH == 32) begin\n                if (wr_cnt == 1) begin\n                    new_bw <= 1;\n                    free_bd_cnt <= free_bd_cnt - 1;\n                    wr_cnt <= 0;\n                end else begin\n                    wr_cnt <= wr_cnt + 1;\n                    new_bw <= 0;\n                end\n            end else begin // 16-bit mode\n                if (wr_cnt == 3) begin\n                    new_bw <= 1;\n                    free_bd_cnt <= free_bd_cnt - 1;\n                    wr_cnt <= 0;\n                end else begin\n                    wr_cnt <= wr_cnt + 1;\n                    new_bw <= 0;\n                end\n            end\n        end else begin\n            new_bw <= 0;\n        end\n\n        // Read BD operation\n        if (re_s) begin\n            dat_out_s_reg <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= s_rd_pnt + 1;\n            \n            if (RAM_MEM_WIDTH == 32) begin\n                if (rd_cnt == 1) begin\n                    ack_o_s_reg <= 1;\n                    rd_cnt <= 0;\n                end else begin\n                    rd_cnt <= rd_cnt + 1;\n                    ack_o_s_reg <= 0;\n                end\n            end else begin // 16-bit mode\n                ack_o_s_reg <= 1;\n                if (rd_cnt == 3) begin\n                    rd_cnt <= 0;\n                end else begin\n                    rd_cnt <= rd_cnt + 1;\n                end\n            end\n        end else begin\n            ack_o_s_reg <= 0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 7, "code": "module sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    input wire rclk,\n    output wire full,\n    output wire empty,\n    output wire [5:0] mem_empt,\n    input wire rst\n);\n\n// Memory declaration\nreg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n\n// Pointers\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Gray code pointers for clock domain crossing\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_gray, adr_o_gray;\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_gray_sync, adr_o_gray_sync;\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_gray_sync_r, adr_o_gray_sync_r;\n\n// Full and empty flags\nreg full_int, empty_int;\n\n// Convert binary to gray code\nfunction [FIFO_RX_MEM_ADR_SIZE-1:0] bin2gray;\n    input [FIFO_RX_MEM_ADR_SIZE-1:0] bin;\n    begin\n        bin2gray = bin ^ (bin >> 1);\n    end\nendfunction\n\n// Convert gray code to binary\nfunction [FIFO_RX_MEM_ADR_SIZE-1:0] gray2bin;\n    input [FIFO_RX_MEM_ADR_SIZE-1:0] gray;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] bin;\n    integer i;\n    begin\n        bin[FIFO_RX_MEM_ADR_SIZE-1] = gray[FIFO_RX_MEM_ADR_SIZE-1];\n        for (i = FIFO_RX_MEM_ADR_SIZE-2; i >= 0; i = i-1)\n            bin[i] = bin[i+1] ^ gray[i];\n        gray2bin = bin;\n    end\nendfunction\n\n// Write pointer management (write clock domain)\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        adr_i_gray <= 0;\n    end else if (wr && !full_int) begin\n        ram[adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]] <= d;\n        adr_i <= adr_i + 1;\n        adr_i_gray <= bin2gray(adr_i + 1);\n    end\nend\n\n// Read pointer management (read clock domain)\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        adr_o_gray <= 0;\n        q <= 0;\n    end else begin\n        if (rd && !empty_int) begin\n            q <= ram[adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]];\n            adr_o <= adr_o + 1;\n            adr_o_gray <= bin2gray(adr_o + 1);\n        end\n    end\nend\n\n// Synchronize write pointer to read clock domain\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_i_gray_sync <= 0;\n        adr_i_gray_sync_r <= 0;\n    end else begin\n        adr_i_gray_sync <= adr_i_gray;\n        adr_i_gray_sync_r <= adr_i_gray_sync;\n    end\nend\n\n// Synchronize read pointer to write clock domain\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_o_gray_sync <= 0;\n        adr_o_gray_sync_r <= 0;\n    end else begin\n        adr_o_gray_sync <= adr_o_gray;\n        adr_o_gray_sync_r <= adr_o_gray_sync;\n    end\nend\n\n// Full flag generation (write clock domain)\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        full_int <= 0;\n    end else begin\n        full_int <= ((bin2gray(adr_i + 1) == adr_o_gray_sync_r) ||\n                    ((adr_i[FIFO_RX_MEM_ADR_SIZE-1] != adr_o_gray_sync_r[FIFO_RX_MEM_ADR_SIZE-1]) &&\n                     (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] == adr_o_gray_sync_r[FIFO_RX_MEM_ADR_SIZE-2:0])));\n    end\nend\n\n// Empty flag generation (read clock domain)\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        empty_int <= 1;\n    end else begin\n        empty_int <= (adr_o_gray == adr_i_gray_sync_r);\n    end\nend\n\n// FIFO occupancy calculation (read clock domain)\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_bin_sync;\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_i_bin_sync <= 0;\n    end else begin\n        adr_i_bin_sync <= gray2bin(adr_i_gray_sync_r);\n    end\nend\n\nassign mem_empt = (adr_i_bin_sync - adr_o) & {FIFO_RX_MEM_ADR_SIZE{1'b1}};\nassign full = full_int;\nassign empty = empty_int;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 8, "code": "module sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    input wire rclk,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt,\n    input wire rst\n);\n\n// Memory array\nreg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n\n// Pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i; // Write pointer\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o; // Read pointer\n\n// Gray code pointers for clock domain crossing\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray;\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_gray;\n\n// Synchronized gray pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray_sync;\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_gray_sync;\n\n// Binary pointers from synchronized gray codes\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_sync;\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_sync;\n\n// Convert binary to gray code\nfunction [FIFO_TX_MEM_ADR_SIZE-1:0] bin2gray;\n    input [FIFO_TX_MEM_ADR_SIZE-1:0] bin;\n    begin\n        bin2gray = bin ^ (bin >> 1);\n    end\nendfunction\n\n// Convert gray code to binary\nfunction [FIFO_TX_MEM_ADR_SIZE-1:0] gray2bin;\n    input [FIFO_TX_MEM_ADR_SIZE-1:0] gray;\n    integer i;\n    begin\n        gray2bin[FIFO_TX_MEM_ADR_SIZE-1] = gray[FIFO_TX_MEM_ADR_SIZE-1];\n        for (i = FIFO_TX_MEM_ADR_SIZE-2; i >= 0; i = i-1)\n            gray2bin[i] = gray2bin[i+1] ^ gray[i];\n    end\nendfunction\n\n// Write clock domain logic\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        adr_i_gray <= 0;\n    end else begin\n        if (wr && !full) begin\n            ram[adr_i[FIFO_TX_MEM_ADR_SIZE-2:0]] <= d;\n            adr_i <= adr_i + 1;\n            adr_i_gray <= bin2gray(adr_i + 1);\n        end\n    end\nend\n\n// Read clock domain logic\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        adr_o_gray <= 0;\n        q <= 0;\n    end else begin\n        if (rd && !empty) begin\n            q <= ram[adr_o[FIFO_TX_MEM_ADR_SIZE-2:0]];\n            adr_o <= adr_o + 1;\n            adr_o_gray <= bin2gray(adr_o + 1);\n        end\n    end\nend\n\n// Synchronize write pointer to read clock domain\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_i_gray_sync <= 0;\n        adr_i_sync <= 0;\n    end else begin\n        adr_i_gray_sync <= adr_i_gray;\n        adr_i_sync <= gray2bin(adr_i_gray_sync);\n    end\nend\n\n// Synchronize read pointer to write clock domain\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_o_gray_sync <= 0;\n        adr_o_sync <= 0;\n    end else begin\n        adr_o_gray_sync <= adr_o_gray;\n        adr_o_sync <= gray2bin(adr_o_gray_sync);\n    end\nend\n\n// Generate empty flag in read clock domain\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        empty <= 1'b1;\n    end else begin\n        empty <= (adr_o_gray == adr_i_gray_sync);\n    end\nend\n\n// Generate full flag in write clock domain\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        full <= 1'b0;\n    end else begin\n        full <= ((adr_i[FIFO_TX_MEM_ADR_SIZE-2:0] == adr_o_sync[FIFO_TX_MEM_ADR_SIZE-2:0]) &&\n                (adr_i[FIFO_TX_MEM_ADR_SIZE-1] != adr_o_sync[FIFO_TX_MEM_ADR_SIZE-1]));\n    end\nend\n\n// Calculate memory occupancy (mem_empt)\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        mem_empt <= 0;\n    end else begin\n        if (adr_i_sync >= adr_o) begin\n            mem_empt <= adr_i_sync - adr_o;\n        end else begin\n            mem_empt <= (FIFO_TX_MEM_DEPTH - adr_o) + adr_i_sync;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 7, "code": "module sd_fifo_rx_filler (\n    input  wire         clk,\n    input  wire         rst,\n    output reg  [31:0]  m_wb_adr_o,\n    output reg          m_wb_we_o,\n    output reg  [31:0]  m_wb_dat_o,\n    output reg          m_wb_cyc_o,\n    output reg          m_wb_stb_o,\n    input  wire         m_wb_ack_i,\n    output wire [2:0]   m_wb_cti_o,\n    output wire [2:0]   m_wb_bte_o,\n    input  wire         en,\n    input  wire [31:0]  adr,\n    input  wire         sd_clk,\n    input  wire [3:0]   dat_i,\n    input  wire         wr,\n    output wire         full,\n    output wire         empty\n);\n\n// Parameters\nparameter MEM_OFFSET = 4; // Address increment between words\n\n// Internal registers\nreg [8:0]  offset;\nreg        wb_free;\nreg        reset_rx_fifo;\nreg        rd;\n\n// FIFO signals\nwire [31:0] dat_o;\nwire [1:0]  mem_empt;\n\n// State machine\nreg [1:0] state;\nlocalparam IDLE   = 2'b00;\nlocalparam READ   = 2'b01;\nlocalparam WRITE  = 2'b10;\nlocalparam WAIT   = 2'b11;\n\n// FIFO instance\nsd_rx_fifo rx_fifo (\n    .d(dat_i),\n    .wr(wr),\n    .wclk(sd_clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(full),\n    .empty(empty),\n    .mem_empt(mem_empt),\n    .rclk(clk),\n    .rst(rst | reset_rx_fifo)\n);\n\n// Wishbone signals\nassign m_wb_cti_o = 3'b000; // Classic cycle\nassign m_wb_bte_o = 2'b00;  // Linear burst\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset state\n        state <= IDLE;\n        m_wb_adr_o <= 32'b0;\n        m_wb_dat_o <= 32'b0;\n        m_wb_we_o <= 1'b0;\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n        offset <= 9'b0;\n        wb_free <= 1'b1;\n        reset_rx_fifo <= 1'b1;\n        rd <= 1'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                if (en) begin\n                    reset_rx_fifo <= 1'b0;\n                    if (~empty && wb_free) begin\n                        rd <= 1'b1;\n                        state <= READ;\n                    end\n                end else begin\n                    reset_rx_fifo <= 1'b1;\n                    offset <= 9'b0;\n                    wb_free <= 1'b1;\n                    rd <= 1'b0;\n                end\n            end\n            \n            READ: begin\n                m_wb_dat_o <= dat_o;\n                m_wb_adr_o <= adr + offset;\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                wb_free <= 1'b0;\n                rd <= 1'b0;\n                state <= WRITE;\n            end\n            \n            WRITE: begin\n                if (m_wb_ack_i) begin\n                    m_wb_we_o <= 1'b0;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    offset <= offset + MEM_OFFSET;\n                    wb_free <= 1'b1;\n                    state <= WAIT;\n                end\n            end\n            \n            WAIT: begin\n                if (~empty && wb_free) begin\n                    rd <= 1'b1;\n                    state <= READ;\n                end else begin\n                    state <= IDLE;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 12, "code": "module sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    input wire rclk,\n    output wire full,\n    output wire empty,\n    output wire [1:0] mem_empt,\n    input wire rst\n);\n\nparameter FIFO_RX_MEM_DEPTH = 16; // Example depth, should be defined in sd_defines.v\nparameter FIFO_RX_MEM_ADR_SIZE = 5; // log2(FIFO_RX_MEM_DEPTH) + 1\n\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_gray, adr_o_gray;\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_gray_sync, adr_o_gray_sync;\n\n// Gray code conversion\nassign adr_i_gray = adr_i ^ (adr_i >> 1);\nassign adr_o_gray = adr_o ^ (adr_o >> 1);\n\n// Full and empty flags\nassign full = (adr_i[FIFO_RX_MEM_ADR_SIZE-1] != adr_o[FIFO_RX_MEM_ADR_SIZE-1]) && \n              (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] == adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]);\nassign empty = (adr_i == adr_o);\nassign mem_empt = (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) >> 2; // Approximate empty space in words\n\n// Synchronizers for cross-clock domain signals\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_i_gray_sync <= 0;\n    end else begin\n        adr_i_gray_sync <= adr_i_gray;\n    end\nend\n\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_o_gray_sync <= 0;\n    end else begin\n        adr_o_gray_sync <= adr_o_gray;\n    end\nend\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n    end else begin\n        if (wr && !full) begin\n            case (we)\n                8'h1: tmp[3:0] <= d;\n                8'h2: tmp[7:4] <= d;\n                8'h4: tmp[11:8] <= d;\n                8'h8: tmp[15:12] <= d;\n                8'h10: tmp[19:16] <= d;\n                8'h20: tmp[23:20] <= d;\n                8'h40: tmp[27:24] <= d;\n                8'h80: begin\n                    tmp[31:28] <= d;\n                    ft <= 1;\n                end\n            endcase\n            \n            if (we == 8'h80) begin\n                ram[adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]] <= tmp;\n                adr_i <= adr_i + 1;\n                we <= 8'h1;\n                ft <= 0;\n            end else begin\n                we <= we << 1;\n            end\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else begin\n        if (rd && !empty) begin\n            q <= ram[adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]];\n            adr_o <= adr_o + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 14, "code": "module sd_bd (\n    input  wire                     clk,\n    input  wire                     rst,\n    input  wire                     we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0]      free_bd,\n    input  wire                     re_s,\n    output reg                      ack_o_s,\n    input  wire                     a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\nparameter BD_WIDTH = 8;\nparameter BD_SIZE = 255;\nparameter RAM_MEM_WIDTH = 32;\n\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\nreg [BD_WIDTH-1:0]      m_wr_pnt;\nreg [BD_WIDTH-1:0]      s_rd_pnt;\nreg [BD_WIDTH-1:0]      free_bd_cnt;\nreg                     new_bw;\nreg                     last_a_cmp;\nreg [1:0]               wr_cnt;\nreg [1:0]               rd_cnt;\n\nwire                    wr_complete;\nwire                    rd_complete;\n\nassign free_bd = free_bd_cnt;\nassign dat_out_s = bd_mem[s_rd_pnt];\n\n// Write completion detection\ngenerate\n    if (RAM_MEM_WIDTH == 32) begin\n        assign wr_complete = (wr_cnt == 2'd1);\n    end else begin\n        assign wr_complete = (wr_cnt == 2'd3);\n    end\nendgenerate\n\n// Read completion detection\ngenerate\n    if (RAM_MEM_WIDTH == 32) begin\n        assign rd_complete = (rd_cnt == 2'd1);\n    end else begin\n        assign rd_complete = (rd_cnt == 2'd3);\n    end\nendgenerate\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        free_bd_cnt <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n        new_bw <= 0;\n        last_a_cmp <= 0;\n        wr_cnt <= 0;\n        rd_cnt <= 0;\n        ack_o_s <= 0;\n    end else begin\n        // Write operation\n        if (we_m && (free_bd_cnt > 0)) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= m_wr_pnt + 1;\n            wr_cnt <= wr_cnt + 1;\n            \n            if (wr_complete) begin\n                new_bw <= 1;\n                free_bd_cnt <= free_bd_cnt - 1;\n                wr_cnt <= 0;\n            end else begin\n                new_bw <= 0;\n            end\n        end else begin\n            new_bw <= 0;\n        end\n        \n        // Read operation\n        if (re_s) begin\n            s_rd_pnt <= s_rd_pnt + 1;\n            rd_cnt <= rd_cnt + 1;\n            \n            if (RAM_MEM_WIDTH == 16) begin\n                ack_o_s <= 1;\n            end else if (rd_complete) begin\n                ack_o_s <= 1;\n            end\n            \n            if (rd_complete) begin\n                rd_cnt <= 0;\n            end\n        end else begin\n            ack_o_s <= 0;\n        end\n        \n        // Release BD on operation completion\n        last_a_cmp <= a_cmp;\n        if (a_cmp && !last_a_cmp) begin\n            free_bd_cnt <= free_bd_cnt + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 9, "code": "module sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    input wire rclk,\n    output wire full,\n    output wire empty,\n    output wire [5:0] mem_empt,\n    input wire rst\n);\n\n    // Memory declaration\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    \n    // Pointers\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;  // Write pointer\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;  // Read pointer\n    \n    // Synchronizers for cross-clock domain signals\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_sync1, adr_i_sync2;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o_sync1, adr_o_sync2;\n    \n    // Status flags\n    reg full_reg, empty_reg;\n    reg [5:0] mem_empt_reg;\n    \n    // Write operation\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]] <= d;\n            adr_i <= adr_i + 1;\n        end\n    end\n    \n    // Read operation\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]];\n            adr_o <= adr_o + 1;\n        end\n    end\n    \n    // Synchronize write pointer to read clock domain\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_i_sync1 <= 0;\n            adr_i_sync2 <= 0;\n        end else begin\n            adr_i_sync1 <= adr_i;\n            adr_i_sync2 <= adr_i_sync1;\n        end\n    end\n    \n    // Synchronize read pointer to write clock domain\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_o_sync1 <= 0;\n            adr_o_sync2 <= 0;\n        end else begin\n            adr_o_sync1 <= adr_o;\n            adr_o_sync2 <= adr_o_sync1;\n        end\n    end\n    \n    // Full flag generation (write clock domain)\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            full_reg <= 0;\n        end else begin\n            full_reg <= ((adr_i[FIFO_RX_MEM_ADR_SIZE-1] != adr_o_sync2[FIFO_RX_MEM_ADR_SIZE-1]) && \n                        (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] == adr_o_sync2[FIFO_RX_MEM_ADR_SIZE-2:0]));\n        end\n    end\n    \n    // Empty flag generation (read clock domain)\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            empty_reg <= 1;\n        end else begin\n            empty_reg <= (adr_i_sync2 == adr_o);\n        end\n    end\n    \n    // FIFO occupancy calculation (read clock domain)\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            mem_empt_reg <= 0;\n        end else begin\n            if (adr_i_sync2 >= adr_o) begin\n                mem_empt_reg <= adr_i_sync2 - adr_o;\n            end else begin\n                mem_empt_reg <= (FIFO_TX_MEM_DEPTH << 1) - adr_o + adr_i_sync2;\n            end\n        end\n    end\n    \n    // Output assignments\n    assign full = full_reg;\n    assign empty = empty_reg;\n    assign mem_empt = mem_empt_reg[5:0];\n    \nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 8, "code": "module sd_fifo_rx_filler (\n    // System clock and reset\n    input               clk,\n    input               rst,\n    \n    // Wishbone master interface\n    output reg [31:0]   m_wb_adr_o,\n    output reg          m_wb_we_o,\n    output reg [31:0]   m_wb_dat_o,\n    output reg          m_wb_cyc_o,\n    output reg          m_wb_stb_o,\n    input               m_wb_ack_i,\n    output reg [2:0]    m_wb_cti_o,\n    output reg [2:0]    m_wb_bte_o,\n    \n    // Control signals\n    input               en,\n    input [31:0]        adr,\n    \n    // SD card interface\n    input               sd_clk,\n    input [3:0]         dat_i,\n    input               wr,\n    output              full,\n    output              empty\n);\n\n// Internal signals\nwire [31:0] dat_o;\nreg         rd;\nreg         reset_rx_fifo;\nreg         wb_free;\nreg [8:0]   offset;\n\n// FIFO instance\nsd_rx_fifo rx_fifo (\n    .d(dat_i),\n    .wr(wr),\n    .wclk(sd_clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(full),\n    .empty(empty),\n    .rclk(clk),\n    .rst(reset_rx_fifo)\n);\n\n// State machine\nparameter IDLE = 1'b0;\nparameter WB_WRITE = 1'b1;\nreg state;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all registers\n        m_wb_adr_o <= 32'b0;\n        m_wb_we_o <= 1'b0;\n        m_wb_dat_o <= 32'b0;\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n        m_wb_cti_o <= 3'b0;\n        m_wb_bte_o <= 2'b0;\n        \n        rd <= 1'b0;\n        reset_rx_fifo <= 1'b1;\n        wb_free <= 1'b1;\n        offset <= 9'b0;\n        state <= IDLE;\n    end else begin\n        if (!en) begin\n            // Disabled state\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            rd <= 1'b0;\n            reset_rx_fifo <= 1'b1;\n            wb_free <= 1'b1;\n            offset <= 9'b0;\n            state <= IDLE;\n        end else begin\n            reset_rx_fifo <= 1'b0;\n            \n            case (state)\n                IDLE: begin\n                    if (!empty && wb_free) begin\n                        // Prepare Wishbone write\n                        m_wb_adr_o <= adr + {23'b0, offset};\n                        m_wb_dat_o <= dat_o;\n                        m_wb_we_o <= 1'b1;\n                        m_wb_cyc_o <= 1'b1;\n                        m_wb_stb_o <= 1'b1;\n                        m_wb_cti_o <= 3'b0;  // Classic cycle\n                        m_wb_bte_o <= 2'b0;  // Linear burst\n                        \n                        rd <= 1'b1;\n                        wb_free <= 1'b0;\n                        state <= WB_WRITE;\n                    end\n                end\n                \n                WB_WRITE: begin\n                    if (m_wb_ack_i) begin\n                        // Transaction complete\n                        m_wb_we_o <= 1'b0;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        rd <= 1'b0;\n                        \n                        // Update address offset\n                        offset <= offset + `MEM_OFFSET;\n                        wb_free <= 1'b1;\n                        state <= IDLE;\n                    end\n                end\n            endcase\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 9, "code": "module sd_fifo_rx_filler (\n    input  wire         clk,\n    input  wire         rst,\n    output reg  [31:0]  m_wb_adr_o,\n    output reg          m_wb_we_o,\n    output reg  [31:0]  m_wb_dat_o,\n    output reg          m_wb_cyc_o,\n    output reg          m_wb_stb_o,\n    input  wire         m_wb_ack_i,\n    output reg  [2:0]   m_wb_cti_o,\n    output reg  [2:0]   m_wb_bte_o,\n    input  wire         en,\n    input  wire [31:0]  adr,\n    input  wire         sd_clk,\n    input  wire [3:0]   dat_i,\n    input  wire         wr,\n    output wire         full,\n    output wire         empty\n);\n\n// Internal registers\nreg [8:0]  offset;\nreg        wb_free;\nreg        reset_rx_fifo;\nreg        rd;\n\n// FIFO signals\nwire [31:0] dat_o;\nwire [1:0]  mem_empt;\n\n// State machine states\nparameter IDLE      = 2'b00;\nparameter READ_FIFO = 2'b01;\nparameter WB_WRITE  = 2'b10;\n\nreg [1:0] state, next_state;\n\n// Instantiate the RX FIFO\nsd_rx_fifo rx_fifo (\n    .d(dat_i),\n    .wr(wr),\n    .wclk(sd_clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(full),\n    .empty(empty),\n    .mem_empt(mem_empt),\n    .rclk(clk),\n    .rst(rst | reset_rx_fifo)\n);\n\n// State machine\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (en && !empty && wb_free) begin\n                next_state = READ_FIFO;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        READ_FIFO: begin\n            next_state = WB_WRITE;\n        end\n        WB_WRITE: begin\n            if (m_wb_ack_i) begin\n                next_state = IDLE;\n            end else begin\n                next_state = WB_WRITE;\n            end\n        end\n        default: begin\n            next_state = IDLE;\n        end\n    endcase\nend\n\n// Output logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wb_adr_o     <= 32'b0;\n        m_wb_we_o      <= 1'b0;\n        m_wb_dat_o     <= 32'b0;\n        m_wb_cyc_o     <= 1'b0;\n        m_wb_stb_o     <= 1'b0;\n        m_wb_cti_o     <= 3'b0;\n        m_wb_bte_o     <= 2'b0;\n        offset         <= 9'b0;\n        wb_free        <= 1'b1;\n        reset_rx_fifo  <= 1'b1;\n        rd             <= 1'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                if (!en) begin\n                    // Disabled state handling\n                    reset_rx_fifo <= 1'b1;\n                    rd            <= 1'b0;\n                    offset        <= 9'b0;\n                    wb_free       <= 1'b1;\n                    m_wb_we_o     <= 1'b0;\n                    m_wb_cyc_o    <= 1'b0;\n                    m_wb_stb_o    <= 1'b0;\n                end else begin\n                    reset_rx_fifo <= 1'b0;\n                    rd            <= 1'b0;\n                end\n            end\n            READ_FIFO: begin\n                rd         <= 1'b1;\n                m_wb_dat_o <= dat_o;\n                m_wb_adr_o <= adr + {23'b0, offset};\n                wb_free    <= 1'b0;\n            end\n            WB_WRITE: begin\n                rd         <= 1'b0;\n                m_wb_we_o  <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                m_wb_cti_o <= 3'b0; // Classic cycle\n                m_wb_bte_o <= 2'b0; // Linear burst\n                \n                if (m_wb_ack_i) begin\n                    m_wb_we_o  <= 1'b0;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    offset     <= offset + `MEM_OFFSET;\n                    wb_free    <= 1'b1;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 10, "code": "module sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    input wire rclk,\n    output wire full,\n    output wire empty,\n    output wire [5:0] mem_empt,\n    input wire rst\n);\n\n    // Memory array\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    \n    // Pointers\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    \n    // Gray code pointers for clock domain crossing\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray, adr_o_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray_sync, adr_o_gray_sync;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray_sync_r, adr_o_gray_sync_r;\n    \n    // Binary pointers after synchronization\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_sync, adr_o_sync;\n    \n    // Status signals\n    reg full_reg, empty_reg;\n    reg [5:0] mem_empt_reg;\n    \n    // Convert binary to gray code\n    function [FIFO_TX_MEM_ADR_SIZE-1:0] bin2gray;\n        input [FIFO_TX_MEM_ADR_SIZE-1:0] bin;\n        begin\n            bin2gray = bin ^ (bin >> 1);\n        end\n    endfunction\n    \n    // Convert gray code to binary\n    function [FIFO_TX_MEM_ADR_SIZE-1:0] gray2bin;\n        input [FIFO_TX_MEM_ADR_SIZE-1:0] gray;\n        integer i;\n        begin\n            gray2bin[FIFO_TX_MEM_ADR_SIZE-1] = gray[FIFO_TX_MEM_ADR_SIZE-1];\n            for (i = FIFO_TX_MEM_ADR_SIZE-2; i >= 0; i = i - 1)\n                gray2bin[i] = gray2bin[i+1] ^ gray[i];\n        end\n    endfunction\n    \n    // Write clock domain logic\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            adr_i_gray <= 0;\n        end else begin\n            if (wr && !full) begin\n                ram[adr_i[FIFO_TX_MEM_ADR_SIZE-2:0]] <= d;\n                adr_i <= adr_i + 1;\n                adr_i_gray <= bin2gray(adr_i + 1);\n            end\n        end\n    end\n    \n    // Read clock domain logic\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            adr_o_gray <= 0;\n            q <= 0;\n        end else begin\n            if (rd && !empty) begin\n                q <= ram[adr_o[FIFO_TX_MEM_ADR_SIZE-2:0]];\n                adr_o <= adr_o + 1;\n                adr_o_gray <= bin2gray(adr_o + 1);\n            end\n        end\n    end\n    \n    // Synchronize write pointer to read clock domain\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_i_gray_sync <= 0;\n            adr_i_gray_sync_r <= 0;\n            adr_i_sync <= 0;\n        end else begin\n            adr_i_gray_sync <= adr_i_gray;\n            adr_i_gray_sync_r <= adr_i_gray_sync;\n            adr_i_sync <= gray2bin(adr_i_gray_sync_r);\n        end\n    end\n    \n    // Synchronize read pointer to write clock domain\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_o_gray_sync <= 0;\n            adr_o_gray_sync_r <= 0;\n            adr_o_sync <= 0;\n        end else begin\n            adr_o_gray_sync <= adr_o_gray;\n            adr_o_gray_sync_r <= adr_o_gray_sync;\n            adr_o_sync <= gray2bin(adr_o_gray_sync_r);\n        end\n    end\n    \n    // Generate status signals in write clock domain\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            full_reg <= 0;\n        end else begin\n            full_reg <= ((adr_i[FIFO_TX_MEM_ADR_SIZE-2:0] == adr_o_sync[FIFO_TX_MEM_ADR_SIZE-2:0]) &&\n                        (adr_i[FIFO_TX_MEM_ADR_SIZE-1] != adr_o_sync[FIFO_TX_MEM_ADR_SIZE-1]));\n        end\n    end\n    \n    // Generate status signals in read clock domain\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            empty_reg <= 1;\n            mem_empt_reg <= 0;\n        end else begin\n            empty_reg <= (adr_i_sync == adr_o);\n            mem_empt_reg <= adr_i_sync - adr_o;\n        end\n    end\n    \n    assign full = full_reg;\n    assign empty = empty_reg;\n    assign mem_empt = mem_empt_reg[5:0];\n    \nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 10, "code": "module sd_fifo_tx_filler (\n    input         clk,\n    input         rst,\n    output [31:0] m_wb_adr_o,\n    output        m_wb_we_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    input         en,\n    input  [31:0] adr,\n    input         sd_clk,\n    output [31:0] dat_o,\n    input         rd,\n    output        empty,\n    output        fe\n);\n\n    // Internal registers\n    reg [8:0]  offset;\n    reg [8:0]  we;\n    reg [31:0] din;\n    reg        wr_tx;\n    reg        reset_tx_fifo;\n    reg        first;\n    reg        ackd;\n    reg        delay;\n\n    // Wishbone signals\n    assign m_wb_we_o = 1'b0;  // Always read operations\n    assign m_wb_cti_o = 3'b000; // Classic cycle\n    assign m_wb_bte_o = 2'b00; // Linear burst\n    assign m_wb_adr_o = adr + {23'b0, offset};\n\n    // FIFO instance\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .rclk(sd_clk),\n        .rst(rst | reset_tx_fifo)\n    );\n\n    // Main state machine\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all registers\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b1;\n            delay <= 1'b0;\n            \n            // Reset Wishbone signals\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n        end else begin\n            // Default values\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b0;\n            \n            if (en) begin\n                if (!fe && !m_wb_ack_i && ackd) begin\n                    // Start Wishbone transaction\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    first <= 1'b0;\n                end\n                \n                if (m_wb_ack_i) begin\n                    // Acknowledge received\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                \n                if (delay) begin\n                    // Delay state\n                    offset <= offset + 1'b1;\n                    ackd <= ~ackd;\n                    wr_tx <= 1'b0;\n                    delay <= 1'b0;\n                end\n            end else begin\n                // Disabled state\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                offset <= 9'b0;\n                reset_tx_fifo <= 1'b1;\n                first <= 1'b1;\n                ackd <= 1'b1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 20, "code": "module sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC[15] <= CRC[14];\n            CRC[14] <= CRC[13];\n            CRC[13] <= CRC[12];\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[11] <= CRC[10];\n            CRC[10] <= CRC[9];\n            CRC[9]  <= CRC[8];\n            CRC[8]  <= CRC[7];\n            CRC[7]  <= CRC[6];\n            CRC[6]  <= CRC[5];\n            CRC[5]  <= CRC[4] ^ inv;\n            CRC[4]  <= CRC[3];\n            CRC[3]  <= CRC[2];\n            CRC[2]  <= CRC[1];\n            CRC[1]  <= CRC[0];\n            CRC[0]  <= inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 10, "code": "module sd_fifo_rx_filler (\n    input  wire         clk,\n    input  wire         rst,\n    output reg  [31:0]  m_wb_adr_o,\n    output reg          m_wb_we_o,\n    output reg  [31:0]  m_wb_dat_o,\n    output reg          m_wb_cyc_o,\n    output reg          m_wb_stb_o,\n    input  wire         m_wb_ack_i,\n    output wire [2:0]   m_wb_cti_o,\n    output wire [1:0]   m_wb_bte_o,\n    input  wire         en,\n    input  wire [31:0]  adr,\n    input  wire         sd_clk,\n    input  wire [3:0]   dat_i,\n    input  wire         wr,\n    output wire         full,\n    output wire         empty\n);\n\n    // Parameters\n    parameter MEM_OFFSET = 4;  // Address increment between words\n\n    // Internal registers\n    reg [8:0]  offset;\n    reg        wb_free;\n    reg        reset_rx_fifo;\n    reg        rd;\n    wire [31:0] dat_o;\n\n    // State machine\n    reg state;\n    localparam IDLE = 1'b0;\n    localparam WB_WRITE = 1'b1;\n\n    // FIFO instance\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    // Wishbone signals\n    assign m_wb_cti_o = 3'b000;  // Classic cycle\n    assign m_wb_bte_o = 2'b00;   // Linear burst\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all control signals\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            state <= IDLE;\n        end else begin\n            if (!en) begin\n                // Disabled state\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                m_wb_we_o <= 1'b0;\n                offset <= 9'b0;\n                wb_free <= 1'b1;\n                reset_rx_fifo <= 1'b1;\n                rd <= 1'b0;\n                state <= IDLE;\n            end else begin\n                reset_rx_fifo <= 1'b0;\n                \n                case (state)\n                    IDLE: begin\n                        if (!empty && wb_free) begin\n                            // Start Wishbone write transaction\n                            m_wb_adr_o <= adr + offset;\n                            m_wb_dat_o <= dat_o;\n                            m_wb_we_o <= 1'b1;\n                            m_wb_cyc_o <= 1'b1;\n                            m_wb_stb_o <= 1'b1;\n                            rd <= 1'b1;\n                            wb_free <= 1'b0;\n                            state <= WB_WRITE;\n                        end else begin\n                            rd <= 1'b0;\n                        end\n                    end\n                    \n                    WB_WRITE: begin\n                        if (m_wb_ack_i) begin\n                            // Transaction complete\n                            m_wb_cyc_o <= 1'b0;\n                            m_wb_stb_o <= 1'b0;\n                            m_wb_we_o <= 1'b0;\n                            offset <= offset + MEM_OFFSET;\n                            wb_free <= 1'b1;\n                            rd <= 1'b0;\n                            state <= IDLE;\n                        end\n                    end\n                endcase\n            end\n        end\n    end\n\nendmodule\n\nmodule sd_rx_fifo (\n    input  wire [3:0]  d,\n    input  wire        wr,\n    input  wire        wclk,\n    output wire [31:0] q,\n    input  wire        rd,\n    output wire        full,\n    output wire        empty,\n    input  wire        rclk,\n    input  wire        rst\n);\n\n    // FIFO implementation would go here\n    // This is a placeholder for the actual FIFO implementation\n    // In a real design, this would be either a behavioral model\n    // or an instantiation of a technology-specific FIFO\n    \n    // For simulation purposes:\n    reg [31:0] mem [0:15];  // Example 16-word deep FIFO\n    reg [4:0]  wptr, rptr;\n    reg [4:0]  count;\n    \n    assign full = (count == 16);\n    assign empty = (count == 0);\n    \n    // Write pointer logic\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            wptr <= 0;\n        end else if (wr && !full) begin\n            // Pack 8 writes into one 32-bit word\n            case (wptr[2:0])\n                3'b000: mem[wptr[4:3]][7:0] <= d;\n                3'b001: mem[wptr[4:3]][15:8] <= d;\n                3'b010: mem[wptr[4:3]][23:16] <= d;\n                3'b011: mem[wptr[4:3]][31:24] <= d;\n            endcase\n            wptr <= wptr + 1;\n        end\n    end\n    \n    // Read pointer logic\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            rptr <= 0;\n        end else if (rd && !empty) begin\n            rptr <= rptr + 1;\n        end\n    end\n    \n    // Count logic\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            count <= 0;\n        end else begin\n            case ({wr && !full, rd && !empty})\n                2'b01: count <= count - 1;\n                2'b10: count <= count + 1;\n                default: count <= count;\n            endcase\n        end\n    end\n    \n    assign q = mem[rptr[4:3]];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 11, "code": "module sd_fifo_tx_filler (\n    input         clk,\n    input         rst,\n    output [31:0] m_wb_adr_o,\n    output        m_wb_we_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    input         en,\n    input  [31:0] adr,\n    input         sd_clk,\n    output [31:0] dat_o,\n    input         rd,\n    output        empty,\n    output        fe\n);\n\n    // Internal registers\n    reg [8:0]  offset;\n    reg [8:0]  we;\n    reg [31:0] din;\n    reg        wr_tx;\n    reg        reset_tx_fifo;\n    reg        first;\n    reg        ackd;\n    reg        delay;\n\n    // Wishbone signals\n    assign m_wb_we_o = 1'b0;  // Always read operations\n    assign m_wb_cti_o = 3'b000;\n    assign m_wb_bte_o = 2'b00;\n    assign m_wb_adr_o = adr + {offset, 2'b00};  // Word addressing\n\n    // FIFO signals\n    wire full;\n    assign fe = full;\n\n    // FIFO instance\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(sd_clk),\n        .rst(rst | reset_tx_fifo)\n    );\n\n    // Main state machine\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all registers\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b1;\n            delay <= 1'b0;\n            \n            // Reset Wishbone signals\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n        end else begin\n            // Default values\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b0;\n            delay <= 1'b0;\n\n            if (en) begin\n                // Module is enabled\n                if (!full && !m_wb_ack_i && ackd) begin\n                    // Start new Wishbone transaction\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                end\n\n                if (m_wb_ack_i) begin\n                    // Wishbone acknowledged\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n\n                if (delay) begin\n                    // Post-acknowledge processing\n                    offset <= offset + 1'b1;\n                    ackd <= ~ackd;\n                    wr_tx <= 1'b0;\n                end\n            end else begin\n                // Module is disabled\n                offset <= 9'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                reset_tx_fifo <= 1'b1;\n                ackd <= 1'b1;\n            end\n        end\n    end\n\nendmodule\n\nmodule sd_tx_fifo (\n    input  [31:0] d,\n    input         wr,\n    input         wclk,\n    output [31:0] q,\n    input         rd,\n    output        full,\n    output        empty,\n    output [5:0]  mem_empt,\n    input         rclk,\n    input         rst\n);\n\n    // FIFO implementation would go here\n    // This is a placeholder for the actual FIFO implementation\n    // In a real design, this would be either a behavioral model\n    // or an instantiation of a technology-specific FIFO\n\n    reg [31:0] mem [0:63];  // Example with 64-entry FIFO\n    reg [5:0]  wptr, rptr;\n    reg [5:0]  count;\n\n    assign full = (count == 6'd63);\n    assign empty = (count == 6'd0);\n    assign mem_empt = count;\n    assign q = mem[rptr[5:0]];\n\n    // Write pointer logic\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            wptr <= 6'b0;\n        end else if (wr && !full) begin\n            mem[wptr] <= d;\n            wptr <= wptr + 1'b1;\n        end\n    end\n\n    // Read pointer logic\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            rptr <= 6'b0;\n        end else if (rd && !empty) begin\n            rptr <= rptr + 1'b1;\n        end\n    end\n\n    // Count logic (synchronized to write clock)\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            count <= 6'b0;\n        end else begin\n            case ({wr && !full, rd && !empty})\n                2'b01: count <= count - 1'b1;\n                2'b10: count <= count + 1'b1;\n                default: count <= count;\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 12, "code": "module sd_fifo_tx_filler (\n    input         clk,\n    input         rst,\n    output [31:0] m_wb_adr_o,\n    output        m_wb_we_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    input         en,\n    input  [31:0] adr,\n    input         sd_clk,\n    output [31:0] dat_o,\n    input         rd,\n    output        empty,\n    output        fe\n);\n\n    // Internal registers\n    reg [8:0]  offset;\n    reg [8:0]  we;\n    reg [31:0] din;\n    reg        wr_tx;\n    reg        reset_tx_fifo;\n    reg        first;\n    reg        ackd;\n    reg        delay;\n\n    // Wishbone signals\n    assign m_wb_we_o = 1'b0;  // Always read\n    assign m_wb_cti_o = 3'b000;\n    assign m_wb_bte_o = 2'b00;\n    assign m_wb_adr_o = adr + {offset, 2'b00};  // Word addressing\n\n    // FIFO control signals\n    wire full;\n    assign fe = full;\n\n    // Instantiate the TX FIFO\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(sd_clk),\n        .rst(rst | reset_tx_fifo)\n    );\n\n    // Main state machine\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all registers\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b1;\n            delay <= 1'b0;\n            \n            // Reset Wishbone signals\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n        end else begin\n            // Default values\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b0;\n            \n            if (en) begin\n                // Module is enabled\n                if (!full && !m_wb_ack_i && ackd) begin\n                    // Start Wishbone transaction\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    first <= 1'b0;\n                end\n                \n                if (m_wb_ack_i) begin\n                    // Wishbone acknowledged\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                \n                if (delay) begin\n                    // Delay state for timing\n                    offset <= offset + 1'b1;\n                    ackd <= ~ackd;\n                    wr_tx <= 1'b0;\n                    delay <= 1'b0;\n                end\n            end else begin\n                // Module is disabled\n                offset <= 9'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                reset_tx_fifo <= 1'b1;\n                first <= 1'b1;\n                ackd <= 1'b1;\n            end\n        end\n    end\n\nendmodule\n\nmodule sd_tx_fifo (\n    input  [31:0] d,\n    input         wr,\n    input         wclk,\n    output [31:0] q,\n    input         rd,\n    output        full,\n    output        empty,\n    output [5:0]  mem_empt,\n    input         rclk,\n    input         rst\n);\n\n    // FIFO parameters\n    parameter FIFO_DEPTH = 16;\n    parameter ADDR_WIDTH = 4;\n    \n    // FIFO memory\n    reg [31:0] mem [0:FIFO_DEPTH-1];\n    \n    // Pointers\n    reg [ADDR_WIDTH:0] wptr, rptr;\n    reg [ADDR_WIDTH:0] wptr_sync, rptr_sync;\n    \n    // Synchronization registers\n    reg [ADDR_WIDTH:0] wptr_gray, rptr_gray;\n    reg [ADDR_WIDTH:0] wptr_gray_sync, rptr_gray_sync;\n    \n    // Status flags\n    assign full = (wptr[ADDR_WIDTH-1:0] == rptr_sync[ADDR_WIDTH-1:0]) && \n                  (wptr[ADDR_WIDTH] != rptr_sync[ADDR_WIDTH]);\n    assign empty = (wptr_sync == rptr);\n    assign mem_empt = FIFO_DEPTH - (wptr - rptr_sync);\n    \n    // Write clock domain\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            wptr <= 0;\n            wptr_gray <= 0;\n        end else if (wr && !full) begin\n            mem[wptr[ADDR_WIDTH-1:0]] <= d;\n            wptr <= wptr + 1;\n            wptr_gray <= (wptr + 1) ^ ((wptr + 1) >> 1);\n        end\n    end\n    \n    // Read clock domain\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            rptr <= 0;\n            rptr_gray <= 0;\n            q <= 0;\n        end else if (rd && !empty) begin\n            q <= mem[rptr[ADDR_WIDTH-1:0]];\n            rptr <= rptr + 1;\n            rptr_gray <= (rptr + 1) ^ ((rptr + 1) >> 1);\n        end\n    end\n    \n    // Synchronizers\n    always @(posedge wclk) begin\n        rptr_gray_sync <= rptr_gray;\n        rptr_sync <= gray2bin(rptr_gray_sync);\n    end\n    \n    always @(posedge rclk) begin\n        wptr_gray_sync <= wptr_gray;\n        wptr_sync <= gray2bin(wptr_gray_sync);\n    end\n    \n    // Gray to binary conversion function\n    function [ADDR_WIDTH:0] gray2bin;\n        input [ADDR_WIDTH:0] gray;\n        integer i;\n        begin\n            gray2bin[ADDR_WIDTH] = gray[ADDR_WIDTH];\n            for (i = ADDR_WIDTH-1; i >= 0; i = i-1)\n                gray2bin[i] = gray2bin[i+1] ^ gray[i];\n        end\n    endfunction\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input                       clk,\n    input                       rst,\n    input                       we_m,\n    input  [RAM_MEM_WIDTH-1:0]  dat_in_m,\n    output [BD_WIDTH-1:0]       free_bd,\n    input                       re_s,\n    output                      ack_o_s,\n    input                       a_cmp,\n    output [RAM_MEM_WIDTH-1:0]  dat_out_s\n);\n\n// Internal registers\nreg [BD_WIDTH-1:0] m_wr_pnt;\nreg [BD_WIDTH-1:0] s_rd_pnt;\nreg [BD_WIDTH-1:0] free_bd_reg;\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\nreg [1:0] wr_cnt;\nreg [1:0] rd_cnt;\nreg new_bw;\nreg last_a_cmp;\nreg ack_o_s_reg;\n\n// Parameters\nparameter WR_COMPLETE_32 = 1;\nparameter WR_COMPLETE_16 = 3;\nparameter RD_COMPLETE_32 = 1;\nparameter RD_COMPLETE_16 = 3;\n\n// Assign outputs\nassign free_bd = free_bd_reg;\nassign ack_o_s = ack_o_s_reg;\nassign dat_out_s = bd_mem[s_rd_pnt];\n\n// Initialization\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        wr_cnt <= 0;\n        rd_cnt <= 0;\n        new_bw <= 0;\n        last_a_cmp <= 0;\n        ack_o_s_reg <= 0;\n        \n        // Initialize free_bd based on mode\n        if (RAM_MEM_WIDTH == 32)\n            free_bd_reg <= BD_SIZE >> 1;\n        else if (RAM_MEM_WIDTH == 16)\n            free_bd_reg <= BD_SIZE >> 2;\n    end\nend\n\n// Write Buffer Descriptor\nalways @(posedge clk) begin\n    if (we_m && (free_bd_reg > 0)) begin\n        bd_mem[m_wr_pnt] <= dat_in_m;\n        m_wr_pnt <= m_wr_pnt + 1;\n        \n        if (RAM_MEM_WIDTH == 32) begin\n            if (wr_cnt == WR_COMPLETE_32) begin\n                new_bw <= 1;\n                free_bd_reg <= free_bd_reg - 1;\n                wr_cnt <= 0;\n            end else begin\n                wr_cnt <= wr_cnt + 1;\n                new_bw <= 0;\n            end\n        end\n        else if (RAM_MEM_WIDTH == 16) begin\n            if (wr_cnt == WR_COMPLETE_16) begin\n                new_bw <= 1;\n                free_bd_reg <= free_bd_reg - 1;\n                wr_cnt <= 0;\n            end else begin\n                wr_cnt <= wr_cnt + 1;\n                new_bw <= 0;\n            end\n        end\n    end\nend\n\n// Read Buffer Descriptor\nalways @(posedge clk) begin\n    if (re_s) begin\n        s_rd_pnt <= s_rd_pnt + 1;\n        \n        if (RAM_MEM_WIDTH == 32) begin\n            if (rd_cnt == RD_COMPLETE_32) begin\n                rd_cnt <= 0;\n                ack_o_s_reg <= 0;\n            end else begin\n                rd_cnt <= rd_cnt + 1;\n                ack_o_s_reg <= 1;\n            end\n        end\n        else if (RAM_MEM_WIDTH == 16) begin\n            if (rd_cnt == RD_COMPLETE_16) begin\n                rd_cnt <= 0;\n                ack_o_s_reg <= 0;\n            end else begin\n                rd_cnt <= rd_cnt + 1;\n                ack_o_s_reg <= 1;\n            end\n        end\n    end\nend\n\n// Release Buffer Descriptor\nalways @(posedge clk) begin\n    last_a_cmp <= a_cmp;\n    \n    if (RAM_MEM_WIDTH == 32) begin\n        if (a_cmp && !last_a_cmp) begin\n            free_bd_reg <= free_bd_reg + 1;\n        end\n    end\n    else if (RAM_MEM_WIDTH == 16) begin\n        if (a_cmp && !last_a_cmp) begin\n            free_bd_reg <= free_bd_reg + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 11, "code": "module sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    input wire rclk,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt,\n    input wire rst\n);\n\n    parameter FIFO_TX_MEM_DEPTH = 64; // Example depth, should match sd_defines.v\n    parameter FIFO_TX_MEM_ADR_SIZE = 7; // log2(FIFO_TX_MEM_DEPTH) + 1\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray, adr_o_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray_sync, adr_o_gray_sync;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_sync, adr_o_sync;\n\n    // Write clock domain logic\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            adr_i_gray <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i[FIFO_TX_MEM_ADR_SIZE-2:0]] <= d;\n            adr_i <= adr_i + 1;\n            adr_i_gray <= (adr_i + 1) ^ ((adr_i + 1) >> 1);\n        end\n    end\n\n    // Read clock domain logic\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            adr_o_gray <= 0;\n            q <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o[FIFO_TX_MEM_ADR_SIZE-2:0]];\n            adr_o <= adr_o + 1;\n            adr_o_gray <= (adr_o + 1) ^ ((adr_o + 1) >> 1);\n        end\n    end\n\n    // Synchronize write pointer to read clock domain\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_i_gray_sync <= 0;\n            adr_i_sync <= 0;\n        end else begin\n            adr_i_gray_sync <= adr_i_gray;\n            // Convert gray code back to binary\n            adr_i_sync[FIFO_TX_MEM_ADR_SIZE-1] = adr_i_gray_sync[FIFO_TX_MEM_ADR_SIZE-1];\n            for (integer i = FIFO_TX_MEM_ADR_SIZE-2; i >= 0; i = i - 1)\n                adr_i_sync[i] = adr_i_sync[i+1] ^ adr_i_gray_sync[i];\n        end\n    end\n\n    // Synchronize read pointer to write clock domain\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_o_gray_sync <= 0;\n            adr_o_sync <= 0;\n        end else begin\n            adr_o_gray_sync <= adr_o_gray;\n            // Convert gray code back to binary\n            adr_o_sync[FIFO_TX_MEM_ADR_SIZE-1] = adr_o_gray_sync[FIFO_TX_MEM_ADR_SIZE-1];\n            for (integer i = FIFO_TX_MEM_ADR_SIZE-2; i >= 0; i = i - 1)\n                adr_o_sync[i] = adr_o_sync[i+1] ^ adr_o_gray_sync[i];\n        end\n    end\n\n    // Generate full and empty flags\n    always @(*) begin\n        // Full when write pointer is one less than read pointer (modulo depth)\n        full = (adr_i[FIFO_TX_MEM_ADR_SIZE-2:0] == adr_o_sync[FIFO_TX_MEM_ADR_SIZE-2:0]) &&\n               (adr_i[FIFO_TX_MEM_ADR_SIZE-1] != adr_o_sync[FIFO_TX_MEM_ADR_SIZE-1]);\n        \n        // Empty when read and write pointers are equal\n        empty = (adr_o == adr_i_sync);\n        \n        // Calculate memory occupancy (write pointer - read pointer)\n        if (adr_i_sync >= adr_o)\n            mem_empt = adr_i_sync - adr_o;\n        else\n            mem_empt = (FIFO_TX_MEM_DEPTH - adr_o) + adr_i_sync;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 11, "code": "module sd_fifo_rx_filler (\n    input  wire         clk,\n    input  wire         rst,\n    output reg  [31:0]  m_wb_adr_o,\n    output reg          m_wb_we_o,\n    output reg  [31:0]  m_wb_dat_o,\n    output reg          m_wb_cyc_o,\n    output reg          m_wb_stb_o,\n    input  wire         m_wb_ack_i,\n    output reg  [2:0]   m_wb_cti_o,\n    output reg  [2:0]   m_wb_bte_o,\n    input  wire         en,\n    input  wire [31:0]  adr,\n    input  wire         sd_clk,\n    input  wire [3:0]   dat_i,\n    input  wire         wr,\n    output wire         full,\n    output wire         empty\n);\n\n    // Parameters\n    parameter MEM_OFFSET = 4;  // Address increment between words\n\n    // Internal registers\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    // FIFO signals\n    wire [31:0] dat_o;\n    wire [1:0] mem_empt;\n\n    // FIFO instance\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .mem_empt(mem_empt),\n        .rclk(clk),\n        .rst(rst | reset_rx_fifo)\n    );\n\n    // State machine\n    reg [1:0] state;\n    localparam IDLE      = 2'b00;\n    localparam READ_FIFO = 2'b01;\n    localparam WB_WRITE  = 2'b10;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all control signals\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            state <= IDLE;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (en) begin\n                        reset_rx_fifo <= 1'b0;\n                        if (!empty && wb_free) begin\n                            rd <= 1'b1;\n                            state <= READ_FIFO;\n                        end\n                    end else begin\n                        // Disabled state handling\n                        reset_rx_fifo <= 1'b1;\n                        rd <= 1'b0;\n                        offset <= 9'b0;\n                        wb_free <= 1'b1;\n                        m_wb_we_o <= 1'b0;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                    end\n                end\n\n                READ_FIFO: begin\n                    // Prepare Wishbone transaction\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_dat_o <= dat_o;\n                    m_wb_we_o <= 1'b1;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_cti_o <= 3'b000;  // Classic cycle\n                    m_wb_bte_o <= 2'b00;   // Linear burst\n                    wb_free <= 1'b0;\n                    rd <= 1'b0;\n                    state <= WB_WRITE;\n                end\n\n                WB_WRITE: begin\n                    if (m_wb_ack_i) begin\n                        // Transaction complete\n                        m_wb_we_o <= 1'b0;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        offset <= offset + MEM_OFFSET;\n                        wb_free <= 1'b1;\n                        state <= IDLE;\n                    end\n                end\n\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule sd_rx_fifo (\n    input  wire [3:0]  d,\n    input  wire        wr,\n    input  wire        wclk,\n    output wire [31:0] q,\n    input  wire        rd,\n    output wire        full,\n    output wire        empty,\n    output wire [1:0]  mem_empt,\n    input  wire        rclk,\n    input  wire        rst\n);\n\n    // FIFO implementation would go here\n    // This is a placeholder for the actual FIFO implementation\n    // In a real design, this would be either a behavioral model\n    // or an instantiation of a vendor-specific FIFO primitive\n\n    assign q = 32'b0;\n    assign full = 1'b0;\n    assign empty = 1'b1;\n    assign mem_empt = 2'b11;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 13, "code": "module sd_fifo_tx_filler (\n    input               clk,\n    input               rst,\n    output reg [31:0]   m_wb_adr_o,\n    output reg          m_wb_we_o,\n    input      [31:0]   m_wb_dat_i,\n    output reg          m_wb_cyc_o,\n    output reg          m_wb_stb_o,\n    input               m_wb_ack_i,\n    output reg [2:0]    m_wb_cti_o,\n    output reg [2:0]    m_wb_bte_o,\n    input               en,\n    input      [31:0]   adr,\n    input               sd_clk,\n    output     [31:0]   dat_o,\n    input               rd,\n    output              empty,\n    output              fe\n);\n\n    // Internal registers\n    reg [8:0]   offset;\n    reg [8:0]   we;\n    reg [31:0]  din;\n    reg         wr_tx;\n    reg         reset_tx_fifo;\n    reg         first;\n    reg         ackd;\n    reg         delay;\n\n    // FIFO instance\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .rclk(sd_clk),\n        .rst(rst | reset_tx_fifo)\n    );\n\n    // State machine\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all control signals\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            \n            // Reset internal registers\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b1;\n            delay <= 1'b0;\n        end else begin\n            // Default values\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b0;\n            m_wb_we_o <= 1'b0;\n            \n            if (en) begin\n                if (first) begin\n                    // First operation after enable\n                    first <= 1'b0;\n                    offset <= 9'b0;\n                    reset_tx_fifo <= 1'b1;\n                end else if (!fe && !m_wb_cyc_o && ackd) begin\n                    // Start Wishbone transaction\n                    m_wb_adr_o <= adr + {offset, 2'b00};\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_cti_o <= 3'b001;  // Incrementing burst\n                    m_wb_bte_o <= 2'b00;   // Linear burst\n                    ackd <= 1'b0;\n                end\n                \n                if (m_wb_ack_i) begin\n                    // Wishbone acknowledge received\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                \n                if (delay) begin\n                    // Delay state for timing\n                    offset <= offset + 1'b1;\n                    ackd <= 1'b1;\n                    wr_tx <= 1'b0;\n                    delay <= 1'b0;\n                end\n            end else begin\n                // Module disabled\n                first <= 1'b1;\n                offset <= 9'b0;\n                reset_tx_fifo <= 1'b1;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                ackd <= 1'b1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 14, "code": "module sd_fifo_tx_filler (\n    input         clk,\n    input         rst,\n    output [31:0] m_wb_adr_o,\n    output        m_wb_we_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    input         en,\n    input  [31:0] adr,\n    input         sd_clk,\n    output [31:0] dat_o,\n    input         rd,\n    output        empty,\n    output        fe\n);\n\n    // Internal registers\n    reg [8:0]  offset;\n    reg [8:0]  we;\n    reg [31:0] din;\n    reg        wr_tx;\n    reg        reset_tx_fifo;\n    reg        first;\n    reg        ackd;\n    reg        delay;\n\n    // Wishbone signals\n    assign m_wb_we_o = 1'b0;  // Always read\n    assign m_wb_cti_o = 3'b000;\n    assign m_wb_bte_o = 2'b00;\n    assign m_wb_adr_o = adr + {23'b0, offset};\n\n    // FIFO control signals\n    wire full;\n    assign fe = full;\n\n    // Instantiate the TX FIFO\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(sd_clk),\n        .rst(rst | reset_tx_fifo)\n    );\n\n    // Main state machine\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all registers\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b1;\n            delay <= 1'b0;\n            \n            // Reset Wishbone signals\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n        end else begin\n            // Default values\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b0;\n            \n            if (en) begin\n                if (!full && !m_wb_ack_i && ackd) begin\n                    // Start new Wishbone transaction\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    first <= 1'b0;\n                end\n                \n                if (m_wb_ack_i) begin\n                    // Acknowledge received\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                \n                if (delay) begin\n                    // Post-acknowledge processing\n                    offset <= offset + 1'b1;\n                    ackd <= ~ackd;\n                    delay <= 1'b0;\n                end\n            end else begin\n                // Module disabled\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                offset <= 9'b0;\n                reset_tx_fifo <= 1'b1;\n                first <= 1'b1;\n                ackd <= 1'b1;\n            end\n        end\n    end\n\nendmodule\n\nmodule sd_tx_fifo (\n    input  [31:0] d,\n    input         wr,\n    input         wclk,\n    output [31:0] q,\n    input         rd,\n    output        full,\n    output        empty,\n    output [5:0]  mem_empt,\n    input         rclk,\n    input         rst\n);\n\n    // FIFO parameters\n    parameter DEPTH = 32;\n    parameter ADDR_WIDTH = 5;\n    \n    // FIFO memory\n    reg [31:0] mem [0:DEPTH-1];\n    \n    // Pointers\n    reg [ADDR_WIDTH:0] wptr, rptr;\n    reg [ADDR_WIDTH:0] wptr_gray, rptr_gray;\n    reg [ADDR_WIDTH:0] wptr_sync, rptr_sync;\n    \n    // Synchronizers\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            wptr_sync <= 0;\n        end else begin\n            wptr_sync <= wptr_gray;\n        end\n    end\n    \n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            rptr_sync <= 0;\n        end else begin\n            rptr_sync <= rptr_gray;\n        end\n    end\n    \n    // Write logic\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            wptr <= 0;\n            wptr_gray <= 0;\n        end else if (wr && !full) begin\n            mem[wptr[ADDR_WIDTH-1:0]] <= d;\n            wptr <= wptr + 1;\n            wptr_gray <= (wptr + 1) ^ ((wptr + 1) >> 1);\n        end\n    end\n    \n    // Read logic\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            rptr <= 0;\n            rptr_gray <= 0;\n        end else if (rd && !empty) begin\n            q <= mem[rptr[ADDR_WIDTH-1:0]];\n            rptr <= rptr + 1;\n            rptr_gray <= (rptr + 1) ^ ((rptr + 1) >> 1);\n        end\n    end\n    \n    // Status flags\n    assign full = (wptr[ADDR_WIDTH-1:0] == rptr_sync[ADDR_WIDTH-1:0]) && \n                  (wptr[ADDR_WIDTH] != rptr_sync[ADDR_WIDTH]);\n    assign empty = (rptr == wptr_sync);\n    assign mem_empt = DEPTH - (wptr - rptr_sync);\n    \nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 12, "code": "module sd_fifo_rx_filler (\n    input  wire         clk,\n    input  wire         rst,\n    output reg  [31:0]  m_wb_adr_o,\n    output reg          m_wb_we_o,\n    output reg  [31:0]  m_wb_dat_o,\n    output reg          m_wb_cyc_o,\n    output reg          m_wb_stb_o,\n    input  wire         m_wb_ack_i,\n    output reg  [2:0]   m_wb_cti_o,\n    output reg  [2:0]   m_wb_bte_o,\n    input  wire         en,\n    input  wire [31:0]  adr,\n    input  wire         sd_clk,\n    input  wire [3:0]   dat_i,\n    input  wire         wr,\n    output wire         full,\n    output wire         empty\n);\n\n    // Internal registers\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n    \n    // FIFO signals\n    wire [31:0] dat_o;\n    wire [1:0] mem_empt;\n    \n    // Instantiate RX FIFO\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .mem_empt(mem_empt),\n        .rclk(clk),\n        .rst(rst | reset_rx_fifo)\n    );\n    \n    // State machine\n    localparam IDLE = 1'b0;\n    localparam WB_WRITE = 1'b1;\n    reg state;\n    \n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all control signals\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            state <= IDLE;\n        end else begin\n            if (!en) begin\n                // Disabled state\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                offset <= 9'b0;\n                wb_free <= 1'b1;\n                reset_rx_fifo <= 1'b1;\n                rd <= 1'b0;\n                state <= IDLE;\n            end else begin\n                reset_rx_fifo <= 1'b0;\n                \n                case (state)\n                    IDLE: begin\n                        if (!empty && wb_free) begin\n                            // Prepare Wishbone write\n                            m_wb_adr_o <= adr + offset;\n                            m_wb_dat_o <= dat_o;\n                            m_wb_we_o <= 1'b1;\n                            m_wb_cyc_o <= 1'b1;\n                            m_wb_stb_o <= 1'b1;\n                            m_wb_cti_o <= 3'b000; // Classic cycle\n                            m_wb_bte_o <= 2'b00;  // Linear burst\n                            rd <= 1'b1;\n                            wb_free <= 1'b0;\n                            state <= WB_WRITE;\n                        end else begin\n                            rd <= 1'b0;\n                        end\n                    end\n                    \n                    WB_WRITE: begin\n                        if (m_wb_ack_i) begin\n                            // Transaction complete\n                            m_wb_we_o <= 1'b0;\n                            m_wb_cyc_o <= 1'b0;\n                            m_wb_stb_o <= 1'b0;\n                            offset <= offset + `MEM_OFFSET;\n                            wb_free <= 1'b1;\n                            rd <= 1'b0;\n                            state <= IDLE;\n                        end\n                    end\n                endcase\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 12, "code": "module sd_tx_fifo (\n    input  wire                  wclk,\n    input  wire                  rclk,\n    input  wire                  rst,\n    input  wire [31:0]           d,\n    input  wire                  wr,\n    output wire [31:0]           q,\n    input  wire                  rd,\n    output wire                  full,\n    output wire                  empty,\n    output wire [5:0]            mem_empt\n);\n\n    // Memory array\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    \n    // Write pointer and gray-coded version\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray;\n    \n    // Read pointer and gray-coded version\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_gray;\n    \n    // Synchronizers for cross-clock domain signals\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray_sync1;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray_sync2;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_gray_sync1;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_gray_sync2;\n    \n    // Convert gray code to binary\n    function [FIFO_TX_MEM_ADR_SIZE-1:0] gray2bin;\n        input [FIFO_TX_MEM_ADR_SIZE-1:0] gray;\n        integer i;\n        begin\n            gray2bin[FIFO_TX_MEM_ADR_SIZE-1] = gray[FIFO_TX_MEM_ADR_SIZE-1];\n            for (i = FIFO_TX_MEM_ADR_SIZE-2; i >= 0; i = i - 1)\n                gray2bin[i] = gray2bin[i+1] ^ gray[i];\n        end\n    endfunction\n    \n    // Write clock domain logic\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            adr_i_gray <= 0;\n        end else begin\n            if (wr && !full) begin\n                ram[adr_i[FIFO_TX_MEM_ADR_SIZE-2:0]] <= d;\n                adr_i <= adr_i + 1;\n                adr_i_gray <= (adr_i + 1) ^ ((adr_i + 1) >> 1);\n            end\n        end\n    end\n    \n    // Read clock domain logic\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            adr_o_gray <= 0;\n        end else begin\n            if (rd && !empty) begin\n                adr_o <= adr_o + 1;\n                adr_o_gray <= (adr_o + 1) ^ ((adr_o + 1) >> 1);\n            end\n        end\n    end\n    \n    // Synchronize write pointer to read clock domain\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_i_gray_sync1 <= 0;\n            adr_i_gray_sync2 <= 0;\n        end else begin\n            adr_i_gray_sync1 <= adr_i_gray;\n            adr_i_gray_sync2 <= adr_i_gray_sync1;\n        end\n    end\n    \n    // Synchronize read pointer to write clock domain\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_o_gray_sync1 <= 0;\n            adr_o_gray_sync2 <= 0;\n        end else begin\n            adr_o_gray_sync1 <= adr_o_gray;\n            adr_o_gray_sync2 <= adr_o_gray_sync1;\n        end\n    end\n    \n    // Convert synchronized gray pointers to binary\n    wire [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_bin_rclk = gray2bin(adr_i_gray_sync2);\n    wire [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_bin_wclk = gray2bin(adr_o_gray_sync2);\n    \n    // Generate full and empty flags\n    assign full = (adr_i[FIFO_TX_MEM_ADR_SIZE-2:0] == adr_o_bin_wclk[FIFO_TX_MEM_ADR_SIZE-2:0]) && \n                  (adr_i[FIFO_TX_MEM_ADR_SIZE-1] != adr_o_bin_wclk[FIFO_TX_MEM_ADR_SIZE-1]);\n    \n    assign empty = (adr_i_bin_rclk == adr_o);\n    \n    // Calculate memory occupancy\n    assign mem_empt = (adr_i_bin_rclk - adr_o) & {FIFO_TX_MEM_ADR_SIZE{1'b1}};\n    \n    // Data output\n    assign q = ram[adr_o[FIFO_TX_MEM_ADR_SIZE-2:0]];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 13, "code": "module sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    input wire rclk,\n    output wire full,\n    output wire empty,\n    output wire [5:0] mem_empt,\n    input wire rst\n);\n\n    // Memory array\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    \n    // Write pointer and gray-coded version\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i = 0;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray = 0;\n    \n    // Read pointer and gray-coded version\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o = 0;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_gray = 0;\n    \n    // Synchronizers for cross-clock domain signals\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray_sync1 = 0;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray_sync2 = 0;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_gray_sync1 = 0;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_gray_sync2 = 0;\n    \n    // Convert gray code to binary\n    function [FIFO_TX_MEM_ADR_SIZE-1:0] gray2bin;\n        input [FIFO_TX_MEM_ADR_SIZE-1:0] gray;\n        integer i;\n        begin\n            gray2bin[FIFO_TX_MEM_ADR_SIZE-1] = gray[FIFO_TX_MEM_ADR_SIZE-1];\n            for (i = FIFO_TX_MEM_ADR_SIZE-2; i >= 0; i = i - 1)\n                gray2bin[i] = gray2bin[i+1] ^ gray[i];\n        end\n    endfunction\n    \n    // Write clock domain logic\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            adr_i_gray <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i[FIFO_TX_MEM_ADR_SIZE-2:0]] <= d;\n            adr_i <= adr_i + 1;\n            adr_i_gray <= (adr_i + 1) ^ ((adr_i + 1) >> 1);\n        end\n    end\n    \n    // Read clock domain logic\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            adr_o_gray <= 0;\n            q <= 0;\n        end else begin\n            if (rd && !empty) begin\n                q <= ram[adr_o[FIFO_TX_MEM_ADR_SIZE-2:0]];\n                adr_o <= adr_o + 1;\n                adr_o_gray <= (adr_o + 1) ^ ((adr_o + 1) >> 1);\n            end\n        end\n    end\n    \n    // Synchronize write pointer to read clock domain\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_i_gray_sync1 <= 0;\n            adr_i_gray_sync2 <= 0;\n        end else begin\n            adr_i_gray_sync1 <= adr_i_gray;\n            adr_i_gray_sync2 <= adr_i_gray_sync1;\n        end\n    end\n    \n    // Synchronize read pointer to write clock domain\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_o_gray_sync1 <= 0;\n            adr_o_gray_sync2 <= 0;\n        end else begin\n            adr_o_gray_sync1 <= adr_o_gray;\n            adr_o_gray_sync2 <= adr_o_gray_sync1;\n        end\n    end\n    \n    // Generate full and empty flags\n    assign empty = (adr_o_gray == adr_i_gray_sync2);\n    assign full = (adr_i_gray == {~adr_o_gray_sync2[FIFO_TX_MEM_ADR_SIZE-1:FIFO_TX_MEM_ADR_SIZE-2], \n                                 adr_o_gray_sync2[FIFO_TX_MEM_ADR_SIZE-3:0]});\n    \n    // Calculate FIFO occupancy (mem_empt)\n    wire [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_sync = gray2bin(adr_i_gray_sync2);\n    wire [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_sync = gray2bin(adr_o_gray);\n    wire [FIFO_TX_MEM_ADR_SIZE-1:0] diff = adr_i_sync - adr_o_sync;\n    \n    assign mem_empt = diff[5:0];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 14, "code": "module sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    output wire full,\n    output wire empty,\n    output wire [5:0] mem_empt,\n    input wire rclk,\n    input wire rst\n);\n\nparameter FIFO_TX_MEM_DEPTH = 32; // Example value, should be defined in sd_defines.v\nparameter FIFO_TX_MEM_ADR_SIZE = 6; // log2(FIFO_TX_MEM_DEPTH)+1\n\nreg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray, adr_o_gray;\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray_sync, adr_o_gray_sync;\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray_sync_r, adr_o_gray_sync_r;\n\n// Write domain\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        adr_i_gray <= 0;\n    end else if (wr && !full) begin\n        ram[adr_i[FIFO_TX_MEM_ADR_SIZE-2:0]] <= d;\n        adr_i <= adr_i + 1;\n        adr_i_gray <= (adr_i + 1) ^ ((adr_i + 1) >> 1);\n    end\nend\n\n// Read domain\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        adr_o_gray <= 0;\n        q <= 0;\n    end else begin\n        if (rd && !empty) begin\n            q <= ram[adr_o[FIFO_TX_MEM_ADR_SIZE-2:0]];\n            adr_o <= adr_o + 1;\n            adr_o_gray <= (adr_o + 1) ^ ((adr_o + 1) >> 1);\n        end\n    end\nend\n\n// Synchronize write pointer to read clock domain\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_i_gray_sync <= 0;\n        adr_i_gray_sync_r <= 0;\n    end else begin\n        adr_i_gray_sync <= adr_i_gray;\n        adr_i_gray_sync_r <= adr_i_gray_sync;\n    end\nend\n\n// Synchronize read pointer to write clock domain\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_o_gray_sync <= 0;\n        adr_o_gray_sync_r <= 0;\n    end else begin\n        adr_o_gray_sync <= adr_o_gray;\n        adr_o_gray_sync_r <= adr_o_gray_sync;\n    end\nend\n\n// Convert gray code back to binary for comparison\nfunction [FIFO_TX_MEM_ADR_SIZE-1:0] gray2bin;\n    input [FIFO_TX_MEM_ADR_SIZE-1:0] gray;\n    integer i;\n    begin\n        gray2bin[FIFO_TX_MEM_ADR_SIZE-1] = gray[FIFO_TX_MEM_ADR_SIZE-1];\n        for (i = FIFO_TX_MEM_ADR_SIZE-2; i >= 0; i = i-1)\n            gray2bin[i] = gray2bin[i+1] ^ gray[i];\n    end\nendfunction\n\n// Generate status signals\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_bin, adr_o_bin;\n\nalways @(*) begin\n    adr_i_bin = gray2bin(adr_i_gray_sync_r);\n    adr_o_bin = gray2bin(adr_o_gray);\nend\n\nassign empty = (adr_o_gray == adr_i_gray_sync_r);\n\nalways @(*) begin\n    adr_i_bin = gray2bin(adr_i_gray);\n    adr_o_bin = gray2bin(adr_o_gray_sync_r);\nend\n\nassign full = ((adr_i_bin[FIFO_TX_MEM_ADR_SIZE-1] != adr_o_bin[FIFO_TX_MEM_ADR_SIZE-1]) && \n              (adr_i_bin[FIFO_TX_MEM_ADR_SIZE-2:0] == adr_o_bin[FIFO_TX_MEM_ADR_SIZE-2:0]));\n\n// Calculate FIFO occupancy\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_sync, adr_o_sync;\n\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_i_sync <= 0;\n        adr_o_sync <= 0;\n    end else begin\n        adr_i_sync <= gray2bin(adr_i_gray_sync_r);\n        adr_o_sync <= adr_o;\n    end\nend\n\nassign mem_empt = adr_i_sync - adr_o_sync;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 15, "code": "module sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    input wire rclk,\n    output wire full,\n    output wire empty,\n    output wire [5:0] mem_empt,\n    input wire rst\n);\n\n// Memory array\nreg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n\n// Pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i; // Write pointer\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o; // Read pointer\n\n// Synchronizers for cross-clock domain signals\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_sync1, adr_i_sync2;\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_sync1, adr_o_sync2;\n\n// Write clock domain logic\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n    end else if (wr && !full) begin\n        ram[adr_i[FIFO_TX_MEM_ADR_SIZE-2:0]] <= d;\n        adr_i <= adr_i + 1;\n    end\nend\n\n// Read clock domain logic\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o[FIFO_TX_MEM_ADR_SIZE-2:0]];\n        adr_o <= adr_o + 1;\n    end\nend\n\n// Synchronize write pointer to read clock domain\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_i_sync1 <= 0;\n        adr_i_sync2 <= 0;\n    end else begin\n        adr_i_sync1 <= adr_i;\n        adr_i_sync2 <= adr_i_sync1;\n    end\nend\n\n// Synchronize read pointer to write clock domain\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_o_sync1 <= 0;\n        adr_o_sync2 <= 0;\n    end else begin\n        adr_o_sync1 <= adr_o;\n        adr_o_sync2 <= adr_o_sync1;\n    end\nend\n\n// Full and empty generation\nassign empty = (adr_i_sync2 == adr_o);\nassign full = ((adr_i[FIFO_TX_MEM_ADR_SIZE-1] != adr_o_sync2[FIFO_TX_MEM_ADR_SIZE-1]) && \n              (adr_i[FIFO_TX_MEM_ADR_SIZE-2:0] == adr_o_sync2[FIFO_TX_MEM_ADR_SIZE-2:0]));\n\n// FIFO occupancy calculation\nassign mem_empt = (adr_i[FIFO_TX_MEM_ADR_SIZE-1] == adr_o_sync2[FIFO_TX_MEM_ADR_SIZE-1]) ?\n                 (adr_i[FIFO_TX_MEM_ADR_SIZE-2:0] - adr_o_sync2[FIFO_TX_MEM_ADR_SIZE-2:0]) :\n                 (FIFO_TX_MEM_DEPTH - adr_o_sync2[FIFO_TX_MEM_ADR_SIZE-2:0] + adr_i[FIFO_TX_MEM_ADR_SIZE-2:0]);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 13, "code": "module sd_fifo_rx_filler (\n    input  wire         clk,\n    input  wire         rst,\n    output reg  [31:0]  m_wb_adr_o,\n    output reg          m_wb_we_o,\n    output reg  [31:0]  m_wb_dat_o,\n    output reg          m_wb_cyc_o,\n    output reg          m_wb_stb_o,\n    input  wire         m_wb_ack_i,\n    output wire [2:0]   m_wb_cti_o,\n    output wire [2:0]   m_wb_bte_o,\n    input  wire         en,\n    input  wire [31:0]  adr,\n    input  wire         sd_clk,\n    input  wire [3:0]   dat_i,\n    input  wire         wr,\n    output wire         full,\n    output wire         empty\n);\n\n    // Parameters\n    parameter MEM_OFFSET = 4; // Address increment between words\n\n    // Internal signals\n    reg  [8:0]  offset;\n    reg         wb_free;\n    reg         reset_rx_fifo;\n    reg         rd;\n    wire [31:0] dat_o;\n    wire        fifo_empty;\n    wire        fifo_full;\n\n    // State machine\n    reg [1:0] state;\n    localparam IDLE     = 2'b00;\n    localparam READ_FIFO = 2'b01;\n    localparam WB_WRITE = 2'b10;\n\n    // FIFO instance\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fifo_full),\n        .empty(fifo_empty),\n        .rclk(clk),\n        .rst(rst | reset_rx_fifo)\n    );\n\n    assign full = fifo_full;\n    assign empty = fifo_empty;\n    assign m_wb_cti_o = 3'b000; // Classic cycle\n    assign m_wb_bte_o = 2'b00;  // Linear burst\n\n    // Main state machine\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            m_wb_adr_o <= 32'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    m_wb_we_o <= 1'b0;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    rd <= 1'b0;\n                    \n                    if (en) begin\n                        reset_rx_fifo <= 1'b0;\n                        if (!fifo_empty && wb_free) begin\n                            rd <= 1'b1;\n                            state <= READ_FIFO;\n                        end\n                    end else begin\n                        reset_rx_fifo <= 1'b1;\n                        offset <= 9'b0;\n                        wb_free <= 1'b1;\n                    end\n                end\n                \n                READ_FIFO: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_dat_o <= dat_o;\n                    m_wb_we_o <= 1'b1;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    wb_free <= 1'b0;\n                    rd <= 1'b0;\n                    state <= WB_WRITE;\n                end\n                \n                WB_WRITE: begin\n                    if (m_wb_ack_i) begin\n                        m_wb_we_o <= 1'b0;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        offset <= offset + MEM_OFFSET;\n                        wb_free <= 1'b1;\n                        state <= IDLE;\n                    end\n                end\n                \n                default: state <= IDLE;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule sd_rx_fifo (\n    input  wire [3:0]  d,\n    input  wire        wr,\n    input  wire        wclk,\n    output wire [31:0] q,\n    input  wire        rd,\n    output wire        full,\n    output wire        empty,\n    output wire [1:0]  mem_empt,\n    input  wire        rclk,\n    input  wire        rst\n);\n\n    // FIFO implementation would go here\n    // This is a placeholder for the actual FIFO implementation\n    \n    // For simulation purposes:\n    reg [31:0] mem [0:15]; // Example 16-entry FIFO\n    reg [4:0] wptr, rptr;\n    reg [4:0] count;\n    \n    assign full = (count == 16);\n    assign empty = (count == 0);\n    assign mem_empt = count[1:0];\n    assign q = mem[rptr[3:0]];\n    \n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            wptr <= 0;\n        end else if (wr && !full) begin\n            mem[wptr[3:0]] <= {mem[wptr[3:0]][27:0], d};\n            if (wptr[1:0] == 2'b11) begin\n                wptr <= wptr + 1;\n            end else begin\n                wptr[1:0] <= wptr[1:0] + 1;\n            end\n        end\n    end\n    \n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            rptr <= 0;\n            count <= 0;\n        end else begin\n            if (wr && !full && !(rd && !empty)) begin\n                count <= count + 1;\n            end else if (rd && !empty && !(wr && !full)) begin\n                rptr <= rptr + 1;\n                count <= count - 1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 16, "code": "module sd_bd (\n    input  wire                     clk,\n    input  wire                     rst,\n    input  wire                     we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0]      free_bd,\n    input  wire                     re_s,\n    output wire                     ack_o_s,\n    input  wire                     a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\nparameter BD_WIDTH = 8;\nparameter RAM_MEM_WIDTH = 32;\n\nlocalparam BD_SIZE = (1 << BD_WIDTH);\n\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\nreg [BD_WIDTH-1:0]      m_wr_pnt;\nreg [BD_WIDTH-1:0]      s_rd_pnt;\nreg [BD_WIDTH-1:0]      free_bd_cnt;\nreg                     new_bw;\nreg                     last_a_cmp;\nreg [1:0]               wr_cnt;\nreg [1:0]               rd_cnt;\n\nwire                    wr_complete;\nwire                    rd_complete;\n\nassign free_bd = free_bd_cnt;\nassign wr_complete = (RAM_MEM_WIDTH == 32) ? (wr_cnt == 1) : (wr_cnt == 3);\nassign rd_complete = (RAM_MEM_WIDTH == 32) ? (rd_cnt == 1) : (rd_cnt == 3);\nassign ack_o_s = (RAM_MEM_WIDTH == 16) ? re_s : rd_complete;\nassign dat_out_s = bd_mem[s_rd_pnt];\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        free_bd_cnt <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n        new_bw <= 0;\n        wr_cnt <= 0;\n        rd_cnt <= 0;\n        last_a_cmp <= 0;\n    end else begin\n        last_a_cmp <= a_cmp;\n        \n        // Write operation\n        if (we_m && (free_bd_cnt > 0)) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= m_wr_pnt + 1;\n            wr_cnt <= wr_cnt + 1;\n            \n            if (wr_complete) begin\n                new_bw <= 1;\n                free_bd_cnt <= free_bd_cnt - 1;\n                wr_cnt <= 0;\n            end else begin\n                new_bw <= 0;\n            end\n        end else begin\n            new_bw <= 0;\n        end\n        \n        // Read operation\n        if (re_s) begin\n            s_rd_pnt <= s_rd_pnt + 1;\n            rd_cnt <= rd_cnt + 1;\n            if (rd_complete) begin\n                rd_cnt <= 0;\n            end\n        end\n        \n        // Release BD on a_cmp rising edge\n        if (RAM_MEM_WIDTH == 16) begin\n            if (a_cmp && !last_a_cmp) begin\n                free_bd_cnt <= free_bd_cnt + 1;\n            end\n        end else begin\n            if (a_cmp) begin\n                free_bd_cnt <= free_bd_cnt + 1;\n            end\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 15, "code": "module sd_fifo_tx_filler (\n    input  wire         clk,\n    input  wire         rst,\n    output wire [31:0]  m_wb_adr_o,\n    output wire         m_wb_we_o,\n    input  wire [31:0]  m_wb_dat_i,\n    output wire         m_wb_cyc_o,\n    output wire         m_wb_stb_o,\n    input  wire         m_wb_ack_i,\n    output wire [2:0]   m_wb_cti_o,\n    output wire [1:0]   m_wb_bte_o,\n    input  wire         en,\n    input  wire [31:0]  adr,\n    input  wire         sd_clk,\n    output wire [31:0]  dat_o,\n    input  wire         rd,\n    output wire         empty,\n    output wire         fe\n);\n\n    // Internal registers\n    reg [8:0]  offset;\n    reg [8:0]  we;\n    reg [31:0] din;\n    reg        wr_tx;\n    reg        reset_tx_fifo;\n    reg        first;\n    reg        ackd;\n    reg        delay;\n\n    // Wishbone interface signals\n    reg        m_wb_cyc;\n    reg        m_wb_stb;\n    reg [31:0] m_wb_adr;\n\n    // FIFO signals\n    wire       full;\n    wire [5:0] mem_empt;\n\n    // Assign outputs\n    assign m_wb_adr_o = m_wb_adr;\n    assign m_wb_we_o  = 1'b0;  // Always read operations\n    assign m_wb_cyc_o = m_wb_cyc;\n    assign m_wb_stb_o = m_wb_stb;\n    assign m_wb_cti_o = 3'b000; // Classic cycle\n    assign m_wb_bte_o = 2'b00;  // Linear burst\n    assign fe         = full;\n\n    // Instantiate the TX FIFO\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .mem_empt(mem_empt),\n        .rclk(sd_clk),\n        .rst(rst | reset_tx_fifo)\n    );\n\n    // Main state machine\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all registers\n            offset        <= 9'b0;\n            we           <= 9'b0;\n            din          <= 32'b0;\n            wr_tx        <= 1'b0;\n            reset_tx_fifo<= 1'b1;\n            first        <= 1'b1;\n            ackd         <= 1'b1;\n            delay        <= 1'b0;\n            \n            // Reset Wishbone signals\n            m_wb_cyc     <= 1'b0;\n            m_wb_stb     <= 1'b0;\n            m_wb_adr     <= 32'b0;\n        end else begin\n            // Default values\n            wr_tx        <= 1'b0;\n            reset_tx_fifo<= 1'b0;\n            \n            if (en) begin\n                // Module is enabled\n                if (!full && !m_wb_ack_i && ackd) begin\n                    // Start new Wishbone transaction\n                    m_wb_adr <= adr + {23'b0, offset};\n                    m_wb_cyc <= 1'b1;\n                    m_wb_stb <= 1'b1;\n                    ackd     <= 1'b0;\n                end\n                \n                if (m_wb_ack_i) begin\n                    // Wishbone transaction acknowledged\n                    din      <= m_wb_dat_i;\n                    wr_tx    <= 1'b1;\n                    m_wb_cyc <= 1'b0;\n                    m_wb_stb <= 1'b0;\n                    delay    <= 1'b1;\n                end\n                \n                if (delay) begin\n                    // Delay state for timing\n                    offset   <= offset + 1'b1;\n                    ackd     <= ~ackd;\n                    wr_tx    <= 1'b0;\n                    delay    <= 1'b0;\n                end\n            end else begin\n                // Module is disabled\n                offset        <= 9'b0;\n                m_wb_cyc      <= 1'b0;\n                m_wb_stb      <= 1'b0;\n                reset_tx_fifo <= 1'b1;\n                ackd          <= 1'b1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 1, "code": "module sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n// State definitions\nlocalparam IDLE    = 3'b001;\nlocalparam SETUP   = 3'b010;\nlocalparam EXECUTE = 3'b100;\n\n// Status bit definitions\nlocalparam dat_ava = 6;\nlocalparam crc_valid = 5;\n\n// Response size definitions\nlocalparam small_rsp = 7'b0101000;\nlocalparam big_rsp = 7'b1111111;\n\n// Internal signals\nreg [2:0] state, next_state;\nreg [3:0] debounce;\nreg card_present;\nreg ack_q, ack_in_int;\nreg req_q, req_in_int;\nreg index_check_enable;\nreg CRC_check_enable;\nreg complete;\nreg [15:0] Watchdog_Cnt;\nreg [6:0] response_size;\nreg [7:0] status;\nreg CIE, CCRCE, CTE, EI, CC;\n\n// Debounce logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0;\n        card_present <= 1'b0;\n    end else begin\n        if (!card_detect) begin\n            if (debounce != 4'b1111)\n                debounce <= debounce + 1'b1;\n        end else begin\n            debounce <= 4'b0;\n        end\n        card_present <= (debounce == 4'b1111) ? 1'b1 : 1'b0;\n    end\nend\n\n// Synchronizers\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        ack_q <= 1'b0;\n        ack_in_int <= 1'b0;\n        req_q <= 1'b0;\n        req_in_int <= 1'b0;\n    end else begin\n        ack_q <= ack_in;\n        ack_in_int <= ack_q;\n        req_q <= req_in;\n        req_in_int <= req_q;\n    end\nend\n\n// FSM state register\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I)\n        state <= IDLE;\n    else\n        state <= next_state;\nend\n\n// FSM next state logic\nalways @(*) begin\n    case (state)\n        IDLE: next_state = New_CMD ? SETUP : IDLE;\n        SETUP: next_state = ack_in_int ? EXECUTE : SETUP;\n        EXECUTE: next_state = complete ? IDLE : EXECUTE;\n        default: next_state = IDLE;\n    endcase\nend\n\n// FSM output logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        // Reset all outputs\n        CRC_check_enable <= 1'b0;\n        complete <= 1'b0;\n        RESP_1_REG <= 32'b0;\n        ERR_INT_REG <= 5'b0;\n        NORMAL_INT_REG <= 16'b0;\n        STATUS_REG <= 16'b0;\n        status <= 8'b0;\n        cmd_out <= 40'b0;\n        settings <= 16'b0;\n        response_size <= 7'b0;\n        req_out <= 1'b0;\n        index_check_enable <= 1'b0;\n        ack_out <= 1'b0;\n        Watchdog_Cnt <= 16'b0;\n        CCRCE <= 1'b0;\n        EI <= 1'b0;\n        CC <= 1'b0;\n        go_idle_o <= 1'b0;\n        CIE <= 1'b0;\n        CTE <= 1'b0;\n    end else begin\n        // Normal operation\n        NORMAL_INT_REG[1] <= card_present;\n        NORMAL_INT_REG[2] <= ~card_present;\n        complete <= 1'b0;\n        \n        // Interrupt reset handling\n        if (ERR_INT_RST) ERR_INT_REG <= 5'b0;\n        if (NORMAL_INT_RST) NORMAL_INT_REG <= 16'b0;\n        \n        case (state)\n            IDLE: begin\n                go_idle_o <= 1'b0;\n                req_out <= 1'b0;\n                ack_out <= 1'b0;\n                STATUS_REG[0] <= 1'b0; // CICMD\n                \n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1'b1;\n                end\n            end\n            \n            SETUP: begin\n                NORMAL_INT_REG <= 16'b0;\n                ERR_INT_REG <= 5'b0;\n                index_check_enable <= CMD_SET_REG[4]; // CICE\n                CRC_check_enable <= CMD_SET_REG[3];   // CRCE\n                \n                // Compose cmd_out\n                cmd_out[39:38] <= 2'b01;\n                cmd_out[37:32] <= CMD_SET_REG[13:8];  // CMDI\n                cmd_out[31:0] <= ARG_REG;\n                \n                // Determine response size\n                case (CMD_SET_REG[1:0]) // RTS\n                    2'b01: response_size <= big_rsp;\n                    2'b10, 2'b11: response_size <= small_rsp;\n                    default: response_size <= 7'b0;\n                endcase\n                \n                // Compose settings\n                settings[14:13] <= CMD_SET_REG[7:6];  // WORD_SELECT\n                settings[12] <= data_read;\n                settings[11] <= data_write;\n                settings[10:8] <= 3'b111;             // Delay\n                settings[7] <= CMD_SET_REG[3];        // CRCE\n                settings[6:0] <= response_size;\n                \n                Watchdog_Cnt <= 16'b0;\n                STATUS_REG[0] <= 1'b1;                // CICMD\n            end\n            \n            EXECUTE: begin\n                Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                \n                // Timeout handling\n                if (Watchdog_Cnt > TIMEOUT_REG) begin\n                    CTE <= 1'b1;\n                    EI <= 1'b1;\n                    ERR_INT_REG[0] <= 1'b1; // CTE\n                    NORMAL_INT_REG[15] <= 1'b1; // EI\n                    if (ack_in) complete <= 1'b1;\n                    go_idle_o <= 1'b1;\n                end\n                \n                // Request handling\n                if (ack_in_int) begin\n                    req_out <= 1'b1;\n                end\n                \n                // Status handling\n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1'b1;\n                    \n                    if (status[dat_ava]) begin\n                        complete <= 1'b1;\n                        EI <= 1'b0;\n                        \n                        // CRC check\n                        if (CRC_check_enable && !status[crc_valid]) begin\n                            CCRCE <= 1'b1;\n                            EI <= 1'b1;\n                            ERR_INT_REG[1] <= 1'b1; // CCRCE\n                            NORMAL_INT_REG[15] <= 1'b1; // EI\n                        end\n                        \n                        // Index check\n                        if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                            CIE <= 1'b1;\n                            EI <= 1'b1;\n                            ERR_INT_REG[3] <= 1'b1; // CIE\n                            NORMAL_INT_REG[15] <= 1'b1; // EI\n                        end\n                        \n                        CC <= 1'b1;\n                        NORMAL_INT_REG[0] <= 1'b1; // CC\n                        \n                        // Store response if needed\n                        if (response_size != 7'b0) begin\n                            RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 13, "code": "module sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    input wire rclk,\n    output wire full,\n    output wire empty,\n    output wire [1:0] mem_empt,\n    input wire rst\n);\n\nparameter FIFO_RX_MEM_DEPTH = 16; // Example value, should be defined in sd_defines.v\nparameter FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH) + 1;\n\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_gray, adr_o_gray;\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_gray_sync, adr_o_gray_sync;\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_gray_sync_r, adr_o_gray_sync_r;\n\n// Binary to Gray code conversion\nfunction [FIFO_RX_MEM_ADR_SIZE-1:0] bin2gray;\n    input [FIFO_RX_MEM_ADR_SIZE-1:0] bin;\n    begin\n        bin2gray = bin ^ (bin >> 1);\n    end\nendfunction\n\n// Gray to binary conversion\nfunction [FIFO_RX_MEM_ADR_SIZE-1:0] gray2bin;\n    input [FIFO_RX_MEM_ADR_SIZE-1:0] gray;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] bin;\n    integer i;\n    begin\n        bin[FIFO_RX_MEM_ADR_SIZE-1] = gray[FIFO_RX_MEM_ADR_SIZE-1];\n        for (i = FIFO_RX_MEM_ADR_SIZE-2; i >= 0; i = i - 1)\n            bin[i] = bin[i+1] ^ gray[i];\n        gray2bin = bin;\n    end\nendfunction\n\nassign adr_i_gray = bin2gray(adr_i);\nassign adr_o_gray = bin2gray(adr_o);\n\n// Full and empty flags\nassign full = (adr_i[FIFO_RX_MEM_ADR_SIZE-1] != adr_o[FIFO_RX_MEM_ADR_SIZE-1]) && \n              (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] == adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]);\nassign empty = (adr_i == adr_o);\n\n// Memory empty space calculation\nassign mem_empt = (adr_i[FIFO_RX_MEM_ADR_SIZE-1] == adr_o[FIFO_RX_MEM_ADR_SIZE-1]) ? \n                 (FIFO_RX_MEM_DEPTH - (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] - adr_o[FIFO_RX_MEM_ADR_SIZE-2:0])) :\n                 (adr_o[FIFO_RX_MEM_ADR_SIZE-2:0] - adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]);\n\n// Write clock domain\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n    end else begin\n        if (wr && !full) begin\n            case (we)\n                8'h1: tmp[3:0] <= d;\n                8'h2: tmp[7:4] <= d;\n                8'h4: tmp[11:8] <= d;\n                8'h8: tmp[15:12] <= d;\n                8'h10: tmp[19:16] <= d;\n                8'h20: tmp[23:20] <= d;\n                8'h40: tmp[27:24] <= d;\n                8'h80: tmp[31:28] <= d;\n            endcase\n            \n            if (we == 8'h80) begin\n                ram[adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]] <= tmp;\n                adr_i <= adr_i + 1;\n                we <= 8'h1;\n                ft <= 1;\n            end else begin\n                we <= we << 1;\n                ft <= 0;\n            end\n        end\n    end\nend\n\n// Read clock domain\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else begin\n        if (rd && !empty) begin\n            q <= ram[adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]];\n            adr_o <= adr_o + 1;\n        end\n    end\nend\n\n// Clock domain crossing synchronization\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_o_gray_sync <= 0;\n        adr_o_gray_sync_r <= 0;\n    end else begin\n        adr_o_gray_sync <= adr_o_gray;\n        adr_o_gray_sync_r <= adr_o_gray_sync;\n    end\nend\n\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_i_gray_sync <= 0;\n        adr_i_gray_sync_r <= 0;\n    end else begin\n        adr_i_gray_sync <= adr_i_gray;\n        adr_i_gray_sync_r <= adr_i_gray_sync;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 14, "code": "module sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    input wire rclk,\n    output wire full,\n    output wire empty,\n    output wire [1:0] mem_empt,\n    input wire rst\n);\n\nparameter FIFO_RX_MEM_DEPTH = 16; // Example value, should be defined in sd_defines.v\nparameter FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH) + 1;\n\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_next = adr_i + 1'b1;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o_next = adr_o + 1'b1;\n\n// Full and empty flags\nassign full = (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] == adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]) && \n              (adr_i[FIFO_RX_MEM_ADR_SIZE-1] != adr_o[FIFO_RX_MEM_ADR_SIZE-1]);\nassign empty = (adr_i == adr_o);\nassign mem_empt = (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) >> 2; // Approximate empty space in words\n\n// Write operation (wclk domain)\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        we <= 8'h1;\n        tmp <= 32'h0;\n        ft <= 1'b0;\n    end else if (wr && !full) begin\n        case (we)\n            8'h1: tmp[3:0] <= d;\n            8'h2: tmp[7:4] <= d;\n            8'h4: tmp[11:8] <= d;\n            8'h8: tmp[15:12] <= d;\n            8'h10: tmp[19:16] <= d;\n            8'h20: tmp[23:20] <= d;\n            8'h40: tmp[27:24] <= d;\n            8'h80: tmp[31:28] <= d;\n        endcase\n        \n        if (we == 8'h80) begin\n            ram[adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]] <= tmp;\n            adr_i <= adr_i_next;\n            we <= 8'h1;\n            ft <= 1'b1;\n        end else begin\n            we <= we << 1;\n            ft <= 1'b0;\n        end\n    end\nend\n\n// Read operation (rclk domain)\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 32'h0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]];\n        adr_o <= adr_o_next;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 16, "code": "module sd_fifo_tx_filler (\n    input  wire         clk,\n    input  wire         rst,\n    output reg  [31:0]  m_wb_adr_o,\n    output reg          m_wb_we_o,\n    input  wire [31:0]  m_wb_dat_i,\n    output reg          m_wb_cyc_o,\n    output reg          m_wb_stb_o,\n    input  wire         m_wb_ack_i,\n    output wire [2:0]   m_wb_cti_o,\n    output wire [1:0]   m_wb_bte_o,\n    input  wire         en,\n    input  wire [31:0]  adr,\n    input  wire         sd_clk,\n    output wire [31:0]  dat_o,\n    input  wire         rd,\n    output wire         empty,\n    output wire         fe\n);\n\n    // Internal registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Wishbone signals\n    assign m_wb_cti_o = 3'b000;  // Classic cycle\n    assign m_wb_bte_o = 2'b00;   // Linear burst\n\n    // FIFO instance\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),  // Not used in this module\n        .rclk(sd_clk),\n        .rst(rst | reset_tx_fifo)\n    );\n\n    // Main state machine\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all registers\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b1;\n            delay <= 1'b0;\n        end else begin\n            // Default values\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b0;\n            delay <= 1'b0;\n\n            if (en) begin\n                // Module is enabled\n                if (!fe && !m_wb_ack_i && ackd) begin\n                    // Start Wishbone transaction\n                    m_wb_adr_o <= adr + {23'b0, offset};\n                    m_wb_we_o <= 1'b0;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    ackd <= 1'b0;\n                end\n\n                if (m_wb_ack_i) begin\n                    // Wishbone acknowledge received\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n\n                if (delay) begin\n                    // Delay cycle after acknowledge\n                    offset <= offset + 1;\n                    ackd <= ~ackd;\n                end\n            end else begin\n                // Module is disabled\n                m_wb_adr_o <= 32'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                offset <= 9'b0;\n                reset_tx_fifo <= 1'b1;\n                ackd <= 1'b1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 17, "code": "module sd_fifo_tx_filler (\n    input         clk,\n    input         rst,\n    output [31:0] m_wb_adr_o,\n    output        m_wb_we_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    input         en,\n    input  [31:0] adr,\n    input         sd_clk,\n    output [31:0] dat_o,\n    input         rd,\n    output        empty,\n    output        fe\n);\n\n    // Internal registers\n    reg [8:0]  offset;\n    reg [8:0]  we;\n    reg [31:0] din;\n    reg        wr_tx;\n    reg        reset_tx_fifo;\n    reg        first;\n    reg        ackd;\n    reg        delay;\n\n    // Wishbone interface signals\n    assign m_wb_we_o = 1'b0;  // Always read operations\n    assign m_wb_cti_o = 3'b000;\n    assign m_wb_bte_o = 2'b00;\n    assign m_wb_adr_o = adr + {offset, 2'b00};  // Word addressing\n\n    // FIFO signals\n    wire full;\n    assign fe = full;\n\n    // Instantiate the TX FIFO\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(sd_clk),\n        .rst(rst | reset_tx_fifo)\n    );\n\n    // Main state machine\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all registers\n            offset <= 9'h0;\n            we <= 9'h0;\n            din <= 32'h0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b1;\n            delay <= 1'b0;\n            \n            // Reset Wishbone signals\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n        end else begin\n            // Default values\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b0;\n            delay <= 1'b0;\n            \n            if (en) begin\n                // Module is enabled\n                if (!full && !m_wb_ack_i && ackd) begin\n                    // Start new Wishbone transaction\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    first <= 1'b0;\n                end\n                \n                if (m_wb_ack_i) begin\n                    // Wishbone transaction acknowledged\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                \n                if (delay) begin\n                    // Delay state for timing\n                    offset <= offset + 1;\n                    ackd <= ~ackd;\n                    wr_tx <= 1'b0;\n                end\n            end else begin\n                // Module is disabled\n                reset_tx_fifo <= 1'b1;\n                offset <= 9'h0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                first <= 1'b1;\n                ackd <= 1'b1;\n            end\n        end\n    end\n\nendmodule\n\nmodule sd_tx_fifo (\n    input  [31:0] d,\n    input         wr,\n    input         wclk,\n    output [31:0] q,\n    input         rd,\n    output        full,\n    output        empty,\n    output [5:0]  mem_empt,\n    input         rclk,\n    input         rst\n);\n\n    // FIFO parameters\n    parameter FIFO_DEPTH = 16;\n    parameter ADDR_WIDTH = 4;\n    \n    // FIFO memory\n    reg [31:0] mem [0:FIFO_DEPTH-1];\n    \n    // Pointers\n    reg [ADDR_WIDTH:0] wptr, rptr;\n    \n    // Synchronization registers\n    reg [ADDR_WIDTH:0] wptr_sync, rptr_sync;\n    \n    // Full/empty flags\n    wire full_wclk = (wptr[ADDR_WIDTH-1:0] == rptr_sync[ADDR_WIDTH-1:0]) && \n                    (wptr[ADDR_WIDTH] != rptr_sync[ADDR_WIDTH]);\n    wire empty_rclk = (rptr == wptr_sync);\n    \n    assign full = full_wclk;\n    assign empty = empty_rclk;\n    \n    // Memory occupancy (write clock domain)\n    assign mem_empt = FIFO_DEPTH - (wptr - rptr_sync);\n    \n    // Write pointer logic (write clock domain)\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            wptr <= 0;\n        end else if (wr && !full_wclk) begin\n            mem[wptr[ADDR_WIDTH-1:0]] <= d;\n            wptr <= wptr + 1;\n        end\n    end\n    \n    // Read pointer logic (read clock domain)\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            rptr <= 0;\n        end else if (rd && !empty_rclk) begin\n            q <= mem[rptr[ADDR_WIDTH-1:0]];\n            rptr <= rptr + 1;\n        end\n    end\n    \n    // Synchronize write pointer to read clock domain\n    always @(posedge rclk) begin\n        wptr_sync <= wptr;\n    end\n    \n    // Synchronize read pointer to write clock domain\n    always @(posedge wclk) begin\n        rptr_sync <= rptr;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 15, "code": "module sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    input wire rclk,\n    output wire full,\n    output wire empty,\n    output wire [1:0] mem_empt,\n    input wire rst\n);\n\nparameter FIFO_RX_MEM_DEPTH = 16; // Example value, should be defined in sd_defines.v\nparameter FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH) + 1;\n\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_next = adr_i + 1'b1;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o_next = adr_o + 1'b1;\n\n// Full and empty flags\nassign full = (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] == adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]) && \n              (adr_i[FIFO_RX_MEM_ADR_SIZE-1] != adr_o[FIFO_RX_MEM_ADR_SIZE-1]);\nassign empty = (adr_i == adr_o);\nassign mem_empt = (adr_i[FIFO_RX_MEM_ADR_SIZE-1] == adr_o[FIFO_RX_MEM_ADR_SIZE-1]) ? \n                  (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] - adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]) : \n                  (FIFO_RX_MEM_DEPTH - adr_o[FIFO_RX_MEM_ADR_SIZE-2:0] + adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]);\n\n// Write operation (wclk domain)\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n    end else if (wr && !full) begin\n        case (we)\n            8'h1: tmp[3:0] <= d;\n            8'h2: tmp[7:4] <= d;\n            8'h4: tmp[11:8] <= d;\n            8'h8: tmp[15:12] <= d;\n            8'h10: tmp[19:16] <= d;\n            8'h20: tmp[23:20] <= d;\n            8'h40: tmp[27:24] <= d;\n            8'h80: begin\n                tmp[31:28] <= d;\n                ft <= 1'b1;\n            end\n        endcase\n        \n        if (we == 8'h80) begin\n            ram[adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]] <= tmp;\n            adr_i <= adr_i_next;\n            we <= 8'h1;\n            ft <= 1'b0;\n        end else begin\n            we <= we << 1;\n        end\n    end\nend\n\n// Read operation (rclk domain)\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]];\n        adr_o <= adr_o_next;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 2, "code": "module sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n    // State definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal signals\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg ack_q, ack_in_int;\n    reg req_q, req_in_int;\n    reg index_check_enable;\n    reg CRC_check_enable;\n    reg complete;\n    reg [7:0] status;\n    reg [6:0] response_size;\n    reg [15:0] Watchdog_Cnt;\n    reg CCRCE;\n    reg EI;\n    reg CC;\n    reg CICMD;\n\n    // Response size constants\n    localparam small_rsp = 7'b0101000;\n    localparam big_rsp = 7'b1111111;\n\n    // Status bits\n    wire dat_ava = status[6];\n    wire crc_valid = status[5];\n\n    // Synchronizers for req_in and ack_in\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            ack_q <= 0;\n            ack_in_int <= 0;\n            req_q <= 0;\n            req_in_int <= 0;\n        end else begin\n            ack_q <= ack_in;\n            ack_in_int <= ack_q;\n            req_q <= req_in;\n            req_in_int <= req_q;\n        end\n    end\n\n    // Debounce logic for card detection\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 0;\n            card_present <= 0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n            end else begin\n                debounce <= 0;\n            end\n            \n            card_present <= (debounce == 4'b1111) ? 1 : 0;\n        end\n    end\n\n    // State register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = New_CMD ? SETUP : IDLE;\n            SETUP: next_state = ack_in_int ? EXECUTE : SETUP;\n            EXECUTE: next_state = complete ? IDLE : EXECUTE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State operations\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            // Reset all registers\n            CRC_check_enable <= 0;\n            complete <= 0;\n            RESP_1_REG <= 0;\n            ERR_INT_REG <= 0;\n            NORMAL_INT_REG <= 0;\n            STATUS_REG <= 0;\n            status <= 0;\n            cmd_out <= 0;\n            settings <= 0;\n            response_size <= 0;\n            req_out <= 0;\n            index_check_enable <= 0;\n            ack_out <= 0;\n            Watchdog_Cnt <= 0;\n            CCRCE <= 0;\n            EI <= 0;\n            CC <= 0;\n            go_idle_o <= 0;\n            CICMD <= 0;\n        end else begin\n            // Update card presence in NORMAL_INT_REG\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            \n            // Reset complete flag\n            complete <= 0;\n            \n            // Handle interrupt resets\n            if (ERR_INT_RST) ERR_INT_REG <= 0;\n            if (NORMAL_INT_RST) NORMAL_INT_REG <= 0;\n            \n            case (state)\n                IDLE: begin\n                    go_idle_o <= 0;\n                    req_out <= 0;\n                    ack_out <= 0;\n                    CICMD <= 0;\n                    \n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1;\n                    end\n                end\n                \n                SETUP: begin\n                    NORMAL_INT_REG <= 0;\n                    ERR_INT_REG <= 0;\n                    index_check_enable <= CMD_SET_REG[4]; // CICE\n                    CRC_check_enable <= CMD_SET_REG[3];   // CRCE\n                    \n                    // Compose cmd_out\n                    cmd_out[39:38] <= 2'b01;\n                    cmd_out[37:32] <= CMD_SET_REG[13:8];  // CMDI\n                    cmd_out[31:0] <= ARG_REG;\n                    \n                    // Determine response size\n                    case (CMD_SET_REG[1:0]) // RTS\n                        2'b10, 2'b11: response_size <= small_rsp;\n                        2'b01: response_size <= big_rsp;\n                        default: response_size <= 0;\n                    endcase\n                    \n                    // Compose settings\n                    settings[14:13] <= CMD_SET_REG[7:6];  // WORD_SELECT\n                    settings[12] <= data_read;\n                    settings[11] <= data_write;\n                    settings[10:8] <= 3'b111;             // Delay\n                    settings[7] <= CMD_SET_REG[3];        // CRCE\n                    settings[6:0] <= response_size;\n                    \n                    Watchdog_Cnt <= 0;\n                    CICMD <= 1;\n                end\n                \n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1;\n                    \n                    // Timeout handling\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1; // CTE\n                        NORMAL_INT_REG[15] <= 1; // EI\n                        if (ack_in) complete <= 1;\n                        go_idle_o <= 1;\n                    end\n                    \n                    // Request handling\n                    if (ack_in_int) begin\n                        req_out <= 1;\n                    end\n                    \n                    // Status handling\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1;\n                        \n                        if (dat_ava) begin\n                            complete <= 1;\n                            NORMAL_INT_REG[15] <= 0; // Clear EI\n                            \n                            // CRC check\n                            if (CRC_check_enable && !crc_valid) begin\n                                ERR_INT_REG[1] <= 1; // CCRCE\n                                NORMAL_INT_REG[15] <= 1; // EI\n                            end\n                            \n                            // Index check\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1; // CIE\n                                NORMAL_INT_REG[15] <= 1; // EI\n                            end\n                            \n                            NORMAL_INT_REG[0] <= 1; // CC\n                            \n                            // Store response if needed\n                            if (response_size != 0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 17, "code": "module sd_bd (\n    input  wire                     clk,\n    input  wire                     rst,\n    input  wire                     we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0]      free_bd,\n    input  wire                     re_s,\n    output wire                     ack_o_s,\n    input  wire                     a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Internal registers\nreg [BD_WIDTH-1:0] m_wr_pnt;\nreg [BD_WIDTH-1:0] s_rd_pnt;\nreg [BD_WIDTH-1:0] free_bd_cnt;\nreg [1:0]          wr_cnt;\nreg [1:0]          rd_cnt;\nreg                new_bw;\nreg                last_a_cmp;\nreg                ack_o_s_reg;\n\n// Memory for buffer descriptors\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n\n// Assign outputs\nassign free_bd = free_bd_cnt;\nassign ack_o_s = ack_o_s_reg;\nassign dat_out_s = bd_mem[s_rd_pnt];\n\n// Initialize pointers and counters\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        wr_cnt <= 0;\n        rd_cnt <= 0;\n        new_bw <= 0;\n        ack_o_s_reg <= 0;\n        last_a_cmp <= 0;\n        \n        // Initialize free_bd based on RAM_MEM_WIDTH\n        if (RAM_MEM_WIDTH == 32)\n            free_bd_cnt <= BD_SIZE >> 1;\n        else // 16-bit mode\n            free_bd_cnt <= BD_SIZE >> 2;\n    end\n    else begin\n        // Handle a_cmp rising edge detection\n        last_a_cmp <= a_cmp;\n        \n        // Write operation\n        if (we_m && (free_bd_cnt > 0)) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= m_wr_pnt + 1;\n            wr_cnt <= wr_cnt + 1;\n            \n            // Check if BD write is complete\n            if ((RAM_MEM_WIDTH == 32 && wr_cnt == 1) || \n                (RAM_MEM_WIDTH == 16 && wr_cnt == 3)) begin\n                new_bw <= 1;\n                free_bd_cnt <= free_bd_cnt - 1;\n                wr_cnt <= 0;\n            end\n            else begin\n                new_bw <= 0;\n            end\n        end\n        else begin\n            new_bw <= 0;\n        end\n        \n        // Read operation\n        if (re_s) begin\n            s_rd_pnt <= s_rd_pnt + 1;\n            rd_cnt <= rd_cnt + 1;\n            \n            // Set ack_o_s in 16-bit mode for each read\n            if (RAM_MEM_WIDTH == 16)\n                ack_o_s_reg <= 1;\n            else if (RAM_MEM_WIDTH == 32 && rd_cnt == 1)\n                ack_o_s_reg <= 1;\n            else\n                ack_o_s_reg <= 0;\n                \n            // Reset rd_cnt when BD read is complete\n            if ((RAM_MEM_WIDTH == 32 && rd_cnt == 1) || \n                (RAM_MEM_WIDTH == 16 && rd_cnt == 3)) begin\n                rd_cnt <= 0;\n            end\n        end\n        else begin\n            ack_o_s_reg <= 0;\n        end\n        \n        // Release BD on a_cmp rising edge\n        if (a_cmp && !last_a_cmp) begin\n            free_bd_cnt <= free_bd_cnt + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 14, "code": "module sd_fifo_rx_filler (\n    input  wire         clk,\n    input  wire         rst,\n    output reg  [31:0]  m_wb_adr_o,\n    output reg          m_wb_we_o,\n    output reg  [31:0]  m_wb_dat_o,\n    output reg          m_wb_cyc_o,\n    output reg          m_wb_stb_o,\n    input  wire         m_wb_ack_i,\n    output wire [2:0]   m_wb_cti_o,\n    output wire [2:0]   m_wb_bte_o,\n    input  wire         en,\n    input  wire [31:0]  adr,\n    input  wire         sd_clk,\n    input  wire [3:0]   dat_i,\n    input  wire         wr,\n    output wire         full,\n    output wire         empty\n);\n\n// Local parameters\nlocalparam IDLE = 2'b00;\nlocalparam READ_FIFO = 2'b01;\nlocalparam WB_WRITE = 2'b10;\n\n// Internal registers\nreg [1:0] state;\nreg [1:0] next_state;\nreg [8:0] offset;\nreg       wb_free;\nreg       reset_rx_fifo;\nreg       rd;\n\n// FIFO connections\nwire [31:0] dat_o;\nwire [1:0]  mem_empt;\n\n// State machine\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (en && !empty && wb_free)\n                next_state = READ_FIFO;\n            else\n                next_state = IDLE;\n        end\n        READ_FIFO: begin\n            next_state = WB_WRITE;\n        end\n        WB_WRITE: begin\n            if (m_wb_ack_i)\n                next_state = IDLE;\n            else\n                next_state = WB_WRITE;\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// Output logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wb_adr_o <= 32'b0;\n        m_wb_dat_o <= 32'b0;\n        m_wb_we_o <= 1'b0;\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n        offset <= 9'b0;\n        wb_free <= 1'b1;\n        reset_rx_fifo <= 1'b1;\n        rd <= 1'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                rd <= 1'b0;\n                \n                if (!en) begin\n                    reset_rx_fifo <= 1'b1;\n                    offset <= 9'b0;\n                    wb_free <= 1'b1;\n                end else begin\n                    reset_rx_fifo <= 1'b0;\n                end\n            end\n            READ_FIFO: begin\n                rd <= 1'b1;\n                m_wb_dat_o <= dat_o;\n                m_wb_adr_o <= adr + offset;\n                wb_free <= 1'b0;\n            end\n            WB_WRITE: begin\n                rd <= 1'b0;\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                \n                if (m_wb_ack_i) begin\n                    offset <= offset + `MEM_OFFSET;\n                    wb_free <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                end\n            end\n        endcase\n    end\nend\n\n// FIFO instance\nsd_rx_fifo rx_fifo (\n    .d(dat_i),\n    .wr(wr),\n    .wclk(sd_clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(full),\n    .empty(empty),\n    .mem_empt(mem_empt),\n    .rclk(clk),\n    .rst(reset_rx_fifo)\n);\n\n// Constant Wishbone outputs\nassign m_wb_cti_o = 3'b0;  // Classic cycle\nassign m_wb_bte_o = 2'b0;  // Linear burst\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 18, "code": "module sd_bd (\n    input  wire                     clk,\n    input  wire                     rst,\n    input  wire                     we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0]      free_bd,\n    input  wire                     re_s,\n    output wire                     ack_o_s,\n    input  wire                     a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\nparameter BD_WIDTH = 8;\nparameter BD_SIZE = 255;\nparameter RAM_MEM_WIDTH = 32;\nparameter RAM_MEM_WIDTH_16 = 0;\n\nreg [BD_WIDTH-1:0] m_wr_pnt;\nreg [BD_WIDTH-1:0] s_rd_pnt;\nreg [BD_WIDTH-1:0] free_bd_cnt;\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\nreg [1:0] wr_cnt;\nreg [1:0] rd_cnt;\nreg new_bw;\nreg last_a_cmp;\nreg ack_o_s_reg;\n\nwire [BD_WIDTH-1:0] free_bd_init = (RAM_MEM_WIDTH_16) ? (BD_SIZE >> 2) : (BD_SIZE >> 1);\n\nassign free_bd = free_bd_cnt;\nassign ack_o_s = ack_o_s_reg;\nassign dat_out_s = bd_mem[s_rd_pnt];\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        free_bd_cnt <= free_bd_init;\n        wr_cnt <= 0;\n        rd_cnt <= 0;\n        new_bw <= 0;\n        last_a_cmp <= 0;\n        ack_o_s_reg <= 0;\n    end else begin\n        last_a_cmp <= a_cmp;\n        \n        // Write operation\n        if (we_m && (free_bd_cnt > 0)) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= m_wr_pnt + 1;\n            \n            if (RAM_MEM_WIDTH_16) begin\n                wr_cnt <= wr_cnt + 1;\n                if (wr_cnt == 3) begin\n                    new_bw <= 1;\n                    free_bd_cnt <= free_bd_cnt - 1;\n                    wr_cnt <= 0;\n                end else begin\n                    new_bw <= 0;\n                end\n            end else begin\n                wr_cnt <= wr_cnt + 1;\n                if (wr_cnt == 1) begin\n                    new_bw <= 1;\n                    free_bd_cnt <= free_bd_cnt - 1;\n                    wr_cnt <= 0;\n                end else begin\n                    new_bw <= 0;\n                end\n            end\n        end else begin\n            new_bw <= 0;\n        end\n        \n        // Read operation\n        if (re_s) begin\n            s_rd_pnt <= s_rd_pnt + 1;\n            \n            if (RAM_MEM_WIDTH_16) begin\n                rd_cnt <= rd_cnt + 1;\n                ack_o_s_reg <= 1;\n                if (rd_cnt == 3) begin\n                    rd_cnt <= 0;\n                end\n            end else begin\n                rd_cnt <= rd_cnt + 1;\n                if (rd_cnt == 1) begin\n                    rd_cnt <= 0;\n                end\n            end\n        end else begin\n            ack_o_s_reg <= 0;\n        end\n        \n        // Release BD on a_cmp rising edge\n        if (a_cmp && !last_a_cmp) begin\n            free_bd_cnt <= free_bd_cnt + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 15, "code": "module sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [2:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [3:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty\n);\n\n// Local parameters\nlocalparam [1:0] IDLE = 2'b00;\nlocalparam [1:0] READ_FIFO = 2'b01;\nlocalparam [1:0] WB_WRITE = 2'b10;\n\n// Internal registers\nreg [1:0] state;\nreg [8:0] offset;\nreg wb_free;\nreg reset_rx_fifo;\nreg rd;\nwire [31:0] dat_o;\n\n// FIFO instance\nsd_rx_fifo rx_fifo (\n    .d(dat_i),\n    .wr(wr),\n    .wclk(sd_clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(full),\n    .empty(empty),\n    .rclk(clk),\n    .rst(rst | reset_rx_fifo)\n);\n\n// State machine\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all control signals\n        state <= IDLE;\n        m_wb_adr_o <= 32'b0;\n        m_wb_we_o <= 1'b0;\n        m_wb_dat_o <= 32'b0;\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n        m_wb_cti_o <= 3'b0;\n        m_wb_bte_o <= 2'b0;\n        offset <= 9'b0;\n        wb_free <= 1'b1;\n        reset_rx_fifo <= 1'b1;\n        rd <= 1'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                if (en) begin\n                    reset_rx_fifo <= 1'b0;\n                    if (!empty && wb_free) begin\n                        rd <= 1'b1;\n                        state <= READ_FIFO;\n                    end\n                end else begin\n                    // Disabled state handling\n                    reset_rx_fifo <= 1'b1;\n                    rd <= 1'b0;\n                    offset <= 9'b0;\n                    wb_free <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                end\n            end\n            \n            READ_FIFO: begin\n                rd <= 1'b0;\n                m_wb_dat_o <= dat_o;\n                m_wb_adr_o <= adr + offset;\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                wb_free <= 1'b0;\n                state <= WB_WRITE;\n            end\n            \n            WB_WRITE: begin\n                if (m_wb_ack_i) begin\n                    m_wb_we_o <= 1'b0;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    offset <= offset + `MEM_OFFSET;\n                    wb_free <= 1'b1;\n                    state <= IDLE;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 3, "code": "module sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n// State definitions\nlocalparam IDLE    = 3'b001;\nlocalparam SETUP   = 3'b010;\nlocalparam EXECUTE = 3'b100;\n\n// Internal signals\nreg [2:0] state, next_state;\nreg [3:0] debounce;\nreg card_present;\nreg ack_q, ack_in_int;\nreg req_q, req_in_int;\nreg index_check_enable;\nreg CRC_check_enable;\nreg complete;\nreg [15:0] Watchdog_Cnt;\nreg [6:0] response_size;\nreg [7:0] status;\nwire dat_ava = status[6];\nwire crc_valid = status[5];\n\n// Response size constants\nlocalparam [6:0] small_rsp = 7'b0101000;\nlocalparam [6:0] big_rsp = 7'b1111111;\n\n// Debounce logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0;\n        card_present <= 1'b0;\n    end else begin\n        if (!card_detect) begin\n            if (debounce != 4'b1111)\n                debounce <= debounce + 1'b1;\n        end else begin\n            debounce <= 4'b0;\n        end\n        card_present <= (debounce == 4'b1111) ? 1'b1 : 1'b0;\n    end\nend\n\n// Synchronizers\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        ack_q <= 1'b0;\n        ack_in_int <= 1'b0;\n        req_q <= 1'b0;\n        req_in_int <= 1'b0;\n    end else begin\n        ack_q <= ack_in;\n        ack_in_int <= ack_q;\n        req_q <= req_in;\n        req_in_int <= req_q;\n    end\nend\n\n// FSM state transition\nalways @(*) begin\n    case (state)\n        IDLE: next_state = New_CMD ? SETUP : IDLE;\n        SETUP: next_state = ack_in_int ? EXECUTE : SETUP;\n        EXECUTE: next_state = complete ? IDLE : EXECUTE;\n        default: next_state = IDLE;\n    endcase\nend\n\n// FSM state register\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I)\n        state <= IDLE;\n    else\n        state <= next_state;\nend\n\n// FSM output logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        CRC_check_enable <= 1'b0;\n        complete <= 1'b0;\n        RESP_1_REG <= 32'b0;\n        ERR_INT_REG <= 5'b0;\n        NORMAL_INT_REG <= 16'b0;\n        STATUS_REG <= 16'b0;\n        status <= 8'b0;\n        cmd_out <= 40'b0;\n        settings <= 16'b0;\n        response_size <= 7'b0;\n        req_out <= 1'b0;\n        index_check_enable <= 1'b0;\n        ack_out <= 1'b0;\n        Watchdog_Cnt <= 16'b0;\n        go_idle_o <= 1'b0;\n    end else begin\n        // Interrupt reset handling\n        if (ERR_INT_RST) ERR_INT_REG <= 5'b0;\n        if (NORMAL_INT_RST) NORMAL_INT_REG <= 16'b0;\n        \n        // Card presence interrupts\n        NORMAL_INT_REG[1] <= card_present;\n        NORMAL_INT_REG[2] <= ~card_present;\n        \n        complete <= 1'b0;\n        \n        case (state)\n            IDLE: begin\n                go_idle_o <= 1'b0;\n                req_out <= 1'b0;\n                ack_out <= 1'b0;\n                STATUS_REG[0] <= 1'b0; // CICMD\n                \n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1'b1;\n                end\n            end\n            \n            SETUP: begin\n                NORMAL_INT_REG <= 16'b0;\n                ERR_INT_REG <= 5'b0;\n                index_check_enable <= CMD_SET_REG[4]; // CICE\n                CRC_check_enable <= CMD_SET_REG[3];   // CRCE\n                \n                // Compose command\n                cmd_out[39:38] <= 2'b01;\n                cmd_out[37:32] <= CMD_SET_REG[13:8]; // CMDI\n                cmd_out[31:0] <= ARG_REG;\n                \n                // Determine response size\n                case (CMD_SET_REG[1:0]) // RTS\n                    2'b10, 2'b11: response_size <= small_rsp;\n                    2'b01: response_size <= big_rsp;\n                    default: response_size <= 7'b0;\n                endcase\n                \n                // Setup settings\n                settings[14:13] <= CMD_SET_REG[7:6]; // WORD_SELECT\n                settings[12] <= data_read;\n                settings[11] <= data_write;\n                settings[10:8] <= 3'b111; // Delay\n                settings[7] <= CMD_SET_REG[3]; // CRCE\n                settings[6:0] <= response_size;\n                \n                Watchdog_Cnt <= 16'b0;\n                STATUS_REG[0] <= 1'b1; // CICMD\n            end\n            \n            EXECUTE: begin\n                Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                \n                // Timeout handling\n                if (Watchdog_Cnt > TIMEOUT_REG) begin\n                    ERR_INT_REG[0] <= 1'b1; // CTE\n                    NORMAL_INT_REG[15] <= 1'b1; // EI\n                    if (ack_in) complete <= 1'b1;\n                    go_idle_o <= 1'b1;\n                end\n                \n                // Request handling\n                if (ack_in_int) begin\n                    req_out <= 1'b1;\n                end\n                \n                // Status handling\n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1'b1;\n                    \n                    if (dat_ava) begin\n                        complete <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b0; // Clear EI\n                        \n                        // CRC check\n                        if (CRC_check_enable && !crc_valid) begin\n                            ERR_INT_REG[1] <= 1'b1; // CCRCE\n                            NORMAL_INT_REG[15] <= 1'b1; // EI\n                        end\n                        \n                        // Index check\n                        if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                            ERR_INT_REG[3] <= 1'b1; // CIE\n                            NORMAL_INT_REG[15] <= 1'b1; // EI\n                        end\n                        \n                        NORMAL_INT_REG[0] <= 1'b1; // CC\n                        \n                        // Store response if needed\n                        if (response_size != 7'b0) begin\n                            RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 16, "code": "module sd_fifo_rx_filler (\n    input  wire         clk,\n    input  wire         rst,\n    output reg  [31:0]  m_wb_adr_o,\n    output reg          m_wb_we_o,\n    output reg  [31:0]  m_wb_dat_o,\n    output reg          m_wb_cyc_o,\n    output reg          m_wb_stb_o,\n    input  wire         m_wb_ack_i,\n    output reg  [2:0]   m_wb_cti_o,\n    output reg  [2:0]   m_wb_bte_o,\n    input  wire         en,\n    input  wire [31:0]  adr,\n    input  wire         sd_clk,\n    input  wire [3:0]   dat_i,\n    input  wire         wr,\n    output wire         full,\n    output wire         empty\n);\n\n    // Parameters\n    parameter MEM_OFFSET = 4;  // Address increment per word (32-bit)\n\n    // Internal registers\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    // FIFO signals\n    wire [31:0] dat_o;\n    wire [1:0] mem_empt;\n\n    // State machine\n    reg [1:0] state;\n    localparam IDLE     = 2'b00;\n    localparam READ_FIFO = 2'b01;\n    localparam WB_WRITE = 2'b10;\n\n    // FIFO instance\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .mem_empt(mem_empt),\n        .rclk(clk),\n        .rst(rst | reset_rx_fifo)\n    );\n\n    // Main state machine\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all control signals\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            \n            // Reset internal registers\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            \n            state <= IDLE;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (en) begin\n                        reset_rx_fifo <= 1'b0;\n                        rd <= 1'b0;\n                        \n                        if (!empty && wb_free) begin\n                            rd <= 1'b1;\n                            state <= READ_FIFO;\n                        end\n                    end else begin\n                        // Disabled state\n                        reset_rx_fifo <= 1'b1;\n                        rd <= 1'b0;\n                        offset <= 9'b0;\n                        wb_free <= 1'b1;\n                    end\n                end\n                \n                READ_FIFO: begin\n                    rd <= 1'b0;\n                    m_wb_dat_o <= dat_o;\n                    m_wb_adr_o <= adr + {23'b0, offset};\n                    m_wb_we_o <= 1'b1;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    wb_free <= 1'b0;\n                    state <= WB_WRITE;\n                end\n                \n                WB_WRITE: begin\n                    if (m_wb_ack_i) begin\n                        // Transaction complete\n                        m_wb_we_o <= 1'b0;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        wb_free <= 1'b1;\n                        offset <= offset + MEM_OFFSET;\n                        state <= IDLE;\n                    end\n                end\n                \n                default: state <= IDLE;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule sd_rx_fifo (\n    input  wire [3:0]  d,\n    input  wire        wr,\n    input  wire        wclk,\n    output wire [31:0] q,\n    input  wire        rd,\n    output wire        full,\n    output wire        empty,\n    output wire [1:0]  mem_empt,\n    input  wire        rclk,\n    input  wire        rst\n);\n\n    // FIFO implementation would go here\n    // This is a placeholder for the actual FIFO implementation\n    // In a real design, this would be either a behavioral model\n    // or an instantiation of a technology-specific FIFO\n\n    assign q = 32'b0;\n    assign full = 1'b0;\n    assign empty = 1'b1;\n    assign mem_empt = 2'b11;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 16, "code": "module sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    output wire full,\n    output wire empty,\n    output wire [5:0] mem_empt,\n    input wire rclk,\n    input wire rst\n);\n\n// Memory declaration\nreg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n\n// Pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i; // Write pointer\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o; // Read pointer\n\n// Synchronizers for cross-clock domain signals\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_sync1, adr_i_sync2;\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_sync1, adr_o_sync2;\n\n// Write clock domain logic\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n    end else if (wr && !full) begin\n        ram[adr_i[FIFO_TX_MEM_ADR_SIZE-2:0]] <= d;\n        adr_i <= adr_i + 1;\n    end\nend\n\n// Read clock domain logic\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o[FIFO_TX_MEM_ADR_SIZE-2:0]];\n        adr_o <= adr_o + 1;\n    end\nend\n\n// Synchronize write pointer to read clock domain\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_i_sync1 <= 0;\n        adr_i_sync2 <= 0;\n    end else begin\n        adr_i_sync1 <= adr_i;\n        adr_i_sync2 <= adr_i_sync1;\n    end\nend\n\n// Synchronize read pointer to write clock domain\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_o_sync1 <= 0;\n        adr_o_sync2 <= 0;\n    end else begin\n        adr_o_sync1 <= adr_o;\n        adr_o_sync2 <= adr_o_sync1;\n    end\nend\n\n// Full and empty generation\nassign empty = (adr_i_sync2 == adr_o);\nassign full = ((adr_i[FIFO_TX_MEM_ADR_SIZE-1] != adr_o_sync2[FIFO_TX_MEM_ADR_SIZE-1]) && \n              (adr_i[FIFO_TX_MEM_ADR_SIZE-2:0] == adr_o_sync2[FIFO_TX_MEM_ADR_SIZE-2:0]));\n\n// FIFO occupancy calculation\nassign mem_empt = adr_i[FIFO_TX_MEM_ADR_SIZE-2:0] - adr_o[FIFO_TX_MEM_ADR_SIZE-2:0];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 4, "code": "module sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n// State definitions\nlocalparam IDLE    = 3'b001;\nlocalparam SETUP   = 3'b010;\nlocalparam EXECUTE = 3'b100;\n\n// Response size constants\nlocalparam small_rsp = 7'b0101000;\nlocalparam big_rsp   = 7'b1111111;\n\n// Internal signals\nreg [2:0] state, next_state;\nreg [3:0] debounce;\nreg card_present;\nreg ack_q, ack_in_int;\nreg req_q, req_in_int;\nreg index_check_enable;\nreg CRC_check_enable;\nreg complete;\nreg [15:0] Watchdog_Cnt;\nreg [7:0] status;\nreg [6:0] response_size;\nreg CTE, CIE, CCRCE, EI, CC;\n\n// Status bits\nwire dat_ava = status[6];\nwire crc_valid = status[5];\n\n// Debounce logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0;\n        card_present <= 1'b0;\n    end else begin\n        if (!card_detect) begin\n            if (debounce != 4'b1111)\n                debounce <= debounce + 1'b1;\n        end else begin\n            debounce <= 4'b0;\n        end\n        card_present <= (debounce == 4'b1111) ? 1'b1 : 1'b0;\n    end\nend\n\n// Synchronizers\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        ack_q <= 1'b0;\n        ack_in_int <= 1'b0;\n        req_q <= 1'b0;\n        req_in_int <= 1'b0;\n    end else begin\n        ack_q <= ack_in;\n        ack_in_int <= ack_q;\n        req_q <= req_in;\n        req_in_int <= req_q;\n    end\nend\n\n// FSM state register\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I)\n        state <= IDLE;\n    else\n        state <= next_state;\nend\n\n// FSM next state logic\nalways @(*) begin\n    case (state)\n        IDLE: next_state = New_CMD ? SETUP : IDLE;\n        SETUP: next_state = ack_in_int ? EXECUTE : SETUP;\n        EXECUTE: next_state = complete ? IDLE : EXECUTE;\n        default: next_state = IDLE;\n    endcase\nend\n\n// FSM output logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        // Reset all outputs\n        CRC_check_enable <= 1'b0;\n        complete <= 1'b0;\n        RESP_1_REG <= 32'b0;\n        ERR_INT_REG <= 5'b0;\n        NORMAL_INT_REG <= 16'b0;\n        STATUS_REG <= 16'b0;\n        status <= 8'b0;\n        cmd_out <= 40'b0;\n        settings <= 16'b0;\n        response_size <= 7'b0;\n        req_out <= 1'b0;\n        index_check_enable <= 1'b0;\n        ack_out <= 1'b0;\n        Watchdog_Cnt <= 16'b0;\n        CCRCE <= 1'b0;\n        EI <= 1'b0;\n        CC <= 1'b0;\n        go_idle_o <= 1'b0;\n        CTE <= 1'b0;\n        CIE <= 1'b0;\n    end else begin\n        // Default assignments\n        NORMAL_INT_REG[1] <= card_present;\n        NORMAL_INT_REG[2] <= ~card_present;\n        complete <= 1'b0;\n        \n        // Interrupt reset handling\n        if (ERR_INT_RST) ERR_INT_REG <= 5'b0;\n        if (NORMAL_INT_RST) NORMAL_INT_REG <= 16'b0;\n        \n        case (state)\n            IDLE: begin\n                go_idle_o <= 1'b0;\n                req_out <= 1'b0;\n                ack_out <= 1'b0;\n                STATUS_REG[0] <= 1'b0; // CICMD\n                \n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1'b1;\n                end\n            end\n            \n            SETUP: begin\n                NORMAL_INT_REG <= 16'b0;\n                ERR_INT_REG <= 5'b0;\n                index_check_enable <= CMD_SET_REG[4]; // CICE\n                CRC_check_enable <= CMD_SET_REG[3];   // CRCE\n                \n                // Compose cmd_out\n                cmd_out[39:38] <= 2'b01;\n                cmd_out[37:32] <= CMD_SET_REG[13:8];  // CMDI\n                cmd_out[31:0] <= ARG_REG;\n                \n                // Determine response size\n                case (CMD_SET_REG[1:0]) // RTS\n                    2'b10, 2'b11: response_size <= small_rsp;\n                    2'b01: response_size <= big_rsp;\n                    default: response_size <= 7'b0;\n                endcase\n                \n                // Compose settings\n                settings[14:13] <= CMD_SET_REG[7:6];  // WORD_SELECT\n                settings[12] <= data_read;\n                settings[11] <= data_write;\n                settings[10:8] <= 3'b111;             // Delay\n                settings[7] <= CMD_SET_REG[3];        // CRCE\n                settings[6:0] <= response_size;\n                \n                Watchdog_Cnt <= 16'b0;\n                STATUS_REG[0] <= 1'b1; // CICMD\n            end\n            \n            EXECUTE: begin\n                Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                \n                // Timeout handling\n                if (Watchdog_Cnt > TIMEOUT_REG) begin\n                    ERR_INT_REG[0] <= 1'b1; // CTE\n                    NORMAL_INT_REG[15] <= 1'b1; // EI\n                    if (ack_in) complete <= 1'b1;\n                    go_idle_o <= 1'b1;\n                end\n                \n                // Request handling\n                if (ack_in_int) begin\n                    req_out <= 1'b1;\n                end\n                \n                // Status handling\n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1'b1;\n                    \n                    if (dat_ava) begin\n                        complete <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b0; // Clear EI\n                        \n                        // CRC check\n                        if (CRC_check_enable && !crc_valid) begin\n                            ERR_INT_REG[1] <= 1'b1; // CCRCE\n                            NORMAL_INT_REG[15] <= 1'b1; // EI\n                        end\n                        \n                        // Index check\n                        if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                            ERR_INT_REG[3] <= 1'b1; // CIE\n                            NORMAL_INT_REG[15] <= 1'b1; // EI\n                        end\n                        \n                        NORMAL_INT_REG[0] <= 1'b1; // CC\n                        \n                        // Store response if needed\n                        if (response_size != 7'b0) begin\n                            RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 5, "code": "module sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n// State definitions\nlocalparam IDLE    = 3'b001;\nlocalparam SETUP   = 3'b010;\nlocalparam EXECUTE = 3'b100;\n\n// Status bit definitions\nlocalparam dat_ava = 6;\nlocalparam crc_valid = 5;\n\n// Response size definitions\nlocalparam small_rsp = 7'b0101000;\nlocalparam big_rsp = 7'b1111111;\n\n// Internal registers\nreg [2:0] state, next_state;\nreg [3:0] debounce;\nreg card_present;\nreg ack_q, ack_in_int;\nreg req_q, req_in_int;\nreg index_check_enable;\nreg CRC_check_enable;\nreg complete;\nreg [15:0] Watchdog_Cnt;\nreg [6:0] response_size;\nreg [7:0] status;\nreg CIE, CCRCE, CTE, EI, CC;\n\n// Debounce logic for card detection\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0;\n        card_present <= 1'b0;\n    end else begin\n        if (!card_detect) begin\n            if (debounce != 4'b1111)\n                debounce <= debounce + 1'b1;\n        end else begin\n            debounce <= 4'b0;\n        end\n        \n        card_present <= (debounce == 4'b1111) ? 1'b1 : 1'b0;\n    end\nend\n\n// Synchronize ack_in\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        ack_q <= 1'b0;\n        ack_in_int <= 1'b0;\n    end else begin\n        ack_q <= ack_in;\n        ack_in_int <= ack_q;\n    end\nend\n\n// Synchronize req_in\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        req_q <= 1'b0;\n        req_in_int <= 1'b0;\n    end else begin\n        req_q <= req_in;\n        req_in_int <= req_q;\n    end\nend\n\n// FSM state register\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I)\n        state <= IDLE;\n    else\n        state <= next_state;\nend\n\n// FSM next state logic\nalways @(*) begin\n    case (state)\n        IDLE: next_state = New_CMD ? SETUP : IDLE;\n        SETUP: next_state = ack_in_int ? EXECUTE : SETUP;\n        EXECUTE: next_state = complete ? IDLE : EXECUTE;\n        default: next_state = IDLE;\n    endcase\nend\n\n// FSM output logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        // Reset all outputs and internal registers\n        CRC_check_enable <= 1'b0;\n        complete <= 1'b0;\n        RESP_1_REG <= 32'b0;\n        ERR_INT_REG <= 5'b0;\n        NORMAL_INT_REG <= 16'b0;\n        STATUS_REG <= 16'b0;\n        status <= 8'b0;\n        cmd_out <= 40'b0;\n        settings <= 16'b0;\n        response_size <= 7'b0;\n        req_out <= 1'b0;\n        index_check_enable <= 1'b0;\n        ack_out <= 1'b0;\n        Watchdog_Cnt <= 16'b0;\n        CCRCE <= 1'b0;\n        EI <= 1'b0;\n        CC <= 1'b0;\n        go_idle_o <= 1'b0;\n        CIE <= 1'b0;\n        CTE <= 1'b0;\n    end else begin\n        // Default assignments\n        complete <= 1'b0;\n        ack_out <= 1'b0;\n        req_out <= 1'b0;\n        go_idle_o <= 1'b0;\n        \n        // Update interrupt registers\n        NORMAL_INT_REG[1] <= card_present;\n        NORMAL_INT_REG[2] <= ~card_present;\n        \n        // Interrupt reset logic\n        if (ERR_INT_RST) ERR_INT_REG <= 5'b0;\n        if (NORMAL_INT_RST) NORMAL_INT_REG <= 16'b0;\n        \n        case (state)\n            IDLE: begin\n                go_idle_o <= 1'b0;\n                req_out <= 1'b0;\n                ack_out <= 1'b0;\n                STATUS_REG[0] <= 1'b0; // CICMD\n                \n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1'b1;\n                end\n            end\n            \n            SETUP: begin\n                NORMAL_INT_REG <= 16'b0;\n                ERR_INT_REG <= 5'b0;\n                index_check_enable <= CMD_SET_REG[4]; // CICE\n                CRC_check_enable <= CMD_SET_REG[3];   // CRCE\n                \n                // Compose cmd_out\n                cmd_out[39:38] <= 2'b01;\n                cmd_out[37:32] <= CMD_SET_REG[13:8]; // CMDI\n                cmd_out[31:0] <= ARG_REG;\n                \n                // Determine response size\n                case (CMD_SET_REG[1:0]) // RTS\n                    2'b10, 2'b11: response_size <= small_rsp;\n                    2'b01: response_size <= big_rsp;\n                    default: response_size <= 7'b0;\n                endcase\n                \n                // Compose settings\n                settings[14:13] <= CMD_SET_REG[7:6]; // WORD_SELECT\n                settings[12] <= data_read;\n                settings[11] <= data_write;\n                settings[10:8] <= 3'b111; // Delay\n                settings[7] <= CMD_SET_REG[3]; // CRCE\n                settings[6:0] <= response_size;\n                \n                Watchdog_Cnt <= 16'b0;\n                STATUS_REG[0] <= 1'b1; // CICMD\n            end\n            \n            EXECUTE: begin\n                Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                \n                // Timeout handling\n                if (Watchdog_Cnt > TIMEOUT_REG) begin\n                    CTE <= 1'b1;\n                    EI <= 1'b1;\n                    if (ack_in) complete <= 1'b1;\n                    go_idle_o <= 1'b1;\n                end\n                \n                // Request handling\n                if (ack_in_int) begin\n                    req_out <= 1'b1;\n                end\n                \n                // Status handling\n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1'b1;\n                    \n                    if (status[dat_ava]) begin\n                        complete <= 1'b1;\n                        EI <= 1'b0;\n                        \n                        // CRC check\n                        if (CRC_check_enable && !status[crc_valid]) begin\n                            CCRCE <= 1'b1;\n                            EI <= 1'b1;\n                        end\n                        \n                        // Index check\n                        if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                            CIE <= 1'b1;\n                            EI <= 1'b1;\n                        end\n                        \n                        CC <= 1'b1;\n                        \n                        // Store response if needed\n                        if (response_size != 7'b0) begin\n                            RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            end\n        endcase\n        \n        // Update interrupt registers\n        ERR_INT_REG[3] <= CIE;\n        ERR_INT_REG[1] <= CCRCE;\n        ERR_INT_REG[0] <= CTE;\n        NORMAL_INT_REG[15] <= EI;\n        NORMAL_INT_REG[0] <= CC;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 19, "code": "module sd_bd (\n    input  wire                     clk,\n    input  wire                     rst,\n    input  wire                     we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0]      free_bd,\n    input  wire                     re_s,\n    output wire                     ack_o_s,\n    input  wire                     a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Internal registers\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\nreg [BD_WIDTH-1:0]      m_wr_pnt;\nreg [BD_WIDTH-1:0]      s_rd_pnt;\nreg [BD_WIDTH-1:0]      free_bd_cnt;\nreg                     new_bw;\nreg                     last_a_cmp;\nreg [1:0]               wr_cnt;\nreg [1:0]               rd_cnt;\nreg                     ack_o_s_reg;\n\n// Assign outputs\nassign free_bd = free_bd_cnt;\nassign ack_o_s = ack_o_s_reg;\nassign dat_out_s = bd_mem[s_rd_pnt];\n\n// Buffer descriptor management\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset initialization\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        wr_cnt <= 0;\n        rd_cnt <= 0;\n        new_bw <= 0;\n        last_a_cmp <= 0;\n        ack_o_s_reg <= 0;\n        \n        // Initialize free_bd based on mode\n`ifdef RAM_MEM_WIDTH_16\n        free_bd_cnt <= BD_SIZE >> 2; // 16-bit mode: 1/4 of BD_SIZE\n`else\n        free_bd_cnt <= BD_SIZE >> 1; // 32-bit mode: 1/2 of BD_SIZE\n`endif\n    end else begin\n        // Clear new_bw flag\n        new_bw <= 0;\n        \n        // Handle write operations\n        if (we_m && (free_bd_cnt > 0)) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= m_wr_pnt + 1;\n            \n`ifdef RAM_MEM_WIDTH_16\n            // 16-bit mode: 4 writes per BD\n            if (wr_cnt == 2'b11) begin\n                free_bd_cnt <= free_bd_cnt - 1;\n                new_bw <= 1;\n                wr_cnt <= 0;\n            end else begin\n                wr_cnt <= wr_cnt + 1;\n            end\n`else\n            // 32-bit mode: 2 writes per BD\n            if (wr_cnt == 1'b1) begin\n                free_bd_cnt <= free_bd_cnt - 1;\n                new_bw <= 1;\n                wr_cnt <= 0;\n            end else begin\n                wr_cnt <= wr_cnt + 1;\n            end\n`endif\n        end\n        \n        // Handle read operations\n        if (re_s) begin\n            s_rd_pnt <= s_rd_pnt + 1;\n            \n`ifdef RAM_MEM_WIDTH_16\n            // 16-bit mode: 4 reads per BD\n            if (rd_cnt == 2'b11) begin\n                rd_cnt <= 0;\n                ack_o_s_reg <= 1;\n            end else begin\n                rd_cnt <= rd_cnt + 1;\n                ack_o_s_reg <= 1;\n            end\n`else\n            // 32-bit mode: 2 reads per BD\n            if (rd_cnt == 1'b1) begin\n                rd_cnt <= 0;\n                ack_o_s_reg <= 1;\n            end else begin\n                rd_cnt <= rd_cnt + 1;\n                ack_o_s_reg <= 0;\n            end\n`endif\n        end else begin\n            ack_o_s_reg <= 0;\n        end\n        \n        // Handle BD release (a_cmp)\n        last_a_cmp <= a_cmp;\n        if (a_cmp && !last_a_cmp) begin\n            free_bd_cnt <= free_bd_cnt + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 20, "code": "module sd_bd (\n    input  wire                     clk,\n    input  wire                     rst,\n    input  wire                     we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0]      free_bd,\n    input  wire                     re_s,\n    output wire                     ack_o_s,\n    input  wire                     a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\nparameter BD_WIDTH = 8;\nparameter RAM_MEM_WIDTH = 32;\n\nlocalparam BD_SIZE = 1 << BD_WIDTH;\n\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\nreg [BD_WIDTH-1:0]      m_wr_pnt;\nreg [BD_WIDTH-1:0]      s_rd_pnt;\nreg [BD_WIDTH-1:0]      free_bd_cnt;\nreg                     new_bw;\nreg                     last_a_cmp;\nreg [1:0]               wr_cnt;\nreg [1:0]               rd_cnt;\nreg [RAM_MEM_WIDTH-1:0] dat_out_reg;\n\nassign free_bd = free_bd_cnt;\nassign dat_out_s = dat_out_reg;\n\n// Initialize the module\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        wr_cnt <= 0;\n        rd_cnt <= 0;\n        new_bw <= 0;\n        last_a_cmp <= 0;\n        dat_out_reg <= 0;\n        \n        if (RAM_MEM_WIDTH == 32)\n            free_bd_cnt <= BD_SIZE >> 1;\n        else\n            free_bd_cnt <= BD_SIZE >> 2;\n    end\nend\n\n// Write Buffer Descriptor\nalways @(posedge clk) begin\n    if (we_m && (free_bd_cnt > 0)) begin\n        bd_mem[m_wr_pnt] <= dat_in_m;\n        m_wr_pnt <= m_wr_pnt + 1;\n        \n        if (RAM_MEM_WIDTH == 32) begin\n            if (wr_cnt == 1) begin\n                new_bw <= 1;\n                free_bd_cnt <= free_bd_cnt - 1;\n                wr_cnt <= 0;\n            end else begin\n                new_bw <= 0;\n                wr_cnt <= wr_cnt + 1;\n            end\n        end\n        else begin // 16-bit mode\n            if (wr_cnt == 3) begin\n                new_bw <= 1;\n                free_bd_cnt <= free_bd_cnt - 1;\n                wr_cnt <= 0;\n            end else begin\n                new_bw <= 0;\n                wr_cnt <= wr_cnt + 1;\n            end\n        end\n    end else begin\n        new_bw <= 0;\n    end\nend\n\n// Read Buffer Descriptor\nalways @(posedge clk) begin\n    if (re_s) begin\n        dat_out_reg <= bd_mem[s_rd_pnt];\n        s_rd_pnt <= s_rd_pnt + 1;\n        \n        if (RAM_MEM_WIDTH == 32) begin\n            if (rd_cnt == 1) begin\n                ack_o_s <= 1;\n                rd_cnt <= 0;\n            end else begin\n                ack_o_s <= 0;\n                rd_cnt <= rd_cnt + 1;\n            end\n        end\n        else begin // 16-bit mode\n            ack_o_s <= 1;\n            if (rd_cnt == 3) begin\n                rd_cnt <= 0;\n            end else begin\n                rd_cnt <= rd_cnt + 1;\n            end\n        end\n    end else begin\n        ack_o_s <= 0;\n    end\nend\n\n// Release Buffer Descriptor\nalways @(posedge clk) begin\n    last_a_cmp <= a_cmp;\n    \n    if (RAM_MEM_WIDTH == 32) begin\n        if (a_cmp && !last_a_cmp) begin\n            free_bd_cnt <= free_bd_cnt + 1;\n        end\n    end\n    else begin // 16-bit mode\n        if (a_cmp && !last_a_cmp) begin\n            free_bd_cnt <= free_bd_cnt + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 17, "code": "module sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [2:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [3:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty\n);\n\n// Internal registers\nreg [8:0] offset;\nreg wb_free;\nreg reset_rx_fifo;\nreg rd;\n\n// FIFO signals\nwire [31:0] dat_o;\nwire [1:0] mem_empt;\n\n// FIFO instance\nsd_rx_fifo rx_fifo (\n    .d(dat_i),\n    .wr(wr),\n    .wclk(sd_clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(full),\n    .empty(empty),\n    .mem_empt(mem_empt),\n    .rclk(clk),\n    .rst(rst | reset_rx_fifo)\n);\n\n// State machine\nparameter IDLE = 1'b0;\nparameter WB_WRITE = 1'b1;\nreg state;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all control signals\n        m_wb_adr_o <= 32'b0;\n        m_wb_we_o <= 1'b0;\n        m_wb_dat_o <= 32'b0;\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n        m_wb_cti_o <= 3'b0;\n        m_wb_bte_o <= 2'b0;\n        \n        // Reset internal registers\n        offset <= 9'b0;\n        wb_free <= 1'b1;\n        reset_rx_fifo <= 1'b1;\n        rd <= 1'b0;\n        \n        state <= IDLE;\n    end else begin\n        case (state)\n            IDLE: begin\n                if (en) begin\n                    reset_rx_fifo <= 1'b0;\n                    rd <= 1'b0;\n                    \n                    if (!empty && wb_free) begin\n                        // Start Wishbone write transaction\n                        m_wb_adr_o <= adr + offset;\n                        m_wb_dat_o <= dat_o;\n                        m_wb_we_o <= 1'b1;\n                        m_wb_cyc_o <= 1'b1;\n                        m_wb_stb_o <= 1'b1;\n                        m_wb_cti_o <= 3'b000; // Classic cycle\n                        m_wb_bte_o <= 2'b00;  // Linear burst\n                        \n                        rd <= 1'b1;\n                        wb_free <= 1'b0;\n                        state <= WB_WRITE;\n                    end\n                end else begin\n                    // Module disabled\n                    reset_rx_fifo <= 1'b1;\n                    rd <= 1'b0;\n                    offset <= 9'b0;\n                    wb_free <= 1'b1;\n                    \n                    // Reset Wishbone signals\n                    m_wb_we_o <= 1'b0;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                end\n            end\n            \n            WB_WRITE: begin\n                if (m_wb_ack_i) begin\n                    // Transaction complete\n                    m_wb_we_o <= 1'b0;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    \n                    // Update address offset\n                    offset <= offset + `MEM_OFFSET;\n                    \n                    wb_free <= 1'b1;\n                    rd <= 1'b0;\n                    state <= IDLE;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 17, "code": "module sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    input wire rclk,\n    output wire full,\n    output wire empty,\n    output wire [5:0] mem_empt,\n    input wire rst\n);\n\n    parameter FIFO_TX_MEM_DEPTH = 64;  // Example depth, should match sd_defines.v\n    parameter FIFO_TX_MEM_ADR_SIZE = 7; // log2(FIFO_TX_MEM_DEPTH) + 1\n\n    // Memory array\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    \n    // Write pointer and synchronized read pointer\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray_sync1, adr_i_gray_sync2;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_sync;\n    \n    // Read pointer and synchronized write pointer\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_gray_sync1, adr_o_gray_sync2;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_sync;\n    \n    // Status signals\n    reg full_reg;\n    reg empty_reg;\n    reg [5:0] mem_empt_reg;\n    \n    // Gray code conversion functions\n    function [FIFO_TX_MEM_ADR_SIZE-1:0] bin2gray;\n        input [FIFO_TX_MEM_ADR_SIZE-1:0] bin;\n        begin\n            bin2gray = bin ^ (bin >> 1);\n        end\n    endfunction\n    \n    function [FIFO_TX_MEM_ADR_SIZE-1:0] gray2bin;\n        input [FIFO_TX_MEM_ADR_SIZE-1:0] gray;\n        integer i;\n        begin\n            gray2bin[FIFO_TX_MEM_ADR_SIZE-1] = gray[FIFO_TX_MEM_ADR_SIZE-1];\n            for (i = FIFO_TX_MEM_ADR_SIZE-2; i >= 0; i = i - 1)\n                gray2bin[i] = gray2bin[i+1] ^ gray[i];\n        end\n    endfunction\n    \n    // Write clock domain logic\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            adr_i_gray <= 0;\n        end else begin\n            if (wr && !full_reg) begin\n                ram[adr_i[FIFO_TX_MEM_ADR_SIZE-2:0]] <= d;\n                adr_i <= adr_i + 1;\n                adr_i_gray <= bin2gray(adr_i + 1);\n            end\n        end\n    end\n    \n    // Read clock domain logic\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            adr_o_gray <= 0;\n            q <= 0;\n        end else begin\n            if (rd && !empty_reg) begin\n                q <= ram[adr_o[FIFO_TX_MEM_ADR_SIZE-2:0]];\n                adr_o <= adr_o + 1;\n                adr_o_gray <= bin2gray(adr_o + 1);\n            end\n        end\n    end\n    \n    // Synchronize read pointer to write clock domain\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_o_gray_sync1 <= 0;\n            adr_o_gray_sync2 <= 0;\n            adr_o_sync <= 0;\n        end else begin\n            adr_o_gray_sync1 <= adr_o_gray;\n            adr_o_gray_sync2 <= adr_o_gray_sync1;\n            adr_o_sync <= gray2bin(adr_o_gray_sync2);\n        end\n    end\n    \n    // Synchronize write pointer to read clock domain\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_i_gray_sync1 <= 0;\n            adr_i_gray_sync2 <= 0;\n            adr_i_sync <= 0;\n        end else begin\n            adr_i_gray_sync1 <= adr_i_gray;\n            adr_i_gray_sync2 <= adr_i_gray_sync1;\n            adr_i_sync <= gray2bin(adr_i_gray_sync2);\n        end\n    end\n    \n    // Full and empty generation in write clock domain\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            full_reg <= 0;\n        end else begin\n            full_reg <= ((adr_i[FIFO_TX_MEM_ADR_SIZE-2:0] == adr_o_sync[FIFO_TX_MEM_ADR_SIZE-2:0]) &&\n                        (adr_i[FIFO_TX_MEM_ADR_SIZE-1] != adr_o_sync[FIFO_TX_MEM_ADR_SIZE-1]));\n        end\n    end\n    \n    // Empty generation in read clock domain\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            empty_reg <= 1;\n        end else begin\n            empty_reg <= (adr_o == adr_i_sync);\n        end\n    end\n    \n    // FIFO occupancy calculation\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            mem_empt_reg <= 0;\n        end else begin\n            if (adr_i_sync >= adr_o)\n                mem_empt_reg <= adr_i_sync - adr_o;\n            else\n                mem_empt_reg <= (FIFO_TX_MEM_DEPTH - adr_o) + adr_i_sync;\n        end\n    end\n    \n    // Output assignments\n    assign full = full_reg;\n    assign empty = empty_reg;\n    assign mem_empt = mem_empt_reg[5:0];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 6, "code": "module sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n    // State definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal signals\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg ack_q, ack_in_int;\n    reg req_q, req_in_int;\n    reg index_check_enable;\n    reg CRC_check_enable;\n    reg complete;\n    reg [15:0] Watchdog_Cnt;\n    reg [6:0] response_size;\n    reg [7:0] status;\n    reg CTE, CCRCE, CIE, EI, CC;\n\n    // Response size constants\n    localparam small_rsp = 7'b0101000;\n    localparam big_rsp = 7'b1111111;\n\n    // Status bits\n    wire dat_ava = status[6];\n    wire crc_valid = status[5];\n\n    // Debounce logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0;\n            end\n            card_present <= (debounce == 4'b1111) ? 1'b1 : 1'b0;\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            ack_q <= 1'b0;\n            ack_in_int <= 1'b0;\n            req_q <= 1'b0;\n            req_in_int <= 1'b0;\n        end else begin\n            ack_q <= ack_in;\n            ack_in_int <= ack_q;\n            req_q <= req_in;\n            req_in_int <= req_q;\n        end\n    end\n\n    // FSM state register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // FSM next state logic\n    always @(*) begin\n        case (state)\n            IDLE:   next_state = New_CMD ? SETUP : IDLE;\n            SETUP:  next_state = ack_in_int ? EXECUTE : SETUP;\n            EXECUTE: next_state = complete ? IDLE : EXECUTE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM output logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            // Reset all outputs\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            CCRCE <= 1'b0;\n            EI <= 1'b0;\n            CC <= 1'b0;\n            go_idle_o <= 1'b0;\n            CTE <= 1'b0;\n            CIE <= 1'b0;\n        end else begin\n            // Normal operation\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n\n            // Interrupt reset handling\n            if (ERR_INT_RST) ERR_INT_REG <= 5'b0;\n            if (NORMAL_INT_RST) NORMAL_INT_REG <= 16'b0;\n\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    STATUS_REG[0] <= 1'b0; // CICMD\n\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4]; // CICE\n                    CRC_check_enable <= CMD_SET_REG[3];   // CRCE\n\n                    // Compose cmd_out\n                    cmd_out[39:38] <= 2'b01;\n                    cmd_out[37:32] <= CMD_SET_REG[13:8];  // CMDI\n                    cmd_out[31:0] <= ARG_REG;\n\n                    // Determine response size\n                    case (CMD_SET_REG[1:0]) // RTS\n                        2'b10, 2'b11: response_size <= small_rsp;\n                        2'b01: response_size <= big_rsp;\n                        default: response_size <= 7'b0;\n                    endcase\n\n                    // Compose settings\n                    settings[14:13] <= CMD_SET_REG[7:6];  // WORD_SELECT\n                    settings[12] <= data_read;\n                    settings[11] <= data_write;\n                    settings[10:8] <= 3'b111;             // Delay\n                    settings[7] <= CMD_SET_REG[3];        // CRCE\n                    settings[6:0] <= response_size;\n\n                    Watchdog_Cnt <= 16'b0;\n                    STATUS_REG[0] <= 1'b1; // CICMD\n                end\n\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n\n                    // Timeout handling\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        CTE <= 1'b1;\n                        EI <= 1'b1;\n                        if (ack_in) complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n\n                    // Request handling\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end\n\n                    // Status handling\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n\n                        if (dat_ava) begin\n                            complete <= 1'b1;\n                            EI <= 1'b0;\n\n                            // CRC check\n                            if (CRC_check_enable && !crc_valid) begin\n                                CCRCE <= 1'b1;\n                                EI <= 1'b1;\n                            end\n\n                            // Index check\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                CIE <= 1'b1;\n                                EI <= 1'b1;\n                            end\n\n                            CC <= 1'b1;\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n\n            // Update interrupt registers\n            ERR_INT_REG[3] <= CIE;\n            ERR_INT_REG[1] <= CCRCE;\n            ERR_INT_REG[0] <= CTE;\n            NORMAL_INT_REG[15] <= EI;\n            NORMAL_INT_REG[0] <= CC;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 18, "code": "module sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt,\n    input wire rclk,\n    input wire rst\n);\n\n    parameter FIFO_TX_MEM_DEPTH = 32; // Example depth, should match defines\n    parameter FIFO_TX_MEM_ADR_SIZE = 6; // log2(FIFO_TX_MEM_DEPTH) + 1\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray, adr_o_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray_sync, adr_o_gray_sync;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_sync, adr_o_sync;\n\n    // Write domain\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            adr_i_gray <= 0;\n        end else begin\n            if (wr && !full) begin\n                ram[adr_i[FIFO_TX_MEM_ADR_SIZE-2:0]] <= d;\n                adr_i <= adr_i + 1;\n                adr_i_gray <= (adr_i + 1) ^ ((adr_i + 1) >> 1);\n            end\n        end\n    end\n\n    // Read domain\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            adr_o_gray <= 0;\n            q <= 0;\n        end else begin\n            if (rd && !empty) begin\n                q <= ram[adr_o[FIFO_TX_MEM_ADR_SIZE-2:0]];\n                adr_o <= adr_o + 1;\n                adr_o_gray <= (adr_o + 1) ^ ((adr_o + 1) >> 1);\n            end\n        end\n    end\n\n    // Clock domain crossing for write pointer to read domain\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_i_gray_sync <= 0;\n            adr_i_sync <= 0;\n        end else begin\n            adr_i_gray_sync <= adr_i_gray;\n            // Convert gray to binary\n            adr_i_sync[FIFO_TX_MEM_ADR_SIZE-1] = adr_i_gray_sync[FIFO_TX_MEM_ADR_SIZE-1];\n            for (integer i = FIFO_TX_MEM_ADR_SIZE-2; i >= 0; i = i - 1)\n                adr_i_sync[i] = adr_i_sync[i+1] ^ adr_i_gray_sync[i];\n        end\n    end\n\n    // Clock domain crossing for read pointer to write domain\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_o_gray_sync <= 0;\n            adr_o_sync <= 0;\n        end else begin\n            adr_o_gray_sync <= adr_o_gray;\n            // Convert gray to binary\n            adr_o_sync[FIFO_TX_MEM_ADR_SIZE-1] = adr_o_gray_sync[FIFO_TX_MEM_ADR_SIZE-1];\n            for (integer i = FIFO_TX_MEM_ADR_SIZE-2; i >= 0; i = i - 1)\n                adr_o_sync[i] = adr_o_sync[i+1] ^ adr_o_gray_sync[i];\n        end\n    end\n\n    // Full and empty generation\n    always @(*) begin\n        // Full when write pointer is one less than read pointer (modulo depth)\n        full = (adr_i[FIFO_TX_MEM_ADR_SIZE-2:0] == adr_o_sync[FIFO_TX_MEM_ADR_SIZE-2:0]) &&\n               (adr_i[FIFO_TX_MEM_ADR_SIZE-1] != adr_o_sync[FIFO_TX_MEM_ADR_SIZE-1]);\n        \n        // Empty when pointers are equal\n        empty = (adr_i_sync == adr_o);\n        \n        // Memory occupancy\n        if (adr_i_sync >= adr_o)\n            mem_empt = adr_i_sync - adr_o;\n        else\n            mem_empt = (FIFO_TX_MEM_DEPTH - adr_o) + adr_i_sync;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 7, "code": "module sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n// State definitions\nlocalparam IDLE    = 3'b001;\nlocalparam SETUP   = 3'b010;\nlocalparam EXECUTE = 3'b100;\n\n// Status bits\nlocalparam dat_ava = 6;\nlocalparam crc_valid = 5;\n\n// Response sizes\nlocalparam small_rsp = 7'b0101000;\nlocalparam big_rsp = 7'b1111111;\n\n// Internal signals\nreg [2:0] state, next_state;\nreg [3:0] debounce;\nreg card_present;\nreg ack_q, ack_in_int;\nreg req_q, req_in_int;\nreg index_check_enable;\nreg CRC_check_enable;\nreg complete;\nreg [15:0] Watchdog_Cnt;\nreg [7:0] status;\nreg [6:0] response_size;\nreg CIE, CCRCE, CTE, EI, CC;\n\n// Debounce logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0;\n        card_present <= 1'b0;\n    end else begin\n        if (!card_detect) begin\n            if (debounce != 4'b1111)\n                debounce <= debounce + 1'b1;\n        end else begin\n            debounce <= 4'b0;\n        end\n        card_present <= (debounce == 4'b1111);\n    end\nend\n\n// Synchronizers\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        ack_q <= 1'b0;\n        ack_in_int <= 1'b0;\n        req_q <= 1'b0;\n        req_in_int <= 1'b0;\n    end else begin\n        ack_q <= ack_in;\n        ack_in_int <= ack_q;\n        req_q <= req_in;\n        req_in_int <= req_q;\n    end\nend\n\n// FSM state register\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I)\n        state <= IDLE;\n    else\n        state <= next_state;\nend\n\n// FSM next state logic\nalways @(*) begin\n    case (state)\n        IDLE: next_state = New_CMD ? SETUP : IDLE;\n        SETUP: next_state = ack_in_int ? EXECUTE : SETUP;\n        EXECUTE: next_state = complete ? IDLE : EXECUTE;\n        default: next_state = IDLE;\n    endcase\nend\n\n// FSM output logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        // Reset all outputs\n        CRC_check_enable <= 1'b0;\n        complete <= 1'b0;\n        RESP_1_REG <= 32'b0;\n        ERR_INT_REG <= 5'b0;\n        NORMAL_INT_REG <= 16'b0;\n        STATUS_REG <= 16'b0;\n        status <= 8'b0;\n        cmd_out <= 40'b0;\n        settings <= 16'b0;\n        response_size <= 7'b0;\n        req_out <= 1'b0;\n        index_check_enable <= 1'b0;\n        ack_out <= 1'b0;\n        Watchdog_Cnt <= 16'b0;\n        CCRCE <= 1'b0;\n        EI <= 1'b0;\n        CC <= 1'b0;\n        go_idle_o <= 1'b0;\n        CIE <= 1'b0;\n        CTE <= 1'b0;\n    end else begin\n        // Default assignments\n        complete <= 1'b0;\n        ack_out <= 1'b0;\n        req_out <= 1'b0;\n        go_idle_o <= 1'b0;\n        \n        // Card presence interrupts\n        NORMAL_INT_REG[1] <= card_present;\n        NORMAL_INT_REG[2] <= ~card_present;\n        \n        // Interrupt resets\n        if (ERR_INT_RST) ERR_INT_REG <= 5'b0;\n        if (NORMAL_INT_RST) NORMAL_INT_REG <= 16'b0;\n        \n        case (state)\n            IDLE: begin\n                go_idle_o <= 1'b0;\n                req_out <= 1'b0;\n                ack_out <= 1'b0;\n                STATUS_REG[0] <= 1'b0; // CICMD\n                \n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1'b1;\n                end\n            end\n            \n            SETUP: begin\n                NORMAL_INT_REG <= 16'b0;\n                ERR_INT_REG <= 5'b0;\n                index_check_enable <= CMD_SET_REG[4]; // CICE\n                CRC_check_enable <= CMD_SET_REG[3];   // CRCE\n                \n                // Compose command\n                cmd_out[39:38] <= 2'b01;\n                cmd_out[37:32] <= CMD_SET_REG[13:8];  // CMDI\n                cmd_out[31:0] <= ARG_REG;\n                \n                // Determine response size\n                case (CMD_SET_REG[1:0]) // RTS\n                    2'b10, 2'b11: response_size <= small_rsp;\n                    2'b01: response_size <= big_rsp;\n                    default: response_size <= 7'b0;\n                endcase\n                \n                // Setup settings\n                settings[14:13] <= CMD_SET_REG[7:6];  // WORD_SELECT\n                settings[12] <= data_read;\n                settings[11] <= data_write;\n                settings[10:8] <= 3'b111;             // Delay\n                settings[7] <= CMD_SET_REG[3];        // CRCE\n                settings[6:0] <= response_size;\n                \n                Watchdog_Cnt <= 16'b0;\n                STATUS_REG[0] <= 1'b1; // CICMD\n            end\n            \n            EXECUTE: begin\n                Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                \n                // Timeout handling\n                if (Watchdog_Cnt > TIMEOUT_REG) begin\n                    ERR_INT_REG[0] <= 1'b1; // CTE\n                    NORMAL_INT_REG[15] <= 1'b1; // EI\n                    if (ack_in) complete <= 1'b1;\n                    go_idle_o <= 1'b1;\n                end\n                \n                // Request handling\n                if (ack_in_int) begin\n                    req_out <= 1'b1;\n                end\n                \n                // Status handling\n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1'b1;\n                    \n                    if (status[dat_ava]) begin\n                        complete <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b0; // Clear EI\n                        \n                        // CRC check\n                        if (CRC_check_enable && !status[crc_valid]) begin\n                            ERR_INT_REG[1] <= 1'b1; // CCRCE\n                            NORMAL_INT_REG[15] <= 1'b1; // EI\n                        end\n                        \n                        // Index check\n                        if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                            ERR_INT_REG[3] <= 1'b1; // CIE\n                            NORMAL_INT_REG[15] <= 1'b1; // EI\n                        end\n                        \n                        NORMAL_INT_REG[0] <= 1'b1; // CC\n                        \n                        // Store response if needed\n                        if (response_size != 7'b0) begin\n                            RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            end\n        endcase\n        \n        // Update interrupt registers\n        ERR_INT_REG[3] <= CIE;\n        ERR_INT_REG[1] <= CCRCE;\n        ERR_INT_REG[0] <= CTE;\n        NORMAL_INT_REG[15] <= EI;\n        NORMAL_INT_REG[0] <= CC;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 18, "code": "module sd_fifo_rx_filler (\n    input  wire         clk,\n    input  wire         rst,\n    output reg  [31:0]  m_wb_adr_o,\n    output reg          m_wb_we_o,\n    output reg  [31:0]  m_wb_dat_o,\n    output reg          m_wb_cyc_o,\n    output reg          m_wb_stb_o,\n    input  wire         m_wb_ack_i,\n    output wire [2:0]   m_wb_cti_o,\n    output wire [2:0]   m_wb_bte_o,\n    input  wire         en,\n    input  wire [31:0]  adr,\n    input  wire         sd_clk,\n    input  wire [3:0]   dat_i,\n    input  wire         wr,\n    output wire         full,\n    output wire         empty\n);\n\n// Internal registers\nreg [8:0]  offset;\nreg        wb_free;\nreg        reset_rx_fifo;\nreg        rd;\n\n// FIFO signals\nwire [31:0] dat_o;\nwire [1:0]  mem_empt;\n\n// State machine\nparameter IDLE      = 2'b00;\nparameter READ_FIFO = 2'b01;\nparameter WB_WRITE  = 2'b10;\nparameter WB_WAIT   = 2'b11;\n\nreg [1:0] state, next_state;\n\n// FIFO instance\nsd_rx_fifo rx_fifo (\n    .d(dat_i),\n    .wr(wr),\n    .wclk(sd_clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(full),\n    .empty(empty),\n    .mem_empt(mem_empt),\n    .rclk(clk),\n    .rst(reset_rx_fifo)\n);\n\n// Wishbone signals\nassign m_wb_cti_o = 3'b000;  // Classic cycle\nassign m_wb_bte_o = 2'b00;   // Linear burst\n\n// State machine\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    next_state = state;\n    case (state)\n        IDLE: begin\n            if (en && !empty && wb_free) begin\n                next_state = READ_FIFO;\n            end\n        end\n        READ_FIFO: begin\n            next_state = WB_WRITE;\n        end\n        WB_WRITE: begin\n            next_state = WB_WAIT;\n        end\n        WB_WAIT: begin\n            if (m_wb_ack_i) begin\n                if (en && !empty && wb_free) begin\n                    next_state = READ_FIFO;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n        end\n    endcase\nend\n\n// Control signals\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wb_adr_o    <= 32'h0;\n        m_wb_dat_o    <= 32'h0;\n        m_wb_we_o     <= 1'b0;\n        m_wb_cyc_o    <= 1'b0;\n        m_wb_stb_o    <= 1'b0;\n        offset        <= 9'h0;\n        wb_free       <= 1'b1;\n        reset_rx_fifo <= 1'b1;\n        rd            <= 1'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                m_wb_we_o     <= 1'b0;\n                m_wb_cyc_o    <= 1'b0;\n                m_wb_stb_o    <= 1'b0;\n                rd            <= 1'b0;\n                reset_rx_fifo <= ~en;\n                \n                if (!en) begin\n                    offset <= 9'h0;\n                    wb_free <= 1'b1;\n                end\n            end\n            READ_FIFO: begin\n                rd <= 1'b1;\n                m_wb_adr_o <= adr + {23'h0, offset};\n                m_wb_dat_o <= dat_o;\n            end\n            WB_WRITE: begin\n                rd <= 1'b0;\n                m_wb_we_o  <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                wb_free    <= 1'b0;\n            end\n            WB_WAIT: begin\n                if (m_wb_ack_i) begin\n                    m_wb_we_o  <= 1'b0;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    wb_free    <= 1'b1;\n                    offset     <= offset + `MEM_OFFSET;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 16, "code": "module sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    output wire full,\n    output wire empty,\n    output wire [1:0] mem_empt,\n    input wire rclk,\n    input wire rst\n);\n\nparameter FIFO_RX_MEM_DEPTH = 16; // Example value, should be defined in sd_defines.v\nparameter FIFO_RX_MEM_ADR_SIZE = 5; // log2(FIFO_RX_MEM_DEPTH) + 1\n\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_next = adr_i + 1'b1;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o_next = adr_o + 1'b1;\n\n// Full and empty flags\nassign full = (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] == adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]) && \n              (adr_i[FIFO_RX_MEM_ADR_SIZE-1] != adr_o[FIFO_RX_MEM_ADR_SIZE-1]);\nassign empty = (adr_i == adr_o);\nassign mem_empt = (adr_i[FIFO_RX_MEM_ADR_SIZE-1] == adr_o[FIFO_RX_MEM_ADR_SIZE-1]) ? \n                  (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] - adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]) : \n                  (FIFO_RX_MEM_DEPTH - adr_o[FIFO_RX_MEM_ADR_SIZE-2:0] + adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]);\n\n// Write clock domain\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n    end else begin\n        if (wr && !full) begin\n            case (we)\n                8'h1: tmp[3:0] <= d;\n                8'h2: tmp[7:4] <= d;\n                8'h4: tmp[11:8] <= d;\n                8'h8: tmp[15:12] <= d;\n                8'h10: tmp[19:16] <= d;\n                8'h20: tmp[23:20] <= d;\n                8'h40: tmp[27:24] <= d;\n                8'h80: begin\n                    tmp[31:28] <= d;\n                    ft <= 1'b1;\n                end\n                default: we <= 8'h1;\n            endcase\n            \n            we <= we << 1;\n            \n            if (ft) begin\n                ram[adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]] <= tmp;\n                adr_i <= adr_i_next;\n                ft <= 1'b0;\n                we <= 8'h1;\n            end\n        end\n    end\nend\n\n// Read clock domain\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else begin\n        if (rd && !empty) begin\n            q <= ram[adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]];\n            adr_o <= adr_o_next;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 1, "code": "module sd_controller_wb (\n    // Wishbone interface\n    input               wb_clk_i,\n    input               wb_rst_i,\n    input      [31:0]   wb_dat_i,\n    output reg [31:0]   wb_dat_o,\n    input      [7:0]    wb_adr_i,\n    input      [3:0]    wb_sel_i,\n    input               wb_we_i,\n    input               wb_cyc_i,\n    input               wb_stb_i,\n    output reg          wb_ack_o,\n    \n    // Control signals\n    output reg          we_m_tx_bd,\n    output reg          we_m_rx_bd,\n    output reg          new_cmd,\n    output reg          we_ack,\n    output reg          int_ack,\n    output reg          cmd_int_busy,\n    output reg          int_busy,\n    \n    // Data master interface\n    input               write_req_s,\n    input      [15:0]   cmd_set_s,\n    input      [32:0]   cmd_arg_s,\n    \n    // Registers\n    output reg [31:0]   argument_reg,\n    output reg [15:0]   cmd_setting_reg,\n    input      [15:0]   status_reg,\n    input      [31:0]   cmd_resp_1,\n    output reg [7:0]    software_reset_reg,\n    output reg [16:0]   time_out_reg,\n    input      [15:0]   normal_int_status_reg,\n    input      [15:0]   error_int_status_reg,\n    output reg [15:0]   normal_int_signal_enable_reg,\n    output reg [15:0]   error_int_signal_enable_reg,\n    output reg [7:0]    clock_divider,\n    input      [15:0]   Bd_Status_reg,\n    input      [8:0]    Bd_isr_reg,\n    output reg [8:0]    Bd_isr_enable_reg,\n    \n    // Interrupt reset signals\n    output reg          Bd_isr_reset,\n    output reg          normal_isr_reset,\n    output reg          error_isr_reset,\n    \n    // BD data\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\nparameter RAM_MEM_WIDTH = 32; // Default to 32-bit width\n\n// Internal signals\nreg [1:0] bd_write_state;\nreg [31:0] bd_write_data;\nreg bd_write_active;\n\n// Reset and initialization\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to default values\n        argument_reg <= 32'h0;\n        cmd_setting_reg <= 16'h0;\n        software_reset_reg <= 8'h0;\n        time_out_reg <= 16'h0;\n        normal_int_signal_enable_reg <= 16'h0;\n        error_int_signal_enable_reg <= 16'h0;\n        clock_divider <= 8'h0;\n        Bd_isr_enable_reg <= 8'h0;\n        \n        // Reset control signals\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        wb_ack_o <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        \n        // BD write state machine\n        bd_write_state <= 2'b00;\n        bd_write_data <= 32'h0;\n        bd_write_active <= 1'b0;\n    end else begin\n        // Default values\n        wb_ack_o <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        \n        // Handle data master interface\n        if (write_req_s) begin\n            argument_reg <= cmd_arg_s;\n            cmd_setting_reg <= cmd_set_s;\n            we_ack <= 1'b1;\n            cmd_int_busy <= 1'b1;\n            int_busy <= 1'b1;\n            new_cmd <= 1'b1;\n        end else begin\n            cmd_int_busy <= 1'b0;\n        end\n        \n        // Handle Wishbone interface\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: begin // Argument register\n                        argument_reg <= wb_dat_i;\n                        int_busy <= 1'b1;\n                        new_cmd <= 1'b1;\n                    end\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_isr_reset <= 1'b1;\n                    8'h34: error_isr_reset <= 1'b1;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1'b1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    \n                    // BD RX/TX handling\n                    8'h60: begin // BD RX\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                            we_m_rx_bd <= 1'b1;\n                            int_ack <= 1'b0;\n                            bd_write_active <= 1'b1;\n                        end else begin // 16-bit\n                            if (bd_write_state == 2'b00) begin\n                                bd_write_data[15:0] <= wb_dat_i[15:0];\n                                bd_write_state <= 2'b01;\n                            end else begin\n                                dat_in_m_rx_bd <= {wb_dat_i[15:0], bd_write_data[15:0]};\n                                we_m_rx_bd <= 1'b1;\n                                int_ack <= 1'b0;\n                                bd_write_state <= 2'b00;\n                                bd_write_active <= 1'b1;\n                            end\n                        end\n                    end\n                    8'h80: begin // BD TX\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                            we_m_tx_bd <= 1'b1;\n                            int_ack <= 1'b0;\n                            bd_write_active <= 1'b1;\n                        end else begin // 16-bit\n                            if (bd_write_state == 2'b00) begin\n                                bd_write_data[15:0] <= wb_dat_i[15:0];\n                                bd_write_state <= 2'b01;\n                            end else begin\n                                dat_in_m_tx_bd <= {wb_dat_i[15:0], bd_write_data[15:0]};\n                                we_m_tx_bd <= 1'b1;\n                                int_ack <= 1'b0;\n                                bd_write_state <= 2'b00;\n                                bd_write_active <= 1'b1;\n                            end\n                        end\n                    end\n                endcase\n                \n                if (!bd_write_active && wb_adr_i != 8'h60 && wb_adr_i != 8'h80) begin\n                    wb_ack_o <= 1'b1;\n                end\n            end else begin\n                // Read operation\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= {16'h0, 16'h0}; // Controller Setting\n                    8'h20: wb_dat_o <= {16'h0, 16'h0200}; // Block Size (fixed 512)\n                    8'h24: wb_dat_o <= {24'h0, 8'h0f}; // Power Control (3.3V)\n                    8'h28: wb_dat_o <= {24'h0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= {16'h0, 16'h0}; // Capability\n                    8'h4c: wb_dat_o <= {24'h0, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'h0;\n                endcase\n                wb_ack_o <= 1'b1;\n            end\n        end\n        \n        // Handle BD write completion\n        if (bd_write_active) begin\n            if (int_ack == 1'b0) begin\n                int_ack <= 1'b1;\n                we_m_tx_bd <= 1'b0;\n                we_m_rx_bd <= 1'b0;\n                wb_ack_o <= 1'b1;\n                bd_write_active <= 1'b0;\n            end\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 17, "code": "module sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    input wire rclk,\n    output reg full,\n    output reg empty,\n    output wire [1:0] mem_empt,\n    input wire rst\n);\n\nparameter FIFO_RX_MEM_DEPTH = 8; // Example value, should be defined in sd_defines.v\nparameter FIFO_RX_MEM_ADR_SIZE = 4; // log2(FIFO_RX_MEM_DEPTH) + 1\n\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_next = adr_i + 1'b1;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o_next = adr_o + 1'b1;\n\n// Memory empty space calculation\nassign mem_empt = (adr_i[FIFO_RX_MEM_ADR_SIZE-1] == adr_o[FIFO_RX_MEM_ADR_SIZE-1]) ? \n                 (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] - adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]) :\n                 (FIFO_RX_MEM_DEPTH - adr_o[FIFO_RX_MEM_ADR_SIZE-2:0] + adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]);\n\n// Full and empty flags\nalways @* begin\n    full = (adr_i == {~adr_o[FIFO_RX_MEM_ADR_SIZE-1], adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]});\n    empty = (adr_i == adr_o);\nend\n\n// Write operation (wclk domain)\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n    end else begin\n        if (wr && !full) begin\n            case (we)\n                8'h1: tmp[3:0] <= d;\n                8'h2: tmp[7:4] <= d;\n                8'h4: tmp[11:8] <= d;\n                8'h8: tmp[15:12] <= d;\n                8'h10: tmp[19:16] <= d;\n                8'h20: tmp[23:20] <= d;\n                8'h40: tmp[27:24] <= d;\n                8'h80: begin\n                    tmp[31:28] <= d;\n                    ft <= 1'b1;\n                end\n            endcase\n            \n            if (we == 8'h80) begin\n                ram[adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]] <= tmp;\n                adr_i <= adr_i_next;\n                we <= 8'h1;\n                ft <= 1'b0;\n            end else begin\n                we <= we << 1;\n            end\n        end\n    end\nend\n\n// Read operation (rclk domain)\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else begin\n        if (rd && !empty) begin\n            q <= ram[adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]];\n            adr_o <= adr_o_next;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 19, "code": "module sd_fifo_rx_filler (\n    input  wire         clk,\n    input  wire         rst,\n    output reg  [31:0]  m_wb_adr_o,\n    output reg          m_wb_we_o,\n    output reg  [31:0]  m_wb_dat_o,\n    output reg          m_wb_cyc_o,\n    output reg          m_wb_stb_o,\n    input  wire         m_wb_ack_i,\n    output wire [2:0]   m_wb_cti_o,\n    output wire [2:0]   m_wb_bte_o,\n    input  wire         en,\n    input  wire [31:0]  adr,\n    input  wire         sd_clk,\n    input  wire [3:0]   dat_i,\n    input  wire         wr,\n    output wire         full,\n    output wire         empty\n);\n\n// Local parameters\nlocalparam MEM_OFFSET = 4; // Assuming 4-byte word alignment\n\n// Internal registers\nreg [8:0]  offset;\nreg        wb_free;\nreg        reset_rx_fifo;\nreg        rd;\n\n// FIFO signals\nwire [31:0] dat_o;\nwire        fifo_empty;\nwire        fifo_full;\n\n// State machine\nreg [1:0] state;\nlocalparam IDLE      = 2'b00;\nlocalparam READ_FIFO = 2'b01;\nlocalparam WB_WRITE  = 2'b10;\n\n// Instantiate RX FIFO\nsd_rx_fifo rx_fifo (\n    .d(dat_i),\n    .wr(wr),\n    .wclk(sd_clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(fifo_full),\n    .empty(fifo_empty),\n    .rclk(clk),\n    .rst(rst | reset_rx_fifo)\n);\n\nassign full = fifo_full;\nassign empty = fifo_empty;\nassign m_wb_cti_o = 3'b000; // Classic cycle\nassign m_wb_bte_o = 2'b00;  // Linear burst\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all control signals\n        m_wb_adr_o <= 32'b0;\n        m_wb_we_o <= 1'b0;\n        m_wb_dat_o <= 32'b0;\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n        offset <= 9'b0;\n        wb_free <= 1'b1;\n        reset_rx_fifo <= 1'b1;\n        rd <= 1'b0;\n        state <= IDLE;\n    end else begin\n        case (state)\n            IDLE: begin\n                if (!en) begin\n                    // Disabled state\n                    reset_rx_fifo <= 1'b1;\n                    rd <= 1'b0;\n                    offset <= 9'b0;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    m_wb_we_o <= 1'b0;\n                    wb_free <= 1'b1;\n                end else begin\n                    reset_rx_fifo <= 1'b0;\n                    if (!fifo_empty && wb_free) begin\n                        // Prepare to read from FIFO\n                        rd <= 1'b1;\n                        state <= READ_FIFO;\n                    end\n                end\n            end\n            \n            READ_FIFO: begin\n                // FIFO data should now be available\n                m_wb_dat_o <= dat_o;\n                m_wb_adr_o <= adr + {23'b0, offset};\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                wb_free <= 1'b0;\n                rd <= 1'b0;\n                state <= WB_WRITE;\n            end\n            \n            WB_WRITE: begin\n                if (m_wb_ack_i) begin\n                    // Transaction complete\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    m_wb_we_o <= 1'b0;\n                    wb_free <= 1'b1;\n                    offset <= offset + MEM_OFFSET;\n                    state <= IDLE;\n                end\n            end\n            \n            default: state <= IDLE;\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 8, "code": "module sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n    // State definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal signals\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg ack_q, ack_in_int;\n    reg req_q, req_in_int;\n    reg index_check_enable;\n    reg CRC_check_enable;\n    reg complete;\n    reg [15:0] Watchdog_Cnt;\n    reg [6:0] response_size;\n    reg [7:0] status;\n    \n    // Status bits\n    wire dat_ava = status[6];\n    wire crc_valid = status[5];\n    \n    // Response sizes\n    wire [6:0] small_rsp = 7'b0101000;\n    wire [6:0] big_rsp = 7'b1111111;\n    \n    // CMD_SET_REG fields\n    wire [5:0] CMDI = CMD_SET_REG[13:8];\n    wire [1:0] WORD_SELECT = CMD_SET_REG[7:6];\n    wire CICE = CMD_SET_REG[4];\n    wire CRCE = CMD_SET_REG[3];\n    wire [1:0] RTS = CMD_SET_REG[1:0];\n    \n    // Interrupt bits\n    wire CTE = ERR_INT_REG[0];\n    wire CCRCE = ERR_INT_REG[1];\n    wire CIE = ERR_INT_REG[3];\n    wire CC = NORMAL_INT_REG[0];\n    wire EI = NORMAL_INT_REG[15];\n\n    // Debounce logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0;\n            end\n            \n            card_present <= (debounce == 4'b1111) ? 1'b1 : 1'b0;\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            ack_q <= 1'b0;\n            ack_in_int <= 1'b0;\n            req_q <= 1'b0;\n            req_in_int <= 1'b0;\n        end else begin\n            ack_q <= ack_in;\n            ack_in_int <= ack_q;\n            req_q <= req_in;\n            req_in_int <= req_q;\n        end\n    end\n\n    // FSM state register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // FSM next state logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = New_CMD ? SETUP : IDLE;\n            SETUP: next_state = ack_in_int ? EXECUTE : SETUP;\n            EXECUTE: next_state = complete ? IDLE : EXECUTE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM output logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            // Reset all outputs\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            // Default assignments\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n            \n            // Handle interrupt resets\n            if (ERR_INT_RST) ERR_INT_REG <= 5'b0;\n            if (NORMAL_INT_RST) NORMAL_INT_REG <= 16'b0;\n            \n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    STATUS_REG[0] <= 1'b0; // CICMD\n                    \n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                \n                SETUP: begin\n                    // Clear interrupt registers\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    \n                    // Set up checks\n                    index_check_enable <= CICE;\n                    CRC_check_enable <= CRCE;\n                    \n                    // Compose command\n                    cmd_out <= {2'b01, CMDI, ARG_REG};\n                    \n                    // Determine response size\n                    case (RTS)\n                        2'b10, 2'b11: response_size <= small_rsp;\n                        2'b01: response_size <= big_rsp;\n                        default: response_size <= 7'b0;\n                    endcase\n                    \n                    // Configure settings\n                    settings <= {WORD_SELECT, data_read, data_write, 3'b111, CRCE, response_size};\n                    \n                    // Reset watchdog\n                    Watchdog_Cnt <= 16'b0;\n                    \n                    // Set CICMD\n                    STATUS_REG[0] <= 1'b1;\n                end\n                \n                EXECUTE: begin\n                    // Increment watchdog\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                    \n                    // Check for timeout\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1; // CTE\n                        NORMAL_INT_REG[15] <= 1'b1; // EI\n                        \n                        if (ack_in) complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    \n                    // Handle request/acknowledge\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        \n                        if (dat_ava) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0; // Clear EI\n                            \n                            // Check CRC if enabled\n                            if (CRC_check_enable && !crc_valid) begin\n                                ERR_INT_REG[1] <= 1'b1; // CCRCE\n                                NORMAL_INT_REG[15] <= 1'b1; // EI\n                            end\n                            \n                            // Check index if enabled\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1; // CIE\n                                NORMAL_INT_REG[15] <= 1'b1; // EI\n                            end\n                            \n                            NORMAL_INT_REG[0] <= 1'b1; // CC\n                            \n                            // Store response if needed\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 2, "code": "module sd_controller_wb (\n    // Wishbone interface\n    input               wb_clk_i,\n    input               wb_rst_i,\n    input      [31:0]   wb_dat_i,\n    output reg [31:0]   wb_dat_o,\n    input      [7:0]    wb_adr_i,\n    input      [3:0]    wb_sel_i,\n    input               wb_we_i,\n    input               wb_cyc_i,\n    input               wb_stb_i,\n    output reg          wb_ack_o,\n    \n    // Control signals\n    output reg          we_m_tx_bd,\n    output reg          we_m_rx_bd,\n    output reg          new_cmd,\n    output reg          we_ack,\n    output reg          int_ack,\n    output reg          cmd_int_busy,\n    output reg          int_busy,\n    \n    // Data master interface\n    input               write_req_s,\n    input      [15:0]   cmd_set_s,\n    input      [32:0]   cmd_arg_s,\n    \n    // Registers\n    output reg [31:0]   argument_reg,\n    output reg [15:0]   cmd_setting_reg,\n    input      [15:0]   status_reg,\n    input      [32:0]   cmd_resp_1,\n    output reg [7:0]    software_reset_reg,\n    output reg [16:0]   time_out_reg,\n    input      [15:0]   normal_int_status_reg,\n    input      [15:0]   error_int_status_reg,\n    output reg [15:0]   normal_int_signal_enable_reg,\n    output reg [15:0]   error_int_signal_enable_reg,\n    output reg [7:0]    clock_divider,\n    input      [15:0]   Bd_Status_reg,\n    input      [7:0]    Bd_isr_reg,\n    output reg [7:0]    Bd_isr_enable_reg,\n    \n    // Interrupt reset signals\n    output reg          Bd_isr_reset,\n    output reg          normal_isr_reset,\n    output reg          error_isr_reset,\n    \n    // BD data\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\nparameter RAM_MEM_WIDTH = 32; // Default to 32-bit width\n\n// Internal signals\nreg [1:0] bd_write_state;\nreg [31:0] bd_temp_data;\n\n// Register read/write logic\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to default values\n        argument_reg <= 32'h0;\n        cmd_setting_reg <= 16'h0;\n        software_reset_reg <= 8'h0;\n        time_out_reg <= 16'h0;\n        normal_int_signal_enable_reg <= 16'h0;\n        error_int_signal_enable_reg <= 16'h0;\n        clock_divider <= 8'h0;\n        Bd_isr_enable_reg <= 8'h0;\n        \n        // Reset control signals\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        wb_ack_o <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        bd_write_state <= 2'b00;\n    end\n    else begin\n        // Default values\n        wb_ack_o <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        \n        // Handle data master interface\n        if (write_req_s) begin\n            argument_reg <= cmd_arg_s;\n            cmd_setting_reg <= cmd_set_s;\n            new_cmd <= 1'b1;\n            we_ack <= 1'b1;\n            cmd_int_busy <= 1'b1;\n        end else begin\n            cmd_int_busy <= 1'b0;\n        end\n        \n        // Wishbone access\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: begin // Argument register\n                        argument_reg <= wb_dat_i;\n                        int_busy <= 1'b1;\n                    end\n                    8'h04: begin // Command setting register\n                        cmd_setting_reg <= wb_dat_i[15:0];\n                    end\n                    8'h28: begin // Software reset register\n                        software_reset_reg <= wb_dat_i[7:0];\n                    end\n                    8'h2c: begin // Timeout register\n                        time_out_reg <= wb_dat_i[15:0];\n                    end\n                    8'h30: begin // Normal interrupt status register\n                        normal_isr_reset <= 1'b1;\n                    end\n                    8'h34: begin // Error interrupt status register\n                        error_isr_reset <= 1'b1;\n                    end\n                    8'h38: begin // Normal interrupt enable register\n                        normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    end\n                    8'h3c: begin // Error interrupt enable register\n                        error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    end\n                    8'h4c: begin // Clock divider register\n                        clock_divider <= wb_dat_i[7:0];\n                    end\n                    8'h54: begin // Data interrupt status register\n                        Bd_isr_reset <= 1'b1;\n                    end\n                    8'h58: begin // Data interrupt enable register\n                        Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    end\n                    8'h60: begin // BD RX\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                            we_m_rx_bd <= 1'b1;\n                            int_ack <= 1'b0;\n                            wb_ack_o <= 1'b1;\n                        end else begin\n                            if (bd_write_state == 2'b00) begin\n                                bd_temp_data[15:0] <= wb_dat_i[15:0];\n                                bd_write_state <= 2'b01;\n                                int_ack <= 1'b0;\n                            end else begin\n                                bd_temp_data[31:16] <= wb_dat_i[15:0];\n                                dat_in_m_rx_bd <= bd_temp_data[31:16];\n                                we_m_rx_bd <= 1'b1;\n                                bd_write_state <= 2'b00;\n                                wb_ack_o <= 1'b1;\n                            end\n                        end\n                    end\n                    8'h80: begin // BD TX\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                            we_m_tx_bd <= 1'b1;\n                            int_ack <= 1'b0;\n                            wb_ack_o <= 1'b1;\n                        end else begin\n                            if (bd_write_state == 2'b00) begin\n                                bd_temp_data[15:0] <= wb_dat_i[15:0];\n                                bd_write_state <= 2'b01;\n                                int_ack <= 1'b0;\n                            end else begin\n                                bd_temp_data[31:16] <= wb_dat_i[15:0];\n                                dat_in_m_tx_bd <= bd_temp_data[31:16];\n                                we_m_tx_bd <= 1'b1;\n                                bd_write_state <= 2'b00;\n                                wb_ack_o <= 1'b1;\n                            end\n                        end\n                    end\n                endcase\n            end\n            else begin\n                // Read operation\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= {16'h0, 16'h0}; // Controller setting\n                    8'h20: wb_dat_o <= {16'h0, 16'h0200}; // Block size (fixed to 512)\n                    8'h24: wb_dat_o <= {24'h0, 8'h0f}; // Power control (fixed to 3.3V)\n                    8'h28: wb_dat_o <= {24'h0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= {16'h0, 16'h0}; // Capability\n                    8'h4c: wb_dat_o <= {24'h0, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'h0;\n                endcase\n                wb_ack_o <= 1'b1;\n            end\n        end\n        \n        // Handle BD write completion\n        if (we_m_tx_bd || we_m_rx_bd) begin\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            int_ack <= 1'b1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 3, "code": "module sd_controller_wb (\n    // Wishbone interface\n    input               wb_clk_i,\n    input               wb_rst_i,\n    input      [31:0]   wb_dat_i,\n    output reg [31:0]   wb_dat_o,\n    input      [7:0]    wb_adr_i,\n    input      [3:0]    wb_sel_i,\n    input               wb_we_i,\n    input               wb_cyc_i,\n    input               wb_stb_i,\n    output reg          wb_ack_o,\n    \n    // Control signals\n    output reg          we_m_tx_bd,\n    output reg          we_m_rx_bd,\n    output reg          new_cmd,\n    output reg          we_ack,\n    output reg          int_ack,\n    output reg          cmd_int_busy,\n    output reg          int_busy,\n    \n    // Data master interface\n    input               write_req_s,\n    input      [15:0]   cmd_set_s,\n    input      [32:0]   cmd_arg_s,\n    \n    // Registers\n    output reg [31:0]   argument_reg,\n    output reg [15:0]   cmd_setting_reg,\n    input      [15:0]   status_reg,\n    input      [32:0]   cmd_resp_1,\n    output reg [7:0]    software_reset_reg,\n    output reg [16:0]   time_out_reg,\n    input      [15:0]   normal_int_status_reg,\n    input      [15:0]   error_int_status_reg,\n    output reg [15:0]   normal_int_signal_enable_reg,\n    output reg [15:0]   error_int_signal_enable_reg,\n    output reg [7:0]    clock_divider,\n    input      [15:0]   Bd_Status_reg,\n    input      [7:0]    Bd_isr_reg,\n    output reg [7:0]    Bd_isr_enable_reg,\n    \n    // Interrupt reset signals\n    output reg          Bd_isr_reset,\n    output reg          normal_isr_reset,\n    output reg          error_isr_reset,\n    \n    // BD data\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\nparameter RAM_MEM_WIDTH = 32;\n\n// Internal signals\nreg [1:0] bd_write_state;\nreg [31:0] bd_write_data;\n\n// Register read/write logic\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to default values\n        argument_reg <= 32'h0;\n        cmd_setting_reg <= 16'h0;\n        software_reset_reg <= 8'h0;\n        time_out_reg <= 16'h0;\n        normal_int_signal_enable_reg <= 16'h0;\n        error_int_signal_enable_reg <= 16'h0;\n        clock_divider <= 8'h0;\n        Bd_isr_enable_reg <= 8'h0;\n        \n        // Reset control signals\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        wb_ack_o <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        bd_write_state <= 2'b00;\n    end\n    else begin\n        // Default values\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        wb_ack_o <= 1'b0;\n        \n        // Handle data master write requests\n        if (write_req_s) begin\n            argument_reg <= cmd_arg_s;\n            cmd_setting_reg <= cmd_set_s;\n            new_cmd <= 1'b1;\n            we_ack <= 1'b1;\n            cmd_int_busy <= 1'b1;\n        end\n        else begin\n            cmd_int_busy <= 1'b0;\n        end\n        \n        // Wishbone access\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i[7:0])\n                    8'h00: begin\n                        argument_reg <= wb_dat_i;\n                        int_busy <= 1'b1;\n                    end\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_isr_reset <= 1'b1;\n                    8'h34: error_isr_reset <= 1'b1;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1'b1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    \n                    // BD RX/TX handling\n                    8'h60: begin\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                            we_m_rx_bd <= 1'b1;\n                            int_ack <= 1'b0;\n                        end\n                        else begin\n                            bd_write_state <= 2'b01;\n                            bd_write_data <= wb_dat_i;\n                            int_ack <= 1'b0;\n                        end\n                    end\n                    8'h80: begin\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                            we_m_tx_bd <= 1'b1;\n                            int_ack <= 1'b0;\n                        end\n                        else begin\n                            bd_write_state <= 2'b10;\n                            bd_write_data <= wb_dat_i;\n                            int_ack <= 1'b0;\n                        end\n                    end\n                endcase\n                \n                // For non-BD writes, generate immediate ack\n                if (!(wb_adr_i[7:0] == 8'h60 || wb_adr_i[7:0] == 8'h80)) begin\n                    wb_ack_o <= 1'b1;\n                end\n            end\n            else begin\n                // Read operation\n                case (wb_adr_i[7:0])\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= 32'h0; // Controller Setting\n                    8'h20: wb_dat_o <= {16'h0, 16'h0200}; // Block Size (fixed 512)\n                    8'h24: wb_dat_o <= {24'h0, 8'h0F}; // Power Control (3.3V)\n                    8'h28: wb_dat_o <= {24'h0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h0; // Capability\n                    8'h4c: wb_dat_o <= {24'h0, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'h0;\n                endcase\n                wb_ack_o <= 1'b1;\n            end\n        end\n        \n        // Handle BD write state machine for 16-bit RAM\n        if (RAM_MEM_WIDTH == 16) begin\n            case (bd_write_state)\n                2'b01: begin // RX BD write\n                    dat_in_m_rx_bd <= bd_write_data[15:0];\n                    we_m_rx_bd <= 1'b1;\n                    bd_write_state <= 2'b11;\n                end\n                2'b10: begin // TX BD write\n                    dat_in_m_tx_bd <= bd_write_data[15:0];\n                    we_m_tx_bd <= 1'b1;\n                    bd_write_state <= 2'b11;\n                end\n                2'b11: begin // Second part of BD write\n                    if (bd_write_state[1]) begin // TX\n                        dat_in_m_tx_bd <= bd_write_data[31:16];\n                    end\n                    else begin // RX\n                        dat_in_m_rx_bd <= bd_write_data[31:16];\n                    end\n                    bd_write_state <= 2'b00;\n                    wb_ack_o <= 1'b1;\n                    int_ack <= 1'b1;\n                    we_m_tx_bd <= 1'b0;\n                    we_m_rx_bd <= 1'b0;\n                end\n            endcase\n        end\n        else if (int_ack == 1'b0) begin\n            // For 32-bit RAM, complete the BD write\n            wb_ack_o <= 1'b1;\n            int_ack <= 1'b1;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 9, "code": "module sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n// State definitions\nlocalparam IDLE    = 3'b001;\nlocalparam SETUP   = 3'b010;\nlocalparam EXECUTE = 3'b100;\n\n// Status bit positions\nlocalparam dat_ava = 6;\nlocalparam crc_valid = 5;\n\n// Response sizes\nlocalparam small_rsp = 7'b0101000;\nlocalparam big_rsp = 7'b1111111;\n\n// Internal registers\nreg [2:0] state, next_state;\nreg [3:0] debounce;\nreg card_present;\nreg ack_q, ack_in_int;\nreg req_q, req_in_int;\nreg index_check_enable;\nreg CRC_check_enable;\nreg complete;\nreg [15:0] Watchdog_Cnt;\nreg [6:0] response_size;\nreg [7:0] status;\n\n// Error flags\nreg CTE, CIE, CCRCE, EI, CC;\n\n// Synchronization flip-flops\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        ack_q <= 0;\n        ack_in_int <= 0;\n        req_q <= 0;\n        req_in_int <= 0;\n    end else begin\n        ack_q <= ack_in;\n        ack_in_int <= ack_q;\n        req_q <= req_in;\n        req_in_int <= req_q;\n    end\nend\n\n// Debounce logic for card detection\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 0;\n        card_present <= 0;\n    end else begin\n        if (!card_detect) begin\n            if (debounce != 4'b1111)\n                debounce <= debounce + 1;\n        end else begin\n            debounce <= 0;\n        end\n        \n        card_present <= (debounce == 4'b1111) ? 1'b1 : 1'b0;\n    end\nend\n\n// State register\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (state)\n        IDLE: next_state = New_CMD ? SETUP : IDLE;\n        SETUP: next_state = ack_in_int ? EXECUTE : SETUP;\n        EXECUTE: next_state = complete ? IDLE : EXECUTE;\n        default: next_state = IDLE;\n    endcase\nend\n\n// Main FSM\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        // Reset all outputs and internal registers\n        CRC_check_enable <= 0;\n        complete <= 0;\n        RESP_1_REG <= 0;\n        ERR_INT_REG <= 0;\n        NORMAL_INT_REG <= 0;\n        STATUS_REG <= 0;\n        status <= 0;\n        cmd_out <= 0;\n        settings <= 0;\n        response_size <= 0;\n        req_out <= 0;\n        index_check_enable <= 0;\n        ack_out <= 0;\n        Watchdog_Cnt <= 0;\n        CCRCE <= 0;\n        EI <= 0;\n        CC <= 0;\n        go_idle_o <= 0;\n        CTE <= 0;\n        CIE <= 0;\n    end else begin\n        // Update card presence status in NORMAL_INT_REG\n        NORMAL_INT_REG[1] <= card_present;\n        NORMAL_INT_REG[2] <= ~card_present;\n        complete <= 0;\n        \n        // Handle interrupt resets\n        if (ERR_INT_RST) ERR_INT_REG <= 0;\n        if (NORMAL_INT_RST) NORMAL_INT_REG <= 0;\n        \n        case (state)\n            IDLE: begin\n                go_idle_o <= 0;\n                req_out <= 0;\n                ack_out <= 0;\n                STATUS_REG[0] <= 0; // CICMD\n                \n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1;\n                end\n            end\n            \n            SETUP: begin\n                NORMAL_INT_REG <= 0;\n                ERR_INT_REG <= 0;\n                index_check_enable <= CMD_SET_REG[4]; // CICE\n                CRC_check_enable <= CMD_SET_REG[3];   // CRCE\n                \n                // Compose command\n                cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                \n                // Determine response size\n                case (CMD_SET_REG[1:0]) // RTS\n                    2'b10, 2'b11: response_size <= small_rsp;\n                    2'b01: response_size <= big_rsp;\n                    default: response_size <= 0;\n                endcase\n                \n                // Compose settings\n                settings <= {\n                    CMD_SET_REG[7:6],  // WORD_SELECT\n                    data_read,\n                    data_write,\n                    3'b111,            // Delay\n                    CMD_SET_REG[3],    // CRCE\n                    response_size\n                };\n                \n                Watchdog_Cnt <= 0;\n                STATUS_REG[0] <= 1; // CICMD\n            end\n            \n            EXECUTE: begin\n                Watchdog_Cnt <= Watchdog_Cnt + 1;\n                \n                // Timeout handling\n                if (Watchdog_Cnt > TIMEOUT_REG) begin\n                    CTE <= 1;\n                    EI <= 1;\n                    ERR_INT_REG[0] <= 1; // CTE\n                    NORMAL_INT_REG[15] <= 1; // EI\n                    \n                    if (ack_in) begin\n                        complete <= 1;\n                    end\n                    \n                    go_idle_o <= 1;\n                end\n                \n                // Request handling\n                if (ack_in_int) begin\n                    req_out <= 1;\n                end\n                \n                // Status handling\n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1;\n                    \n                    if (status[dat_ava]) begin\n                        complete <= 1;\n                        EI <= 0;\n                        \n                        // CRC check\n                        if (CRC_check_enable && !status[crc_valid]) begin\n                            CCRCE <= 1;\n                            EI <= 1;\n                            ERR_INT_REG[1] <= 1; // CCRCE\n                            NORMAL_INT_REG[15] <= 1; // EI\n                        end\n                        \n                        // Index check\n                        if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                            CIE <= 1;\n                            EI <= 1;\n                            ERR_INT_REG[3] <= 1; // CIE\n                            NORMAL_INT_REG[15] <= 1; // EI\n                        end\n                        \n                        CC <= 1;\n                        NORMAL_INT_REG[0] <= 1; // CC\n                        \n                        // Store response if needed\n                        if (response_size != 0) begin\n                            RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n// Parameters\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'hC1A;\nparameter ACMD13 = 16'hD1A;\nparameter ACMD51 = 16'h331A;\nparameter SIZE = 9;\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\n\n// Internal signals\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [8:0] state;\nreg [8:0] next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr_reg;\nreg [31:0] cmd_arg_reg;\nreg [15:0] cmd_set_reg;\nreg CIDAT_reg;\n\n// FSM sequential logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM combinational logic\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (free_tx_bd != BD_EMPTY) begin\n                next_state = GET_TX_BD;\n            end else if (free_rx_bd != BD_EMPTY) begin\n                next_state = GET_RX_BD;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        GET_TX_BD: begin\n            if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_TX_BD;\n            end\n        end\n        GET_RX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_RX_BD;\n            end\n        end\n        SEND_CMD: begin\n            if (send_done == 1) begin\n                next_state = RECIVE_CMD;\n            end else begin\n                next_state = SEND_CMD;\n            end\n        end\n        RECIVE_CMD: begin\n            if (rec_done == 1) begin\n                next_state = DATA_TRANSFER;\n            end else if (rec_failed == 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        DATA_TRANSFER: begin\n            if (trans_done == 1) begin\n                next_state = IDLE;\n            end else if (trans_failed == 1) begin\n                next_state = STOP;\n            end else begin\n                next_state = DATA_TRANSFER;\n            end\n        end\n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        STOP_SEND: begin\n            if (send_done == 1) begin\n                next_state = IDLE;\n            end else begin\n                next_state = STOP_SEND;\n            end\n        end\n        default: begin\n            next_state = IDLE;\n        end\n    endcase\nend\n\n// Output logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        re_s_tx <= 0;\n        a_cmp_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        sys_adr <= 0;\n        ack_transfer <= 0;\n        Dat_Int_Status <= 0;\n        CIDAT <= 0;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                re_s_tx <= 0;\n                re_s_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                ack_transfer <= 0;\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                bd_cnt <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n            end\n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                if (ack_i_s_tx) begin\n                    if (RAM_MEM_WIDTH == 32) begin\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_tx;\n                            bd_cnt <= bd_cnt + 1;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                            cmd_set <= CMD24;\n                            tx_cycle <= 1;\n                            bd_cnt <= bd_cnt + 1;\n                        end\n                    end else begin // 16-bit\n                        if (bd_cnt < 3) begin\n                            sys_adr <= {sys_adr[15:0], dat_in_tx};\n                            bd_cnt <= bd_cnt + 1;\n                        end else begin\n                            cmd_arg <= {cmd_arg[15:0], dat_in_tx};\n                            start_tx_fifo <= 1;\n                            cmd_set <= CMD24;\n                            tx_cycle <= 1;\n                            bd_cnt <= bd_cnt + 1;\n                        end\n                    end\n                end\n            end\n            GET_RX_BD: begin\n                re_s_rx <= 1;\n                if (ack_i_s_rx) begin\n                    if (RAM_MEM_WIDTH == 32) begin\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_rx;\n                            bd_cnt <= bd_cnt + 1;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_rx;\n                            case (transfer_type)\n                                2'b00: cmd_set <= CMD17;\n                                2'b01: cmd_set <= ACMD13;\n                                default: cmd_set <= ACMD51;\n                            endcase\n                            rx_cycle <= 1;\n                            bd_cnt <= bd_cnt + 1;\n                        end\n                    end else begin // 16-bit\n                        if (bd_cnt < 3) begin\n                            sys_adr <= {sys_adr[15:0], dat_in_rx};\n                            bd_cnt <= bd_cnt + 1;\n                        end else begin\n                            cmd_arg <= {cmd_arg[15:0], dat_in_rx};\n                            case (transfer_type)\n                                2'b00: cmd_set <= CMD17;\n                                2'b01: cmd_set <= ACMD13;\n                                default: cmd_set <= ACMD51;\n                            endcase\n                            rx_cycle <= 1;\n                            bd_cnt <= bd_cnt + 1;\n                        end\n                    end\n                end\n            end\n            SEND_CMD: begin\n                if (tx_cycle) begin\n                    d_write <= 1;\n                end else if (rx_cycle) begin\n                    d_read <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                end\n                \n                if (we_ack) begin\n                    send_done <= 1;\n                    we_req <= 0;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rx_cycle) begin\n                    start_rx_fifo <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    if (cmd_tsf_err) begin\n                        rec_failed <= 1;\n                    end else if (card_status[0] == 1 || \n                               (card_status[4:1] == 4 || \n                                card_status[4:1] == 5 || \n                                card_status[4:1] == 6)) begin\n                        rec_done <= 1;\n                    end\n                end\n            end\n            DATA_TRANSFER: begin\n                if (tx_cycle) begin\n                    if (tx_empt) begin\n                        trans_failed <= 1;\n                    end\n                end else if (rx_cycle) begin\n                    if (rx_full) begin\n                        trans_failed <= 1;\n                    end\n                end\n                \n                if (transm_complete) begin\n                    if (crc_ok) begin\n                        trans_done <= 1;\n                        if (tx_cycle) begin\n                            a_cmp_tx <= 1;\n                        end else begin\n                            a_cmp_rx <= 1;\n                        end\n                    end else begin\n                        trans_failed <= 1;\n                    end\n                end\n            end\n            STOP: begin\n                cmd_set <= CMD12;\n                rec_done <= 0;\n                rec_failed <= 0;\n                send_done <= 0;\n                trans_failed <= 0;\n                trans_done <= 0;\n                d_read <= 1;\n                d_write <= 1;\n                start_rx_fifo <= 0;\n                start_tx_fifo <= 0;\n            end\n            STOP_SEND: begin\n                resend_try_cnt <= resend_try_cnt + 1;\n                if (resend_try_cnt == RESEND_MAX_CNT) begin\n                    Dat_Int_Status[1] <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                end\n                \n                if (we_ack) begin\n                    send_done <= 1;\n                end\n            end\n        endcase\n        \n        // Handle Dat_Int_Status reset\n        if (Dat_Int_Status_rst) begin\n            Dat_Int_Status <= 0;\n        end\n        \n        // Track transmission complete\n        transm_complete_q <= transm_complete;\n        internal_transm_complete <= transm_complete && !transm_complete_q;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 19, "code": "module sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt,\n    input wire rclk,\n    input wire rst\n);\n\n    // Memory array\n    reg [31:0] ram [0:(1 << FIFO_TX_MEM_ADR_SIZE)-1];\n    \n    // Pointers\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i; // Write pointer\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o; // Read pointer\n    \n    // Gray code pointers for clock domain crossing\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_gray;\n    \n    // Synchronized pointers\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray_sync1, adr_i_gray_sync2;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_gray_sync1, adr_o_gray_sync2;\n    \n    // Binary pointers after synchronization\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_sync;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_sync;\n    \n    // Convert binary to gray code\n    function [FIFO_TX_MEM_ADR_SIZE-1:0] bin2gray;\n        input [FIFO_TX_MEM_ADR_SIZE-1:0] bin;\n        begin\n            bin2gray = bin ^ (bin >> 1);\n        end\n    endfunction\n    \n    // Convert gray code to binary\n    function [FIFO_TX_MEM_ADR_SIZE-1:0] gray2bin;\n        input [FIFO_TX_MEM_ADR_SIZE-1:0] gray;\n        integer i;\n        begin\n            gray2bin[FIFO_TX_MEM_ADR_SIZE-1] = gray[FIFO_TX_MEM_ADR_SIZE-1];\n            for (i = FIFO_TX_MEM_ADR_SIZE-2; i >= 0; i = i-1)\n                gray2bin[i] = gray2bin[i+1] ^ gray[i];\n        end\n    endfunction\n    \n    // Write clock domain logic\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            adr_i_gray <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i[FIFO_TX_MEM_ADR_SIZE-2:0]] <= d;\n            adr_i <= adr_i + 1;\n            adr_i_gray <= bin2gray(adr_i + 1);\n        end\n    end\n    \n    // Read clock domain logic\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            adr_o_gray <= 0;\n            q <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o[FIFO_TX_MEM_ADR_SIZE-2:0]];\n            adr_o <= adr_o + 1;\n            adr_o_gray <= bin2gray(adr_o + 1);\n        end\n    end\n    \n    // Synchronize write pointer to read clock domain\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_i_gray_sync1 <= 0;\n            adr_i_gray_sync2 <= 0;\n            adr_i_sync <= 0;\n        end else begin\n            adr_i_gray_sync1 <= adr_i_gray;\n            adr_i_gray_sync2 <= adr_i_gray_sync1;\n            adr_i_sync <= gray2bin(adr_i_gray_sync2);\n        end\n    end\n    \n    // Synchronize read pointer to write clock domain\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_o_gray_sync1 <= 0;\n            adr_o_gray_sync2 <= 0;\n            adr_o_sync <= 0;\n        end else begin\n            adr_o_gray_sync1 <= adr_o_gray;\n            adr_o_gray_sync2 <= adr_o_gray_sync1;\n            adr_o_sync <= gray2bin(adr_o_gray_sync2);\n        end\n    end\n    \n    // Generate full and empty flags\n    always @(*) begin\n        // Full flag (write clock domain)\n        full = (adr_i[FIFO_TX_MEM_ADR_SIZE-2:0] == adr_o_sync[FIFO_TX_MEM_ADR_SIZE-2:0]) && \n               (adr_i[FIFO_TX_MEM_ADR_SIZE-1] != adr_o_sync[FIFO_TX_MEM_ADR_SIZE-1]);\n        \n        // Empty flag (read clock domain)\n        empty = (adr_i_sync == adr_o);\n        \n        // Memory occupancy (read clock domain)\n        if (adr_i_sync >= adr_o)\n            mem_empt = adr_i_sync - adr_o;\n        else\n            mem_empt = (1 << FIFO_TX_MEM_ADR_SIZE) - adr_o + adr_i_sync;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 4, "code": "module sd_controller_wb (\n    // Wishbone interface\n    input               wb_clk_i,\n    input               wb_rst_i,\n    input      [31:0]   wb_dat_i,\n    output reg [31:0]   wb_dat_o,\n    input      [7:0]    wb_adr_i,\n    input      [3:0]    wb_sel_i,\n    input               wb_we_i,\n    input               wb_cyc_i,\n    input               wb_stb_i,\n    output reg          wb_ack_o,\n    \n    // Control signals\n    output reg          we_m_tx_bd,\n    output reg          we_m_rx_bd,\n    output reg          new_cmd,\n    output reg          we_ack,\n    output reg          int_ack,\n    output reg          cmd_int_busy,\n    output reg          int_busy,\n    input               write_req_s,\n    input      [15:0]   cmd_set_s,\n    input      [32:0]   cmd_arg_s,\n    \n    // Registers\n    output reg [31:0]   argument_reg,\n    output reg [15:0]   cmd_setting_reg,\n    input      [15:0]   status_reg,\n    input      [31:0]   cmd_resp_1,\n    output reg [7:0]    software_reset_reg,\n    output reg [16:0]   time_out_reg,\n    input      [15:0]   normal_int_status_reg,\n    input      [15:0]   error_int_status_reg,\n    output reg [15:0]   normal_int_signal_enable_reg,\n    output reg [15:0]   error_int_signal_enable_reg,\n    output reg [7:0]    clock_divider,\n    input      [15:0]   Bd_Status_reg,\n    input      [8:0]    Bd_isr_reg,\n    output reg [8:0]    Bd_isr_enable_reg,\n    output reg          Bd_isr_reset,\n    output reg          normal_isr_reset,\n    output reg          error_isr_reset,\n    \n    // BD data\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\nparameter RAM_MEM_WIDTH = 32; // Default to 32-bit width\n\n// Internal signals\nreg [1:0] bd_write_state;\nreg [31:0] bd_temp_data;\n\n// Reset and register initialization\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to default values\n        argument_reg <= 32'h0;\n        cmd_setting_reg <= 16'h0;\n        software_reset_reg <= 8'h0;\n        time_out_reg <= 16'h0;\n        normal_int_signal_enable_reg <= 16'h0;\n        error_int_signal_enable_reg <= 16'h0;\n        clock_divider <= 8'h0;\n        Bd_isr_enable_reg <= 8'h0;\n        \n        // Reset control signals\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        wb_ack_o <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        \n        // Reset BD write state\n        bd_write_state <= 2'b00;\n        bd_temp_data <= 32'h0;\n    end else begin\n        // Default values\n        wb_ack_o <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        \n        // Handle data master access\n        if (write_req_s) begin\n            cmd_setting_reg <= cmd_set_s;\n            argument_reg <= cmd_arg_s;\n            cmd_int_busy <= 1'b1;\n            int_busy <= 1'b1;\n            new_cmd <= 1'b1;\n            we_ack <= 1'b1;\n        end else begin\n            cmd_int_busy <= 1'b0;\n        end\n        \n        // Handle Wishbone access\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: begin // Argument register\n                        argument_reg <= wb_dat_i;\n                        int_busy <= 1'b1;\n                        new_cmd <= 1'b1;\n                    end\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_isr_reset <= 1'b1;\n                    8'h34: error_isr_reset <= 1'b1;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1'b1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    \n                    // BD RX/TX handling\n                    8'h60: begin // BD RX\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                            we_m_rx_bd <= 1'b1;\n                            int_ack <= 1'b0;\n                            bd_write_state <= 2'b01;\n                        end else begin // 16-bit\n                            if (bd_write_state == 2'b00) begin\n                                bd_temp_data[15:0] <= wb_dat_i[15:0];\n                                bd_write_state <= 2'b01;\n                            end else begin\n                                dat_in_m_rx_bd <= {wb_dat_i[15:0], bd_temp_data[15:0]};\n                                we_m_rx_bd <= 1'b1;\n                                int_ack <= 1'b0;\n                                bd_write_state <= 2'b10;\n                            end\n                        end\n                    end\n                    \n                    8'h80: begin // BD TX\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                            we_m_tx_bd <= 1'b1;\n                            int_ack <= 1'b0;\n                            bd_write_state <= 2'b01;\n                        end else begin // 16-bit\n                            if (bd_write_state == 2'b00) begin\n                                bd_temp_data[15:0] <= wb_dat_i[15:0];\n                                bd_write_state <= 2'b01;\n                            end else begin\n                                dat_in_m_tx_bd <= {wb_dat_i[15:0], bd_temp_data[15:0]};\n                                we_m_tx_bd <= 1'b1;\n                                int_ack <= 1'b0;\n                                bd_write_state <= 2'b10;\n                            end\n                        end\n                    end\n                endcase\n            end else begin\n                // Read operation\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= 32'h0; // Controller Setting\n                    8'h20: wb_dat_o <= 32'h0200; // Block Size (512)\n                    8'h24: wb_dat_o <= 32'h0000000f; // Power Control (3.3V)\n                    8'h28: wb_dat_o <= {24'h0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h0; // Capability\n                    8'h4c: wb_dat_o <= {24'h0, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'h0;\n                endcase\n            end\n            \n            // Handle BD write completion\n            if (bd_write_state == 2'b01) begin\n                if (RAM_MEM_WIDTH == 32) begin\n                    we_m_rx_bd <= 1'b0;\n                    we_m_tx_bd <= 1'b0;\n                    int_ack <= 1'b1;\n                    bd_write_state <= 2'b00;\n                end\n            end else if (bd_write_state == 2'b10) begin\n                we_m_rx_bd <= 1'b0;\n                we_m_tx_bd <= 1'b0;\n                int_ack <= 1'b1;\n                bd_write_state <= 2'b00;\n            end\n            \n            // Generate acknowledge\n            if (int_ack) begin\n                wb_ack_o <= 1'b1;\n            end\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 1, "code": "module sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    \n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\nparameter SD_BUS_W = 4;\nparameter BIT_BLOCK = 512;\nparameter CRC_OFF = 16;\nparameter BIT_BLOCK_REC = 512;\nparameter BIT_CRC_CYCLE = 16;\nparameter LITTLE_ENDIAN = 1;\nparameter BIG_ENDIAN = 0;\nparameter SD_BUS_WIDTH_1 = 1;\nparameter SD_BUS_WIDTH_4 = 4;\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out [0:SD_BUS_W-1];\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// States\nlocalparam IDLE       = 6'b000001;\nlocalparam WRITE_DAT  = 6'b000010;\nlocalparam WRITE_CRC  = 6'b000100;\nlocalparam WRITE_BUSY = 6'b001000;\nlocalparam READ_WAIT  = 6'b010000;\nlocalparam READ_DAT   = 6'b100000;\n\n// CRC generation blocks\ngenerate\ngenvar i;\nfor (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n    sd_crc_16 crc_inst (\n        .BITVAL(crc_in[i]),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out[i])\n    );\nend\nendgenerate\n\n// ACK_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        ack_transfer_int <= 0;\n        ack_q <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// FSM_COMBO block\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b10) next_state = WRITE_DAT;\n            else if (start_dat == 2'b01) next_state = READ_WAIT;\n            else next_state = IDLE;\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == BIT_BLOCK) next_state = WRITE_CRC;\n            else next_state = WRITE_DAT;\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b001) next_state = WRITE_BUSY;\n            else next_state = WRITE_CRC;\n        end\n        WRITE_BUSY: begin\n            if (!busy_int) next_state = IDLE;\n            else next_state = WRITE_BUSY;\n        end\n        READ_WAIT: begin\n            if (!DAT_dat_i[0] && state == READ_WAIT) next_state = READ_DAT;\n            else next_state = READ_WAIT;\n        end\n        READ_DAT: begin\n            if (transf_cnt == BIT_BLOCK_REC) next_state = IDLE;\n            else next_state = READ_DAT;\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// START_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else begin\n        if (!DAT_dat_i[0] && state == READ_WAIT)\n            q_start_bit <= 0;\n        else\n            q_start_bit <= 1;\n    end\nend\n\n// FSM_SEQ block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        write_buf_0 <= 0;\n        write_buf_1 <= 0;\n        DAT_oe_o <= 0;\n        crc_en <= 0;\n        crc_rst <= 1;\n        transf_cnt <= 0;\n        rd <= 0;\n        last_din <= 0;\n        crc_c <= 0;\n        crc_in <= 0;\n        DAT_dat_o <= 0;\n        crc_status <= 7;\n        crc_s <= 0;\n        transm_complete <= 0;\n        busy_n <= 1;\n        we <= 0;\n        data_out <= 0;\n        crc_ok <= 0;\n        busy_int <= 0;\n        data_send_index <= 0;\n        out_buff_ptr <= 0;\n        in_buff_ptr <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                crc_rst <= 1;\n                crc_en <= 0;\n                DAT_oe_o <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                transf_cnt <= 0;\n                crc_c <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n                \n                if (start_dat == 2'b10) begin\n                    write_buf_0 <= data_in;\n                    rd <= 1;\n                end\n            end\n            \n            WRITE_DAT: begin\n                crc_rst <= 0;\n                DAT_oe_o <= 1;\n                \n                if (transf_cnt == 0) begin\n                    DAT_dat_o <= 4'b0000; // Start bit\n                    crc_en <= 1;\n                end else if (transf_cnt < BIT_BLOCK) begin\n                    if (transf_cnt[1:0] == 2'b00) begin\n                        last_din <= sd_data_out[3:0];\n                        crc_in <= sd_data_out[3:0];\n                        DAT_dat_o <= sd_data_out[3:0];\n                        sd_data_out <= sd_data_out >> 4;\n                        data_send_index <= data_send_index + 1;\n                        \n                        if (data_send_index == 7) begin\n                            out_buff_ptr <= ~out_buff_ptr;\n                            if (out_buff_ptr)\n                                sd_data_out <= write_buf_1;\n                            else\n                                sd_data_out <= write_buf_0;\n                            data_send_index <= 0;\n                        end\n                    end\n                end\n                \n                transf_cnt <= transf_cnt + 1;\n                \n                if (transf_cnt == 32) begin\n                    write_buf_1 <= data_in;\n                    rd <= 1;\n                end else begin\n                    rd <= 0;\n                end\n            end\n            \n            WRITE_CRC: begin\n                if (transf_cnt < BIT_BLOCK + BIT_CRC_CYCLE) begin\n                    if (transf_cnt[1:0] == 2'b00) begin\n                        DAT_dat_o <= crc_out[0][3:0];\n                        crc_out[0] <= crc_out[0] >> 4;\n                    end\n                    transf_cnt <= transf_cnt + 1;\n                end else begin\n                    DAT_dat_o <= 4'b1111; // Stop bit\n                    crc_status <= 3'b001;\n                end\n            end\n            \n            WRITE_BUSY: begin\n                DAT_oe_o <= 0;\n                transm_complete <= 1;\n                busy_int <= DAT_dat_i[0];\n                busy_n <= ~DAT_dat_i[0];\n                \n                if (crc_s == 3'b010) crc_ok <= 1;\n                else crc_ok <= 0;\n            end\n            \n            READ_WAIT: begin\n                crc_rst <= 0;\n                crc_en <= 1;\n                DAT_oe_o <= 0;\n                transf_cnt <= 0;\n            end\n            \n            READ_DAT: begin\n                if (transf_cnt < BIT_BLOCK_REC) begin\n                    data_out <= DAT_dat_i;\n                    crc_in <= DAT_dat_i;\n                    we <= 1;\n                end else begin\n                    we <= 0;\n                    // Check CRC\n                    if (SD_BUS_W == 4) begin\n                        crc_ok <= (DAT_dat_i == {crc_out[3][15], crc_out[2][15], crc_out[1][15], crc_out[0][15]});\n                    end else begin\n                        crc_ok <= (DAT_dat_i[0] == crc_out[0][15]);\n                    end\n                    \n                    if (transf_cnt == BIT_BLOCK_REC + BIT_CRC_CYCLE - 1) begin\n                        transm_complete <= 1;\n                        busy_n <= 0;\n                    end\n                end\n                transf_cnt <= transf_cnt + 1;\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'h0000;\n    end else if (Enable) begin\n        CRC[0] <= CRC[15] ^ BITVAL;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2];\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4] ^ CRC[15] ^ BITVAL;\n        CRC[6] <= CRC[5];\n        CRC[7] <= CRC[6];\n        CRC[8] <= CRC[7];\n        CRC[9] <= CRC[8];\n        CRC[10] <= CRC[9];\n        CRC[11] <= CRC[10];\n        CRC[12] <= CRC[11] ^ CRC[15] ^ BITVAL;\n        CRC[13] <= CRC[12];\n        CRC[14] <= CRC[13];\n        CRC[15] <= CRC[14];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 10, "code": "module sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n// State definitions\nlocalparam IDLE    = 3'b001;\nlocalparam SETUP   = 3'b010;\nlocalparam EXECUTE = 3'b100;\n\n// Internal signals\nreg [2:0] state, next_state;\nreg [3:0] debounce;\nreg card_present;\nreg ack_q, ack_in_int;\nreg req_q, req_in_int;\nreg index_check_enable;\nreg CRC_check_enable;\nreg complete;\nreg [15:0] Watchdog_Cnt;\nreg [6:0] response_size;\nreg [7:0] status;\nreg CIE, CCRCE, CTE, EI, CC;\n\n// Response size constants\nlocalparam small_rsp = 7'b0101000;\nlocalparam big_rsp = 7'b1111111;\n\n// Status bit positions\nlocalparam dat_ava = 6;\nlocalparam crc_valid = 5;\n\n// Debounce logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0;\n        card_present <= 1'b0;\n    end else begin\n        if (!card_detect) begin\n            if (debounce != 4'b1111)\n                debounce <= debounce + 1'b1;\n        end else begin\n            debounce <= 4'b0;\n        end\n        card_present <= (debounce == 4'b1111);\n    end\nend\n\n// Synchronizers\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        ack_q <= 1'b0;\n        ack_in_int <= 1'b0;\n        req_q <= 1'b0;\n        req_in_int <= 1'b0;\n    end else begin\n        ack_q <= ack_in;\n        ack_in_int <= ack_q;\n        req_q <= req_in;\n        req_in_int <= req_q;\n    end\nend\n\n// State register\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I)\n        state <= IDLE;\n    else\n        state <= next_state;\nend\n\n// Next state logic\nalways @(*) begin\n    case (state)\n        IDLE: next_state = New_CMD ? SETUP : IDLE;\n        SETUP: next_state = ack_in_int ? EXECUTE : SETUP;\n        EXECUTE: next_state = complete ? IDLE : EXECUTE;\n        default: next_state = IDLE;\n    endcase\nend\n\n// State operations\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        // Reset all registers\n        CRC_check_enable <= 1'b0;\n        complete <= 1'b0;\n        RESP_1_REG <= 32'b0;\n        ERR_INT_REG <= 5'b0;\n        NORMAL_INT_REG <= 16'b0;\n        STATUS_REG <= 16'b0;\n        status <= 8'b0;\n        cmd_out <= 40'b0;\n        settings <= 16'b0;\n        response_size <= 7'b0;\n        req_out <= 1'b0;\n        index_check_enable <= 1'b0;\n        ack_out <= 1'b0;\n        Watchdog_Cnt <= 16'b0;\n        CCRCE <= 1'b0;\n        EI <= 1'b0;\n        CC <= 1'b0;\n        go_idle_o <= 1'b0;\n        CIE <= 1'b0;\n        CTE <= 1'b0;\n    end else begin\n        // Update card presence status\n        NORMAL_INT_REG[1] <= card_present;\n        NORMAL_INT_REG[2] <= ~card_present;\n        complete <= 1'b0;\n        \n        // Handle interrupt resets\n        if (ERR_INT_RST) ERR_INT_REG <= 5'b0;\n        if (NORMAL_INT_RST) NORMAL_INT_REG <= 16'b0;\n        \n        case (state)\n            IDLE: begin\n                go_idle_o <= 1'b0;\n                req_out <= 1'b0;\n                ack_out <= 1'b0;\n                STATUS_REG[0] <= 1'b0; // CICMD\n                \n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1'b1;\n                end\n            end\n            \n            SETUP: begin\n                NORMAL_INT_REG <= 16'b0;\n                ERR_INT_REG <= 5'b0;\n                index_check_enable <= CMD_SET_REG[4]; // CICE\n                CRC_check_enable <= CMD_SET_REG[3];   // CRCE\n                \n                // Compose command\n                cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                \n                // Determine response size\n                case (CMD_SET_REG[1:0]) // RTS\n                    2'b10, 2'b11: response_size <= small_rsp;\n                    2'b01: response_size <= big_rsp;\n                    default: response_size <= 7'b0;\n                endcase\n                \n                // Compose settings\n                settings <= {\n                    CMD_SET_REG[7:6],  // WORD_SELECT\n                    data_read,\n                    data_write,\n                    3'b111,            // Delay\n                    CMD_SET_REG[3],    // CRCE\n                    response_size\n                };\n                \n                Watchdog_Cnt <= 16'b0;\n                STATUS_REG[0] <= 1'b1; // CICMD\n            end\n            \n            EXECUTE: begin\n                Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                \n                // Timeout handling\n                if (Watchdog_Cnt > TIMEOUT_REG) begin\n                    CTE <= 1'b1;\n                    EI <= 1'b1;\n                    if (ack_in) complete <= 1'b1;\n                    go_idle_o <= 1'b1;\n                end\n                \n                // Request handling\n                if (ack_in_int) begin\n                    req_out <= 1'b1;\n                end\n                \n                // Status handling\n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1'b1;\n                    \n                    if (status[dat_ava]) begin\n                        complete <= 1'b1;\n                        EI <= 1'b0;\n                        \n                        // CRC check\n                        if (CRC_check_enable && !status[crc_valid]) begin\n                            CCRCE <= 1'b1;\n                            EI <= 1'b1;\n                        end\n                        \n                        // Index check\n                        if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                            CIE <= 1'b1;\n                            EI <= 1'b1;\n                        end\n                        \n                        CC <= 1'b1;\n                        \n                        // Store response if needed\n                        if (response_size != 7'b0) begin\n                            RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            end\n        endcase\n        \n        // Update interrupt registers\n        ERR_INT_REG <= {1'b0, CIE, 1'b0, CCRCE, CTE};\n        NORMAL_INT_REG <= {EI, 14'b0, CC};\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 2, "code": "module sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    \n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\nparameter SD_BUS_W = 4;\nparameter BIT_BLOCK = 512;\nparameter CRC_OFF = 16;\nparameter BIT_BLOCK_REC = 512;\nparameter BIT_CRC_CYCLE = 16;\nparameter LITTLE_ENDIAN = 1;\nparameter BIG_ENDIAN = 0;\nparameter SD_BUS_WIDTH_1 = 1;\nparameter SD_BUS_WIDTH_4 = 4;\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out [0:SD_BUS_W-1];\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// State definitions\nlocalparam IDLE       = 6'b000001;\nlocalparam WRITE_DAT  = 6'b000010;\nlocalparam WRITE_CRC  = 6'b000100;\nlocalparam WRITE_BUSY = 6'b001000;\nlocalparam READ_WAIT  = 6'b010000;\nlocalparam READ_DAT   = 6'b100000;\n\n// CRC generation instances\ngenvar i;\ngenerate\n    for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n        sd_crc_16 crc_inst (\n            .BITVAL(crc_in[i]),\n            .Enable(crc_en),\n            .CLK(sd_clk),\n            .RST(crc_rst),\n            .CRC(crc_out[i])\n        );\n    end\nendgenerate\n\n// ACK_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        ack_transfer_int <= 0;\n        ack_q <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// FSM_COMBO block\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (start_dat[0] & ~start_dat[1]) next_state = READ_WAIT;\n            else if (~start_dat[0] & start_dat[1]) next_state = WRITE_DAT;\n            else next_state = IDLE;\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == BIT_BLOCK) next_state = WRITE_CRC;\n            else next_state = WRITE_DAT;\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b001) next_state = WRITE_BUSY;\n            else next_state = WRITE_CRC;\n        end\n        WRITE_BUSY: begin\n            if (~busy_int) next_state = IDLE;\n            else next_state = WRITE_BUSY;\n        end\n        READ_WAIT: begin\n            if (~DAT_dat_i[0]) next_state = READ_DAT;\n            else next_state = READ_WAIT;\n        end\n        READ_DAT: begin\n            if (transf_cnt == BIT_BLOCK_REC) next_state = IDLE;\n            else next_state = READ_DAT;\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// START_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else begin\n        if (~DAT_dat_i[0] & (state == READ_WAIT)) begin\n            q_start_bit <= 0;\n        end else begin\n            q_start_bit <= 1;\n        end\n    end\nend\n\n// FSM_SEQ block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        write_buf_0 <= 0;\n        write_buf_1 <= 0;\n        DAT_oe_o <= 0;\n        crc_en <= 0;\n        crc_rst <= 1;\n        transf_cnt <= 0;\n        rd <= 0;\n        last_din <= 0;\n        crc_c <= 0;\n        crc_in <= 0;\n        DAT_dat_o <= 0;\n        crc_status <= 7;\n        crc_s <= 0;\n        transm_complete <= 0;\n        busy_n <= 1;\n        we <= 0;\n        data_out <= 0;\n        crc_ok <= 0;\n        busy_int <= 0;\n        data_send_index <= 0;\n        out_buff_ptr <= 0;\n        in_buff_ptr <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                crc_rst <= 1;\n                crc_en <= 0;\n                DAT_oe_o <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                transf_cnt <= 0;\n                crc_status <= 7;\n                crc_ok <= 0;\n                busy_int <= 0;\n                \n                if (start_dat[1]) begin\n                    write_buf_0 <= data_in;\n                    rd <= 1;\n                end\n            end\n            \n            WRITE_DAT: begin\n                crc_rst <= 0;\n                DAT_oe_o <= 1;\n                \n                if (transf_cnt == 0) begin\n                    DAT_dat_o <= 0; // Start bit\n                    crc_en <= 1;\n                end else if (transf_cnt <= BIT_BLOCK) begin\n                    if (transf_cnt[1:0] == 0) begin\n                        sd_data_out <= out_buff_ptr ? write_buf_1 : write_buf_0;\n                        if (transf_cnt[4:2] == 7) begin\n                            out_buff_ptr <= ~out_buff_ptr;\n                            rd <= 1;\n                            if (in_buff_ptr) write_buf_1 <= data_in;\n                            else write_buf_0 <= data_in;\n                            in_buff_ptr <= ~in_buff_ptr;\n                        end\n                    end\n                    \n                    last_din <= sd_data_out[31:28];\n                    sd_data_out <= {sd_data_out[27:0], 4'b0};\n                    DAT_dat_o <= last_din;\n                    crc_in <= last_din;\n                    crc_en <= 1;\n                end\n                \n                transf_cnt <= transf_cnt + 1;\n            end\n            \n            WRITE_CRC: begin\n                if (transf_cnt < BIT_BLOCK + BIT_CRC_CYCLE) begin\n                    if (transf_cnt == BIT_BLOCK) begin\n                        DAT_dat_o <= crc_out[0][15:12];\n                    end else if (transf_cnt == BIT_BLOCK + 4) begin\n                        DAT_dat_o <= crc_out[0][11:8];\n                    end else if (transf_cnt == BIT_BLOCK + 8) begin\n                        DAT_dat_o <= crc_out[0][7:4];\n                    end else if (transf_cnt == BIT_BLOCK + 12) begin\n                        DAT_dat_o <= crc_out[0][3:0];\n                    end\n                    \n                    transf_cnt <= transf_cnt + 1;\n                end else begin\n                    DAT_dat_o <= 4'b1111; // Stop bit\n                    crc_status <= 3'b001;\n                end\n            end\n            \n            WRITE_BUSY: begin\n                transm_complete <= 1;\n                busy_int <= DAT_dat_i[0];\n                busy_n <= ~DAT_dat_i[0];\n                \n                if (ack_transfer_int) begin\n                    crc_ok <= (crc_s == 3'b010);\n                    transm_complete <= 0;\n                end\n            end\n            \n            READ_WAIT: begin\n                crc_rst <= 0;\n                crc_en <= 1;\n                DAT_oe_o <= 0;\n                transf_cnt <= 0;\n            end\n            \n            READ_DAT: begin\n                if (transf_cnt < BIT_BLOCK_REC) begin\n                    data_out <= DAT_dat_i;\n                    crc_in <= DAT_dat_i;\n                    we <= 1;\n                end else begin\n                    we <= 0;\n                    if (SD_BUS_W == 4) begin\n                        crc_ok <= (DAT_dat_i == {crc_out[3][15], crc_out[2][15], crc_out[1][15], crc_out[0][15]});\n                    end else begin\n                        crc_ok <= (DAT_dat_i[0] == crc_out[0][15]);\n                    end\n                    \n                    if (transf_cnt == BIT_BLOCK_REC + BIT_CRC_CYCLE - 1) begin\n                        transm_complete <= 1;\n                    end\n                end\n                \n                transf_cnt <= transf_cnt + 1;\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'h0000;\n    end else if (Enable) begin\n        CRC[0] <= CRC[15] ^ BITVAL;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2];\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4] ^ (CRC[15] ^ BITVAL);\n        CRC[6] <= CRC[5];\n        CRC[7] <= CRC[6];\n        CRC[8] <= CRC[7];\n        CRC[9] <= CRC[8];\n        CRC[10] <= CRC[9];\n        CRC[11] <= CRC[10];\n        CRC[12] <= CRC[11] ^ (CRC[15] ^ BITVAL);\n        CRC[13] <= CRC[12];\n        CRC[14] <= CRC[13];\n        CRC[15] <= CRC[14];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    \n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n// Parameters\nparameter IDLE       = 6'b000001;\nparameter WRITE_DAT  = 6'b000010;\nparameter WRITE_CRC  = 6'b000100;\nparameter WRITE_BUSY = 6'b001000;\nparameter READ_WAIT  = 6'b010000;\nparameter READ_DAT   = 6'b100000;\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out [0:SD_BUS_W-1];\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// Generate CRC instances\ngenvar i;\ngenerate\n    for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n        sd_crc_16 crc_inst (\n            .BITVAL(crc_in[i]),\n            .Enable(crc_en),\n            .CLK(sd_clk),\n            .RST(crc_rst),\n            .CRC(crc_out[i])\n        );\n    end\nendgenerate\n\n// ACK_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        ack_transfer_int <= 1'b0;\n        ack_q <= 1'b0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// FSM_COMBO block\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b10) next_state = WRITE_DAT;\n            else if (start_dat == 2'b01) next_state = READ_WAIT;\n            else next_state = IDLE;\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == SD_BUS_W) next_state = WRITE_CRC;\n            else next_state = WRITE_DAT;\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b111) next_state = WRITE_BUSY;\n            else next_state = WRITE_CRC;\n        end\n        WRITE_BUSY: begin\n            if (!busy_int) next_state = IDLE;\n            else next_state = WRITE_BUSY;\n        end\n        READ_WAIT: begin\n            if (!DAT_dat_i[0] && state == READ_WAIT) next_state = READ_DAT;\n            else next_state = READ_WAIT;\n        end\n        READ_DAT: begin\n            if (transf_cnt == SD_BUS_W) next_state = IDLE;\n            else next_state = READ_DAT;\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// START_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        q_start_bit <= 1'b1;\n    end else begin\n        if (!DAT_dat_i[0] && state == READ_WAIT)\n            q_start_bit <= 1'b0;\n        else\n            q_start_bit <= 1'b1;\n    end\nend\n\n// FSM_SEQ block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        write_buf_0 <= 32'b0;\n        write_buf_1 <= 32'b0;\n        DAT_oe_o <= 1'b0;\n        crc_en <= 1'b0;\n        crc_rst <= 1'b1;\n        transf_cnt <= 11'b0;\n        rd <= 1'b0;\n        last_din <= 4'b0;\n        crc_c <= 5'b0;\n        crc_in <= {SD_BUS_W{1'b0}};\n        DAT_dat_o <= {SD_BUS_W{1'b0}};\n        crc_status <= 3'b111;\n        crc_s <= 3'b0;\n        transm_complete <= 1'b0;\n        busy_n <= 1'b1;\n        we <= 1'b0;\n        data_out <= {SD_BUS_W{1'b0}};\n        crc_ok <= 1'b0;\n        busy_int <= 1'b0;\n        data_send_index <= 3'b0;\n        out_buff_ptr <= 1'b0;\n        in_buff_ptr <= 1'b0;\n        sd_data_out <= 32'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                crc_rst <= 1'b1;\n                crc_en <= 1'b0;\n                DAT_oe_o <= 1'b0;\n                transm_complete <= 1'b0;\n                busy_n <= 1'b1;\n                transf_cnt <= 11'b0;\n                crc_c <= 5'b0;\n                crc_status <= 3'b111;\n                \n                if (start_dat == 2'b10) begin\n                    write_buf_0 <= data_in;\n                    write_buf_1 <= data_in;\n                    out_buff_ptr <= 1'b0;\n                    in_buff_ptr <= 1'b0;\n                    rd <= 1'b1;\n                end\n            end\n            \n            WRITE_DAT: begin\n                crc_rst <= 1'b0;\n                DAT_oe_o <= 1'b1;\n                rd <= 1'b0;\n                \n                if (transf_cnt == 0) begin\n                    sd_data_out <= out_buff_ptr ? write_buf_1 : write_buf_0;\n                    DAT_dat_o <= {SD_BUS_W{1'b0}}; // Start bit\n                    crc_in <= {SD_BUS_W{1'b0}};\n                    crc_en <= 1'b1;\n                    transf_cnt <= transf_cnt + 1;\n                end else if (transf_cnt < SD_BUS_W) begin\n                    last_din <= sd_data_out[3:0];\n                    crc_in <= sd_data_out[3:0];\n                    DAT_dat_o <= sd_data_out[3:0];\n                    sd_data_out <= {4'b0, sd_data_out[31:4]};\n                    transf_cnt <= transf_cnt + 1;\n                    \n                    if (transf_cnt[1:0] == 2'b11) begin\n                        if (out_buff_ptr) begin\n                            write_buf_1 <= data_in;\n                        end else begin\n                            write_buf_0 <= data_in;\n                        end\n                        out_buff_ptr <= ~out_buff_ptr;\n                        rd <= 1'b1;\n                    end else begin\n                        rd <= 1'b0;\n                    end\n                end\n            end\n            \n            WRITE_CRC: begin\n                if (transf_cnt < 16) begin\n                    DAT_dat_o <= crc_out[0][15 - transf_cnt];\n                    transf_cnt <= transf_cnt + 1;\n                end else begin\n                    DAT_dat_o <= {SD_BUS_W{1'b1}}; // Stop bit\n                    crc_status <= 3'b111;\n                    busy_int <= 1'b1;\n                end\n            end\n            \n            WRITE_BUSY: begin\n                transm_complete <= 1'b1;\n                busy_int <= DAT_dat_i[0];\n                busy_n <= ~busy_int;\n                crc_ok <= (crc_s == 3'b010);\n            end\n            \n            READ_WAIT: begin\n                crc_rst <= 1'b0;\n                crc_en <= 1'b1;\n                DAT_oe_o <= 1'b0;\n                transf_cnt <= 11'b0;\n                we <= 1'b0;\n            end\n            \n            READ_DAT: begin\n                if (transf_cnt < SD_BUS_W) begin\n                    crc_in <= DAT_dat_i;\n                    data_out <= DAT_dat_i;\n                    we <= 1'b1;\n                    transf_cnt <= transf_cnt + 1;\n                end else begin\n                    we <= 1'b0;\n                    // CRC check logic would go here\n                    transm_complete <= 1'b1;\n                    busy_n <= 1'b0;\n                end\n            end\n            \n            default: begin\n                state <= IDLE;\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'b0;\n    end else if (Enable) begin\n        CRC[0] <= CRC[15] ^ BITVAL;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2];\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4] ^ (CRC[15] ^ BITVAL);\n        CRC[6] <= CRC[5];\n        CRC[7] <= CRC[6];\n        CRC[8] <= CRC[7];\n        CRC[9] <= CRC[8];\n        CRC[10] <= CRC[9];\n        CRC[11] <= CRC[10];\n        CRC[12] <= CRC[11] ^ (CRC[15] ^ BITVAL);\n        CRC[13] <= CRC[12];\n        CRC[14] <= CRC[13];\n        CRC[15] <= CRC[14];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 4, "code": "module sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    \n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\nparameter SD_BUS_W = 4;\nparameter BIT_BLOCK = 512;\nparameter CRC_OFF = 16;\nparameter BIT_BLOCK_REC = 512;\nparameter BIT_CRC_CYCLE = 16;\nparameter LITTLE_ENDIAN = 1;\nparameter BIG_ENDIAN = 0;\nparameter SD_BUS_WIDTH_1 = 1;\nparameter SD_BUS_WIDTH_4 = 4;\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out [0:SD_BUS_W-1];\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// States\nlocalparam IDLE       = 6'b000001;\nlocalparam WRITE_DAT  = 6'b000010;\nlocalparam WRITE_CRC  = 6'b000100;\nlocalparam WRITE_BUSY = 6'b001000;\nlocalparam READ_WAIT  = 6'b010000;\nlocalparam READ_DAT   = 6'b100000;\n\n// CRC generation blocks\ngenvar i;\ngenerate\n    for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n        sd_crc_16 crc_inst (\n            .BITVAL(crc_in[i]),\n            .Enable(crc_en),\n            .CLK(sd_clk),\n            .RST(crc_rst),\n            .CRC(crc_out[i])\n        );\n    end\nendgenerate\n\n// ACK_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        ack_transfer_int <= 0;\n        ack_q <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// FSM_COMBO block\nalways @(*) begin\n    next_state = state;\n    case (state)\n        IDLE: begin\n            if (start_dat[1] & ~start_dat[0]) next_state = WRITE_DAT;\n            else if (start_dat[0] & ~start_dat[1]) next_state = READ_WAIT;\n            else next_state = IDLE;\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == BIT_BLOCK) next_state = WRITE_CRC;\n            else next_state = WRITE_DAT;\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b111) next_state = WRITE_BUSY;\n            else next_state = WRITE_CRC;\n        end\n        WRITE_BUSY: begin\n            if (~busy_int) next_state = IDLE;\n            else next_state = WRITE_BUSY;\n        end\n        READ_WAIT: begin\n            if (~DAT_dat_i[0]) next_state = READ_DAT;\n            else next_state = READ_WAIT;\n        end\n        READ_DAT: begin\n            if (transf_cnt == BIT_BLOCK_REC + BIT_CRC_CYCLE) next_state = IDLE;\n            else next_state = READ_DAT;\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// START_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else begin\n        if (~DAT_dat_i[0] && state == READ_WAIT)\n            q_start_bit <= 0;\n        else\n            q_start_bit <= 1;\n    end\nend\n\n// FSM_SEQ block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        write_buf_0 <= 0;\n        write_buf_1 <= 0;\n        DAT_oe_o <= 0;\n        crc_en <= 0;\n        crc_rst <= 1;\n        transf_cnt <= 0;\n        rd <= 0;\n        last_din <= 0;\n        crc_c <= 0;\n        crc_in <= 0;\n        DAT_dat_o <= 0;\n        crc_status <= 7;\n        crc_s <= 0;\n        transm_complete <= 0;\n        busy_n <= 1;\n        we <= 0;\n        data_out <= 0;\n        crc_ok <= 0;\n        busy_int <= 0;\n        data_send_index <= 0;\n        out_buff_ptr <= 0;\n        in_buff_ptr <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                crc_rst <= 1;\n                crc_en <= 0;\n                DAT_oe_o <= 0;\n                transf_cnt <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n                \n                if (start_dat[1] & ~start_dat[0]) begin\n                    write_buf_0 <= data_in;\n                    rd <= 1;\n                end\n            end\n            \n            WRITE_DAT: begin\n                crc_rst <= 0;\n                DAT_oe_o <= 1;\n                rd <= 0;\n                \n                if (transf_cnt == 0) begin\n                    DAT_dat_o <= 0; // Start bit\n                    crc_en <= 0;\n                end else if (transf_cnt <= BIT_BLOCK) begin\n                    if (transf_cnt[1:0] == 0) begin\n                        if (out_buff_ptr == 0)\n                            sd_data_out <= write_buf_0;\n                        else\n                            sd_data_out <= write_buf_1;\n                            \n                        if (in_buff_ptr == 0) begin\n                            write_buf_1 <= data_in;\n                            in_buff_ptr <= 1;\n                        end else begin\n                            write_buf_0 <= data_in;\n                            in_buff_ptr <= 0;\n                        end\n                    end\n                    \n                    last_din <= sd_data_out[3:0];\n                    crc_in <= sd_data_out[3:0];\n                    DAT_dat_o <= last_din;\n                    sd_data_out <= {4'b0, sd_data_out[31:4]};\n                    crc_en <= 1;\n                    \n                    if (transf_cnt[1:0] == 3) begin\n                        out_buff_ptr <= ~out_buff_ptr;\n                    end\n                end\n                \n                transf_cnt <= transf_cnt + 1;\n            end\n            \n            WRITE_CRC: begin\n                if (transf_cnt < BIT_BLOCK + BIT_CRC_CYCLE) begin\n                    if (transf_cnt[1:0] == 0) begin\n                        case (data_send_index)\n                            0: DAT_dat_o <= crc_out[0][15:12];\n                            1: DAT_dat_o <= crc_out[0][11:8];\n                            2: DAT_dat_o <= crc_out[0][7:4];\n                            3: DAT_dat_o <= crc_out[0][3:0];\n                            4: DAT_dat_o <= 4'b1111; // Stop bit\n                            default: DAT_dat_o <= 4'b1111;\n                        endcase\n                        data_send_index <= data_send_index + 1;\n                    end\n                    transf_cnt <= transf_cnt + 1;\n                end else begin\n                    crc_status <= 3'b111;\n                end\n            end\n            \n            WRITE_BUSY: begin\n                transm_complete <= 1;\n                busy_int <= DAT_dat_i[0];\n                busy_n <= ~DAT_dat_i[0];\n                \n                if (crc_s == 3'b010)\n                    crc_ok <= 1;\n                else\n                    crc_ok <= 0;\n            end\n            \n            READ_WAIT: begin\n                crc_rst <= 0;\n                crc_en <= 1;\n                DAT_oe_o <= 0;\n                transf_cnt <= 0;\n                we <= 0;\n            end\n            \n            READ_DAT: begin\n                if (transf_cnt < BIT_BLOCK_REC) begin\n                    crc_in <= DAT_dat_i;\n                    data_out <= DAT_dat_i;\n                    we <= 1;\n                end else if (transf_cnt < BIT_BLOCK_REC + BIT_CRC_CYCLE) begin\n                    // CRC checking logic would go here\n                    we <= 0;\n                end else begin\n                    transm_complete <= 1;\n                    busy_n <= 0;\n                end\n                \n                transf_cnt <= transf_cnt + 1;\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'b0;\n    end else if (Enable) begin\n        CRC[0] <= CRC[15] ^ BITVAL;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2];\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4] ^ (CRC[15] ^ BITVAL);\n        CRC[6] <= CRC[5];\n        CRC[7] <= CRC[6];\n        CRC[8] <= CRC[7];\n        CRC[9] <= CRC[8];\n        CRC[10] <= CRC[9];\n        CRC[11] <= CRC[10];\n        CRC[12] <= CRC[11] ^ (CRC[15] ^ BITVAL);\n        CRC[13] <= CRC[12];\n        CRC[14] <= CRC[13];\n        CRC[15] <= CRC[14];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 18, "code": "module sd_fifo_tx_filler (\n    input         clk,\n    input         rst,\n    output [31:0] m_wb_adr_o,\n    output        m_wb_we_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    input         en,\n    input  [31:0] adr,\n    input         sd_clk,\n    output [31:0] dat_o,\n    input         rd,\n    output        empty,\n    output        fe\n);\n\n    // Internal registers\n    reg [8:0]  offset;\n    reg [8:0]  we;\n    reg [31:0] din;\n    reg        wr_tx;\n    reg        reset_tx_fifo;\n    reg        first;\n    reg        ackd;\n    reg        delay;\n\n    // Wishbone signals\n    assign m_wb_we_o = 1'b0;  // Always read operations\n    assign m_wb_cti_o = 3'b000;\n    assign m_wb_bte_o = 2'b00;\n    assign m_wb_adr_o = adr + {offset, 2'b00};  // Word addressing\n\n    // FIFO signals\n    wire full;\n    assign fe = full;\n\n    // FIFO instance\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(sd_clk),\n        .rst(rst | reset_tx_fifo)\n    );\n\n    // Main state machine\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all registers\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b1;\n            delay <= 1'b0;\n            \n            // Reset Wishbone signals\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n        end else begin\n            // Default values\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b0;\n            delay <= 1'b0;\n            \n            if (en) begin\n                // Module is enabled\n                if (!full && !m_wb_ack_i && ackd) begin\n                    // Start new Wishbone transaction\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    ackd <= 1'b0;\n                end\n                \n                if (m_wb_ack_i) begin\n                    // Wishbone transaction acknowledged\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                \n                if (delay) begin\n                    // Post-acknowledge processing\n                    offset <= offset + 1'b1;\n                    ackd <= ~ackd;\n                    delay <= 1'b0;\n                end\n            end else begin\n                // Module is disabled\n                offset <= 9'b0;\n                reset_tx_fifo <= 1'b1;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                ackd <= 1'b1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 18, "code": "module sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    input wire rclk,\n    output wire full,\n    output wire empty,\n    output wire [1:0] mem_empt,\n    input wire rst\n);\n\nparameter FIFO_RX_MEM_DEPTH = 16; // Example value, should be defined in sd_defines.v\nparameter FIFO_RX_MEM_ADR_SIZE = 5; // log2(FIFO_RX_MEM_DEPTH) + 1\n\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_next = adr_i + 1;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o_next = adr_o + 1;\n\n// Full and empty flags\nassign full = (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] == adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]) && \n              (adr_i[FIFO_RX_MEM_ADR_SIZE-1] != adr_o[FIFO_RX_MEM_ADR_SIZE-1]);\nassign empty = (adr_i == adr_o);\nassign mem_empt = (adr_i[FIFO_RX_MEM_ADR_SIZE-1] == adr_o[FIFO_RX_MEM_ADR_SIZE-1]) ? \n                  (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] - adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]) : \n                  (FIFO_RX_MEM_DEPTH - adr_o[FIFO_RX_MEM_ADR_SIZE-2:0] + adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]);\n\n// Write operation (wclk domain)\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n    end else begin\n        if (wr && !full) begin\n            case (we)\n                8'h1: begin\n                    tmp[3:0] <= d;\n                    we <= 8'h3;\n                end\n                8'h3: begin\n                    tmp[7:4] <= d;\n                    we <= 8'h7;\n                end\n                8'h7: begin\n                    tmp[11:8] <= d;\n                    we <= 8'hF;\n                end\n                8'hF: begin\n                    tmp[15:12] <= d;\n                    we <= 8'h1F;\n                end\n                8'h1F: begin\n                    tmp[19:16] <= d;\n                    we <= 8'h3F;\n                end\n                8'h3F: begin\n                    tmp[23:20] <= d;\n                    we <= 8'h7F;\n                end\n                8'h7F: begin\n                    tmp[27:24] <= d;\n                    we <= 8'hFF;\n                end\n                8'hFF: begin\n                    tmp[31:28] <= d;\n                    ram[adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]] <= tmp;\n                    adr_i <= adr_i_next;\n                    we <= 8'h1;\n                    ft <= 1;\n                end\n                default: we <= 8'h1;\n            endcase\n        end\n    end\nend\n\n// Read operation (rclk domain)\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else begin\n        if (rd && !empty) begin\n            q <= ram[adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]];\n            adr_o <= adr_o_next;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 20, "code": "module sd_fifo_rx_filler (\n    input  wire         clk,\n    input  wire         rst,\n    output reg  [31:0]  m_wb_adr_o,\n    output reg          m_wb_we_o,\n    output reg  [31:0]  m_wb_dat_o,\n    output reg          m_wb_cyc_o,\n    output reg          m_wb_stb_o,\n    input  wire         m_wb_ack_i,\n    output reg  [2:0]   m_wb_cti_o,\n    output reg  [2:0]   m_wb_bte_o,\n    input  wire         en,\n    input  wire [31:0]  adr,\n    input  wire         sd_clk,\n    input  wire [3:0]   dat_i,\n    input  wire         wr,\n    output wire         full,\n    output wire         empty\n);\n\n// Local parameters\nlocalparam IDLE = 2'b00;\nlocalparam READ_FIFO = 2'b01;\nlocalparam WB_WRITE = 2'b10;\n\n// Internal registers\nreg [1:0] state;\nreg [8:0] offset;\nreg wb_free;\nreg reset_rx_fifo;\nreg rd;\n\n// FIFO signals\nwire [31:0] dat_o;\nwire [1:0] mem_empt;\n\n// Instantiate the RX FIFO\nsd_rx_fifo rx_fifo (\n    .d(dat_i),\n    .wr(wr),\n    .wclk(sd_clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(full),\n    .empty(empty),\n    .mem_empt(mem_empt),\n    .rclk(clk),\n    .rst(rst | reset_rx_fifo)\n);\n\n// State machine\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all control signals\n        state <= IDLE;\n        offset <= 9'b0;\n        wb_free <= 1'b1;\n        reset_rx_fifo <= 1'b1;\n        rd <= 1'b0;\n        \n        // Reset Wishbone signals\n        m_wb_adr_o <= 32'b0;\n        m_wb_we_o <= 1'b0;\n        m_wb_dat_o <= 32'b0;\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n        m_wb_cti_o <= 3'b0;\n        m_wb_bte_o <= 2'b0;\n    end else begin\n        if (!en) begin\n            // Disabled state handling\n            state <= IDLE;\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            \n            // Reset Wishbone signals\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else begin\n            reset_rx_fifo <= 1'b0;\n            \n            case (state)\n                IDLE: begin\n                    rd <= 1'b0;\n                    if (!empty && wb_free) begin\n                        // Start reading from FIFO\n                        rd <= 1'b1;\n                        state <= READ_FIFO;\n                    end\n                end\n                \n                READ_FIFO: begin\n                    // Prepare Wishbone transaction\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_dat_o <= dat_o;\n                    m_wb_we_o <= 1'b1;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_cti_o <= 3'b000; // Classic cycle\n                    m_wb_bte_o <= 2'b00;  // Linear burst\n                    \n                    wb_free <= 1'b0;\n                    state <= WB_WRITE;\n                end\n                \n                WB_WRITE: begin\n                    if (m_wb_ack_i) begin\n                        // Transaction complete\n                        m_wb_we_o <= 1'b0;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        \n                        // Update address offset\n                        offset <= offset + `MEM_OFFSET;\n                        wb_free <= 1'b1;\n                        state <= IDLE;\n                    end\n                end\n                \n                default: state <= IDLE;\n            endcase\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 19, "code": "module sd_fifo_tx_filler (\n    input         clk,\n    input         rst,\n    output [31:0] m_wb_adr_o,\n    output        m_wb_we_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    input         en,\n    input  [31:0] adr,\n    input         sd_clk,\n    output [31:0] dat_o,\n    input         rd,\n    output        empty,\n    output        fe\n);\n\n    // Internal registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Wishbone outputs\n    assign m_wb_we_o = 1'b0;  // Always read operations\n    assign m_wb_cti_o = 3'b000;\n    assign m_wb_bte_o = 2'b00;\n    assign m_wb_adr_o = adr + {offset, 2'b00};  // Word addressing\n\n    // FIFO control signals\n    assign fe = ~empty & (we == 9'h1FF);  // FIFO full estimation\n\n    // Instantiate the TX FIFO\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(rst | reset_tx_fifo)\n    );\n\n    // Wishbone transaction control\n    assign m_wb_cyc_o = en & ~fe & ~m_wb_ack_i & ackd;\n    assign m_wb_stb_o = m_wb_cyc_o;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all registers\n            offset <= 9'h000;\n            we <= 9'h000;\n            din <= 32'h00000000;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b1;\n            delay <= 1'b0;\n        end else begin\n            // Default assignments\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b0;\n\n            if (en) begin\n                if (m_wb_ack_i) begin\n                    // Wishbone transaction acknowledged\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    delay <= 1'b1;\n                end else if (delay) begin\n                    // Delay state for timing\n                    offset <= offset + 9'h001;\n                    we <= we + 9'h001;\n                    ackd <= ~ackd;\n                    delay <= 1'b0;\n                end\n            end else begin\n                // Module disabled\n                offset <= 9'h000;\n                we <= 9'h000;\n                reset_tx_fifo <= 1'b1;\n                ackd <= 1'b1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 11, "code": "module sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n// State definitions\nlocalparam IDLE    = 3'b001;\nlocalparam SETUP   = 3'b010;\nlocalparam EXECUTE = 3'b100;\n\n// Internal signals\nreg [2:0] state, next_state;\nreg [3:0] debounce;\nreg card_present;\nreg ack_q, ack_in_int;\nreg req_q, req_in_int;\nreg index_check_enable;\nreg CRC_check_enable;\nreg complete;\nreg [15:0] Watchdog_Cnt;\nreg [6:0] response_size;\nwire dat_ava = serial_status[6];\nwire crc_valid = serial_status[5];\n\n// Response size constants\nlocalparam small_rsp = 7'b0101000;\nlocalparam big_rsp = 7'b1111111;\n\n// Debounce logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0;\n        card_present <= 1'b0;\n    end else begin\n        if (!card_detect) begin\n            if (debounce != 4'b1111)\n                debounce <= debounce + 1'b1;\n        end else begin\n            debounce <= 4'b0;\n        end\n        card_present <= (debounce == 4'b1111);\n    end\nend\n\n// Synchronizers\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        ack_q <= 1'b0;\n        ack_in_int <= 1'b0;\n        req_q <= 1'b0;\n        req_in_int <= 1'b0;\n    end else begin\n        ack_q <= ack_in;\n        ack_in_int <= ack_q;\n        req_q <= req_in;\n        req_in_int <= req_q;\n    end\nend\n\n// FSM state register\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I)\n        state <= IDLE;\n    else\n        state <= next_state;\nend\n\n// FSM next state logic\nalways @(*) begin\n    next_state = state;\n    case (state)\n        IDLE: begin\n            if (New_CMD)\n                next_state = SETUP;\n        end\n        SETUP: begin\n            if (ack_in_int)\n                next_state = EXECUTE;\n        end\n        EXECUTE: begin\n            if (complete)\n                next_state = IDLE;\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// FSM output logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        CRC_check_enable <= 1'b0;\n        complete <= 1'b0;\n        RESP_1_REG <= 32'b0;\n        ERR_INT_REG <= 5'b0;\n        NORMAL_INT_REG <= 16'b0;\n        STATUS_REG <= 16'b0;\n        settings <= 16'b0;\n        cmd_out <= 40'b0;\n        req_out <= 1'b0;\n        ack_out <= 1'b0;\n        index_check_enable <= 1'b0;\n        Watchdog_Cnt <= 16'b0;\n        go_idle_o <= 1'b0;\n    end else begin\n        // Common operations\n        NORMAL_INT_REG[1] <= card_present;\n        NORMAL_INT_REG[2] <= ~card_present;\n        complete <= 1'b0;\n        \n        // Interrupt resets\n        if (ERR_INT_RST)\n            ERR_INT_REG <= 5'b0;\n        if (NORMAL_INT_RST)\n            NORMAL_INT_REG <= 16'b0;\n        \n        case (state)\n            IDLE: begin\n                go_idle_o <= 1'b0;\n                req_out <= 1'b0;\n                ack_out <= 1'b0;\n                STATUS_REG[0] <= 1'b0; // CICMD\n                \n                if (req_in_int) begin\n                    STATUS_REG[7:0] <= serial_status;\n                    ack_out <= 1'b1;\n                end\n            end\n            \n            SETUP: begin\n                NORMAL_INT_REG <= 16'b0;\n                ERR_INT_REG <= 5'b0;\n                index_check_enable <= CMD_SET_REG[4]; // CICE\n                CRC_check_enable <= CMD_SET_REG[3];   // CRCE\n                \n                // Compose cmd_out\n                cmd_out[39:38] <= 2'b01;\n                cmd_out[37:32] <= CMD_SET_REG[13:8];  // CMDI\n                cmd_out[31:0] <= ARG_REG;\n                \n                // Determine response size\n                case (CMD_SET_REG[1:0]) // RTS\n                    2'b10, 2'b11: response_size <= small_rsp;\n                    2'b01: response_size <= big_rsp;\n                    default: response_size <= 7'b0;\n                endcase\n                \n                // Compose settings\n                settings[14:13] <= CMD_SET_REG[7:6];  // WORD_SELECT\n                settings[12] <= data_read;\n                settings[11] <= data_write;\n                settings[10:8] <= 3'b111;             // Delay\n                settings[7] <= CMD_SET_REG[3];        // CRCE\n                settings[6:0] <= response_size;\n                \n                Watchdog_Cnt <= 16'b0;\n                STATUS_REG[0] <= 1'b1; // CICMD\n            end\n            \n            EXECUTE: begin\n                Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                \n                // Timeout handling\n                if (Watchdog_Cnt > TIMEOUT_REG) begin\n                    ERR_INT_REG[0] <= 1'b1; // CTE\n                    NORMAL_INT_REG[15] <= 1'b1; // EI\n                    if (ack_in) complete <= 1'b1;\n                    go_idle_o <= 1'b1;\n                end\n                \n                // Request handling\n                if (ack_in_int) begin\n                    req_out <= 1'b1;\n                end\n                \n                // Status handling\n                if (req_in_int) begin\n                    STATUS_REG[7:0] <= serial_status;\n                    ack_out <= 1'b1;\n                    \n                    if (dat_ava) begin\n                        complete <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b0; // Clear EI\n                        \n                        // CRC check\n                        if (CRC_check_enable && !crc_valid) begin\n                            ERR_INT_REG[1] <= 1'b1; // CCRCE\n                            NORMAL_INT_REG[15] <= 1'b1; // EI\n                        end\n                        \n                        // Index check\n                        if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                            ERR_INT_REG[3] <= 1'b1; // CIE\n                            NORMAL_INT_REG[15] <= 1'b1; // EI\n                        end\n                        \n                        NORMAL_INT_REG[0] <= 1'b1; // CC\n                        \n                        // Store response if needed\n                        if (response_size != 7'b0) begin\n                            RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 20, "code": "module sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    output wire full,\n    output wire empty,\n    output wire [5:0] mem_empt,\n    input wire rclk,\n    input wire rst\n);\n\n// Memory array\nreg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n\n// Pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Gray code pointers for clock domain crossing\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray, adr_o_gray;\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_gray_sync1, adr_i_gray_sync2;\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_gray_sync1, adr_o_gray_sync2;\n\n// Binary pointers after synchronization\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_sync, adr_o_sync;\n\n// Full and empty flags\nreg full_reg, empty_reg;\n\n// Convert binary to gray code\nfunction [FIFO_TX_MEM_ADR_SIZE-1:0] bin2gray;\n    input [FIFO_TX_MEM_ADR_SIZE-1:0] bin;\n    begin\n        bin2gray = bin ^ (bin >> 1);\n    end\nendfunction\n\n// Convert gray code to binary\nfunction [FIFO_TX_MEM_ADR_SIZE-1:0] gray2bin;\n    input [FIFO_TX_MEM_ADR_SIZE-1:0] gray;\n    integer i;\n    begin\n        gray2bin[FIFO_TX_MEM_ADR_SIZE-1] = gray[FIFO_TX_MEM_ADR_SIZE-1];\n        for (i = FIFO_TX_MEM_ADR_SIZE-2; i >= 0; i = i-1)\n            gray2bin[i] = gray2bin[i+1] ^ gray[i];\n    end\nendfunction\n\n// Write pointer management (write clock domain)\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        adr_i_gray <= 0;\n    end else if (wr && !full) begin\n        ram[adr_i[FIFO_TX_MEM_ADR_SIZE-2:0]] <= d;\n        adr_i <= adr_i + 1;\n        adr_i_gray <= bin2gray(adr_i + 1);\n    end\nend\n\n// Read pointer management (read clock domain)\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        adr_o_gray <= 0;\n        q <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o[FIFO_TX_MEM_ADR_SIZE-2:0]];\n        adr_o <= adr_o + 1;\n        adr_o_gray <= bin2gray(adr_o + 1);\n    end\nend\n\n// Synchronize write pointer to read clock domain\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_i_gray_sync1 <= 0;\n        adr_i_gray_sync2 <= 0;\n        adr_i_sync <= 0;\n    end else begin\n        adr_i_gray_sync1 <= adr_i_gray;\n        adr_i_gray_sync2 <= adr_i_gray_sync1;\n        adr_i_sync <= gray2bin(adr_i_gray_sync2);\n    end\nend\n\n// Synchronize read pointer to write clock domain\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_o_gray_sync1 <= 0;\n        adr_o_gray_sync2 <= 0;\n        adr_o_sync <= 0;\n    end else begin\n        adr_o_gray_sync1 <= adr_o_gray;\n        adr_o_gray_sync2 <= adr_o_gray_sync1;\n        adr_o_sync <= gray2bin(adr_o_gray_sync2);\n    end\nend\n\n// Generate full flag (write clock domain)\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        full_reg <= 1'b0;\n    end else begin\n        full_reg <= ((adr_i[FIFO_TX_MEM_ADR_SIZE-2:0] == adr_o_sync[FIFO_TX_MEM_ADR_SIZE-2:0]) &&\n                    (adr_i[FIFO_TX_MEM_ADR_SIZE-1] != adr_o_sync[FIFO_TX_MEM_ADR_SIZE-1]));\n    end\nend\n\n// Generate empty flag (read clock domain)\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        empty_reg <= 1'b1;\n    end else begin\n        empty_reg <= (adr_o == adr_i_sync);\n    end\nend\n\n// Calculate memory occupancy (read clock domain)\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] mem_occupancy;\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        mem_occupancy <= 0;\n    end else begin\n        mem_occupancy <= adr_i_sync - adr_o;\n    end\nend\n\nassign full = full_reg;\nassign empty = empty_reg;\nassign mem_empt = mem_occupancy[5:0];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 20, "code": "module sd_fifo_tx_filler (\n    input         clk,\n    input         rst,\n    output [31:0] m_wb_adr_o,\n    output        m_wb_we_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    input         en,\n    input  [31:0] adr,\n    input         sd_clk,\n    output [31:0] dat_o,\n    input         rd,\n    output        empty,\n    output        fe\n);\n\n    // Internal registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Wishbone signals\n    reg [31:0] m_wb_adr_o;\n    reg m_wb_cyc_o;\n    reg m_wb_stb_o;\n    wire m_wb_we_o = 1'b0; // Always read operations\n\n    // FIFO signals\n    wire full;\n    wire [5:0] mem_empt;\n\n    // Assign outputs\n    assign fe = full;\n    assign m_wb_cti_o = 3'b000; // Classic cycle\n    assign m_wb_bte_o = 2'b00;  // Linear burst\n\n    // Instantiate TX FIFO\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .mem_empt(mem_empt),\n        .rclk(sd_clk),\n        .rst(rst | reset_tx_fifo)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all registers\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b1;\n            delay <= 1'b0;\n            \n            // Reset Wishbone signals\n            m_wb_adr_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n        end else begin\n            // Default values\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b0;\n            delay <= 1'b0;\n\n            if (en) begin\n                if (!full && !m_wb_ack_i && ackd) begin\n                    // Start Wishbone transaction\n                    m_wb_adr_o <= adr + {23'b0, offset};\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    first <= 1'b0;\n                end\n\n                if (m_wb_ack_i) begin\n                    // Write data to FIFO\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n\n                if (delay) begin\n                    // Increment offset and toggle acknowledge\n                    offset <= offset + 1;\n                    ackd <= ~ackd;\n                end\n            end else begin\n                // Module disabled\n                reset_tx_fifo <= 1'b1;\n                offset <= 9'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                m_wb_we_o <= 1'b0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 19, "code": "module sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    output wire full,\n    output wire empty,\n    output wire [1:0] mem_empt,\n    input wire rclk,\n    input wire rst\n);\n\nparameter FIFO_RX_MEM_DEPTH = 16; // Example value, should be defined in sd_defines.v\nparameter FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH) + 1;\n\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_next = adr_i + 1;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o_next = adr_o + 1;\n\n// Full and empty flags\nassign full = (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] == adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]) && \n              (adr_i[FIFO_RX_MEM_ADR_SIZE-1] != adr_o[FIFO_RX_MEM_ADR_SIZE-1]);\nassign empty = (adr_i == adr_o);\nassign mem_empt = (adr_i[FIFO_RX_MEM_ADR_SIZE-1] == adr_o[FIFO_RX_MEM_ADR_SIZE-1]) ? \n                  (FIFO_RX_MEM_DEPTH - (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] - adr_o[FIFO_RX_MEM_ADR_SIZE-2:0])) : \n                  (adr_o[FIFO_RX_MEM_ADR_SIZE-2:0] - adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]);\n\n// Write operation (wclk domain)\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n    end else begin\n        if (wr && !full) begin\n            case (we)\n                8'h1: tmp[3:0] <= d;\n                8'h2: tmp[7:4] <= d;\n                8'h4: tmp[11:8] <= d;\n                8'h8: tmp[15:12] <= d;\n                8'h10: tmp[19:16] <= d;\n                8'h20: tmp[23:20] <= d;\n                8'h40: tmp[27:24] <= d;\n                8'h80: begin\n                    tmp[31:28] <= d;\n                    ft <= 1;\n                end\n                default: we <= 8'h1;\n            endcase\n            \n            we <= we << 1;\n            \n            if (ft) begin\n                ram[adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]] <= tmp;\n                adr_i <= adr_i_next;\n                ft <= 0;\n                we <= 8'h1;\n            end\n        end\n    end\nend\n\n// Read operation (rclk domain)\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else begin\n        if (rd && !empty) begin\n            q <= ram[adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]];\n            adr_o <= adr_o_next;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 12, "code": "module sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n// State definitions\nlocalparam IDLE    = 3'b001;\nlocalparam SETUP   = 3'b010;\nlocalparam EXECUTE = 3'b100;\n\n// Internal signals\nreg [2:0] state, next_state;\nreg [3:0] debounce;\nreg card_present;\nreg ack_q, ack_in_int;\nreg req_q, req_in_int;\nreg index_check_enable;\nreg CRC_check_enable;\nreg complete;\nreg [6:0] response_size;\nreg [15:0] Watchdog_Cnt;\nreg CIE, CCRCE, CTE, EI, CC;\n\n// Status bits\nwire dat_ava = serial_status[6];\nwire crc_valid = serial_status[5];\n\n// Response sizes\nlocalparam small_rsp = 7'b0101000;\nlocalparam big_rsp = 7'b1111111;\n\n// Debounce logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0;\n        card_present <= 1'b0;\n    end else begin\n        if (!card_detect) begin\n            if (debounce != 4'b1111)\n                debounce <= debounce + 1'b1;\n        end else begin\n            debounce <= 4'b0;\n        end\n        \n        card_present <= (debounce == 4'b1111) ? 1'b1 : 1'b0;\n    end\nend\n\n// Synchronizers\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        ack_q <= 1'b0;\n        ack_in_int <= 1'b0;\n        req_q <= 1'b0;\n        req_in_int <= 1'b0;\n    end else begin\n        ack_q <= ack_in;\n        ack_in_int <= ack_q;\n        req_q <= req_in;\n        req_in_int <= req_q;\n    end\nend\n\n// FSM state transition\nalways @(*) begin\n    case (state)\n        IDLE: next_state = New_CMD ? SETUP : IDLE;\n        SETUP: next_state = ack_in_int ? EXECUTE : SETUP;\n        EXECUTE: next_state = complete ? IDLE : EXECUTE;\n        default: next_state = IDLE;\n    endcase\nend\n\n// FSM state register\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I)\n        state <= IDLE;\n    else\n        state <= next_state;\nend\n\n// FSM output logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        // Reset all outputs\n        CRC_check_enable <= 1'b0;\n        complete <= 1'b0;\n        RESP_1_REG <= 32'b0;\n        ERR_INT_REG <= 5'b0;\n        NORMAL_INT_REG <= 16'b0;\n        STATUS_REG <= 16'b0;\n        settings <= 16'b0;\n        cmd_out <= 40'b0;\n        req_out <= 1'b0;\n        ack_out <= 1'b0;\n        index_check_enable <= 1'b0;\n        response_size <= 7'b0;\n        Watchdog_Cnt <= 16'b0;\n        CCRCE <= 1'b0;\n        EI <= 1'b0;\n        CC <= 1'b0;\n        go_idle_o <= 1'b0;\n        CIE <= 1'b0;\n        CTE <= 1'b0;\n    end else begin\n        // Update card presence status\n        NORMAL_INT_REG[1] <= card_present;\n        NORMAL_INT_REG[2] <= ~card_present;\n        \n        // Reset complete flag\n        complete <= 1'b0;\n        \n        // Handle interrupt resets\n        if (ERR_INT_RST) ERR_INT_REG <= 5'b0;\n        if (NORMAL_INT_RST) NORMAL_INT_REG <= 16'b0;\n        \n        case (state)\n            IDLE: begin\n                go_idle_o <= 1'b0;\n                req_out <= 1'b0;\n                ack_out <= 1'b0;\n                STATUS_REG[0] <= 1'b0; // CICMD\n                \n                if (req_in_int) begin\n                    // Update status and acknowledge\n                    ack_out <= 1'b1;\n                end\n            end\n            \n            SETUP: begin\n                // Clear interrupt registers\n                NORMAL_INT_REG <= 16'b0;\n                ERR_INT_REG <= 5'b0;\n                \n                // Set check enables\n                index_check_enable <= CMD_SET_REG[4]; // CICE\n                CRC_check_enable <= CMD_SET_REG[3];   // CRCE\n                \n                // Compose command\n                cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                \n                // Determine response size\n                case (CMD_SET_REG[1:0]) // RTS\n                    2'b01: response_size <= big_rsp;\n                    2'b10, 2'b11: response_size <= small_rsp;\n                    default: response_size <= 7'b0;\n                endcase\n                \n                // Configure settings\n                settings <= {\n                    CMD_SET_REG[7:6],  // WORD_SELECT\n                    data_read,\n                    data_write,\n                    3'b111,            // Delay\n                    CMD_SET_REG[3],    // CRCE\n                    response_size\n                };\n                \n                // Reset watchdog\n                Watchdog_Cnt <= 16'b0;\n                \n                // Set CICMD\n                STATUS_REG[0] <= 1'b1;\n            end\n            \n            EXECUTE: begin\n                // Increment watchdog counter\n                Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                \n                // Check for timeout\n                if (Watchdog_Cnt > TIMEOUT_REG) begin\n                    // Set timeout error\n                    CTE <= 1'b1;\n                    EI <= 1'b1;\n                    ERR_INT_REG[0] <= 1'b1; // CTE\n                    NORMAL_INT_REG[15] <= 1'b1; // EI\n                    \n                    if (ack_in) begin\n                        complete <= 1'b1;\n                    end\n                    \n                    go_idle_o <= 1'b1;\n                end\n                \n                // Handle request/acknowledge\n                if (ack_in_int) begin\n                    req_out <= 1'b1;\n                end\n                \n                if (req_in_int) begin\n                    // Update status and acknowledge\n                    ack_out <= 1'b1;\n                    \n                    if (dat_ava) begin\n                        complete <= 1'b1;\n                        EI <= 1'b0;\n                        \n                        // Check CRC if enabled\n                        if (CRC_check_enable && !crc_valid) begin\n                            CCRCE <= 1'b1;\n                            EI <= 1'b1;\n                            ERR_INT_REG[1] <= 1'b1; // CCRCE\n                            NORMAL_INT_REG[15] <= 1'b1; // EI\n                        end\n                        \n                        // Check index if enabled\n                        if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                            CIE <= 1'b1;\n                            EI <= 1'b1;\n                            ERR_INT_REG[3] <= 1'b1; // CIE\n                            NORMAL_INT_REG[15] <= 1'b1; // EI\n                        end\n                        \n                        // Set command complete\n                        CC <= 1'b1;\n                        NORMAL_INT_REG[0] <= 1'b1; // CC\n                        \n                        // Store response if needed\n                        if (response_size != 7'b0) begin\n                            RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 13, "code": "module sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n    // State definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n    \n    // Status bit definitions\n    localparam dat_ava = 6;\n    localparam crc_valid = 5;\n    \n    // Response size constants\n    localparam [6:0] small_rsp = 7'b0101000;\n    localparam [6:0] big_rsp = 7'b1111111;\n    \n    // Internal registers\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg ack_q, ack_in_int;\n    reg req_q, req_in_int;\n    reg index_check_enable;\n    reg CRC_check_enable;\n    reg complete;\n    reg [15:0] Watchdog_Cnt;\n    reg [6:0] response_size;\n    reg [7:0] status;\n    \n    // Error flags\n    reg CIE, CCRCE, CTE, EI, CC;\n    \n    // Synchronizers for req_in and ack_in\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            ack_q <= 0;\n            ack_in_int <= 0;\n            req_q <= 0;\n            req_in_int <= 0;\n        end else begin\n            ack_q <= ack_in;\n            ack_in_int <= ack_q;\n            req_q <= req_in;\n            req_in_int <= req_q;\n        end\n    end\n    \n    // Debounce logic for card detection\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 0;\n            card_present <= 0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n            end else begin\n                debounce <= 0;\n            end\n            \n            card_present <= (debounce == 4'b1111) ? 1 : 0;\n        end\n    end\n    \n    // State register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n    \n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = New_CMD ? SETUP : IDLE;\n            SETUP: next_state = ack_in_int ? EXECUTE : SETUP;\n            EXECUTE: next_state = complete ? IDLE : EXECUTE;\n            default: next_state = IDLE;\n        endcase\n    end\n    \n    // Output logic and state operations\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            // Reset all outputs and internal registers\n            CRC_check_enable <= 0;\n            complete <= 0;\n            RESP_1_REG <= 0;\n            ERR_INT_REG <= 0;\n            NORMAL_INT_REG <= 0;\n            STATUS_REG <= 0;\n            status <= 0;\n            cmd_out <= 0;\n            settings <= 0;\n            response_size <= 0;\n            req_out <= 0;\n            index_check_enable <= 0;\n            ack_out <= 0;\n            Watchdog_Cnt <= 0;\n            CCRCE <= 0;\n            EI <= 0;\n            CC <= 0;\n            go_idle_o <= 0;\n            CIE <= 0;\n            CTE <= 0;\n        end else begin\n            // Update interrupt registers\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 0;\n            \n            // Handle interrupt resets\n            if (ERR_INT_RST) ERR_INT_REG <= 0;\n            if (NORMAL_INT_RST) NORMAL_INT_REG <= 0;\n            \n            case (state)\n                IDLE: begin\n                    go_idle_o <= 0;\n                    req_out <= 0;\n                    ack_out <= 0;\n                    STATUS_REG[0] <= 0; // CICMD\n                    \n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1;\n                    end\n                end\n                \n                SETUP: begin\n                    NORMAL_INT_REG <= 0;\n                    ERR_INT_REG <= 0;\n                    index_check_enable <= CMD_SET_REG[4]; // CICE\n                    CRC_check_enable <= CMD_SET_REG[3];   // CRCE\n                    \n                    // Compose cmd_out\n                    cmd_out[39:38] <= 2'b01;\n                    cmd_out[37:32] <= CMD_SET_REG[13:8];  // CMDI\n                    cmd_out[31:0] <= ARG_REG;\n                    \n                    // Determine response size\n                    case (CMD_SET_REG[1:0]) // RTS\n                        2'b01: response_size <= big_rsp;\n                        2'b10, 2'b11: response_size <= small_rsp;\n                        default: response_size <= 0;\n                    endcase\n                    \n                    // Compose settings\n                    settings[14:13] <= CMD_SET_REG[7:6];  // WORD_SELECT\n                    settings[12] <= data_read;\n                    settings[11] <= data_write;\n                    settings[10:8] <= 3'b111;             // Delay\n                    settings[7] <= CMD_SET_REG[3];        // CRCE\n                    settings[6:0] <= response_size;\n                    \n                    Watchdog_Cnt <= 0;\n                    STATUS_REG[0] <= 1;                   // CICMD\n                end\n                \n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1;\n                    \n                    // Timeout handling\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1;  // CTE\n                        NORMAL_INT_REG[15] <= 1; // EI\n                        if (ack_in) complete <= 1;\n                        go_idle_o <= 1;\n                    end\n                    \n                    // Request handling\n                    if (ack_in_int) begin\n                        req_out <= 1;\n                    end\n                    \n                    // Status handling\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1;\n                        \n                        if (status[dat_ava]) begin\n                            complete <= 1;\n                            NORMAL_INT_REG[15] <= 0; // Clear EI\n                            \n                            // CRC check\n                            if (CRC_check_enable && !status[crc_valid]) begin\n                                ERR_INT_REG[1] <= 1; // CCRCE\n                                NORMAL_INT_REG[15] <= 1; // EI\n                            end\n                            \n                            // Index check\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1; // CIE\n                                NORMAL_INT_REG[15] <= 1; // EI\n                            end\n                            \n                            NORMAL_INT_REG[0] <= 1; // CC\n                            \n                            // Store response if needed\n                            if (response_size != 0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n    \n    // Continuous assignments for interrupt registers\n    always @(*) begin\n        ERR_INT_REG = {1'b0, CIE, 1'b0, CCRCE, CTE};\n        NORMAL_INT_REG[15] = EI;\n        NORMAL_INT_REG[0] = CC;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 5, "code": "module sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAR_dat_i,\n    \n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\nparameter SD_BUS_W = 4;\nparameter BIT_BLOCK = 512;\nparameter CRC_OFF = 16;\nparameter BIT_BLOCK_REC = 512;\nparameter BIT_CRC_CYCLE = 16;\nparameter LITTLE_ENDIAN = 1;\nparameter BIG_ENDIAN = 0;\nparameter SD_BUS_WIDTH_1 = 1;\nparameter SD_BUS_WIDTH_4 = 4;\n\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out [0:SD_BUS_W-1];\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// State definitions\nlocalparam IDLE       = 6'b000001;\nlocalparam WRITE_DAT  = 6'b000010;\nlocalparam WRITE_CRC  = 6'b000100;\nlocalparam WRITE_BUSY = 6'b001000;\nlocalparam READ_WAIT  = 6'b010000;\nlocalparam READ_DAT   = 6'b100000;\n\n// CRC generation modules\ngenerate\ngenvar i;\nfor (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n    sd_crc_16 crc_inst (\n        .BITVAL(crc_in[i]),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out[i])\n    );\nend\nendgenerate\n\n// ACK_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        ack_transfer_int <= 0;\n        ack_q <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// FSM_COMBO block\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b10) next_state = WRITE_DAT;\n            else if (start_dat == 2'b01) next_state = READ_WAIT;\n            else next_state = IDLE;\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == BIT_BLOCK) next_state = WRITE_CRC;\n            else next_state = WRITE_DAT;\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b001) next_state = WRITE_BUSY;\n            else next_state = WRITE_CRC;\n        end\n        WRITE_BUSY: begin\n            if (!busy_int) next_state = IDLE;\n            else next_state = WRITE_BUSY;\n        end\n        READ_WAIT: begin\n            if (!DAR_dat_i[0]) next_state = READ_DAT;\n            else next_state = READ_WAIT;\n        end\n        READ_DAT: begin\n            if (transf_cnt == BIT_BLOCK_REC) next_state = IDLE;\n            else next_state = READ_DAT;\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// START_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else begin\n        if (!DAR_dat_i[0] && state == READ_WAIT)\n            q_start_bit <= 0;\n        else\n            q_start_bit <= 1;\n    end\nend\n\n// FSM_SEQ block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        write_buf_0 <= 0;\n        write_buf_1 <= 0;\n        DAT_oe_o <= 0;\n        crc_en <= 0;\n        crc_rst <= 1;\n        transf_cnt <= 0;\n        rd <= 0;\n        last_din <= 0;\n        crc_c <= 0;\n        crc_in <= 0;\n        DAT_dat_o <= 0;\n        crc_status <= 7;\n        crc_s <= 0;\n        transm_complete <= 0;\n        busy_n <= 1;\n        we <= 0;\n        data_out <= 0;\n        crc_ok <= 0;\n        busy_int <= 0;\n        data_send_index <= 0;\n        out_buff_ptr <= 0;\n        in_buff_ptr <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                crc_rst <= 1;\n                crc_en <= 0;\n                DAT_oe_o <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                transf_cnt <= 0;\n                crc_c <= 0;\n                crc_status <= 7;\n                busy_int <= 0;\n                \n                if (start_dat == 2'b10) begin\n                    write_buf_0 <= data_in;\n                    rd <= 1;\n                end\n            end\n            \n            WRITE_DAT: begin\n                crc_rst <= 0;\n                DAT_oe_o <= 1;\n                \n                if (transf_cnt == 0) begin\n                    DAT_dat_o <= 0; // Start bit\n                    crc_en <= 0;\n                end else if (transf_cnt < BIT_BLOCK) begin\n                    crc_en <= 1;\n                    if (transf_cnt[1:0] == 2'b00) begin\n                        last_din <= sd_data_out[3:0];\n                        crc_in <= sd_data_out[3:0];\n                        DAT_dat_o <= sd_data_out[3:0];\n                        sd_data_out <= {4'b0, sd_data_out[31:4]};\n                    end\n                end\n                \n                if (transf_cnt[1:0] == 2'b11) begin\n                    rd <= 1;\n                end else begin\n                    rd <= 0;\n                end\n                \n                if (transf_cnt == 31) begin\n                    sd_data_out <= write_buf_1;\n                    out_buff_ptr <= ~out_buff_ptr;\n                end\n                \n                transf_cnt <= transf_cnt + 1;\n            end\n            \n            WRITE_CRC: begin\n                if (transf_cnt < BIT_BLOCK + BIT_CRC_CYCLE) begin\n                    if (transf_cnt[1:0] == 2'b00) begin\n                        DAT_dat_o <= crc_out[0][3:0];\n                        crc_in <= crc_out[0][3:0];\n                    end\n                    transf_cnt <= transf_cnt + 1;\n                end else begin\n                    crc_status <= 3'b001;\n                end\n            end\n            \n            WRITE_BUSY: begin\n                transm_complete <= 1;\n                busy_int <= DAR_dat_i[0];\n                busy_n <= ~DAR_dat_i[0];\n                \n                if (crc_s == 3'b010) crc_ok <= 1;\n                else crc_ok <= 0;\n            end\n            \n            READ_WAIT: begin\n                crc_rst <= 0;\n                crc_en <= 1;\n                DAT_oe_o <= 0;\n                transf_cnt <= 0;\n            end\n            \n            READ_DAT: begin\n                if (transf_cnt < BIT_BLOCK_REC) begin\n                    data_out <= DAR_dat_i;\n                    crc_in <= DAR_dat_i;\n                    we <= 1;\n                end else begin\n                    we <= 0;\n                    // CRC checking logic would go here\n                end\n                \n                transf_cnt <= transf_cnt + 1;\n                \n                if (transf_cnt == BIT_BLOCK_REC + BIT_CRC_CYCLE) begin\n                    transm_complete <= 1;\n                    busy_n <= 0;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'h0000;\n    end else if (Enable) begin\n        CRC[0] <= CRC[15] ^ BITVAL;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2];\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4] ^ (CRC[15] ^ BITVAL);\n        CRC[6] <= CRC[5];\n        CRC[7] <= CRC[6];\n        CRC[8] <= CRC[7];\n        CRC[9] <= CRC[8];\n        CRC[10] <= CRC[9];\n        CRC[11] <= CRC[10];\n        CRC[12] <= CRC[11] ^ (CRC[15] ^ BITVAL);\n        CRC[13] <= CRC[12];\n        CRC[14] <= CRC[13];\n        CRC[15] <= CRC[14];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 6, "code": "module sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    \n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\nparameter SD_BUS_W = 4;\nparameter BIT_BLOCK = 512;\nparameter CRC_OFF = 16;\nparameter BIT_BLOCK_REC = 512;\nparameter BIT_CRC_CYCLE = 16;\nparameter LITTLE_ENDIAN = 1;\nparameter BIG_ENDIAN = 0;\nparameter SD_BUS_WIDTH_1 = 1;\nparameter SD_BUS_WIDTH_4 = 4;\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out [0:SD_BUS_W-1];\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// State definitions\nlocalparam IDLE      = 6'b000001;\nlocalparam WRITE_DAT = 6'b000010;\nlocalparam WRITE_CRC = 6'b000100;\nlocalparam WRITE_BUSY = 6'b001000;\nlocalparam READ_WAIT = 6'b010000;\nlocalparam READ_DAT  = 6'b100000;\n\n// CRC generation modules\ngenerate\ngenvar i;\nfor (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n    sd_crc_16 crc_inst (\n        .BITVAL(crc_in[i]),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out[i])\n    );\nend\nendgenerate\n\n// ACK_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        ack_transfer_int <= 0;\n        ack_q <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// FSM_COMBO block\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b10) next_state = WRITE_DAT;\n            else if (start_dat == 2'b01) next_state = READ_WAIT;\n            else next_state = IDLE;\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == BIT_BLOCK) next_state = WRITE_CRC;\n            else next_state = WRITE_DAT;\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b001) next_state = WRITE_BUSY;\n            else next_state = WRITE_CRC;\n        end\n        WRITE_BUSY: begin\n            if (!busy_int) next_state = IDLE;\n            else next_state = WRITE_BUSY;\n        end\n        READ_WAIT: begin\n            if (!DAT_dat_i[0]) next_state = READ_DAT;\n            else next_state = READ_WAIT;\n        end\n        READ_DAT: begin\n            if (transf_cnt == BIT_BLOCK_REC) next_state = IDLE;\n            else next_state = READ_DAT;\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// START_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else begin\n        if (!DAT_dat_i[0] && state == READ_WAIT)\n            q_start_bit <= 0;\n        else\n            q_start_bit <= 1;\n    end\nend\n\n// FSM_SEQ block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        write_buf_0 <= 0;\n        write_buf_1 <= 0;\n        DAT_oe_o <= 0;\n        crc_en <= 0;\n        crc_rst <= 1;\n        transf_cnt <= 0;\n        rd <= 0;\n        last_din <= 0;\n        crc_c <= 0;\n        crc_in <= 0;\n        DAT_dat_o <= 0;\n        crc_status <= 7;\n        crc_s <= 0;\n        transm_complete <= 0;\n        busy_n <= 1;\n        we <= 0;\n        data_out <= 0;\n        crc_ok <= 0;\n        busy_int <= 0;\n        data_send_index <= 0;\n        out_buff_ptr <= 0;\n        in_buff_ptr <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                crc_rst <= 1;\n                crc_en <= 0;\n                DAT_oe_o <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                transf_cnt <= 0;\n                crc_c <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n                \n                if (start_dat == 2'b10) begin\n                    write_buf_0 <= data_in;\n                    rd <= 1;\n                end\n            end\n            \n            WRITE_DAT: begin\n                crc_rst <= 0;\n                DAT_oe_o <= 1;\n                \n                if (transf_cnt == 0) begin\n                    DAT_dat_o <= 0; // Start bit\n                    crc_en <= 1;\n                end else if (transf_cnt < BIT_BLOCK) begin\n                    if (transf_cnt[1:0] == 2'b00) begin\n                        if (out_buff_ptr == 0)\n                            sd_data_out <= write_buf_0;\n                        else\n                            sd_data_out <= write_buf_1;\n                    end\n                    \n                    last_din <= sd_data_out[31:28];\n                    crc_in <= sd_data_out[31:28];\n                    DAT_dat_o <= sd_data_out[31:28];\n                    sd_data_out <= {sd_data_out[27:0], 4'b0};\n                    \n                    if (transf_cnt[1:0] == 2'b11 && transf_cnt < (BIT_BLOCK - 4)) begin\n                        out_buff_ptr <= ~out_buff_ptr;\n                        if (out_buff_ptr == 0)\n                            write_buf_1 <= data_in;\n                        else\n                            write_buf_0 <= data_in;\n                        rd <= 1;\n                    end else begin\n                        rd <= 0;\n                    end\n                end\n                \n                transf_cnt <= transf_cnt + 1;\n            end\n            \n            WRITE_CRC: begin\n                if (transf_cnt < (BIT_BLOCK + BIT_CRC_CYCLE)) begin\n                    if (transf_cnt >= BIT_BLOCK && transf_cnt < (BIT_BLOCK + 16)) begin\n                        DAT_dat_o <= crc_out[0][15 - (transf_cnt - BIT_BLOCK)];\n                    end\n                    transf_cnt <= transf_cnt + 1;\n                end else begin\n                    crc_status <= 3'b001;\n                end\n            end\n            \n            WRITE_BUSY: begin\n                transm_complete <= 1;\n                busy_int <= DAT_dat_i[0];\n                busy_n <= ~DAT_dat_i[0];\n                \n                if (crc_s == 3'b010)\n                    crc_ok <= 1;\n                else\n                    crc_ok <= 0;\n            end\n            \n            READ_WAIT: begin\n                crc_rst <= 0;\n                crc_en <= 1;\n                DAT_oe_o <= 0;\n                we <= 0;\n            end\n            \n            READ_DAT: begin\n                if (transf_cnt < BIT_BLOCK_REC) begin\n                    data_out <= DAT_dat_i;\n                    crc_in <= DAT_dat_i;\n                    we <= 1;\n                end else begin\n                    we <= 0;\n                    // CRC checking logic would go here\n                end\n                \n                transf_cnt <= transf_cnt + 1;\n                \n                if (transf_cnt == (BIT_BLOCK_REC + BIT_CRC_CYCLE - 1)) begin\n                    transm_complete <= 1;\n                    busy_n <= 0;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'h0000;\n    end else if (Enable) begin\n        CRC[0] <= CRC[15] ^ BITVAL;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2];\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4] ^ CRC[15] ^ BITVAL;\n        CRC[6] <= CRC[5];\n        CRC[7] <= CRC[6];\n        CRC[8] <= CRC[7];\n        CRC[9] <= CRC[8];\n        CRC[10] <= CRC[9];\n        CRC[11] <= CRC[10];\n        CRC[12] <= CRC[11] ^ CRC[15] ^ BITVAL;\n        CRC[13] <= CRC[12];\n        CRC[14] <= CRC[13];\n        CRC[15] <= CRC[14];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 7, "code": "module sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAR_dat_i,\n    \n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\nparameter SD_BUS_W = 4;\nparameter BIT_BLOCK = 512;\nparameter CRC_OFF = 16;\nparameter BIT_BLOCK_REC = 512;\nparameter BIT_CRC_CYCLE = 16;\nparameter LITTLE_ENDIAN = 1;\nparameter BIG_ENDIAN = 0;\nparameter SD_BUS_WIDTH_1 = 1;\nparameter SD_BUS_WIDTH_4 = 4;\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out [0:SD_BUS_W-1];\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// States\nlocalparam [5:0]\n    IDLE       = 6'b000001,\n    WRITE_DAT  = 6'b000010,\n    WRITE_CRC  = 6'b000100,\n    WRITE_BUSY = 6'b001000,\n    READ_WAIT  = 6'b010000,\n    READ_DAT   = 6'b100000;\n\n// CRC generation modules\ngenerate\n    genvar i;\n    for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n        sd_crc_16 crc_inst (\n            .BITVAL(crc_in[i]),\n            .Enable(crc_en),\n            .CLK(sd_clk),\n            .RST(crc_rst),\n            .CRC(crc_out[i])\n        );\n    end\nendgenerate\n\n// ACK_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        ack_transfer_int <= 0;\n        ack_q <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// FSM_COMBO block\nalways @(*) begin\n    next_state = state;\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b10) next_state = WRITE_DAT;\n            else if (start_dat == 2'b01) next_state = READ_WAIT;\n            else next_state = IDLE;\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == BIT_BLOCK) next_state = WRITE_CRC;\n            else next_state = WRITE_DAT;\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b001) next_state = WRITE_BUSY;\n            else next_state = WRITE_CRC;\n        end\n        WRITE_BUSY: begin\n            if (!busy_int) next_state = IDLE;\n            else next_state = WRITE_BUSY;\n        end\n        READ_WAIT: begin\n            if (!DAR_dat_i[0]) next_state = READ_DAT;\n            else next_state = READ_WAIT;\n        end\n        READ_DAT: begin\n            if (transf_cnt == BIT_BLOCK_REC) next_state = IDLE;\n            else next_state = READ_DAT;\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// START_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else begin\n        if (!DAR_dat_i[0] && state == READ_WAIT)\n            q_start_bit <= 0;\n        else\n            q_start_bit <= 1;\n    end\nend\n\n// FSM_SEQ block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        write_buf_0 <= 0;\n        write_buf_1 <= 0;\n        DAT_oe_o <= 0;\n        crc_en <= 0;\n        crc_rst <= 1;\n        transf_cnt <= 0;\n        rd <= 0;\n        last_din <= 0;\n        crc_c <= 0;\n        crc_in <= 0;\n        DAT_dat_o <= 0;\n        crc_status <= 7;\n        crc_s <= 0;\n        transm_complete <= 0;\n        busy_n <= 1;\n        we <= 0;\n        data_out <= 0;\n        crc_ok <= 0;\n        busy_int <= 0;\n        data_send_index <= 0;\n        out_buff_ptr <= 0;\n        in_buff_ptr <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                crc_rst <= 1;\n                crc_en <= 0;\n                DAT_oe_o <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                transf_cnt <= 0;\n                crc_c <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n                \n                if (start_dat == 2'b10) begin\n                    write_buf_0 <= data_in;\n                    rd <= 1;\n                end\n            end\n            \n            WRITE_DAT: begin\n                crc_rst <= 0;\n                DAT_oe_o <= 1;\n                \n                if (transf_cnt == 0) begin\n                    DAT_dat_o <= 0; // Start bit\n                    crc_en <= 0;\n                end else begin\n                    if (transf_cnt % 32 == 0) begin\n                        if (out_buff_ptr == 0)\n                            sd_data_out <= write_buf_0;\n                        else\n                            sd_data_out <= write_buf_1;\n                        out_buff_ptr <= ~out_buff_ptr;\n                    end\n                    \n                    if (transf_cnt % 8 == 0) begin\n                        last_din <= sd_data_out[31:28];\n                        sd_data_out <= {sd_data_out[27:0], 4'b0};\n                    end\n                    \n                    DAT_dat_o <= last_din;\n                    crc_in <= last_din;\n                    crc_en <= 1;\n                end\n                \n                transf_cnt <= transf_cnt + 1;\n            end\n            \n            WRITE_CRC: begin\n                if (crc_c < BIT_CRC_CYCLE) begin\n                    DAT_dat_o <= crc_out[data_send_index][15 - crc_c];\n                    crc_c <= crc_c + 1;\n                end else begin\n                    DAT_dat_o <= 4'b1111; // Stop bit\n                    crc_status <= 3'b001;\n                end\n            end\n            \n            WRITE_BUSY: begin\n                transm_complete <= 1;\n                busy_int <= DAR_dat_i[0];\n                busy_n <= ~DAR_dat_i[0];\n                \n                if (crc_s == 3'b010)\n                    crc_ok <= 1;\n                else\n                    crc_ok <= 0;\n            end\n            \n            READ_WAIT: begin\n                DAT_oe_o <= 0;\n                crc_rst <= 0;\n                crc_en <= 1;\n                transf_cnt <= 0;\n            end\n            \n            READ_DAT: begin\n                data_out <= DAR_dat_i;\n                crc_in <= DAR_dat_i;\n                we <= 1;\n                transf_cnt <= transf_cnt + 1;\n                \n                if (transf_cnt >= BIT_BLOCK_REC) begin\n                    // Check CRC\n                    if (SD_BUS_W == 4) begin\n                        crc_ok <= (crc_out[0] == 16'hFFFF) && (crc_out[1] == 16'hFFFF) && \n                                 (crc_out[2] == 16'hFFFF) && (crc_out[3] == 16'hFFFF);\n                    end else begin\n                        crc_ok <= (crc_out[0] == 16'hFFFF);\n                    end\n                    \n                    transm_complete <= 1;\n                    busy_n <= 0;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'h0000;\n    end else if (Enable) begin\n        CRC[0] <= CRC[15] ^ BITVAL;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ (CRC[15] ^ BITVAL);\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n        CRC[7] <= CRC[6];\n        CRC[8] <= CRC[7];\n        CRC[9] <= CRC[8];\n        CRC[10] <= CRC[9];\n        CRC[11] <= CRC[10];\n        CRC[12] <= CRC[11] ^ (CRC[15] ^ BITVAL);\n        CRC[13] <= CRC[12];\n        CRC[14] <= CRC[13];\n        CRC[15] <= CRC[14];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 20, "code": "module sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    output wire full,\n    output wire empty,\n    output wire [1:0] mem_empt,\n    input wire rclk,\n    input wire rst\n);\n\nparameter FIFO_RX_MEM_DEPTH = 16; // Example value, should be defined in sd_defines.v\nparameter FIFO_RX_MEM_ADR_SIZE = 5; // log2(FIFO_RX_MEM_DEPTH)+1\n\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_gray, adr_o_gray;\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_gray_sync, adr_o_gray_sync;\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_gray_sync_r, adr_o_gray_sync_r;\n\n// Binary to Gray code conversion\nfunction [FIFO_RX_MEM_ADR_SIZE-1:0] bin2gray;\n    input [FIFO_RX_MEM_ADR_SIZE-1:0] bin;\n    begin\n        bin2gray = bin ^ (bin >> 1);\n    end\nendfunction\n\n// Gray to binary conversion\nfunction [FIFO_RX_MEM_ADR_SIZE-1:0] gray2bin;\n    input [FIFO_RX_MEM_ADR_SIZE-1:0] gray;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] bin;\n    integer i;\n    begin\n        bin[FIFO_RX_MEM_ADR_SIZE-1] = gray[FIFO_RX_MEM_ADR_SIZE-1];\n        for (i = FIFO_RX_MEM_ADR_SIZE-2; i >= 0; i = i - 1)\n            bin[i] = bin[i+1] ^ gray[i];\n        gray2bin = bin;\n    end\nendfunction\n\nassign adr_i_gray = bin2gray(adr_i);\nassign adr_o_gray = bin2gray(adr_o);\n\n// Synchronize write pointer to read clock domain\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_i_gray_sync <= 0;\n        adr_i_gray_sync_r <= 0;\n    end else begin\n        adr_i_gray_sync <= adr_i_gray;\n        adr_i_gray_sync_r <= adr_i_gray_sync;\n    end\nend\n\n// Synchronize read pointer to write clock domain\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_o_gray_sync <= 0;\n        adr_o_gray_sync_r <= 0;\n    end else begin\n        adr_o_gray_sync <= adr_o_gray;\n        adr_o_gray_sync_r <= adr_o_gray_sync;\n    end\nend\n\n// Full and empty flags\nassign full = (adr_i[FIFO_RX_MEM_ADR_SIZE-1] != adr_o_sync[FIFO_RX_MEM_ADR_SIZE-1]) && \n              (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] == adr_o_sync[FIFO_RX_MEM_ADR_SIZE-2:0]);\n\nassign empty = (adr_i_sync == adr_o);\n\n// Memory empty space calculation\nassign mem_empt = (FIFO_RX_MEM_DEPTH - (adr_i - adr_o_sync)) >> 2;\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n    end else begin\n        if (wr && !full) begin\n            case (we)\n                8'h1: tmp[7:0] <= d;\n                8'h2: tmp[15:8] <= d;\n                8'h4: tmp[23:16] <= d;\n                8'h8: tmp[31:24] <= d;\n                default: tmp <= tmp;\n            endcase\n            \n            if (we == 8'h8) begin\n                ram[adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]] <= tmp;\n                adr_i <= adr_i + 1;\n                we <= 8'h1;\n                ft <= 1;\n            end else begin\n                we <= we << 1;\n                ft <= 0;\n            end\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else begin\n        if (rd && !empty) begin\n            q <= ram[adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]];\n            adr_o <= adr_o + 1;\n        end\n    end\nend\n\n// Synchronized pointers for full/empty calculation\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o_sync = gray2bin(adr_o_gray_sync_r);\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_sync = gray2bin(adr_i_gray_sync_r);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 14, "code": "module sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n// State definitions\nlocalparam IDLE    = 3'b001;\nlocalparam SETUP   = 3'b010;\nlocalparam EXECUTE = 3'b100;\n\n// Status bit definitions\nlocalparam dat_ava = 6;\nlocalparam crc_valid = 5;\n\n// Response size definitions\nlocalparam small_rsp = 7'b0101000;\nlocalparam big_rsp = 7'b1111111;\n\n// Internal signals\nreg [2:0] state, next_state;\nreg [3:0] debounce;\nreg card_present;\nreg ack_q, ack_in_int;\nreg req_q, req_in_int;\nreg index_check_enable;\nreg CRC_check_enable;\nreg complete;\nreg [15:0] Watchdog_Cnt;\nreg [6:0] response_size;\nreg [7:0] status;\nreg CC, EI;\nreg CTE, CCRCE, CIE;\n\n// Debounce logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0;\n        card_present <= 1'b0;\n    end else begin\n        if (!card_detect) begin\n            if (debounce != 4'b1111)\n                debounce <= debounce + 1'b1;\n        end else begin\n            debounce <= 4'b0;\n        end\n        card_present <= (debounce == 4'b1111) ? 1'b1 : 1'b0;\n    end\nend\n\n// Synchronizers\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        ack_q <= 1'b0;\n        ack_in_int <= 1'b0;\n        req_q <= 1'b0;\n        req_in_int <= 1'b0;\n    end else begin\n        ack_q <= ack_in;\n        ack_in_int <= ack_q;\n        req_q <= req_in;\n        req_in_int <= req_q;\n    end\nend\n\n// FSM state register\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I)\n        state <= IDLE;\n    else\n        state <= next_state;\nend\n\n// FSM next state logic\nalways @(*) begin\n    case (state)\n        IDLE: next_state = New_CMD ? SETUP : IDLE;\n        SETUP: next_state = ack_in_int ? EXECUTE : SETUP;\n        EXECUTE: next_state = complete ? IDLE : EXECUTE;\n        default: next_state = IDLE;\n    endcase\nend\n\n// FSM output logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        // Reset all outputs and internal registers\n        CRC_check_enable <= 1'b0;\n        complete <= 1'b0;\n        RESP_1_REG <= 32'b0;\n        ERR_INT_REG <= 5'b0;\n        NORMAL_INT_REG <= 16'b0;\n        STATUS_REG <= 16'b0;\n        status <= 8'b0;\n        cmd_out <= 40'b0;\n        settings <= 16'b0;\n        response_size <= 7'b0;\n        req_out <= 1'b0;\n        index_check_enable <= 1'b0;\n        ack_out <= 1'b0;\n        Watchdog_Cnt <= 16'b0;\n        CCRCE <= 1'b0;\n        EI <= 1'b0;\n        CC <= 1'b0;\n        go_idle_o <= 1'b0;\n        CTE <= 1'b0;\n        CIE <= 1'b0;\n    end else begin\n        // Interrupt reset handling\n        if (ERR_INT_RST) ERR_INT_REG <= 5'b0;\n        if (NORMAL_INT_RST) NORMAL_INT_REG <= 16'b0;\n        \n        // Card presence status\n        NORMAL_INT_REG[1] <= card_present;\n        NORMAL_INT_REG[2] <= ~card_present;\n        \n        complete <= 1'b0;\n        \n        case (state)\n            IDLE: begin\n                go_idle_o <= 1'b0;\n                req_out <= 1'b0;\n                ack_out <= 1'b0;\n                STATUS_REG[0] <= 1'b0; // CICMD\n                \n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1'b1;\n                end\n            end\n            \n            SETUP: begin\n                NORMAL_INT_REG <= 16'b0;\n                ERR_INT_REG <= 5'b0;\n                index_check_enable <= CMD_SET_REG[4]; // CICE\n                CRC_check_enable <= CMD_SET_REG[3];   // CRCE\n                \n                // Compose command\n                cmd_out[39:38] <= 2'b01;\n                cmd_out[37:32] <= CMD_SET_REG[13:8]; // CMDI\n                cmd_out[31:0] <= ARG_REG;\n                \n                // Determine response size\n                case (CMD_SET_REG[1:0]) // RTS\n                    2'b10, 2'b11: response_size <= small_rsp;\n                    2'b01: response_size <= big_rsp;\n                    default: response_size <= 7'b0;\n                endcase\n                \n                // Setup settings\n                settings[14:13] <= CMD_SET_REG[7:6]; // WORD_SELECT\n                settings[12] <= data_read;\n                settings[11] <= data_write;\n                settings[10:8] <= 3'b111; // Delay\n                settings[7] <= CMD_SET_REG[3]; // CRCE\n                settings[6:0] <= response_size;\n                \n                Watchdog_Cnt <= 16'b0;\n                STATUS_REG[0] <= 1'b1; // CICMD\n            end\n            \n            EXECUTE: begin\n                Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                \n                // Timeout handling\n                if (Watchdog_Cnt > TIMEOUT_REG) begin\n                    ERR_INT_REG[0] <= 1'b1; // CTE\n                    NORMAL_INT_REG[15] <= 1'b1; // EI\n                    if (ack_in) complete <= 1'b1;\n                    go_idle_o <= 1'b1;\n                end\n                \n                // Request handling\n                if (ack_in_int) begin\n                    req_out <= 1'b1;\n                end\n                \n                // Status handling\n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1'b1;\n                    \n                    if (status[dat_ava]) begin\n                        complete <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b0; // Clear EI\n                        \n                        // CRC check\n                        if (CRC_check_enable && !status[crc_valid]) begin\n                            ERR_INT_REG[1] <= 1'b1; // CCRCE\n                            NORMAL_INT_REG[15] <= 1'b1; // EI\n                        end\n                        \n                        // Index check\n                        if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                            ERR_INT_REG[3] <= 1'b1; // CIE\n                            NORMAL_INT_REG[15] <= 1'b1; // EI\n                        end\n                        \n                        NORMAL_INT_REG[0] <= 1'b1; // CC\n                        \n                        // Store response if needed\n                        if (response_size != 7'b0) begin\n                            RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 15, "code": "module sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n// Local parameters\nlocalparam [2:0] IDLE    = 3'b001;\nlocalparam [2:0] SETUP   = 3'b010;\nlocalparam [2:0] EXECUTE = 3'b100;\n\n// Response sizes\nlocalparam [6:0] small_rsp = 7'b0101000;\nlocalparam [6:0] big_rsp   = 7'b1111111;\n\n// Status bits\nlocalparam dat_ava   = 6;\nlocalparam crc_valid = 5;\n\n// State registers\nreg [2:0] state;\nreg [2:0] next_state;\n\n// Internal signals\nreg [3:0] debounce;\nreg card_present;\nreg ack_q, ack_in_int;\nreg req_q, req_in_int;\nreg index_check_enable;\nreg CRC_check_enable;\nreg complete;\nreg [15:0] Watchdog_Cnt;\nreg [6:0] response_size;\nreg [7:0] status;\nreg CC, EI, CTE, CCRCE, CIE;\n\n// Debounce logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0;\n        card_present <= 1'b0;\n    end else begin\n        if (!card_detect) begin\n            if (debounce != 4'b1111)\n                debounce <= debounce + 1'b1;\n        end else begin\n            debounce <= 4'b0;\n        end\n        card_present <= (debounce == 4'b1111);\n    end\nend\n\n// Synchronizers\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        ack_q <= 1'b0;\n        ack_in_int <= 1'b0;\n        req_q <= 1'b0;\n        req_in_int <= 1'b0;\n    end else begin\n        ack_q <= ack_in;\n        ack_in_int <= ack_q;\n        req_q <= req_in;\n        req_in_int <= req_q;\n    end\nend\n\n// FSM state transition\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I)\n        state <= IDLE;\n    else\n        state <= next_state;\nend\n\n// FSM next state logic\nalways @(*) begin\n    case (state)\n        IDLE: next_state = New_CMD ? SETUP : IDLE;\n        SETUP: next_state = ack_in_int ? EXECUTE : SETUP;\n        EXECUTE: next_state = complete ? IDLE : EXECUTE;\n        default: next_state = IDLE;\n    endcase\nend\n\n// FSM output logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        // Reset all outputs\n        CRC_check_enable <= 1'b0;\n        complete <= 1'b0;\n        RESP_1_REG <= 32'b0;\n        ERR_INT_REG <= 5'b0;\n        NORMAL_INT_REG <= 16'b0;\n        STATUS_REG <= 16'b0;\n        status <= 8'b0;\n        cmd_out <= 40'b0;\n        settings <= 16'b0;\n        response_size <= 7'b0;\n        req_out <= 1'b0;\n        index_check_enable <= 1'b0;\n        ack_out <= 1'b0;\n        Watchdog_Cnt <= 16'b0;\n        CCRCE <= 1'b0;\n        EI <= 1'b0;\n        CC <= 1'b0;\n        go_idle_o <= 1'b0;\n        CTE <= 1'b0;\n        CIE <= 1'b0;\n    end else begin\n        // Default assignments\n        NORMAL_INT_REG[1] <= card_present;\n        NORMAL_INT_REG[2] <= ~card_present;\n        complete <= 1'b0;\n        \n        // Handle interrupt resets\n        if (ERR_INT_RST) ERR_INT_REG <= 5'b0;\n        if (NORMAL_INT_RST) NORMAL_INT_REG <= 16'b0;\n        \n        case (state)\n            IDLE: begin\n                go_idle_o <= 1'b0;\n                req_out <= 1'b0;\n                ack_out <= 1'b0;\n                STATUS_REG[0] <= 1'b0; // CICMD\n                \n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1'b1;\n                end\n            end\n            \n            SETUP: begin\n                NORMAL_INT_REG <= 16'b0;\n                ERR_INT_REG <= 5'b0;\n                index_check_enable <= CMD_SET_REG[4]; // CICE\n                CRC_check_enable <= CMD_SET_REG[3];   // CRCE\n                \n                // Compose cmd_out\n                cmd_out[39:38] <= 2'b01;\n                cmd_out[37:32] <= CMD_SET_REG[13:8];  // CMDI\n                cmd_out[31:0] <= ARG_REG;\n                \n                // Determine response size\n                case (CMD_SET_REG[1:0]) // RTS\n                    2'b10, 2'b11: response_size <= small_rsp;\n                    2'b01: response_size <= big_rsp;\n                    default: response_size <= 7'b0;\n                endcase\n                \n                // Compose settings\n                settings[14:13] <= CMD_SET_REG[7:6];  // WORD_SELECT\n                settings[12] <= data_read;\n                settings[11] <= data_write;\n                settings[10:8] <= 3'b111;             // Delay\n                settings[7] <= CMD_SET_REG[3];        // CRCE\n                settings[6:0] <= response_size;\n                \n                Watchdog_Cnt <= 16'b0;\n                STATUS_REG[0] <= 1'b1; // CICMD\n            end\n            \n            EXECUTE: begin\n                Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                \n                // Timeout handling\n                if (Watchdog_Cnt > TIMEOUT_REG) begin\n                    ERR_INT_REG[0] <= 1'b1; // CTE\n                    NORMAL_INT_REG[15] <= 1'b1; // EI\n                    if (ack_in) complete <= 1'b1;\n                    go_idle_o <= 1'b1;\n                end\n                \n                // Request handling\n                if (ack_in_int) begin\n                    req_out <= 1'b1;\n                end\n                \n                // Status handling\n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1'b1;\n                    \n                    if (status[dat_ava]) begin\n                        complete <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b0; // Clear EI\n                        \n                        // CRC check\n                        if (CRC_check_enable && !status[crc_valid]) begin\n                            ERR_INT_REG[1] <= 1'b1; // CCRCE\n                            NORMAL_INT_REG[15] <= 1'b1; // EI\n                        end\n                        \n                        // Index check\n                        if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                            ERR_INT_REG[3] <= 1'b1; // CIE\n                            NORMAL_INT_REG[15] <= 1'b1; // EI\n                        end\n                        \n                        NORMAL_INT_REG[0] <= 1'b1; // CC\n                        \n                        // Store response if needed\n                        if (response_size != 7'b0) begin\n                            RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            end\n        endcase\n        \n        // Update interrupt registers\n        ERR_INT_REG[0] <= CTE;\n        ERR_INT_REG[1] <= CCRCE;\n        ERR_INT_REG[3] <= CIE;\n        NORMAL_INT_REG[0] <= CC;\n        NORMAL_INT_REG[15] <= EI;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 5, "code": "module sd_controller_wb (\n    // Wishbone interface\n    input               wb_clk_i,\n    input               wb_rst_i,\n    input      [31:0]   wb_dat_i,\n    output reg [31:0]   wb_dat_o,\n    input      [7:0]    wb_adr_i,\n    input      [3:0]    wb_sel_i,\n    input               wb_we_i,\n    input               wb_cyc_i,\n    input               wb_stb_i,\n    output reg          wb_ack_o,\n    \n    // Control signals\n    output reg          we_m_tx_bd,\n    output reg          we_m_rx_bd,\n    output reg          new_cmd,\n    output reg          we_ack,\n    output reg          int_ack,\n    output reg          cmd_int_busy,\n    output reg          int_busy,\n    \n    // Data master interface\n    input               write_req_s,\n    input      [15:0]   cmd_set_s,\n    input      [32:0]   cmd_arg_s,\n    \n    // Registers\n    output reg [31:0]   argument_reg,\n    output reg [15:0]   cmd_setting_reg,\n    input      [15:0]   status_reg,\n    input      [31:0]   cmd_resp_1,\n    output reg [7:0]    software_reset_reg,\n    output reg [16:0]   time_out_reg,\n    input      [15:0]   normal_int_status_reg,\n    input      [15:0]   error_int_status_reg,\n    output reg [15:0]   normal_int_signal_enable_reg,\n    output reg [15:0]   error_int_signal_enable_reg,\n    output reg [7:0]    clock_divider,\n    input      [15:0]   Bd_Status_reg,\n    input      [7:0]    Bd_isr_reg,\n    output reg [7:0]    Bd_isr_enable_reg,\n    \n    // Interrupt reset signals\n    output reg          Bd_isr_reset,\n    output reg          normal_isr_reset,\n    output reg          error_isr_reset,\n    \n    // BD data\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\nparameter RAM_MEM_WIDTH = 32;\n\n// Internal signals\nreg [1:0] bd_write_state;\nreg [31:0] bd_temp_data;\n\n// Register read/write logic\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to default values\n        argument_reg <= 32'h0;\n        cmd_setting_reg <= 16'h0;\n        software_reset_reg <= 8'h0;\n        time_out_reg <= 16'h0;\n        normal_int_signal_enable_reg <= 16'h0;\n        error_int_signal_enable_reg <= 16'h0;\n        clock_divider <= 8'h0;\n        Bd_isr_enable_reg <= 8'h0;\n        \n        // Reset control signals\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        wb_ack_o <= 1'b0;\n        bd_write_state <= 2'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n    end else begin\n        // Default values\n        wb_ack_o <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        \n        // Handle data master interface\n        if (write_req_s) begin\n            cmd_setting_reg <= cmd_set_s;\n            argument_reg <= cmd_arg_s;\n            new_cmd <= 1'b1;\n            we_ack <= 1'b1;\n            cmd_int_busy <= 1'b1;\n        end else begin\n            cmd_int_busy <= 1'b0;\n        end\n        \n        // Handle Wishbone interface\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i[7:0])\n                    8'h00: begin\n                        argument_reg <= wb_dat_i;\n                        int_busy <= 1'b1;\n                    end\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_isr_reset <= 1'b1;\n                    8'h34: error_isr_reset <= 1'b1;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1'b1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    \n                    // BD RX/TX handling\n                    8'h60, 8'h64: begin\n                        if (bd_write_state == 2'b00) begin\n                            bd_temp_data <= wb_dat_i;\n                            we_m_rx_bd <= 1'b1;\n                            dat_in_m_rx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                            int_ack <= 1'b0;\n                            bd_write_state <= 2'b01;\n                        end else if (bd_write_state == 2'b01) begin\n                            if (RAM_MEM_WIDTH == 16) begin\n                                dat_in_m_rx_bd <= wb_dat_i[15:0];\n                                bd_write_state <= 2'b10;\n                            end else begin\n                                bd_write_state <= 2'b10;\n                            end\n                        end else begin\n                            we_m_rx_bd <= 1'b0;\n                            int_ack <= 1'b1;\n                            bd_write_state <= 2'b00;\n                            wb_ack_o <= 1'b1;\n                        end\n                    end\n                    \n                    8'h80, 8'h84: begin\n                        if (bd_write_state == 2'b00) begin\n                            bd_temp_data <= wb_dat_i;\n                            we_m_tx_bd <= 1'b1;\n                            dat_in_m_tx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                            int_ack <= 1'b0;\n                            bd_write_state <= 2'b01;\n                        end else if (bd_write_state == 2'b01) begin\n                            if (RAM_MEM_WIDTH == 16) begin\n                                dat_in_m_tx_bd <= wb_dat_i[15:0];\n                                bd_write_state <= 2'b10;\n                            end else begin\n                                bd_write_state <= 2'b10;\n                            end\n                        end else begin\n                            we_m_tx_bd <= 1'b0;\n                            int_ack <= 1'b1;\n                            bd_write_state <= 2'b00;\n                            wb_ack_o <= 1'b1;\n                        end\n                    end\n                endcase\n                \n                if (bd_write_state == 2'b00 && !(wb_adr_i[7:0] inside {8'h60, 8'h64, 8'h80, 8'h84})) begin\n                    wb_ack_o <= 1'b1;\n                end\n            end else begin\n                // Read operation\n                case (wb_adr_i[7:0])\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= {16'h0, 16'h0}; // Controller Setting\n                    8'h20: wb_dat_o <= {16'h0, 16'h0200}; // Block Size (512)\n                    8'h24: wb_dat_o <= {24'h0, 8'h0f}; // Power Control (3.3V)\n                    8'h28: wb_dat_o <= {24'h0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= {16'h0, 16'h0}; // Capability\n                    8'h4c: wb_dat_o <= {24'h0, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'h0;\n                endcase\n                wb_ack_o <= 1'b1;\n            end\n        end\n        \n        // Clear int_busy when not accessing cmd_setting_reg\n        if (!(wb_cyc_i && wb_stb_i && wb_adr_i[7:0] == 8'h04 && wb_we_i)) begin\n            int_busy <= 1'b0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 16, "code": "module sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n// State definitions\nlocalparam IDLE    = 3'b001;\nlocalparam SETUP   = 3'b010;\nlocalparam EXECUTE = 3'b100;\n\n// Status bits\nlocalparam dat_ava = 6;\nlocalparam crc_valid = 5;\n\n// Response sizes\nlocalparam small_rsp = 7'b0101000;\nlocalparam big_rsp = 7'b1111111;\n\n// Internal signals\nreg [2:0] state, next_state;\nreg [3:0] debounce;\nreg card_present;\nreg ack_q, ack_in_int;\nreg req_q, req_in_int;\nreg index_check_enable;\nreg CRC_check_enable;\nreg complete;\nreg [15:0] Watchdog_Cnt;\nreg [6:0] response_size;\nreg [7:0] status;\nreg CIE, CCRCE, CTE, EI, CC;\n\n// Debounce logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0;\n        card_present <= 1'b0;\n    end else begin\n        if (!card_detect) begin\n            if (debounce != 4'b1111)\n                debounce <= debounce + 1'b1;\n        end else begin\n            debounce <= 4'b0;\n        end\n        card_present <= (debounce == 4'b1111);\n    end\nend\n\n// Synchronizers\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        ack_q <= 1'b0;\n        ack_in_int <= 1'b0;\n        req_q <= 1'b0;\n        req_in_int <= 1'b0;\n    end else begin\n        ack_q <= ack_in;\n        ack_in_int <= ack_q;\n        req_q <= req_in;\n        req_in_int <= req_q;\n    end\nend\n\n// FSM state transition\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I)\n        state <= IDLE;\n    else\n        state <= next_state;\nend\n\n// FSM next state logic\nalways @(*) begin\n    case (state)\n        IDLE: next_state = New_CMD ? SETUP : IDLE;\n        SETUP: next_state = ack_in_int ? EXECUTE : SETUP;\n        EXECUTE: next_state = complete ? IDLE : EXECUTE;\n        default: next_state = IDLE;\n    endcase\nend\n\n// FSM output logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        // Reset all outputs\n        CRC_check_enable <= 1'b0;\n        complete <= 1'b0;\n        RESP_1_REG <= 32'b0;\n        ERR_INT_REG <= 5'b0;\n        NORMAL_INT_REG <= 16'b0;\n        STATUS_REG <= 16'b0;\n        status <= 8'b0;\n        cmd_out <= 40'b0;\n        settings <= 16'b0;\n        response_size <= 7'b0;\n        req_out <= 1'b0;\n        index_check_enable <= 1'b0;\n        ack_out <= 1'b0;\n        Watchdog_Cnt <= 16'b0;\n        CCRCE <= 1'b0;\n        EI <= 1'b0;\n        CC <= 1'b0;\n        go_idle_o <= 1'b0;\n        CIE <= 1'b0;\n        CTE <= 1'b0;\n    end else begin\n        // Update interrupt registers\n        NORMAL_INT_REG[1] <= card_present;\n        NORMAL_INT_REG[2] <= ~card_present;\n        complete <= 1'b0;\n        \n        // Handle interrupt resets\n        if (ERR_INT_RST) ERR_INT_REG <= 5'b0;\n        if (NORMAL_INT_RST) NORMAL_INT_REG <= 16'b0;\n        \n        case (state)\n            IDLE: begin\n                go_idle_o <= 1'b0;\n                req_out <= 1'b0;\n                ack_out <= 1'b0;\n                STATUS_REG[0] <= 1'b0; // CICMD\n                \n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1'b1;\n                end\n            end\n            \n            SETUP: begin\n                NORMAL_INT_REG <= 16'b0;\n                ERR_INT_REG <= 5'b0;\n                index_check_enable <= CMD_SET_REG[4]; // CICE\n                CRC_check_enable <= CMD_SET_REG[3];   // CRCE\n                \n                // Compose command\n                cmd_out[39:38] <= 2'b01;\n                cmd_out[37:32] <= CMD_SET_REG[13:8];  // CMDI\n                cmd_out[31:0] <= ARG_REG;\n                \n                // Determine response size\n                case (CMD_SET_REG[1:0]) // RTS\n                    2'b10, 2'b11: response_size <= small_rsp;\n                    2'b01: response_size <= big_rsp;\n                    default: response_size <= 7'b0;\n                endcase\n                \n                // Setup settings\n                settings[14:13] <= CMD_SET_REG[7:6]; // WORD_SELECT\n                settings[12] <= data_read;\n                settings[11] <= data_write;\n                settings[10:8] <= 3'b111; // Delay\n                settings[7] <= CMD_SET_REG[3]; // CRCE\n                settings[6:0] <= response_size;\n                \n                Watchdog_Cnt <= 16'b0;\n                STATUS_REG[0] <= 1'b1; // CICMD\n            end\n            \n            EXECUTE: begin\n                Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                \n                // Timeout handling\n                if (Watchdog_Cnt > TIMEOUT_REG) begin\n                    ERR_INT_REG[0] <= 1'b1; // CTE\n                    NORMAL_INT_REG[15] <= 1'b1; // EI\n                    if (ack_in) complete <= 1'b1;\n                    go_idle_o <= 1'b1;\n                end\n                \n                // Request handling\n                if (ack_in_int) begin\n                    req_out <= 1'b1;\n                end\n                \n                // Status handling\n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1'b1;\n                    \n                    if (status[dat_ava]) begin\n                        complete <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b0; // EI\n                        \n                        // CRC check\n                        if (CRC_check_enable && !status[crc_valid]) begin\n                            ERR_INT_REG[1] <= 1'b1; // CCRCE\n                            NORMAL_INT_REG[15] <= 1'b1; // EI\n                        end\n                        \n                        // Index check\n                        if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                            ERR_INT_REG[3] <= 1'b1; // CIE\n                            NORMAL_INT_REG[15] <= 1'b1; // EI\n                        end\n                        \n                        NORMAL_INT_REG[0] <= 1'b1; // CC\n                        \n                        // Store response if needed\n                        if (response_size != 7'b0) begin\n                            RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 17, "code": "module sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n    // State definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal signals\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg ack_q, ack_in_int;\n    reg req_q, req_in_int;\n    reg index_check_enable;\n    reg CRC_check_enable;\n    reg complete;\n    reg [7:0] status;\n    reg [6:0] response_size;\n    reg [15:0] Watchdog_Cnt;\n    reg CCRCE;\n    reg EI;\n    reg CC;\n    wire dat_ava = status[6];\n    wire crc_valid = status[5];\n\n    // Response size constants\n    localparam small_rsp = 7'b0101000;\n    localparam big_rsp = 7'b1111111;\n\n    // Debounce logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0;\n            end\n            card_present <= (debounce == 4'b1111) ? 1'b1 : 1'b0;\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            ack_q <= 1'b0;\n            ack_in_int <= 1'b0;\n            req_q <= 1'b0;\n            req_in_int <= 1'b0;\n        end else begin\n            ack_q <= ack_in;\n            ack_in_int <= ack_q;\n            req_q <= req_in;\n            req_in_int <= req_q;\n        end\n    end\n\n    // FSM state register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // FSM next state logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = New_CMD ? SETUP : IDLE;\n            SETUP: next_state = ack_in_int ? EXECUTE : SETUP;\n            EXECUTE: next_state = complete ? IDLE : EXECUTE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM output logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            // Reset all outputs\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            CCRCE <= 1'b0;\n            EI <= 1'b0;\n            CC <= 1'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            // Update card presence status\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n\n            // Handle interrupt resets\n            if (ERR_INT_RST)\n                ERR_INT_REG <= 5'b0;\n            if (NORMAL_INT_RST)\n                NORMAL_INT_REG <= 16'b0;\n\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    STATUS_REG[0] <= 1'b0; // CICMD\n\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4]; // CICE\n                    CRC_check_enable <= CMD_SET_REG[3];   // CRCE\n\n                    // Compose cmd_out\n                    cmd_out[39:38] <= 2'b01;\n                    cmd_out[37:32] <= CMD_SET_REG[13:8];  // CMDI\n                    cmd_out[31:0] <= ARG_REG;\n\n                    // Determine response size\n                    case (CMD_SET_REG[1:0]) // RTS\n                        2'b10, 2'b11: response_size <= small_rsp;\n                        2'b01: response_size <= big_rsp;\n                        default: response_size <= 7'b0;\n                    endcase\n\n                    // Compose settings\n                    settings[14:13] <= CMD_SET_REG[7:6];  // WORD_SELECT\n                    settings[12] <= data_read;\n                    settings[11] <= data_write;\n                    settings[10:8] <= 3'b111;             // Delay\n                    settings[7] <= CMD_SET_REG[3];        // CRCE\n                    settings[6:0] <= response_size;\n\n                    Watchdog_Cnt <= 16'b0;\n                    STATUS_REG[0] <= 1'b1; // CICMD\n                end\n\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n\n                    // Timeout handling\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1; // CTE\n                        EI <= 1'b1;\n                        if (ack_in) begin\n                            complete <= 1'b1;\n                        end\n                        go_idle_o <= 1'b1;\n                    end\n\n                    // Request handling\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end\n\n                    // Status handling\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n\n                        if (dat_ava) begin\n                            complete <= 1'b1;\n                            EI <= 1'b0;\n\n                            // CRC check\n                            if (CRC_check_enable && !crc_valid) begin\n                                ERR_INT_REG[1] <= 1'b1; // CCRCE\n                                EI <= 1'b1;\n                            end\n\n                            // Index check\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1; // CIE\n                                EI <= 1'b1;\n                            end\n\n                            CC <= 1'b1;\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n\n            // Update interrupt registers\n            NORMAL_INT_REG[15] <= EI;\n            NORMAL_INT_REG[0] <= CC;\n            ERR_INT_REG[3] <= (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) ? 1'b1 : ERR_INT_REG[3];\n            ERR_INT_REG[1] <= (CRC_check_enable && !crc_valid) ? 1'b1 : ERR_INT_REG[1];\n            ERR_INT_REG[0] <= (Watchdog_Cnt > TIMEOUT_REG) ? 1'b1 : ERR_INT_REG[0];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 6, "code": "module sd_controller_wb (\n    // Wishbone interface\n    input               wb_clk_i,\n    input               wb_rst_i,\n    input      [31:0]   wb_dat_i,\n    output reg [31:0]   wb_dat_o,\n    input      [7:0]    wb_adr_i,\n    input      [3:0]    wb_sel_i,\n    input               wb_we_i,\n    input               wb_cyc_i,\n    input               wb_stb_i,\n    output reg          wb_ack_o,\n    \n    // Control signals\n    output reg          we_m_tx_bd,\n    output reg          we_m_rx_bd,\n    output reg          new_cmd,\n    output reg          we_ack,\n    output reg          int_ack,\n    output              cmd_int_busy,\n    output reg          int_busy,\n    \n    // Data master interface\n    input               write_req_s,\n    input      [15:0]   cmd_set_s,\n    input      [32:0]   cmd_arg_s,\n    \n    // Registers\n    output reg [31:0]   argument_reg,\n    output reg [15:0]   cmd_setting_reg,\n    input      [15:0]   status_reg,\n    input      [32:0]   cmd_resp_1,\n    output reg [7:0]    software_reset_reg,\n    output reg [16:0]   time_out_reg,\n    input      [15:0]   normal_int_status_reg,\n    input      [15:0]   error_int_status_reg,\n    output reg [15:0]   normal_int_signal_enable_reg,\n    output reg [15:0]   error_int_signal_enable_reg,\n    output reg [7:0]    clock_divider,\n    input      [15:0]   Bd_Status_reg,\n    input      [7:0]    Bd_isr_reg,\n    output reg [7:0]    Bd_isr_enable_reg,\n    \n    // Interrupt reset signals\n    output reg          Bd_isr_reset,\n    output reg          normal_isr_reset,\n    output reg          error_isr_reset,\n    \n    // BD data\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\nparameter RAM_MEM_WIDTH = 32; // Default to 32-bit width\n\n// Internal signals\nreg [1:0] bd_write_state;\nreg [31:0] bd_write_data;\nreg bd_write_upper;\n\nassign cmd_int_busy = write_req_s;\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to default values\n        argument_reg <= 32'h0;\n        cmd_setting_reg <= 16'h0;\n        software_reset_reg <= 8'h0;\n        time_out_reg <= 16'h0;\n        normal_int_signal_enable_reg <= 16'h0;\n        error_int_signal_enable_reg <= 16'h0;\n        clock_divider <= 8'h0;\n        Bd_isr_enable_reg <= 8'h0;\n        \n        // Reset control signals\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        int_busy <= 1'b0;\n        wb_ack_o <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        \n        // Reset BD write state machine\n        bd_write_state <= 2'b00;\n        bd_write_data <= 32'h0;\n        bd_write_upper <= 1'b0;\n    end else begin\n        // Default values\n        wb_ack_o <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        \n        // Handle data master write requests\n        if (write_req_s) begin\n            argument_reg <= cmd_arg_s;\n            cmd_setting_reg <= cmd_set_s;\n            new_cmd <= 1'b1;\n            we_ack <= 1'b1;\n            int_busy <= 1'b1;\n        end else begin\n            int_busy <= 1'b0;\n        end\n        \n        // Handle Wishbone transactions\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: begin // Argument register\n                        argument_reg <= wb_dat_i;\n                        new_cmd <= 1'b1;\n                    end\n                    8'h04: begin // Command setting register\n                        cmd_setting_reg <= wb_dat_i[15:0];\n                        new_cmd <= 1'b1;\n                    end\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_isr_reset <= 1'b1;\n                    8'h34: error_isr_reset <= 1'b1;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1'b1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    \n                    // BD RX/TX handling\n                    8'h60: begin // BD RX\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                            we_m_rx_bd <= 1'b1;\n                            wb_ack_o <= int_ack;\n                        end else begin // 16-bit\n                            if (!bd_write_upper) begin\n                                bd_write_data[15:0] <= wb_dat_i[15:0];\n                                bd_write_upper <= 1'b1;\n                                int_ack <= 1'b0;\n                            end else begin\n                                dat_in_m_rx_bd <= {wb_dat_i[15:0], bd_write_data[15:0]};\n                                we_m_rx_bd <= 1'b1;\n                                bd_write_upper <= 1'b0;\n                                int_ack <= 1'b1;\n                                wb_ack_o <= 1'b1;\n                            end\n                        end\n                    end\n                    \n                    8'h80: begin // BD TX\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                            we_m_tx_bd <= 1'b1;\n                            wb_ack_o <= int_ack;\n                        end else begin // 16-bit\n                            if (!bd_write_upper) begin\n                                bd_write_data[15:0] <= wb_dat_i[15:0];\n                                bd_write_upper <= 1'b1;\n                                int_ack <= 1'b0;\n                            end else begin\n                                dat_in_m_tx_bd <= {wb_dat_i[15:0], bd_write_data[15:0]};\n                                we_m_tx_bd <= 1'b1;\n                                bd_write_upper <= 1'b0;\n                                int_ack <= 1'b1;\n                                wb_ack_o <= 1'b1;\n                            end\n                        end\n                    end\n                endcase\n            end else begin\n                // Read operation\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= 32'h0; // Controller setting (not used)\n                    8'h20: wb_dat_o <= {16'h0, 16'h0200}; // Block size (fixed to 512)\n                    8'h24: wb_dat_o <= {24'h0, 8'h0f}; // Power control (fixed to 3.3V)\n                    8'h28: wb_dat_o <= {24'h0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h0; // Capability (not used)\n                    8'h4c: wb_dat_o <= {24'h0, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'h0;\n                endcase\n                wb_ack_o <= 1'b1;\n            end\n        end\n        \n        // Reset BD write signals after one clock cycle\n        if (we_m_rx_bd) we_m_rx_bd <= 1'b0;\n        if (we_m_tx_bd) we_m_tx_bd <= 1'b0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 18, "code": "module sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n    // State definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n    \n    // Response size definitions\n    localparam small_rsp = 7'b0101000;\n    localparam big_rsp = 7'b1111111;\n    \n    // Status bits\n    localparam dat_ava = 6;\n    localparam crc_valid = 5;\n    \n    // Internal signals\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg ack_q, ack_in_int;\n    reg req_q, req_in_int;\n    reg index_check_enable;\n    reg CRC_check_enable;\n    reg complete;\n    reg [6:0] response_size;\n    reg [15:0] Watchdog_Cnt;\n    reg CIE, CCRCE, CTE, EI, CC;\n    \n    // Debounce logic for card detection\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0;\n            end\n            \n            card_present <= (debounce == 4'b1111) ? 1'b1 : 1'b0;\n        end\n    end\n    \n    // Synchronizers for req_in and ack_in\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            ack_q <= 1'b0;\n            ack_in_int <= 1'b0;\n            req_q <= 1'b0;\n            req_in_int <= 1'b0;\n        end else begin\n            ack_q <= ack_in;\n            ack_in_int <= ack_q;\n            req_q <= req_in;\n            req_in_int <= req_q;\n        end\n    end\n    \n    // FSM state transition\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n    \n    // FSM next state logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = New_CMD ? SETUP : IDLE;\n            SETUP: next_state = ack_in_int ? EXECUTE : SETUP;\n            EXECUTE: next_state = complete ? IDLE : EXECUTE;\n            default: next_state = IDLE;\n        endcase\n    end\n    \n    // FSM output logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            // Reset all outputs\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            settings <= 16'b0;\n            cmd_out <= 40'b0;\n            req_out <= 1'b0;\n            ack_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            response_size <= 7'b0;\n            Watchdog_Cnt <= 16'b0;\n            CCRCE <= 1'b0;\n            EI <= 1'b0;\n            CC <= 1'b0;\n            go_idle_o <= 1'b0;\n            CIE <= 1'b0;\n            CTE <= 1'b0;\n        end else begin\n            // Update interrupt registers\n            if (ERR_INT_RST) ERR_INT_REG <= 5'b0;\n            if (NORMAL_INT_RST) NORMAL_INT_REG <= 16'b0;\n            \n            // Update card presence status\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            \n            // Reset complete flag\n            complete <= 1'b0;\n            \n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    STATUS_REG[0] <= 1'b0; // CICMD\n                    \n                    if (req_in_int) begin\n                        STATUS_REG[15:8] <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                \n                SETUP: begin\n                    // Clear interrupt registers\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    \n                    // Set check enables\n                    index_check_enable <= CMD_SET_REG[4]; // CICE\n                    CRC_check_enable <= CMD_SET_REG[3];   // CRCE\n                    \n                    // Compose command output\n                    cmd_out[39:38] <= 2'b01;\n                    cmd_out[37:32] <= CMD_SET_REG[13:8]; // CMDI\n                    cmd_out[31:0] <= ARG_REG;\n                    \n                    // Determine response size\n                    case (CMD_SET_REG[1:0]) // RTS\n                        2'b10, 2'b11: response_size <= small_rsp;\n                        2'b01: response_size <= big_rsp;\n                        default: response_size <= 7'b0;\n                    endcase\n                    \n                    // Configure settings\n                    settings[14:13] <= CMD_SET_REG[7:6]; // WORD_SELECT\n                    settings[12] <= data_read;\n                    settings[11] <= data_write;\n                    settings[10:8] <= 3'b111; // Delay\n                    settings[7] <= CMD_SET_REG[3]; // CRCE\n                    settings[6:0] <= response_size;\n                    \n                    // Reset watchdog counter\n                    Watchdog_Cnt <= 16'b0;\n                    \n                    // Set CICMD status\n                    STATUS_REG[0] <= 1'b1;\n                end\n                \n                EXECUTE: begin\n                    // Increment watchdog counter\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                    \n                    // Check for timeout\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        CTE <= 1'b1;\n                        EI <= 1'b1;\n                        if (ack_in) complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    \n                    // Handle request/acknowledge\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        STATUS_REG[15:8] <= serial_status;\n                        ack_out <= 1'b1;\n                        \n                        // Check for command completion\n                        if (STATUS_REG[dat_ava]) begin\n                            complete <= 1'b1;\n                            EI <= 1'b0;\n                            \n                            // Check CRC if enabled\n                            if (CRC_check_enable && !STATUS_REG[crc_valid]) begin\n                                CCRCE <= 1'b1;\n                                EI <= 1'b1;\n                            end\n                            \n                            // Check command index if enabled\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                CIE <= 1'b1;\n                                EI <= 1'b1;\n                            end\n                            \n                            CC <= 1'b1;\n                            \n                            // Store response if needed\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n            \n            // Update interrupt registers\n            ERR_INT_REG[3] <= CIE;\n            ERR_INT_REG[1] <= CCRCE;\n            ERR_INT_REG[0] <= CTE;\n            NORMAL_INT_REG[15] <= EI;\n            NORMAL_INT_REG[0] <= CC;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 7, "code": "module sd_controller_wb (\n    // Wishbone interface\n    input               wb_clk_i,\n    input               wb_rst_i,\n    input      [31:0]   wb_dat_i,\n    output reg [31:0]   wb_dat_o,\n    input      [7:0]    wb_adr_i,\n    input      [3:0]    wb_sel_i,\n    input               wb_we_i,\n    input               wb_cyc_i,\n    input               wb_stb_i,\n    output reg          wb_ack_o,\n    \n    // Control signals\n    output reg          we_m_tx_bd,\n    output reg          we_m_rx_bd,\n    output reg          new_cmd,\n    output reg          we_ack,\n    output reg          int_ack,\n    output reg          cmd_int_busy,\n    output reg          int_busy,\n    input               write_req_s,\n    input      [15:0]   cmd_set_s,\n    input      [32:0]   cmd_arg_s,\n    \n    // Registers\n    output reg [31:0]   argument_reg,\n    output reg [15:0]   cmd_setting_reg,\n    input      [15:0]   status_reg,\n    input      [31:0]   cmd_resp_1,\n    output reg [7:0]    software_reset_reg,\n    output reg [16:0]   time_out_reg,\n    input      [15:0]   normal_int_status_reg,\n    input      [15:0]   error_int_status_reg,\n    output reg [15:0]   normal_int_signal_enable_reg,\n    output reg [15:0]   error_int_signal_enable_reg,\n    output reg [7:0]    clock_divider,\n    input      [15:0]   Bd_Status_reg,\n    input      [8:0]    Bd_isr_reg,\n    output reg [8:0]    Bd_isr_enable_reg,\n    output reg          Bd_isr_reset,\n    output reg          normal_isr_reset,\n    output reg          error_isr_reset,\n    \n    // BD data\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\nparameter RAM_MEM_WIDTH = 32; // Default to 32-bit width\n\n// Internal signals\nreg [1:0] bd_write_state;\nreg [31:0] bd_temp_data;\n\n// Register read/write operations\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to default values\n        argument_reg <= 32'h0;\n        cmd_setting_reg <= 16'h0;\n        software_reset_reg <= 8'h0;\n        time_out_reg <= 16'h0;\n        normal_int_signal_enable_reg <= 16'h0;\n        error_int_signal_enable_reg <= 16'h0;\n        clock_divider <= 8'h0;\n        Bd_isr_enable_reg <= 8'h0;\n        \n        // Reset control signals\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        wb_ack_o <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        \n        // Reset BD write state\n        bd_write_state <= 2'b00;\n        bd_temp_data <= 32'h0;\n    end else begin\n        // Default values\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        wb_ack_o <= 1'b0;\n        \n        // Handle data master write requests\n        if (write_req_s) begin\n            argument_reg <= cmd_arg_s;\n            cmd_setting_reg <= cmd_set_s;\n            new_cmd <= 1'b1;\n            we_ack <= 1'b1;\n            cmd_int_busy <= 1'b1;\n        end else begin\n            cmd_int_busy <= 1'b0;\n        end\n        \n        // Wishbone access\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: begin // Argument register\n                        argument_reg <= wb_dat_i;\n                        int_busy <= 1'b1;\n                    end\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_isr_reset <= 1'b1;\n                    8'h34: error_isr_reset <= 1'b1;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1'b1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    \n                    // BD RX/TX handling\n                    8'h60: begin // BD RX\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                            we_m_rx_bd <= 1'b1;\n                            wb_ack_o <= 1'b1;\n                        end else begin // 16-bit\n                            if (bd_write_state == 2'b00) begin\n                                bd_temp_data[15:0] <= wb_dat_i[15:0];\n                                bd_write_state <= 2'b01;\n                                int_ack <= 1'b0;\n                            end else begin\n                                bd_temp_data[31:16] <= wb_dat_i[15:0];\n                                dat_in_m_rx_bd <= bd_temp_data;\n                                we_m_rx_bd <= 1'b1;\n                                bd_write_state <= 2'b00;\n                                int_ack <= 1'b1;\n                                wb_ack_o <= 1'b1;\n                            end\n                        end\n                    end\n                    \n                    8'h80: begin // BD TX\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                            we_m_tx_bd <= 1'b1;\n                            wb_ack_o <= 1'b1;\n                        end else begin // 16-bit\n                            if (bd_write_state == 2'b00) begin\n                                bd_temp_data[15:0] <= wb_dat_i[15:0];\n                                bd_write_state <= 2'b01;\n                                int_ack <= 1'b0;\n                            end else begin\n                                bd_temp_data[31:16] <= wb_dat_i[15:0];\n                                dat_in_m_tx_bd <= bd_temp_data;\n                                we_m_tx_bd <= 1'b1;\n                                bd_write_state <= 2'b00;\n                                int_ack <= 1'b1;\n                                wb_ack_o <= 1'b1;\n                            end\n                        end\n                    end\n                    \n                    default: wb_ack_o <= 1'b1;\n                endcase\n            end else begin\n                // Read operation\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= {16'h0, 16'h0}; // Controller Setting\n                    8'h20: wb_dat_o <= {16'h0, 16'h0200}; // Block Size (fixed 512)\n                    8'h24: wb_dat_o <= {24'h0, 8'h0f}; // Power Control (3.3V)\n                    8'h28: wb_dat_o <= {24'h0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= {16'h0, 16'h0}; // Capability\n                    8'h4c: wb_dat_o <= {24'h0, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'h0;\n                endcase\n                wb_ack_o <= 1'b1;\n            end\n        end\n        \n        // Clear busy flags when not accessing\n        if (!(wb_cyc_i && wb_stb_i && wb_adr_i == 8'h00 && wb_we_i)) begin\n            int_busy <= 1'b0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n// Parameters\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'hC1A;\nparameter ACMD13 = 16'hD1A;\nparameter ACMD51 = 16'h331A;\nparameter SIZE = 9;\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\n\n// Internal signals\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\n`ifdef RAM_MEM_WIDTH_32\n    reg [1:0] bd_cnt;\n    parameter READ_CYCLE = 2;\n    parameter BD_EMPTY = BD_SIZE / 2;\n`else\n    reg [2:0] bd_cnt;\n    parameter READ_CYCLE = 4;\n    parameter BD_EMPTY = BD_SIZE / 4;\n`endif\n\n// FSM sequential logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM combinational logic\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (free_tx_bd != BD_EMPTY) begin\n                next_state = GET_TX_BD;\n            end else if (free_rx_bd != BD_EMPTY) begin\n                next_state = GET_RX_BD;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        GET_TX_BD: begin\n            if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_TX_BD;\n            end\n        end\n        GET_RX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_RX_BD;\n            end\n        end\n        SEND_CMD: begin\n            if (send_done == 1) begin\n                next_state = RECIVE_CMD;\n            end else begin\n                next_state = SEND_CMD;\n            end\n        end\n        RECIVE_CMD: begin\n            if (rec_done == 1) begin\n                next_state = DATA_TRANSFER;\n            end else if (rec_failed == 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        DATA_TRANSFER: begin\n            if (trans_done == 1) begin\n                next_state = IDLE;\n            end else if (trans_failed == 1) begin\n                next_state = STOP;\n            end else begin\n                next_state = DATA_TRANSFER;\n            end\n        end\n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        STOP_SEND: begin\n            if (send_done == 1) begin\n                next_state = IDLE;\n            end else begin\n                next_state = STOP_SEND;\n            end\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// FSM output logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all outputs\n        re_s_tx <= 0;\n        a_cmp_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        sys_adr <= 0;\n        ack_transfer <= 0;\n        Dat_Int_Status <= 0;\n        CIDAT <= 0;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n    end else begin\n        // Default outputs\n        re_s_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_tx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        ack_transfer <= 0;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n\n        case (state)\n            IDLE: begin\n                // Reset counters and flags\n                bd_cnt <= 0;\n                resend_try_cnt <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n            end\n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                if (ack_i_s_tx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    `ifdef RAM_MEM_WIDTH_32\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_tx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                        end\n                    `else\n                        case (bd_cnt)\n                            0: sys_adr[15:0] <= dat_in_rx;\n                            1: sys_adr[31:16] <= dat_in_rx;\n                            2: cmd_arg[15:0] <= dat_in_rx;\n                            3: begin\n                                cmd_arg[31:16] <= dat_in_rx;\n                                start_tx_fifo <= 1;\n                            end\n                        endcase\n                    `endif\n                end\n                cmd_set <= CMD24;\n                tx_cycle <= 1;\n            end\n            GET_RX_BD: begin\n                re_s_rx <= 1;\n                if (ack_i_s_rx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    `ifdef RAM_MEM_WIDTH_32\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_rx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_rx;\n                        end\n                    `else\n                        case (bd_cnt)\n                            0: sys_adr[15:0] <= dat_in_rx;\n                            1: sys_adr[31:16] <= dat_in_rx;\n                            2: cmd_arg[15:0] <= dat_in_rx;\n                            3: cmd_arg[31:16] <= dat_in_rx;\n                        endcase\n                    `endif\n                end\n                case (transfer_type)\n                    2'b00: cmd_set <= CMD17;\n                    2'b01: cmd_set <= ACMD13;\n                    default: cmd_set <= ACMD51;\n                endcase\n                rx_cycle <= 1;\n            end\n            SEND_CMD: begin\n                if (tx_cycle) d_write <= 1;\n                if (rx_cycle) d_read <= 1;\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n            RECIVE_CMD: begin\n                if (rx_cycle) start_rx_fifo <= 1;\n                \n                if (!cmd_busy) begin\n                    if (cmd_tsf_err) begin\n                        rec_failed <= 1;\n                    end else if (card_status[0] == 1 || \n                               (card_status[4:1] == 4 || \n                                card_status[4:1] == 5 || \n                                card_status[4:1] == 6)) begin\n                        rec_done <= 1;\n                    end\n                end\n            end\n            DATA_TRANSFER: begin\n                if (tx_cycle && tx_empt) begin\n                    trans_failed <= 1;\n                    Dat_Int_Status[0] <= 1; // Underflow error\n                end\n                if (rx_cycle && rx_full) begin\n                    trans_failed <= 1;\n                    Dat_Int_Status[1] <= 1; // Overflow error\n                end\n                \n                if (transm_complete) begin\n                    ack_transfer <= 1;\n                    if (crc_ok) begin\n                        trans_done <= 1;\n                        if (tx_cycle) a_cmp_tx <= 1;\n                        if (rx_cycle) a_cmp_rx <= 1;\n                    end else begin\n                        trans_failed <= 1;\n                        Dat_Int_Status[2] <= 1; // CRC error\n                    end\n                end\n            end\n            STOP: begin\n                cmd_set <= CMD12;\n                d_read <= 1;\n                d_write <= 1;\n            end\n            STOP_SEND: begin\n                resend_try_cnt <= resend_try_cnt + 1;\n                if (resend_try_cnt == RESEND_MAX_CNT) begin\n                    Dat_Int_Status[1] <= 1; // Overflow error\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n        endcase\n\n        // Handle transmission complete signal\n        transm_complete_q <= transm_complete;\n        internal_transm_complete <= transm_complete && !transm_complete_q;\n\n        // Reset Dat_Int_Status if requested\n        if (Dat_Int_Status_rst) begin\n            Dat_Int_Status <= 0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 8, "code": "module sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    \n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\nparameter SD_BUS_W = 4;\nparameter BIT_BLOCK = 512;\nparameter CRC_OFF = 16;\nparameter BIT_BLOCK_REC = 512;\nparameter BIT_CRC_CYCLE = 16;\nparameter LITTLE_ENDIAN = 1;\nparameter BIG_ENDIAN = 0;\nparameter SD_BUS_WIDTH_1 = 1;\nparameter SD_BUS_WIDTH_4 = 4;\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out [0:SD_BUS_W-1];\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// State definitions\nlocalparam IDLE       = 6'b000001;\nlocalparam WRITE_DAT  = 6'b000010;\nlocalparam WRITE_CRC  = 6'b000100;\nlocalparam WRITE_BUSY = 6'b001000;\nlocalparam READ_WAIT  = 6'b010000;\nlocalparam READ_DAT   = 6'b100000;\n\n// CRC generation instances\ngenerate\n    genvar i;\n    for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n        sd_crc_16 crc_inst (\n            .BITVAL(crc_in[i]),\n            .Enable(crc_en),\n            .CLK(sd_clk),\n            .RST(crc_rst),\n            .CRC(crc_out[i])\n        );\n    end\nendgenerate\n\n// ACK_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        ack_transfer_int <= 0;\n        ack_q <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// FSM_COMBO block\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (start_dat[0]) next_state = WRITE_DAT;\n            else if (start_dat[1]) next_state = READ_WAIT;\n            else next_state = IDLE;\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == BIT_BLOCK) next_state = WRITE_CRC;\n            else next_state = WRITE_DAT;\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b001) next_state = WRITE_BUSY;\n            else next_state = WRITE_CRC;\n        end\n        WRITE_BUSY: begin\n            if (!busy_int) next_state = IDLE;\n            else next_state = WRITE_BUSY;\n        end\n        READ_WAIT: begin\n            if (!DAT_dat_i[0]) next_state = READ_DAT;\n            else next_state = READ_WAIT;\n        end\n        READ_DAT: begin\n            if (transf_cnt == BIT_BLOCK_REC) next_state = IDLE;\n            else next_state = READ_DAT;\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// START_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else begin\n        if (!DAT_dat_i[0] && (state == READ_WAIT))\n            q_start_bit <= 0;\n        else\n            q_start_bit <= 1;\n    end\nend\n\n// FSM_SEQ block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        write_buf_0 <= 0;\n        write_buf_1 <= 0;\n        DAT_oe_o <= 0;\n        crc_en <= 0;\n        crc_rst <= 1;\n        transf_cnt <= 0;\n        rd <= 0;\n        last_din <= 0;\n        crc_c <= 0;\n        crc_in <= 0;\n        DAT_dat_o <= 0;\n        crc_status <= 7;\n        crc_s <= 0;\n        transm_complete <= 0;\n        busy_n <= 1;\n        we <= 0;\n        data_out <= 0;\n        crc_ok <= 0;\n        busy_int <= 0;\n        data_send_index <= 0;\n        out_buff_ptr <= 0;\n        in_buff_ptr <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                crc_rst <= 1;\n                crc_en <= 0;\n                DAT_oe_o <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                transf_cnt <= 0;\n                crc_c <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n                \n                if (start_dat[0]) begin\n                    write_buf_0 <= data_in;\n                    rd <= 1;\n                end else if (start_dat[1]) begin\n                    write_buf_1 <= data_in;\n                    rd <= 1;\n                end else begin\n                    rd <= 0;\n                end\n            end\n            \n            WRITE_DAT: begin\n                crc_rst <= 0;\n                DAT_oe_o <= 1;\n                \n                if (transf_cnt == 0) begin\n                    DAT_dat_o <= 0; // Start bit\n                    crc_en <= 0;\n                end else begin\n                    crc_en <= 1;\n                    \n                    if (out_buff_ptr == 0)\n                        sd_data_out <= write_buf_0;\n                    else\n                        sd_data_out <= write_buf_1;\n                    \n                    last_din <= sd_data_out[data_send_index*4 +: 4];\n                    crc_in <= last_din;\n                    DAT_dat_o <= last_din;\n                    \n                    if (data_send_index == 7) begin\n                        data_send_index <= 0;\n                        out_buff_ptr <= ~out_buff_ptr;\n                        if (in_buff_ptr == out_buff_ptr) begin\n                            rd <= 1;\n                            if (in_buff_ptr == 0)\n                                write_buf_0 <= data_in;\n                            else\n                                write_buf_1 <= data_in;\n                            in_buff_ptr <= ~in_buff_ptr;\n                        end\n                    end else begin\n                        data_send_index <= data_send_index + 1;\n                    end\n                end\n                \n                transf_cnt <= transf_cnt + 1;\n            end\n            \n            WRITE_CRC: begin\n                if (transf_cnt < BIT_BLOCK + BIT_CRC_CYCLE) begin\n                    if (transf_cnt >= BIT_BLOCK && transf_cnt < BIT_BLOCK + 16) begin\n                        DAT_dat_o <= crc_out[0][transf_cnt - BIT_BLOCK];\n                    end\n                    transf_cnt <= transf_cnt + 1;\n                end else begin\n                    DAT_dat_o <= 1; // Stop bit\n                    crc_status <= 3'b001;\n                end\n            end\n            \n            WRITE_BUSY: begin\n                transm_complete <= 1;\n                busy_int <= DAT_dat_i[0];\n                busy_n <= ~DAT_dat_i[0];\n                \n                if (ack_transfer_int) begin\n                    crc_ok <= (crc_s == 3'b010);\n                    transm_complete <= 0;\n                end\n            end\n            \n            READ_WAIT: begin\n                DAT_oe_o <= 0;\n                crc_rst <= 0;\n                crc_en <= 1;\n                transf_cnt <= 0;\n            end\n            \n            READ_DAT: begin\n                if (transf_cnt < BIT_BLOCK_REC) begin\n                    data_out <= DAT_dat_i;\n                    crc_in <= DAT_dat_i;\n                    we <= 1;\n                end else begin\n                    we <= 0;\n                    if (transf_cnt >= BIT_BLOCK_REC + CRC_OFF) begin\n                        crc_ok <= (crc_out[0] == {DAT_dat_i, last_din});\n                        transm_complete <= 1;\n                    end\n                end\n                \n                transf_cnt <= transf_cnt + 1;\n                last_din <= DAT_dat_i;\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'h0000;\n    end else if (Enable) begin\n        CRC[0] <= CRC[15] ^ BITVAL;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2];\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4] ^ (CRC[15] ^ BITVAL);\n        CRC[6] <= CRC[5];\n        CRC[7] <= CRC[6];\n        CRC[8] <= CRC[7];\n        CRC[9] <= CRC[8];\n        CRC[10] <= CRC[9];\n        CRC[11] <= CRC[10];\n        CRC[12] <= CRC[11] ^ (CRC[15] ^ BITVAL);\n        CRC[13] <= CRC[12];\n        CRC[14] <= CRC[13];\n        CRC[15] <= CRC[14];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 8, "code": "module sd_controller_wb (\n    // Wishbone interface\n    input               wb_clk_i,\n    input               wb_rst_i,\n    input      [31:0]   wb_dat_i,\n    output reg [31:0]   wb_dat_o,\n    input      [7:0]    wb_adr_i,\n    input      [3:0]    wb_sel_i,\n    input               wb_we_i,\n    input               wb_cyc_i,\n    input               wb_stb_i,\n    output reg          wb_ack_o,\n    \n    // Control signals\n    output reg          we_m_tx_bd,\n    output reg          we_m_rx_bd,\n    output reg          new_cmd,\n    output reg          we_ack,\n    output reg          int_ack,\n    output reg          cmd_int_busy,\n    output reg          int_busy,\n    \n    // Data master interface\n    input               write_req_s,\n    input      [15:0]   cmd_set_s,\n    input      [32:0]   cmd_arg_s,\n    \n    // Registers\n    output reg [31:0]   argument_reg,\n    output reg [15:0]   cmd_setting_reg,\n    input      [15:0]   status_reg,\n    input      [31:0]   cmd_resp_1,\n    output reg [7:0]    software_reset_reg,\n    output reg [16:0]   time_out_reg,\n    input      [15:0]   normal_int_status_reg,\n    input      [15:0]   error_int_status_reg,\n    output reg [15:0]   normal_int_signal_enable_reg,\n    output reg [15:0]   error_int_signal_enable_reg,\n    output reg [7:0]    clock_divider,\n    input      [15:0]   Bd_Status_reg,\n    input      [8:0]    Bd_isr_reg,\n    output reg [8:0]    Bd_isr_enable_reg,\n    \n    // Interrupt reset signals\n    output reg          Bd_isr_reset,\n    output reg          normal_isr_reset,\n    output reg          error_isr_reset,\n    \n    // BD data\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\nparameter RAM_MEM_WIDTH = 32; // Default to 32-bit width\n\n// Internal signals\nreg [1:0] bd_write_state;\nreg [31:0] bd_write_data;\n\n// Reset and initialization\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to default values\n        argument_reg <= 32'h0;\n        cmd_setting_reg <= 16'h0;\n        software_reset_reg <= 8'h0;\n        time_out_reg <= 16'h0;\n        normal_int_signal_enable_reg <= 16'h0;\n        error_int_signal_enable_reg <= 16'h0;\n        clock_divider <= 8'h0;\n        Bd_isr_enable_reg <= 8'h0;\n        \n        // Reset control signals\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        wb_ack_o <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        bd_write_state <= 2'b0;\n    end else begin\n        // Default values for single-cycle signals\n        wb_ack_o <= 1'b0;\n        new_cmd <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        \n        // Handle data master interface\n        if (write_req_s) begin\n            argument_reg <= cmd_arg_s;\n            cmd_setting_reg <= cmd_set_s;\n            new_cmd <= 1'b1;\n            we_ack <= 1'b1;\n            cmd_int_busy <= 1'b1;\n        end else begin\n            we_ack <= 1'b0;\n            cmd_int_busy <= 1'b0;\n        end\n        \n        // Wishbone interface\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: begin // Argument register\n                        argument_reg <= wb_dat_i;\n                        int_busy <= 1'b1;\n                    end\n                    8'h04: begin // Command setting register\n                        cmd_setting_reg <= wb_dat_i[15:0];\n                    end\n                    8'h28: begin // Software reset\n                        software_reset_reg <= wb_dat_i[7:0];\n                    end\n                    8'h2c: begin // Timeout register\n                        time_out_reg <= wb_dat_i[15:0];\n                    end\n                    8'h30: begin // Normal interrupt status\n                        normal_isr_reset <= 1'b1;\n                    end\n                    8'h34: begin // Error interrupt status\n                        error_isr_reset <= 1'b1;\n                    end\n                    8'h38: begin // Normal interrupt enable\n                        normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    end\n                    8'h3c: begin // Error interrupt enable\n                        error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    end\n                    8'h4c: begin // Clock divider\n                        clock_divider <= wb_dat_i[7:0];\n                    end\n                    8'h54: begin // Data interrupt status\n                        Bd_isr_reset <= 1'b1;\n                    end\n                    8'h58: begin // Data interrupt enable\n                        Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    end\n                    8'h60: begin // BD RX\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                            we_m_rx_bd <= 1'b1;\n                            wb_ack_o <= 1'b1;\n                        end else begin // 16-bit\n                            if (bd_write_state == 2'b00) begin\n                                bd_write_data[15:0] <= wb_dat_i[15:0];\n                                bd_write_state <= 2'b01;\n                                int_ack <= 1'b0;\n                            end else begin\n                                dat_in_m_rx_bd <= {wb_dat_i[15:0], bd_write_data[15:0]};\n                                we_m_rx_bd <= 1'b1;\n                                bd_write_state <= 2'b00;\n                                int_ack <= 1'b1;\n                                wb_ack_o <= 1'b1;\n                            end\n                        end\n                    end\n                    8'h80: begin // BD TX\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                            we_m_tx_bd <= 1'b1;\n                            wb_ack_o <= 1'b1;\n                        end else begin // 16-bit\n                            if (bd_write_state == 2'b00) begin\n                                bd_write_data[15:0] <= wb_dat_i[15:0];\n                                bd_write_state <= 2'b01;\n                                int_ack <= 1'b0;\n                            end else begin\n                                dat_in_m_tx_bd <= {wb_dat_i[15:0], bd_write_data[15:0]};\n                                we_m_tx_bd <= 1'b1;\n                                bd_write_state <= 2'b00;\n                                int_ack <= 1'b1;\n                                wb_ack_o <= 1'b1;\n                            end\n                        end\n                    end\n                    default: wb_ack_o <= 1'b1;\n                endcase\n            end else begin\n                // Read operation\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= {16'h0, 16'h0}; // Controller setting\n                    8'h20: wb_dat_o <= {16'h0, 16'h0200}; // Block size (fixed 512)\n                    8'h24: wb_dat_o <= {24'h0, 8'h0f}; // Power control (3.3V)\n                    8'h28: wb_dat_o <= {24'h0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= {16'h0, 16'h0}; // Capability\n                    8'h4c: wb_dat_o <= {24'h0, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'h0;\n                endcase\n                wb_ack_o <= 1'b1;\n            end\n        end\n        \n        // Reset write enables after one cycle\n        if (we_m_tx_bd) we_m_tx_bd <= 1'b0;\n        if (we_m_rx_bd) we_m_rx_bd <= 1'b0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 9, "code": "module sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    \n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n// Parameters from sd_defines.v\nparameter SD_BUS_W = 4;\nparameter BIT_BLOCK = 512;\nparameter CRC_OFF = 16;\nparameter BIT_BLOCK_REC = 512;\nparameter BIT_CRC_CYCLE = 16;\nparameter LITTLE_ENDIAN = 1;\nparameter BIG_ENDIAN = 0;\nparameter SD_BUS_WIDTH_1 = 1;\nparameter SD_BUS_WIDTH_4 = 4;\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out [0:SD_BUS_W-1];\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// State definitions\nlocalparam IDLE      = 6'b000001;\nlocalparam WRITE_DAT = 6'b000010;\nlocalparam WRITE_CRC = 6'b000100;\nlocalparam WRITE_BUSY = 6'b001000;\nlocalparam READ_WAIT = 6'b010000;\nlocalparam READ_DAT  = 6'b100000;\n\n// CRC generation modules\ngenvar i;\ngenerate\n    for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n        sd_crc_16 crc_inst (\n            .BITVAL(crc_in[i]),\n            .Enable(crc_en),\n            .CLK(sd_clk),\n            .RST(crc_rst),\n            .CRC(crc_out[i])\n        );\n    end\nendgenerate\n\n// ACK_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        ack_transfer_int <= 0;\n        ack_q <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// FSM_COMBO block\nalways @(*) begin\n    next_state = state;\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b10) next_state = WRITE_DAT;\n            else if (start_dat == 2'b01) next_state = READ_WAIT;\n            else next_state = IDLE;\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == BIT_BLOCK) next_state = WRITE_CRC;\n            else next_state = WRITE_DAT;\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b111) next_state = WRITE_BUSY;\n            else next_state = WRITE_CRC;\n        end\n        WRITE_BUSY: begin\n            if (!busy_int) next_state = IDLE;\n            else next_state = WRITE_BUSY;\n        end\n        READ_WAIT: begin\n            if (!DAT_dat_i[0]) next_state = READ_DAT;\n            else next_state = READ_WAIT;\n        end\n        READ_DAT: begin\n            if (transf_cnt == BIT_BLOCK_REC) next_state = IDLE;\n            else next_state = READ_DAT;\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// START_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else begin\n        if (!DAT_dat_i[0] && state == READ_WAIT)\n            q_start_bit <= 0;\n        else\n            q_start_bit <= 1;\n    end\nend\n\n// FSM_SEQ block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        write_buf_0 <= 0;\n        write_buf_1 <= 0;\n        DAT_oe_o <= 0;\n        crc_en <= 0;\n        crc_rst <= 1;\n        transf_cnt <= 0;\n        rd <= 0;\n        last_din <= 0;\n        crc_c <= 0;\n        crc_in <= 0;\n        DAT_dat_o <= 0;\n        crc_status <= 7;\n        crc_s <= 0;\n        transm_complete <= 0;\n        busy_n <= 1;\n        we <= 0;\n        data_out <= 0;\n        crc_ok <= 0;\n        busy_int <= 0;\n        data_send_index <= 0;\n        out_buff_ptr <= 0;\n        in_buff_ptr <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                crc_rst <= 1;\n                crc_en <= 0;\n                DAT_oe_o <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                transf_cnt <= 0;\n                crc_c <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n                \n                if (start_dat == 2'b10) begin\n                    write_buf_0 <= data_in;\n                    rd <= 1;\n                end\n            end\n            \n            WRITE_DAT: begin\n                crc_rst <= 0;\n                DAT_oe_o <= 1;\n                \n                if (transf_cnt == 0) begin\n                    DAT_dat_o <= 0; // Start bit\n                    crc_en <= 0;\n                end else if (transf_cnt <= BIT_BLOCK) begin\n                    crc_en <= 1;\n                    \n                    if (transf_cnt[1:0] == 2'b00) begin\n                        if (out_buff_ptr == 0) begin\n                            last_din <= write_buf_0[31:28];\n                            write_buf_0 <= {write_buf_0[27:0], 4'b0};\n                        end else begin\n                            last_din <= write_buf_1[31:28];\n                            write_buf_1 <= {write_buf_1[27:0], 4'b0};\n                        end\n                        \n                        if (transf_cnt[4:0] == 28) begin\n                            out_buff_ptr <= ~out_buff_ptr;\n                            if (out_buff_ptr == 0)\n                                write_buf_1 <= data_in;\n                            else\n                                write_buf_0 <= data_in;\n                            rd <= 1;\n                        end else begin\n                            rd <= 0;\n                        end\n                    end\n                    \n                    crc_in <= last_din;\n                    DAT_dat_o <= last_din;\n                end\n                \n                transf_cnt <= transf_cnt + 1;\n            end\n            \n            WRITE_CRC: begin\n                if (transf_cnt < BIT_BLOCK + BIT_CRC_CYCLE) begin\n                    if (transf_cnt >= BIT_BLOCK && transf_cnt < BIT_BLOCK + 16) begin\n                        DAT_dat_o <= {\n                            crc_out[3][(BIT_BLOCK + 15 - transf_cnt)],\n                            crc_out[2][(BIT_BLOCK + 15 - transf_cnt)],\n                            crc_out[1][(BIT_BLOCK + 15 - transf_cnt)],\n                            crc_out[0][(BIT_BLOCK + 15 - transf_cnt)]\n                        };\n                    end else if (transf_cnt == BIT_BLOCK + 16) begin\n                        DAT_dat_o <= 4'b1111; // Stop bit\n                    end\n                    \n                    transf_cnt <= transf_cnt + 1;\n                end else begin\n                    crc_status <= 3'b111;\n                end\n            end\n            \n            WRITE_BUSY: begin\n                DAT_oe_o <= 0;\n                transm_complete <= 1;\n                busy_int <= DAT_dat_i[0];\n                busy_n <= ~DAT_dat_i[0];\n                \n                if (crc_s == 3'b010) // CRC OK\n                    crc_ok <= 1;\n                else\n                    crc_ok <= 0;\n            end\n            \n            READ_WAIT: begin\n                crc_rst <= 0;\n                crc_en <= 1;\n                DAT_oe_o <= 0;\n                transf_cnt <= 0;\n                we <= 0;\n            end\n            \n            READ_DAT: begin\n                if (transf_cnt < BIT_BLOCK_REC) begin\n                    crc_in <= DAT_dat_i;\n                    data_out <= DAT_dat_i;\n                    we <= 1;\n                end else begin\n                    we <= 0;\n                    // Check CRC\n                    if (SD_BUS_W == 4) begin\n                        crc_ok <= (DAT_dat_i == {\n                            crc_out[3][(transf_cnt - BIT_BLOCK_REC)],\n                            crc_out[2][(transf_cnt - BIT_BLOCK_REC)],\n                            crc_out[1][(transf_cnt - BIT_BLOCK_REC)],\n                            crc_out[0][(transf_cnt - BIT_BLOCK_REC)]\n                        });\n                    end else begin\n                        crc_ok <= (DAT_dat_i[0] == crc_out[0][(transf_cnt - BIT_BLOCK_REC)]);\n                    end\n                    \n                    if (transf_cnt == BIT_BLOCK_REC + BIT_CRC_CYCLE - 1) begin\n                        transm_complete <= 1;\n                        busy_n <= 0;\n                    end\n                end\n                \n                transf_cnt <= transf_cnt + 1;\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'b0;\n    end else if (Enable) begin\n        CRC[0] <= CRC[15] ^ BITVAL;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2];\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4] ^ CRC[15] ^ BITVAL;\n        CRC[6] <= CRC[5];\n        CRC[7] <= CRC[6];\n        CRC[8] <= CRC[7];\n        CRC[9] <= CRC[8];\n        CRC[10] <= CRC[9];\n        CRC[11] <= CRC[10];\n        CRC[12] <= CRC[11] ^ CRC[15] ^ BITVAL;\n        CRC[13] <= CRC[12];\n        CRC[14] <= CRC[13];\n        CRC[15] <= CRC[14];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    \n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out [0:SD_BUS_W-1];\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// State definitions\nlocalparam IDLE       = 6'b000001;\nlocalparam WRITE_DAT  = 6'b000010;\nlocalparam WRITE_CRC  = 6'b000100;\nlocalparam WRITE_BUSY = 6'b001000;\nlocalparam READ_WAIT  = 6'b010000;\nlocalparam READ_DAT   = 6'b100000;\n\n// CRC status definitions\nlocalparam CRC_IDLE = 3'b000;\nlocalparam CRC_CALC = 3'b001;\nlocalparam CRC_OK   = 3'b010;\nlocalparam CRC_ERR  = 3'b100;\n\n// Generate CRC modules\ngenerate\ngenvar i;\nfor (i = 0; i < SD_BUS_W; i = i + 1) begin : CRC_GEN\n    sd_crc_16 crc_inst (\n        .BITVAL(crc_in[i]),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out[i])\n    );\nend\nendgenerate\n\n// ACK_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        ack_transfer_int <= 1'b0;\n        ack_q <= 1'b0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// FSM_COMBO block\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b10) next_state = WRITE_DAT;\n            else if (start_dat == 2'b01) next_state = READ_WAIT;\n            else next_state = IDLE;\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == SD_BUS_W) next_state = WRITE_CRC;\n            else next_state = WRITE_DAT;\n        end\n        WRITE_CRC: begin\n            if (crc_status == CRC_OK) next_state = WRITE_BUSY;\n            else next_state = WRITE_CRC;\n        end\n        WRITE_BUSY: begin\n            if (!busy_int) next_state = IDLE;\n            else next_state = WRITE_BUSY;\n        end\n        READ_WAIT: begin\n            if (!DAT_dat_i[0] && state == READ_WAIT) next_state = READ_DAT;\n            else next_state = READ_WAIT;\n        end\n        READ_DAT: begin\n            if (transf_cnt == SD_BUS_W) next_state = IDLE;\n            else next_state = READ_DAT;\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// START_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        q_start_bit <= 1'b1;\n    end else begin\n        if (!DAT_dat_i[0] && state == READ_WAIT)\n            q_start_bit <= 1'b0;\n        else\n            q_start_bit <= 1'b1;\n    end\nend\n\n// FSM_SEQ block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        write_buf_0 <= 32'b0;\n        write_buf_1 <= 32'b0;\n        DAT_oe_o <= 1'b0;\n        crc_en <= 1'b0;\n        crc_rst <= 1'b1;\n        transf_cnt <= 11'b0;\n        rd <= 1'b0;\n        last_din <= 4'b0;\n        crc_c <= 5'b0;\n        crc_in <= {SD_BUS_W{1'b0}};\n        DAT_dat_o <= {SD_BUS_W{1'b0}};\n        crc_status <= 3'b111;\n        crc_s <= 3'b0;\n        transm_complete <= 1'b0;\n        busy_n <= 1'b1;\n        we <= 1'b0;\n        data_out <= {SD_BUS_W{1'b0}};\n        crc_ok <= 1'b0;\n        busy_int <= 1'b0;\n        data_send_index <= 3'b0;\n        out_buff_ptr <= 1'b0;\n        in_buff_ptr <= 1'b0;\n        sd_data_out <= 32'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                crc_rst <= 1'b1;\n                crc_en <= 1'b0;\n                DAT_oe_o <= 1'b0;\n                transm_complete <= 1'b0;\n                busy_n <= 1'b1;\n                transf_cnt <= 11'b0;\n                crc_status <= CRC_IDLE;\n                crc_ok <= 1'b0;\n                busy_int <= 1'b0;\n                \n                if (start_dat == 2'b10) begin\n                    // Prepare for write\n                    write_buf_0 <= data_in;\n                    rd <= 1'b1;\n                end\n            end\n            \n            WRITE_DAT: begin\n                crc_rst <= 1'b0;\n                DAT_oe_o <= 1'b1;\n                \n                if (transf_cnt == 0) begin\n                    // Start bit\n                    DAT_dat_o <= {SD_BUS_W{1'b0}};\n                    transf_cnt <= transf_cnt + 1;\n                end else if (transf_cnt < SD_BUS_W) begin\n                    // Data bits\n                    last_din <= sd_data_out[3:0];\n                    crc_in <= sd_data_out[3:0];\n                    DAT_dat_o <= sd_data_out[3:0];\n                    sd_data_out <= {4'b0, sd_data_out[31:4]};\n                    transf_cnt <= transf_cnt + 1;\n                    crc_en <= 1'b1;\n                    \n                    if (transf_cnt[1:0] == 2'b11) begin\n                        // Every 4 bits, switch buffers\n                        if (out_buff_ptr) begin\n                            sd_data_out <= write_buf_1;\n                            if (in_buff_ptr) rd <= 1'b1;\n                        end else begin\n                            sd_data_out <= write_buf_0;\n                            if (!in_buff_ptr) rd <= 1'b1;\n                        end\n                        out_buff_ptr <= ~out_buff_ptr;\n                    end\n                end else begin\n                    // End of data, prepare for CRC\n                    crc_en <= 1'b0;\n                    crc_status <= CRC_CALC;\n                end\n            end\n            \n            WRITE_CRC: begin\n                if (crc_c < 16) begin\n                    // Send CRC bits\n                    DAT_dat_o <= {SD_BUS_W{crc_out[0][crc_c]}};\n                    crc_c <= crc_c + 1;\n                end else begin\n                    // End of CRC, check response\n                    crc_status <= CRC_OK;\n                    busy_int <= 1'b1;\n                end\n            end\n            \n            WRITE_BUSY: begin\n                transm_complete <= 1'b1;\n                busy_int <= DAT_dat_i[0];\n                busy_n <= ~DAT_dat_i[0];\n                \n                if (!DAT_dat_i[0]) begin\n                    // Card not busy anymore\n                    crc_ok <= (crc_s == 3'b010);\n                end\n            end\n            \n            READ_WAIT: begin\n                crc_rst <= 1'b0;\n                crc_en <= 1'b1;\n                DAT_oe_o <= 1'b0;\n                we <= 1'b0;\n                transf_cnt <= 11'b0;\n            end\n            \n            READ_DAT: begin\n                if (transf_cnt < SD_BUS_W) begin\n                    // Read data bits\n                    crc_in <= DAT_dat_i;\n                    data_out <= DAT_dat_i;\n                    we <= 1'b1;\n                    transf_cnt <= transf_cnt + 1;\n                end else begin\n                    // End of data, check CRC\n                    we <= 1'b0;\n                    crc_en <= 1'b0;\n                    transm_complete <= 1'b1;\n                    busy_n <= 1'b0;\n                    \n                    // Simple CRC check (actual implementation would compare with crc_out)\n                    crc_ok <= 1'b1;\n                end\n            end\n            \n            default: begin\n                // Default case\n                state <= IDLE;\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 9, "code": "module sd_controller_wb (\n    // Wishbone interface\n    input               wb_clk_i,\n    input               wb_rst_i,\n    input      [31:0]   wb_dat_i,\n    output reg [31:0]   wb_dat_o,\n    input      [7:0]    wb_adr_i,\n    input      [3:0]    wb_sel_i,\n    input               wb_we_i,\n    input               wb_cyc_i,\n    input               wb_stb_i,\n    output reg          wb_ack_o,\n    \n    // Control signals\n    output reg          we_m_tx_bd,\n    output reg          we_m_rx_bd,\n    output reg          new_cmd,\n    output reg          we_ack,\n    output reg          int_ack,\n    output reg          cmd_int_busy,\n    output reg          int_busy,\n    \n    // Data master interface\n    input               write_req_s,\n    input      [15:0]   cmd_set_s,\n    input      [32:0]   cmd_arg_s,\n    \n    // Registers\n    output reg [31:0]   argument_reg,\n    output reg [15:0]   cmd_setting_reg,\n    input      [15:0]   status_reg,\n    input      [31:0]   cmd_resp_1,\n    output reg [7:0]    software_reset_reg,\n    output reg [16:0]   time_out_reg,\n    input      [15:0]   normal_int_status_reg,\n    input      [15:0]   error_int_status_reg,\n    output reg [15:0]   normal_int_signal_enable_reg,\n    output reg [15:0]   error_int_signal_enable_reg,\n    output reg [7:0]    clock_divider,\n    input      [15:0]   Bd_Status_reg,\n    input      [8:0]    Bd_isr_reg,\n    output reg [8:0]    Bd_isr_enable_reg,\n    \n    // Interrupt reset signals\n    output reg          Bd_isr_reset,\n    output reg          normal_isr_reset,\n    output reg          error_isr_reset,\n    \n    // BD data\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\nparameter RAM_MEM_WIDTH = 32; // Default to 32-bit width\n\n// Internal signals\nreg [1:0] bd_write_state;\nreg [31:0] bd_temp_data;\n\n// Register read/write logic\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to default values\n        argument_reg <= 32'h0;\n        cmd_setting_reg <= 16'h0;\n        software_reset_reg <= 8'h0;\n        time_out_reg <= 16'h0;\n        normal_int_signal_enable_reg <= 16'h0;\n        error_int_signal_enable_reg <= 16'h0;\n        clock_divider <= 8'h0;\n        Bd_isr_enable_reg <= 8'h0;\n        \n        // Reset control signals\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        wb_ack_o <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        bd_write_state <= 2'b0;\n        bd_temp_data <= 32'b0;\n    end\n    else begin\n        // Default values\n        wb_ack_o <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        \n        // Handle data master interface\n        if (write_req_s) begin\n            argument_reg <= cmd_arg_s;\n            cmd_setting_reg <= cmd_set_s;\n            new_cmd <= 1'b1;\n            we_ack <= 1'b1;\n            cmd_int_busy <= 1'b1;\n        end else begin\n            cmd_int_busy <= 1'b0;\n        end\n        \n        // Wishbone access\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: begin\n                        argument_reg <= wb_dat_i;\n                        int_busy <= 1'b1;\n                    end\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_isr_reset <= 1'b1;\n                    8'h34: error_isr_reset <= 1'b1;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1'b1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    \n                    // BD RX/TX handling\n                    8'h60, 8'h80: begin\n                        if (bd_write_state == 2'b00) begin\n                            if (RAM_MEM_WIDTH == 32) begin\n                                if (wb_adr_i == 8'h60) begin\n                                    dat_in_m_rx_bd <= wb_dat_i;\n                                    we_m_rx_bd <= 1'b1;\n                                end else begin\n                                    dat_in_m_tx_bd <= wb_dat_i;\n                                    we_m_tx_bd <= 1'b1;\n                                end\n                                bd_write_state <= 2'b01;\n                            end else begin\n                                // 16-bit mode - store lower 16 bits\n                                bd_temp_data[15:0] <= wb_dat_i[15:0];\n                                bd_write_state <= 2'b10;\n                            end\n                            int_ack <= 1'b0;\n                        end\n                        else if (bd_write_state == 2'b10) begin\n                            // 16-bit mode - store upper 16 bits\n                            bd_temp_data[31:16] <= wb_dat_i[15:0];\n                            bd_write_state <= 2'b11;\n                        end\n                        else if (bd_write_state == 2'b11) begin\n                            // 16-bit mode - complete write\n                            if (wb_adr_i == 8'h60) begin\n                                dat_in_m_rx_bd <= bd_temp_data[RAM_MEM_WIDTH-1:0];\n                                we_m_rx_bd <= 1'b1;\n                            end else begin\n                                dat_in_m_tx_bd <= bd_temp_data[RAM_MEM_WIDTH-1:0];\n                                we_m_tx_bd <= 1'b1;\n                            end\n                            bd_write_state <= 2'b01;\n                        end\n                    end\n                endcase\n            end\n            \n            // Read operation (or write completion)\n            if ((!wb_we_i || (wb_adr_i == 8'h60 || wb_adr_i == 8'h80) && bd_write_state == 2'b01) && int_ack) begin\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'b0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'b0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= 32'b0; // Controller Setting\n                    8'h20: wb_dat_o <= {16'b0, 16'h0200}; // Block Size (fixed to 512)\n                    8'h24: wb_dat_o <= {24'b0, 8'h0f}; // Power Control (fixed to 3.3V)\n                    8'h28: wb_dat_o <= {24'b0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'b0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'b0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'b0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'b0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'b0, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'b0; // Capability\n                    8'h4c: wb_dat_o <= {24'b0, clock_divider};\n                    8'h50: wb_dat_o <= {16'b0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'b0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'b0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'b0;\n                endcase\n                wb_ack_o <= 1'b1;\n                \n                // Reset BD write state if needed\n                if (wb_adr_i == 8'h60 || wb_adr_i == 8'h80) begin\n                    if (wb_adr_i == 8'h60) we_m_rx_bd <= 1'b0;\n                    else we_m_tx_bd <= 1'b0;\n                    bd_write_state <= 2'b00;\n                    int_ack <= 1'b1;\n                end\n            end\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 10, "code": "module sd_controller_wb (\n    // Wishbone interface\n    input               wb_clk_i,\n    input               wb_rst_i,\n    input      [31:0]   wb_dat_i,\n    output reg [31:0]   wb_dat_o,\n    input      [7:0]    wb_adr_i,\n    input      [3:0]    wb_sel_i,\n    input               wb_we_i,\n    input               wb_cyc_i,\n    input               wb_stb_i,\n    output reg          wb_ack_o,\n    \n    // Control signals\n    output reg          we_m_tx_bd,\n    output reg          we_m_rx_bd,\n    output reg          new_cmd,\n    output reg          we_ack,\n    output reg          int_ack,\n    output reg          cmd_int_busy,\n    output reg          int_busy,\n    \n    // Data master interface\n    input               write_req_s,\n    input      [15:0]   cmd_set_s,\n    input      [32:0]   cmd_arg_s,\n    \n    // Registers\n    output reg [31:0]   argument_reg,\n    output reg [15:0]   cmd_setting_reg,\n    input      [15:0]   status_reg,\n    input      [31:0]   cmd_resp_1,\n    output reg [7:0]    software_reset_reg,\n    output reg [16:0]   time_out_reg,\n    input      [15:0]   normal_int_status_reg,\n    input      [15:0]   error_int_status_reg,\n    output reg [15:0]   normal_int_signal_enable_reg,\n    output reg [15:0]   error_int_signal_enable_reg,\n    output reg [7:0]    clock_divider,\n    input      [15:0]   Bd_Status_reg,\n    input      [8:0]    Bd_isr_reg,\n    output reg [8:0]    Bd_isr_enable_reg,\n    \n    // Interrupt reset signals\n    output reg          Bd_isr_reset,\n    output reg          normal_isr_reset,\n    output reg          error_isr_reset,\n    \n    // BD data\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\nparameter RAM_MEM_WIDTH = 32; // Default to 32-bit width\n\n// Internal signals\nreg [1:0] bd_write_state;\nreg [31:0] bd_data_temp;\n\n// Reset and initialization\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to default values\n        argument_reg <= 32'h0;\n        cmd_setting_reg <= 16'h0;\n        software_reset_reg <= 8'h0;\n        time_out_reg <= 16'h0;\n        normal_int_signal_enable_reg <= 16'h0;\n        error_int_signal_enable_reg <= 16'h0;\n        clock_divider <= 8'h0;\n        Bd_isr_enable_reg <= 8'h0;\n        \n        // Reset control signals\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        wb_ack_o <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        bd_write_state <= 2'b00;\n        bd_data_temp <= 32'h0;\n    end else begin\n        // Default values\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        wb_ack_o <= 1'b0;\n        \n        // Handle data master interface\n        if (write_req_s) begin\n            argument_reg <= cmd_arg_s;\n            cmd_setting_reg <= cmd_set_s;\n            new_cmd <= 1'b1;\n            we_ack <= 1'b1;\n            cmd_int_busy <= 1'b1;\n        end else begin\n            cmd_int_busy <= 1'b0;\n        end\n        \n        // Handle Wishbone interface\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: begin // Argument register\n                        argument_reg <= wb_dat_i;\n                        int_busy <= 1'b1;\n                    end\n                    8'h04: begin // Command setting register\n                        cmd_setting_reg <= wb_dat_i[15:0];\n                    end\n                    8'h28: begin // Software reset register\n                        software_reset_reg <= wb_dat_i[7:0];\n                    end\n                    8'h2c: begin // Timeout register\n                        time_out_reg <= wb_dat_i[15:0];\n                    end\n                    8'h30: begin // Normal interrupt status register\n                        normal_isr_reset <= 1'b1;\n                    end\n                    8'h34: begin // Error interrupt status register\n                        error_isr_reset <= 1'b1;\n                    end\n                    8'h38: begin // Normal interrupt enable register\n                        normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    end\n                    8'h3c: begin // Error interrupt enable register\n                        error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    end\n                    8'h4c: begin // Clock divider register\n                        clock_divider <= wb_dat_i[7:0];\n                    end\n                    8'h54: begin // Data interrupt status register\n                        Bd_isr_reset <= 1'b1;\n                    end\n                    8'h58: begin // Data interrupt enable register\n                        Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    end\n                    8'h60: begin // BD RX register\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                            we_m_rx_bd <= 1'b1;\n                            int_ack <= 1'b0;\n                            bd_write_state <= 2'b01;\n                        end else begin // 16-bit\n                            if (bd_write_state == 2'b00) begin\n                                bd_data_temp[15:0] <= wb_dat_i[15:0];\n                                bd_write_state <= 2'b10;\n                            end else begin\n                                dat_in_m_rx_bd <= {wb_dat_i[15:0], bd_data_temp[15:0]};\n                                we_m_rx_bd <= 1'b1;\n                                int_ack <= 1'b0;\n                                bd_write_state <= 2'b01;\n                            end\n                        end\n                    end\n                    8'h80: begin // BD TX register\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                            we_m_tx_bd <= 1'b1;\n                            int_ack <= 1'b0;\n                            bd_write_state <= 2'b01;\n                        end else begin // 16-bit\n                            if (bd_write_state == 2'b00) begin\n                                bd_data_temp[15:0] <= wb_dat_i[15:0];\n                                bd_write_state <= 2'b11;\n                            end else begin\n                                dat_in_m_tx_bd <= {wb_dat_i[15:0], bd_data_temp[15:0]};\n                                we_m_tx_bd <= 1'b1;\n                                int_ack <= 1'b0;\n                                bd_write_state <= 2'b01;\n                            end\n                        end\n                    end\n                endcase\n                \n                if (wb_adr_i != 8'h60 && wb_adr_i != 8'h80) begin\n                    wb_ack_o <= 1'b1;\n                end\n            end else begin\n                // Read operation\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= {16'h0, 16'h0}; // Controller setting (not used)\n                    8'h20: wb_dat_o <= {16'h0, 16'h0200}; // Block size (fixed to 512)\n                    8'h24: wb_dat_o <= {24'h0, 8'h0f}; // Power control (3.3V)\n                    8'h28: wb_dat_o <= {24'h0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= {16'h0, 16'h0}; // Capability (not used)\n                    8'h4c: wb_dat_o <= {24'h0, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'h0;\n                endcase\n                wb_ack_o <= 1'b1;\n            end\n        end\n        \n        // Handle BD write completion\n        if (bd_write_state == 2'b01) begin\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            int_ack <= 1'b1;\n            wb_ack_o <= 1'b1;\n            bd_write_state <= 2'b00;\n        end\n        \n        // Clear int_busy when not accessing cmd_arg register\n        if (!(wb_cyc_i && wb_stb_i && wb_we_i && wb_adr_i == 8'h00)) begin\n            int_busy <= 1'b0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 3, "code": "module sd_data_master (\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n// Parameters\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'hC1A;\nparameter ACMD13 = 16'hD1A;\nparameter ACMD51 = 16'h331A;\nparameter SIZE = 9;\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\nparameter RESEND_MAX_CNT = 3;\n\n// Internal signals\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\nreg [2:0] bd_cnt;\n\n// State machine\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (free_tx_bd != BD_EMPTY) begin\n                next_state = GET_TX_BD;\n            end else if (free_rx_bd != BD_EMPTY) begin\n                next_state = GET_RX_BD;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        GET_TX_BD: begin\n            if (bd_cnt > READ_CYCLE - 1 && tx_full) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_TX_BD;\n            end\n        end\n        GET_RX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_RX_BD;\n            end\n        end\n        SEND_CMD: begin\n            if (send_done) begin\n                next_state = RECIVE_CMD;\n            end else begin\n                next_state = SEND_CMD;\n            end\n        end\n        RECIVE_CMD: begin\n            if (rec_done) begin\n                next_state = DATA_TRANSFER;\n            end else if (rec_failed) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        DATA_TRANSFER: begin\n            if (trans_done) begin\n                next_state = IDLE;\n            end else if (trans_failed) begin\n                next_state = STOP;\n            end else begin\n                next_state = DATA_TRANSFER;\n            end\n        end\n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        STOP_SEND: begin\n            if (send_done) begin\n                next_state = IDLE;\n            end else begin\n                next_state = STOP_SEND;\n            end\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// Output logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all outputs\n        re_s_tx <= 0;\n        a_cmp_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        sys_adr <= 0;\n        ack_transfer <= 0;\n        Dat_Int_Status <= 0;\n        CIDAT <= 0;\n        \n        // Reset internal signals\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n    end else begin\n        // Default outputs\n        re_s_tx <= 0;\n        re_s_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        ack_transfer <= 0;\n        a_cmp_tx <= 0;\n        a_cmp_rx <= 0;\n        \n        // State-specific outputs\n        case (state)\n            IDLE: begin\n                // Reset internal signals\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                bd_cnt <= 0;\n            end\n            \n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                if (ack_i_s_tx) begin\n                    if (RAM_MEM_WIDTH == 32) begin\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_tx;\n                            bd_cnt <= bd_cnt + 1;\n                        end else begin\n                            cmd_arg <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                            tx_cycle <= 1;\n                            cmd_set <= CMD24;\n                            bd_cnt <= 0;\n                        end\n                    end else begin // 16-bit\n                        if (bd_cnt == 0) begin\n                            sys_adr[15:0] <= dat_in_tx;\n                            bd_cnt <= bd_cnt + 1;\n                        end else if (bd_cnt == 1) begin\n                            sys_adr[31:16] <= dat_in_tx;\n                            bd_cnt <= bd_cnt + 1;\n                        end else if (bd_cnt == 2) begin\n                            cmd_arg[15:0] <= dat_in_tx;\n                            bd_cnt <= bd_cnt + 1;\n                        end else begin\n                            cmd_arg[31:16] <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                            tx_cycle <= 1;\n                            cmd_set <= CMD24;\n                            bd_cnt <= 0;\n                        end\n                    end\n                end\n            end\n            \n            GET_RX_BD: begin\n                re_s_rx <= 1;\n                if (ack_i_s_rx) begin\n                    if (RAM_MEM_WIDTH == 32) begin\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_rx;\n                            bd_cnt <= bd_cnt + 1;\n                        end else begin\n                            cmd_arg <= dat_in_rx;\n                            rx_cycle <= 1;\n                            case (transfer_type)\n                                2'b00: cmd_set <= CMD17;\n                                2'b01: cmd_set <= ACMD13;\n                                default: cmd_set <= ACMD51;\n                            endcase\n                            bd_cnt <= 0;\n                        end\n                    end else begin // 16-bit\n                        if (bd_cnt == 0) begin\n                            sys_adr[15:0] <= dat_in_rx;\n                            bd_cnt <= bd_cnt + 1;\n                        end else if (bd_cnt == 1) begin\n                            sys_adr[31:16] <= dat_in_rx;\n                            bd_cnt <= bd_cnt + 1;\n                        end else if (bd_cnt == 2) begin\n                            cmd_arg[15:0] <= dat_in_rx;\n                            bd_cnt <= bd_cnt + 1;\n                        end else begin\n                            cmd_arg[31:16] <= dat_in_rx;\n                            rx_cycle <= 1;\n                            case (transfer_type)\n                                2'b00: cmd_set <= CMD17;\n                                2'b01: cmd_set <= ACMD13;\n                                default: cmd_set <= ACMD51;\n                            endcase\n                            bd_cnt <= 0;\n                        end\n                    end\n                end\n            end\n            \n            SEND_CMD: begin\n                if (tx_cycle) d_write <= 1;\n                if (rx_cycle) d_read <= 1;\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n            \n            RECIVE_CMD: begin\n                if (rx_cycle) start_rx_fifo <= 1;\n                \n                if (!cmd_busy) begin\n                    if (cmd_tsf_err) begin\n                        rec_failed <= 1;\n                    end else if (card_status[0] || (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) begin\n                        rec_done <= 1;\n                    end\n                end\n            end\n            \n            DATA_TRANSFER: begin\n                if (tx_cycle && tx_empt) begin\n                    trans_failed <= 1;\n                end else if (rx_cycle && rx_full) begin\n                    trans_failed <= 1;\n                end\n                \n                if (transm_complete) begin\n                    ack_transfer <= 1;\n                    if (crc_ok) begin\n                        trans_done <= 1;\n                        if (tx_cycle) a_cmp_tx <= 1;\n                        if (rx_cycle) a_cmp_rx <= 1;\n                    end else begin\n                        trans_failed <= 1;\n                    end\n                end\n            end\n            \n            STOP: begin\n                cmd_set <= CMD12;\n                rec_done <= 0;\n                rec_failed <= 0;\n                send_done <= 0;\n                trans_failed <= 0;\n                trans_done <= 0;\n                d_read <= 1;\n                d_write <= 1;\n                start_rx_fifo <= 0;\n                start_tx_fifo <= 0;\n            end\n            \n            STOP_SEND: begin\n                resend_try_cnt <= resend_try_cnt + 1;\n                if (resend_try_cnt == RESEND_MAX_CNT) begin\n                    Dat_Int_Status[1] <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n        endcase\n        \n        // Handle Dat_Int_Status reset\n        if (Dat_Int_Status_rst) begin\n            Dat_Int_Status <= 0;\n        end\n        \n        // Track transmission complete\n        transm_complete_q <= transm_complete;\n        internal_transm_complete <= transm_complete && !transm_complete_q;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n// Parameters\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'h0C1A;\nparameter ACMD13 = 16'h0D1A;\nparameter ACMD51 = 16'h331A;\n\nparameter SIZE = 9;\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\n\nparameter RESEND_MAX_CNT = 3;\n\n`ifdef RAM_MEM_WIDTH_32\n    parameter READ_CYCLE = 2;\n    reg [1:0] bd_cnt;\n    parameter BD_EMPTY = BD_SIZE / 2;\n`else\n    parameter READ_CYCLE = 4;\n    reg [2:0] bd_cnt;\n    parameter BD_EMPTY = BD_SIZE / 4;\n`endif\n\n// Internal signals\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\n\n// FSM sequential logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM combinational logic\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (free_tx_bd != BD_EMPTY) begin\n                next_state = GET_TX_BD;\n            end else if (free_rx_bd != BD_EMPTY) begin\n                next_state = GET_RX_BD;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        \n        GET_TX_BD: begin\n            if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_TX_BD;\n            end\n        end\n        \n        GET_RX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_RX_BD;\n            end\n        end\n        \n        SEND_CMD: begin\n            if (send_done == 1) begin\n                next_state = RECIVE_CMD;\n            end else begin\n                next_state = SEND_CMD;\n            end\n        end\n        \n        RECIVE_CMD: begin\n            if (rec_done == 1) begin\n                next_state = DATA_TRANSFER;\n            end else if (rec_failed == 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        \n        DATA_TRANSFER: begin\n            if (trans_done == 1) begin\n                next_state = IDLE;\n            end else if (trans_failed == 1) begin\n                next_state = STOP;\n            end else begin\n                next_state = DATA_TRANSFER;\n            end\n        end\n        \n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        \n        STOP_SEND: begin\n            if (send_done == 1) begin\n                next_state = IDLE;\n            end else begin\n                next_state = STOP_SEND;\n            end\n        end\n        \n        default: begin\n            next_state = IDLE;\n        end\n    endcase\nend\n\n// FSM output logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all outputs\n        re_s_tx <= 0;\n        a_cmp_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        sys_adr <= 0;\n        ack_transfer <= 0;\n        Dat_Int_Status <= 0;\n        CIDAT <= 0;\n        \n        // Reset internal signals\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n    end else begin\n        // Default outputs\n        re_s_tx <= 0;\n        re_s_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        ack_transfer <= 0;\n        a_cmp_tx <= 0;\n        a_cmp_rx <= 0;\n        \n        // State-specific outputs\n        case (state)\n            IDLE: begin\n                // Reset internal signals\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                resend_try_cnt <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                bd_cnt <= 0;\n            end\n            \n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                if (ack_i_s_tx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    `ifdef RAM_MEM_WIDTH_32\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_tx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                        end\n                    `else\n                        if (bd_cnt == 0) begin\n                            sys_adr[15:0] <= dat_in_tx;\n                        end else if (bd_cnt == 1) begin\n                            sys_adr[31:16] <= dat_in_tx;\n                        end else if (bd_cnt == 2) begin\n                            cmd_arg[15:0] <= dat_in_tx;\n                        end else if (bd_cnt == 3) begin\n                            cmd_arg[31:16] <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                        end\n                    `endif\n                end\n                cmd_set <= CMD24;\n                tx_cycle <= 1;\n            end\n            \n            GET_RX_BD: begin\n                re_s_rx <= 1;\n                if (ack_i_s_rx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    `ifdef RAM_MEM_WIDTH_32\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_rx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_rx;\n                        end\n                    `else\n                        if (bd_cnt == 0) begin\n                            sys_adr[15:0] <= dat_in_rx;\n                        end else if (bd_cnt == 1) begin\n                            sys_adr[31:16] <= dat_in_rx;\n                        end else if (bd_cnt == 2) begin\n                            cmd_arg[15:0] <= dat_in_rx;\n                        end else if (bd_cnt == 3) begin\n                            cmd_arg[31:16] <= dat_in_rx;\n                        end\n                    `endif\n                end\n                \n                case (transfer_type)\n                    2'b00: cmd_set <= CMD17;\n                    2'b01: cmd_set <= ACMD13;\n                    default: cmd_set <= ACMD51;\n                endcase\n                rx_cycle <= 1;\n            end\n            \n            SEND_CMD: begin\n                if (tx_cycle) begin\n                    d_write <= 1;\n                end else if (rx_cycle) begin\n                    d_read <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n            \n            RECIVE_CMD: begin\n                if (rx_cycle) begin\n                    start_rx_fifo <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    if (cmd_tsf_err) begin\n                        rec_failed <= 1;\n                    end else if (card_status[0] == 1 || \n                               (card_status[4:1] == 4 || \n                                card_status[4:1] == 5 || \n                                card_status[4:1] == 6)) begin\n                        rec_done <= 1;\n                    end\n                end\n            end\n            \n            DATA_TRANSFER: begin\n                if (tx_cycle) begin\n                    if (tx_empt) begin\n                        trans_failed <= 1;\n                    end\n                end else if (rx_cycle) begin\n                    if (rx_full) begin\n                        trans_failed <= 1;\n                    end\n                end\n                \n                if (transm_complete) begin\n                    ack_transfer <= 1;\n                    if (crc_ok) begin\n                        trans_done <= 1;\n                        if (tx_cycle) begin\n                            a_cmp_tx <= 1;\n                        end else begin\n                            a_cmp_rx <= 1;\n                        end\n                    end else begin\n                        trans_failed <= 1;\n                    end\n                end\n            end\n            \n            STOP: begin\n                cmd_set <= CMD12;\n                rec_done <= 0;\n                rec_failed <= 0;\n                send_done <= 0;\n                trans_failed <= 0;\n                trans_done <= 0;\n                d_read <= 1;\n                d_write <= 1;\n                start_rx_fifo <= 0;\n                start_tx_fifo <= 0;\n            end\n            \n            STOP_SEND: begin\n                resend_try_cnt <= resend_try_cnt + 1;\n                if (resend_try_cnt == RESEND_MAX_CNT) begin\n                    Dat_Int_Status[1] <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n        endcase\n        \n        // Handle Dat_Int_Status reset\n        if (Dat_Int_Status_rst) begin\n            Dat_Int_Status <= 0;\n        end\n        \n        // Update transmission complete tracking\n        transm_complete_q <= transm_complete;\n        internal_transm_complete <= transm_complete && !transm_complete_q;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n// Parameters\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'h0C1A;\nparameter ACMD13 = 16'h0D1A;\nparameter ACMD51 = 16'h331A;\n\nparameter SIZE = 9;\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\n\n// Internal signals\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\n\n`ifdef RAM_MEM_WIDTH_32\n    parameter READ_CYCLE = 2;\n    reg [1:0] bd_cnt;\n    parameter BD_EMPTY = BD_SIZE / 2;\n`else\n    parameter READ_CYCLE = 4;\n    reg [2:0] bd_cnt;\n    parameter BD_EMPTY = BD_SIZE / 4;\n`endif\n\n// FSM sequential logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM combinational logic\nalways @(*) begin\n    next_state = state;\n    case (state)\n        IDLE: begin\n            if (free_tx_bd != BD_EMPTY) begin\n                next_state = GET_TX_BD;\n            end else if (free_rx_bd != BD_EMPTY) begin\n                next_state = GET_RX_BD;\n            end\n        end\n        GET_TX_BD: begin\n            if (bd_cnt > READ_CYCLE-1 && tx_full) begin\n                next_state = SEND_CMD;\n            end\n        end\n        GET_RX_BD: begin\n            if (bd_cnt >= READ_CYCLE-1) begin\n                next_state = SEND_CMD;\n            end\n        end\n        SEND_CMD: begin\n            if (send_done) begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        RECIVE_CMD: begin\n            if (rec_done) begin\n                next_state = DATA_TRANSFER;\n            end else if (rec_failed) begin\n                next_state = SEND_CMD;\n            end\n        end\n        DATA_TRANSFER: begin\n            if (trans_done) begin\n                next_state = IDLE;\n            end else if (trans_failed) begin\n                next_state = STOP;\n            end\n        end\n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        STOP_SEND: begin\n            if (send_done) begin\n                next_state = IDLE;\n            end\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// FSM output logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all outputs\n        re_s_tx <= 0;\n        a_cmp_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        sys_adr <= 0;\n        ack_transfer <= 0;\n        Dat_Int_Status <= 0;\n        CIDAT <= 0;\n        \n        // Reset internal signals\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n    end else begin\n        // Default outputs\n        re_s_tx <= 0;\n        re_s_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        ack_transfer <= 0;\n        a_cmp_tx <= 0;\n        a_cmp_rx <= 0;\n        \n        // State machine outputs\n        case (state)\n            IDLE: begin\n                // Reset internal signals when idle\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                resend_try_cnt <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                bd_cnt <= 0;\n            end\n            \n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                if (ack_i_s_tx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    if (bd_cnt == 0) begin\n                        sys_adr <= dat_in_tx;\n                    end else if (bd_cnt == 1) begin\n                        cmd_arg <= dat_in_tx;\n                        start_tx_fifo <= 1;\n                        cmd_set <= CMD24;\n                        tx_cycle <= 1;\n                    end\n                end\n            end\n            \n            GET_RX_BD: begin\n                re_s_rx <= 1;\n                if (ack_i_s_rx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    if (bd_cnt == 0) begin\n                        sys_adr <= dat_in_rx;\n                    end else if (bd_cnt == 1) begin\n                        cmd_arg <= dat_in_rx;\n                        case (transfer_type)\n                            2'b00: cmd_set <= CMD17;\n                            2'b01: cmd_set <= ACMD13;\n                            default: cmd_set <= ACMD51;\n                        endcase\n                        rx_cycle <= 1;\n                    end\n                end\n            end\n            \n            SEND_CMD: begin\n                if (tx_cycle) d_write <= 1;\n                if (rx_cycle) d_read <= 1;\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n            \n            RECIVE_CMD: begin\n                if (rx_cycle) start_rx_fifo <= 1;\n                \n                if (!cmd_busy) begin\n                    if (cmd_tsf_err) begin\n                        rec_failed <= 1;\n                    end else if (card_status[0] || (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) begin\n                        rec_done <= 1;\n                    end\n                end\n            end\n            \n            DATA_TRANSFER: begin\n                if (tx_cycle && tx_empt) begin\n                    trans_failed <= 1;\n                end else if (rx_cycle && rx_full) begin\n                    trans_failed <= 1;\n                end\n                \n                if (transm_complete && !transm_complete_q) begin\n                    internal_transm_complete <= 1;\n                    transm_complete_q <= 1;\n                end\n                \n                if (internal_transm_complete) begin\n                    if (crc_ok) begin\n                        trans_done <= 1;\n                        if (tx_cycle) a_cmp_tx <= 1;\n                        if (rx_cycle) a_cmp_rx <= 1;\n                    end else begin\n                        trans_failed <= 1;\n                    end\n                end\n            end\n            \n            STOP: begin\n                cmd_set <= CMD12;\n                rec_done <= 0;\n                rec_failed <= 0;\n                send_done <= 0;\n                trans_failed <= 0;\n                trans_done <= 0;\n                d_read <= 1;\n                d_write <= 1;\n                start_rx_fifo <= 0;\n                start_tx_fifo <= 0;\n            end\n            \n            STOP_SEND: begin\n                resend_try_cnt <= resend_try_cnt + 1;\n                if (resend_try_cnt == RESEND_MAX_CNT) begin\n                    Dat_Int_Status[1] <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n        endcase\n        \n        // Update transmission complete tracking\n        transm_complete_q <= transm_complete;\n        \n        // Handle Dat_Int_Status reset\n        if (Dat_Int_Status_rst) begin\n            Dat_Int_Status <= 0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 11, "code": "module sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    \n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\nparameter SD_BUS_W = 4;\nparameter BIT_BLOCK = 512;\nparameter CRC_OFF = 16;\nparameter BIT_BLOCK_REC = 512;\nparameter BIT_CRC_CYCLE = 16;\nparameter LITTLE_ENDIAN = 1;\nparameter BIG_ENDIAN = 0;\nparameter SD_BUS_WIDTH_1 = 0;\nparameter SD_BUS_WIDTH_4 = 1;\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out [SD_BUS_W-1:0];\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// FSM states\nlocalparam [5:0]\n    IDLE       = 6'b000001,\n    WRITE_DAT  = 6'b000010,\n    WRITE_CRC  = 6'b000100,\n    WRITE_BUSY = 6'b001000,\n    READ_WAIT  = 6'b010000,\n    READ_DAT   = 6'b100000;\n\n// CRC generation modules\ngenerate\ngenvar i;\nfor (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n    sd_crc_16 crc_inst (\n        .BITVAL(crc_in[i]),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out[i])\n    );\nend\nendgenerate\n\n// ACK_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        ack_transfer_int <= 0;\n        ack_q <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// FSM_COMBO block\nalways @(*) begin\n    next_state = state;\n    case (state)\n        IDLE: begin\n            if (start_dat[1] & ~start_dat[0]) next_state = WRITE_DAT;\n            else if (~start_dat[1] & start_dat[0]) next_state = READ_WAIT;\n            else next_state = IDLE;\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == BIT_BLOCK) next_state = WRITE_CRC;\n            else next_state = WRITE_DAT;\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b111) next_state = WRITE_BUSY;\n            else next_state = WRITE_CRC;\n        end\n        WRITE_BUSY: begin\n            if (~busy_int) next_state = IDLE;\n            else next_state = WRITE_BUSY;\n        end\n        READ_WAIT: begin\n            if (~DAT_dat_i[0]) next_state = READ_DAT;\n            else next_state = READ_WAIT;\n        end\n        READ_DAT: begin\n            if (transf_cnt == BIT_BLOCK_REC + BIT_CRC_CYCLE) next_state = IDLE;\n            else next_state = READ_DAT;\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// START_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else begin\n        if (~DAT_dat_i[0] && state == READ_WAIT)\n            q_start_bit <= 0;\n        else\n            q_start_bit <= 1;\n    end\nend\n\n// FSM_SEQ block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        write_buf_0 <= 0;\n        write_buf_1 <= 0;\n        DAT_oe_o <= 0;\n        crc_en <= 0;\n        crc_rst <= 1;\n        transf_cnt <= 0;\n        rd <= 0;\n        last_din <= 0;\n        crc_c <= 0;\n        crc_in <= 0;\n        DAT_dat_o <= 0;\n        crc_status <= 7;\n        crc_s <= 0;\n        transm_complete <= 0;\n        busy_n <= 1;\n        we <= 0;\n        data_out <= 0;\n        crc_ok <= 0;\n        busy_int <= 0;\n        data_send_index <= 0;\n        out_buff_ptr <= 0;\n        in_buff_ptr <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                crc_rst <= 1;\n                crc_en <= 0;\n                DAT_oe_o <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                transf_cnt <= 0;\n                crc_c <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n                \n                if (start_dat[1] & ~start_dat[0]) begin\n                    write_buf_0 <= data_in;\n                    rd <= 1;\n                end\n            end\n            \n            WRITE_DAT: begin\n                crc_rst <= 0;\n                DAT_oe_o <= 1;\n                \n                if (transf_cnt == 0) begin\n                    DAT_dat_o <= 0; // Start bit\n                    crc_en <= 0;\n                end else if (transf_cnt <= BIT_BLOCK) begin\n                    crc_en <= 1;\n                    \n                    if (transf_cnt[1:0] == 2'b00) begin\n                        if (out_buff_ptr) sd_data_out <= write_buf_1;\n                        else sd_data_out <= write_buf_0;\n                    end\n                    \n                    if (transf_cnt[1:0] == 2'b11 && transf_cnt < BIT_BLOCK - 4) begin\n                        rd <= 1;\n                        if (in_buff_ptr) write_buf_1 <= data_in;\n                        else write_buf_0 <= data_in;\n                        in_buff_ptr <= ~in_buff_ptr;\n                    end else begin\n                        rd <= 0;\n                    end\n                    \n                    case (transf_cnt[1:0])\n                        2'b00: last_din <= sd_data_out[3:0];\n                        2'b01: last_din <= sd_data_out[7:4];\n                        2'b10: last_din <= sd_data_out[11:8];\n                        2'b11: begin\n                            last_din <= sd_data_out[15:12];\n                            if (transf_cnt[4:2] == 3'b111) begin\n                                out_buff_ptr <= ~out_buff_ptr;\n                            end\n                        end\n                    endcase\n                    \n                    DAT_dat_o <= last_din;\n                    crc_in <= last_din;\n                end\n                \n                transf_cnt <= transf_cnt + 1;\n            end\n            \n            WRITE_CRC: begin\n                if (transf_cnt < BIT_BLOCK + BIT_CRC_CYCLE) begin\n                    if (transf_cnt < BIT_BLOCK + 16) begin\n                        case (data_send_index)\n                            0: DAT_dat_o <= crc_out[0][15:12];\n                            1: DAT_dat_o <= crc_out[0][11:8];\n                            2: DAT_dat_o <= crc_out[0][7:4];\n                            3: DAT_dat_o <= crc_out[0][3:0];\n                        endcase\n                        if (transf_cnt[1:0] == 2'b11) data_send_index <= data_send_index + 1;\n                    end else begin\n                        DAT_dat_o <= 4'b1111; // Stop bit\n                    end\n                    transf_cnt <= transf_cnt + 1;\n                end else begin\n                    DAT_oe_o <= 0;\n                    crc_status <= 3'b111;\n                end\n            end\n            \n            WRITE_BUSY: begin\n                transm_complete <= 1;\n                busy_int <= DAT_dat_i[0];\n                busy_n <= ~DAT_dat_i[0];\n                \n                if (crc_s == 3'b010) crc_ok <= 1;\n                else crc_ok <= 0;\n            end\n            \n            READ_WAIT: begin\n                crc_rst <= 0;\n                crc_en <= 1;\n                DAT_oe_o <= 0;\n                transf_cnt <= 0;\n                we <= 0;\n            end\n            \n            READ_DAT: begin\n                if (transf_cnt < BIT_BLOCK_REC) begin\n                    data_out <= DAT_dat_i;\n                    crc_in <= DAT_dat_i;\n                    we <= 1;\n                end else if (transf_cnt < BIT_BLOCK_REC + BIT_CRC_CYCLE) begin\n                    we <= 0;\n                    // CRC checking logic would go here\n                end\n                \n                if (transf_cnt == BIT_BLOCK_REC + BIT_CRC_CYCLE - 1) begin\n                    transm_complete <= 1;\n                    busy_n <= 0;\n                end\n                \n                transf_cnt <= transf_cnt + 1;\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'h0000;\n        end else if (Enable) begin\n            CRC[0] <= CRC[15] ^ BITVAL;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2];\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4] ^ CRC[15] ^ BITVAL;\n            CRC[6] <= CRC[5];\n            CRC[7] <= CRC[6];\n            CRC[8] <= CRC[7];\n            CRC[9] <= CRC[8];\n            CRC[10] <= CRC[9];\n            CRC[11] <= CRC[10];\n            CRC[12] <= CRC[11] ^ CRC[15] ^ BITVAL;\n            CRC[13] <= CRC[12];\n            CRC[14] <= CRC[13];\n            CRC[15] <= CRC[14];\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 11, "code": "module sd_controller_wb (\n    // Wishbone interface\n    input               wb_clk_i,\n    input               wb_rst_i,\n    input      [31:0]   wb_dat_i,\n    output reg [31:0]   wb_dat_o,\n    input      [7:0]    wb_adr_i,\n    input      [3:0]    wb_sel_i,\n    input               wb_we_i,\n    input               wb_cyc_i,\n    input               wb_stb_i,\n    output reg          wb_ack_o,\n    \n    // Control signals\n    output reg          we_m_tx_bd,\n    output reg          we_m_rx_bd,\n    output reg          new_cmd,\n    output reg          we_ack,\n    output reg          int_ack,\n    output reg          cmd_int_busy,\n    output reg          int_busy,\n    \n    // Data master interface\n    input               write_req_s,\n    input      [15:0]   cmd_set_s,\n    input      [32:0]   cmd_arg_s,\n    \n    // Registers\n    output reg [31:0]   argument_reg,\n    output reg [15:0]   cmd_setting_reg,\n    input      [15:0]   status_reg,\n    input      [31:0]   cmd_resp_1,\n    output reg [7:0]    software_reset_reg,\n    output reg [16:0]   time_out_reg,\n    input      [15:0]   normal_int_status_reg,\n    input      [15:0]   error_int_status_reg,\n    output reg [15:0]   normal_int_signal_enable_reg,\n    output reg [15:0]   error_int_signal_enable_reg,\n    output reg [7:0]    clock_divider,\n    input      [15:0]   Bd_Status_reg,\n    input      [8:0]    Bd_isr_reg,\n    output reg [8:0]    Bd_isr_enable_reg,\n    \n    // Reset signals\n    output reg          Bd_isr_reset,\n    output reg          normal_isr_reset,\n    output reg          error_isr_reset,\n    \n    // BD data\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\nparameter RAM_MEM_WIDTH = 32; // Default to 32-bit width\n\n// Internal signals\nreg [1:0] bd_write_state;\nreg [31:0] bd_temp_data;\n\n// Register read/write logic\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers\n        argument_reg <= 32'h0;\n        cmd_setting_reg <= 16'h0;\n        software_reset_reg <= 8'h0;\n        time_out_reg <= 16'h0;\n        normal_int_signal_enable_reg <= 16'h0;\n        error_int_signal_enable_reg <= 16'h0;\n        clock_divider <= 8'h0;\n        Bd_isr_enable_reg <= 8'h0;\n        \n        // Reset control signals\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        wb_ack_o <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        bd_write_state <= 2'b00;\n    end\n    else begin\n        // Default values\n        wb_ack_o <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        \n        // Handle data master write requests\n        if (write_req_s) begin\n            argument_reg <= cmd_arg_s;\n            cmd_setting_reg <= cmd_set_s;\n            new_cmd <= 1'b1;\n            we_ack <= 1'b1;\n            cmd_int_busy <= 1'b1;\n        end else begin\n            cmd_int_busy <= 1'b0;\n        end\n        \n        // Wishbone access\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i[7:0])\n                    8'h00: begin // Argument register\n                        argument_reg <= wb_dat_i;\n                        int_busy <= 1'b1;\n                        new_cmd <= 1'b1;\n                    end\n                    8'h04: begin // Command setting register\n                        cmd_setting_reg <= wb_dat_i[15:0];\n                    end\n                    8'h28: begin // Software reset register\n                        software_reset_reg <= wb_dat_i[7:0];\n                    end\n                    8'h2c: begin // Timeout register\n                        time_out_reg <= wb_dat_i[15:0];\n                    end\n                    8'h30: begin // Normal interrupt status register\n                        normal_isr_reset <= 1'b1;\n                    end\n                    8'h34: begin // Error interrupt status register\n                        error_isr_reset <= 1'b1;\n                    end\n                    8'h38: begin // Normal interrupt enable register\n                        normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    end\n                    8'h3c: begin // Error interrupt enable register\n                        error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    end\n                    8'h4c: begin // Clock divider register\n                        clock_divider <= wb_dat_i[7:0];\n                    end\n                    8'h54: begin // Data interrupt status register\n                        Bd_isr_reset <= 1'b1;\n                    end\n                    8'h58: begin // Data interrupt enable register\n                        Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    end\n                    8'h60: begin // BD RX\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                            we_m_rx_bd <= 1'b1;\n                            wb_ack_o <= 1'b1;\n                        end else begin // 16-bit\n                            if (bd_write_state == 2'b00) begin\n                                bd_temp_data[15:0] <= wb_dat_i[15:0];\n                                bd_write_state <= 2'b01;\n                                int_ack <= 1'b0;\n                            end else begin\n                                bd_temp_data[31:16] <= wb_dat_i[15:0];\n                                dat_in_m_rx_bd <= bd_temp_data;\n                                we_m_rx_bd <= 1'b1;\n                                bd_write_state <= 2'b00;\n                                int_ack <= 1'b1;\n                                wb_ack_o <= 1'b1;\n                            end\n                        end\n                    end\n                    8'h80: begin // BD TX\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                            we_m_tx_bd <= 1'b1;\n                            wb_ack_o <= 1'b1;\n                        end else begin // 16-bit\n                            if (bd_write_state == 2'b00) begin\n                                bd_temp_data[15:0] <= wb_dat_i[15:0];\n                                bd_write_state <= 2'b01;\n                                int_ack <= 1'b0;\n                            end else begin\n                                bd_temp_data[31:16] <= wb_dat_i[15:0];\n                                dat_in_m_tx_bd <= bd_temp_data;\n                                we_m_tx_bd <= 1'b1;\n                                bd_write_state <= 2'b00;\n                                int_ack <= 1'b1;\n                                wb_ack_o <= 1'b1;\n                            end\n                        end\n                    end\n                    default: wb_ack_o <= 1'b1;\n                endcase\n            end\n            else begin\n                // Read operation\n                case (wb_adr_i[7:0])\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= {16'h0, 16'h0}; // Controller setting\n                    8'h20: wb_dat_o <= {16'h0, 16'h0200}; // Block size (fixed to 512)\n                    8'h24: wb_dat_o <= {24'h0, 8'h0f}; // Power control (fixed to 3.3V)\n                    8'h28: wb_dat_o <= {24'h0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= {16'h0, 16'h0}; // Capability\n                    8'h4c: wb_dat_o <= {24'h0, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'h0;\n                endcase\n                wb_ack_o <= 1'b1;\n            end\n            \n            // Reset write enables after one cycle\n            if (we_m_rx_bd) we_m_rx_bd <= 1'b0;\n            if (we_m_tx_bd) we_m_tx_bd <= 1'b0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 12, "code": "module sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    \n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\nparameter SD_BUS_W = 4;\nparameter BIT_BLOCK = 512;\nparameter CRC_OFF = 16;\nparameter BIT_BLOCK_REC = 512;\nparameter BIT_CRC_CYCLE = 16;\nparameter LITTLE_ENDIAN = 1;\nparameter BIG_ENDIAN = 0;\nparameter SD_BUS_WIDTH_1 = 1;\nparameter SD_BUS_WIDTH_4 = 4;\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out [0:SD_BUS_W-1];\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// States\nlocalparam [5:0]\n    IDLE       = 6'b000001,\n    WRITE_DAT  = 6'b000010,\n    WRITE_CRC  = 6'b000100,\n    WRITE_BUSY = 6'b001000,\n    READ_WAIT  = 6'b010000,\n    READ_DAT   = 6'b100000;\n\n// CRC generation blocks\ngenerate\n    genvar i;\n    for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n        sd_crc_16 crc_inst (\n            .BITVAL(crc_in[i]),\n            .Enable(crc_en),\n            .CLK(sd_clk),\n            .RST(crc_rst),\n            .CRC(crc_out[i])\n        );\n    end\nendgenerate\n\n// ACK_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        ack_transfer_int <= 0;\n        ack_q <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// FSM_COMBO block\nalways @(*) begin\n    next_state = state;\n    case (state)\n        IDLE: begin\n            if (start_dat[1] & ~start_dat[0]) next_state = WRITE_DAT;\n            else if (~start_dat[1] & start_dat[0]) next_state = READ_WAIT;\n            else next_state = IDLE;\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == BIT_BLOCK) next_state = WRITE_CRC;\n            else next_state = WRITE_DAT;\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b001) next_state = WRITE_BUSY;\n            else next_state = WRITE_CRC;\n        end\n        WRITE_BUSY: begin\n            if (~busy_int) next_state = IDLE;\n            else next_state = WRITE_BUSY;\n        end\n        READ_WAIT: begin\n            if (~DAT_dat_i[0]) next_state = READ_DAT;\n            else next_state = READ_WAIT;\n        end\n        READ_DAT: begin\n            if (transf_cnt == BIT_BLOCK_REC) next_state = IDLE;\n            else next_state = READ_DAT;\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// START_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else begin\n        if (~DAT_dat_i[0] && (state == READ_WAIT))\n            q_start_bit <= 0;\n        else\n            q_start_bit <= 1;\n    end\nend\n\n// FSM_SEQ block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        write_buf_0 <= 0;\n        write_buf_1 <= 0;\n        DAT_oe_o <= 0;\n        crc_en <= 0;\n        crc_rst <= 1;\n        transf_cnt <= 0;\n        rd <= 0;\n        last_din <= 0;\n        crc_c <= 0;\n        crc_in <= 0;\n        DAT_dat_o <= 0;\n        crc_status <= 7;\n        crc_s <= 0;\n        transm_complete <= 0;\n        busy_n <= 1;\n        we <= 0;\n        data_out <= 0;\n        crc_ok <= 0;\n        busy_int <= 0;\n        data_send_index <= 0;\n        out_buff_ptr <= 0;\n        in_buff_ptr <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                crc_rst <= 1;\n                crc_en <= 0;\n                DAT_oe_o <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                transf_cnt <= 0;\n                crc_c <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n                \n                if (start_dat[1] & ~start_dat[0]) begin\n                    write_buf_0 <= data_in;\n                    write_buf_1 <= data_in;\n                end\n            end\n            \n            WRITE_DAT: begin\n                crc_rst <= 0;\n                DAT_oe_o <= 1;\n                \n                if (transf_cnt == 0) begin\n                    DAT_dat_o <= 0; // Start bit\n                    crc_en <= 0;\n                end else begin\n                    crc_en <= 1;\n                    if (transf_cnt[2:0] == 0) begin\n                        last_din <= sd_data_out[3:0];\n                        sd_data_out <= {4'b0, sd_data_out[31:4]};\n                        if (transf_cnt[5:0] == 28) begin\n                            out_buff_ptr <= ~out_buff_ptr;\n                            sd_data_out <= out_buff_ptr ? write_buf_1 : write_buf_0;\n                        end\n                    end\n                    \n                    DAT_dat_o <= last_din;\n                    crc_in <= last_din;\n                end\n                \n                transf_cnt <= transf_cnt + 1;\n            end\n            \n            WRITE_CRC: begin\n                if (crc_c < 5'd16) begin\n                    DAT_dat_o <= crc_out[0][crc_c];\n                    crc_c <= crc_c + 1;\n                end else begin\n                    DAT_dat_o <= 1; // Stop bit\n                    crc_status <= 3'b001;\n                end\n            end\n            \n            WRITE_BUSY: begin\n                transm_complete <= 1;\n                busy_int <= DAT_dat_i[0];\n                busy_n <= ~busy_int;\n                crc_ok <= (crc_s == 3'b010);\n            end\n            \n            READ_WAIT: begin\n                crc_rst <= 0;\n                crc_en <= 1;\n                DAT_oe_o <= 0;\n                we <= 0;\n            end\n            \n            READ_DAT: begin\n                if (transf_cnt < BIT_BLOCK_REC) begin\n                    data_out <= DAT_dat_i;\n                    crc_in <= DAT_dat_i;\n                    we <= 1;\n                end else begin\n                    we <= 0;\n                    // CRC checking logic would go here\n                end\n                \n                if (transf_cnt == BIT_BLOCK_REC + BIT_CRC_CYCLE) begin\n                    transm_complete <= 1;\n                    busy_n <= 0;\n                end\n                \n                transf_cnt <= transf_cnt + 1;\n            end\n            \n            default: begin\n                state <= IDLE;\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'h0000;\n    end else if (Enable) begin\n        CRC[0] <= CRC[15] ^ BITVAL;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2];\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4] ^ (CRC[15] ^ BITVAL);\n        CRC[6] <= CRC[5];\n        CRC[7] <= CRC[6];\n        CRC[8] <= CRC[7];\n        CRC[9] <= CRC[8];\n        CRC[10] <= CRC[9];\n        CRC[11] <= CRC[10];\n        CRC[12] <= CRC[11] ^ (CRC[15] ^ BITVAL);\n        CRC[13] <= CRC[12];\n        CRC[14] <= CRC[13];\n        CRC[15] <= CRC[14];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 12, "code": "module sd_controller_wb (\n    // Wishbone interface\n    input               wb_clk_i,\n    input               wb_rst_i,\n    input      [31:0]   wb_dat_i,\n    output reg [31:0]   wb_dat_o,\n    input      [7:0]    wb_adr_i,\n    input      [3:0]    wb_sel_i,\n    input               wb_we_i,\n    input               wb_cyc_i,\n    input               wb_stb_i,\n    output reg          wb_ack_o,\n    \n    // Control signals\n    output reg          we_m_tx_bd,\n    output reg          we_m_rx_bd,\n    output reg          new_cmd,\n    output reg          we_ack,\n    output reg          int_ack,\n    output reg          cmd_int_busy,\n    output reg          int_busy,\n    \n    // Data master interface\n    input               write_req_s,\n    input      [15:0]   cmd_set_s,\n    input      [32:0]   cmd_arg_s,\n    \n    // Registers\n    output reg [31:0]   argument_reg,\n    output reg [15:0]   cmd_setting_reg,\n    input      [15:0]   status_reg,\n    input      [32:0]   cmd_resp_1,\n    output reg [7:0]    software_reset_reg,\n    output reg [16:0]   time_out_reg,\n    input      [15:0]   normal_int_status_reg,\n    input      [15:0]   error_int_status_reg,\n    output reg [15:0]   normal_int_signal_enable_reg,\n    output reg [15:0]   error_int_signal_enable_reg,\n    output reg [7:0]    clock_divider,\n    input      [15:0]   Bd_Status_reg,\n    input      [7:0]    Bd_isr_reg,\n    output reg [7:0]    Bd_isr_enable_reg,\n    \n    // Interrupt reset signals\n    output reg          Bd_isr_reset,\n    output reg          normal_isr_reset,\n    output reg          error_isr_reset,\n    \n    // BD data\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\nparameter RAM_MEM_WIDTH = 32; // Default to 32-bit width\n\n// Internal signals\nreg [1:0] bd_write_state;\nreg [31:0] bd_write_data;\n\n// Register read/write logic\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to default values\n        argument_reg <= 32'h0;\n        cmd_setting_reg <= 16'h0;\n        software_reset_reg <= 8'h0;\n        time_out_reg <= 16'h0;\n        normal_int_signal_enable_reg <= 16'h0;\n        error_int_signal_enable_reg <= 16'h0;\n        clock_divider <= 8'h0;\n        Bd_isr_enable_reg <= 8'h0;\n        \n        // Reset control signals\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        wb_ack_o <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        bd_write_state <= 2'b0;\n    end\n    else begin\n        // Default values\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        wb_ack_o <= 1'b0;\n        \n        // Handle data master interface\n        if (write_req_s) begin\n            cmd_setting_reg <= cmd_set_s;\n            argument_reg <= cmd_arg_s;\n            we_ack <= 1'b1;\n            cmd_int_busy <= 1'b1;\n            int_busy <= 1'b1;\n            new_cmd <= 1'b1;\n        end else begin\n            cmd_int_busy <= 1'b0;\n            int_busy <= 1'b0;\n        end\n        \n        // Wishbone access\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: begin\n                        argument_reg <= wb_dat_i;\n                        int_busy <= 1'b1;\n                    end\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_isr_reset <= 1'b1;\n                    8'h34: error_isr_reset <= 1'b1;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1'b1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60: begin // BD RX\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                            we_m_rx_bd <= 1'b1;\n                            wb_ack_o <= 1'b1;\n                        end else begin\n                            if (bd_write_state == 2'b00) begin\n                                bd_write_data[15:0] <= wb_dat_i[15:0];\n                                bd_write_state <= 2'b01;\n                            end else begin\n                                dat_in_m_rx_bd <= wb_dat_i[15:0];\n                                we_m_rx_bd <= 1'b1;\n                                wb_ack_o <= 1'b1;\n                                bd_write_state <= 2'b00;\n                            end\n                        end\n                    end\n                    8'h80: begin // BD TX\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                            we_m_tx_bd <= 1'b1;\n                            wb_ack_o <= 1'b1;\n                        end else begin\n                            if (bd_write_state == 2'b00) begin\n                                bd_write_data[15:0] <= wb_dat_i[15:0];\n                                bd_write_state <= 2'b01;\n                            end else begin\n                                dat_in_m_tx_bd <= wb_dat_i[15:0];\n                                we_m_tx_bd <= 1'b1;\n                                wb_ack_o <= 1'b1;\n                                bd_write_state <= 2'b00;\n                            end\n                        end\n                    end\n                    default: wb_ack_o <= 1'b1;\n                endcase\n            end\n            else begin\n                // Read operation\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= 32'h0; // Controller Setting\n                    8'h20: wb_dat_o <= {16'h0, 16'h0200}; // Block Size (fixed to 512)\n                    8'h24: wb_dat_o <= {24'h0, 8'h0f}; // Power Control (fixed to 3.3V)\n                    8'h28: wb_dat_o <= {24'h0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h0; // Capability\n                    8'h4c: wb_dat_o <= {24'h0, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'h0;\n                endcase\n                wb_ack_o <= 1'b1;\n            end\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 13, "code": "module sd_controller_wb (\n    // Wishbone interface\n    input               wb_clk_i,\n    input               wb_rst_i,\n    input      [31:0]   wb_dat_i,\n    output reg [31:0]   wb_dat_o,\n    input      [7:0]    wb_adr_i,\n    input      [3:0]    wb_sel_i,\n    input               wb_we_i,\n    input               wb_cyc_i,\n    input               wb_stb_i,\n    output reg          wb_ack_o,\n    \n    // Control signals\n    output reg          we_m_tx_bd,\n    output reg          we_m_rx_bd,\n    output reg          new_cmd,\n    output reg          we_ack,\n    output reg          int_ack,\n    output reg          cmd_int_busy,\n    output reg          int_busy,\n    \n    // Data master interface\n    input               write_req_s,\n    input      [15:0]   cmd_set_s,\n    input      [32:0]   cmd_arg_s,\n    \n    // Registers\n    output reg [31:0]   argument_reg,\n    output reg [15:0]   cmd_setting_reg,\n    input      [16:0]   status_reg,\n    input      [31:0]   cmd_resp_1,\n    output reg [7:0]    software_reset_reg,\n    output reg [15:0]   time_out_reg,\n    input      [15:0]   normal_int_status_reg,\n    input      [15:0]   error_int_status_reg,\n    output reg [15:0]   normal_int_signal_enable_reg,\n    output reg [15:0]   error_int_signal_enable_reg,\n    output reg [7:0]    clock_divider,\n    input      [15:0]   Bd_Status_reg,\n    input      [8:0]    Bd_isr_reg,\n    output reg [8:0]    Bd_isr_enable_reg,\n    \n    // Interrupt reset signals\n    output reg          Bd_isr_reset,\n    output reg          normal_isr_reset,\n    output reg          error_isr_reset,\n    \n    // BD data\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\nparameter RAM_MEM_WIDTH = 32;\n\n// Internal signals\nreg [1:0] bd_write_state;\nreg [31:0] bd_temp_data;\n\n// Register read/write logic\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers\n        argument_reg <= 32'h0;\n        cmd_setting_reg <= 16'h0;\n        software_reset_reg <= 8'h0;\n        time_out_reg <= 16'h0;\n        normal_int_signal_enable_reg <= 16'h0;\n        error_int_signal_enable_reg <= 16'h0;\n        clock_divider <= 8'h0;\n        Bd_isr_enable_reg <= 8'h0;\n        \n        // Reset control signals\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        wb_ack_o <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        bd_write_state <= 2'b00;\n    end\n    else begin\n        // Default values\n        wb_ack_o <= 1'b0;\n        new_cmd <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        we_ack <= 1'b0;\n        \n        // Handle data master access\n        if (write_req_s) begin\n            argument_reg <= cmd_arg_s;\n            cmd_setting_reg <= cmd_set_s;\n            new_cmd <= 1'b1;\n            we_ack <= 1'b1;\n            cmd_int_busy <= 1'b1;\n        end else begin\n            cmd_int_busy <= 1'b0;\n        end\n        \n        // Wishbone access\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: begin\n                        argument_reg <= wb_dat_i;\n                        int_busy <= 1'b1;\n                    end\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_isr_reset <= 1'b1;\n                    8'h34: error_isr_reset <= 1'b1;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1'b1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    \n                    // BD RX/TX handling\n                    8'h60, 8'h80: begin\n                        if (bd_write_state == 2'b00) begin\n                            bd_temp_data <= wb_dat_i;\n                            if (wb_adr_i == 8'h60) we_m_rx_bd <= 1'b1;\n                            else we_m_tx_bd <= 1'b1;\n                            int_ack <= 1'b0;\n                            bd_write_state <= 2'b01;\n                        end\n                        else if (bd_write_state == 2'b01) begin\n                            if (wb_adr_i == 8'h60) begin\n                                dat_in_m_rx_bd <= bd_temp_data[RAM_MEM_WIDTH-1:0];\n                            end\n                            else begin\n                                dat_in_m_tx_bd <= bd_temp_data[RAM_MEM_WIDTH-1:0];\n                            end\n                            bd_write_state <= 2'b10;\n                        end\n                        else if (bd_write_state == 2'b10) begin\n                            we_m_rx_bd <= 1'b0;\n                            we_m_tx_bd <= 1'b0;\n                            int_ack <= 1'b1;\n                            bd_write_state <= 2'b00;\n                            wb_ack_o <= 1'b1;\n                        end\n                    end\n                endcase\n            end\n            else begin\n                // Read operation\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= 32'h0; // Controller Setting\n                    8'h20: wb_dat_o <= 32'h0200; // Block Size (512)\n                    8'h24: wb_dat_o <= {24'h0, 8'h0f}; // Power Control (3.3V)\n                    8'h28: wb_dat_o <= {24'h0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h0; // Capability\n                    8'h4c: wb_dat_o <= {24'h0, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'h0;\n                endcase\n                wb_ack_o <= int_ack;\n            end\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 13, "code": "module sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    \n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\nparameter SD_BUS_W = 4;\nparameter BIT_BLOCK = 512;\nparameter CRC_OFF = 16;\nparameter BIT_BLOCK_REC = 512;\nparameter BIT_CRC_CYCLE = 16;\nparameter LITTLE_ENDIAN = 1;\nparameter BIG_ENDIAN = 0;\nparameter SD_BUS_WIDTH_1 = 1;\nparameter SD_BUS_WIDTH_4 = 4;\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out [0:SD_BUS_W-1];\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// State definitions\nlocalparam IDLE       = 6'b000001;\nlocalparam WRITE_DAT  = 6'b000010;\nlocalparam WRITE_CRC  = 6'b000100;\nlocalparam WRITE_BUSY = 6'b001000;\nlocalparam READ_WAIT  = 6'b010000;\nlocalparam READ_DAT   = 6'b100000;\n\n// CRC generation modules\ngenerate\ngenvar i;\nfor (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n    sd_crc_16 crc_inst (\n        .BITVAL(crc_in[i]),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out[i])\n    );\nend\nendgenerate\n\n// ACK_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        ack_transfer_int <= 0;\n        ack_q <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// FSM_COMBO block\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b10) next_state = WRITE_DAT;\n            else if (start_dat == 2'b01) next_state = READ_WAIT;\n            else next_state = IDLE;\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == BIT_BLOCK) next_state = WRITE_CRC;\n            else next_state = WRITE_DAT;\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b001) next_state = WRITE_BUSY;\n            else next_state = WRITE_CRC;\n        end\n        WRITE_BUSY: begin\n            if (!busy_int) next_state = IDLE;\n            else next_state = WRITE_BUSY;\n        end\n        READ_WAIT: begin\n            if (!DAT_dat_i[0]) next_state = READ_DAT;\n            else next_state = READ_WAIT;\n        end\n        READ_DAT: begin\n            if (transf_cnt == BIT_BLOCK_REC) next_state = IDLE;\n            else next_state = READ_DAT;\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// START_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else begin\n        if (!DAT_dat_i[0] && state == READ_WAIT)\n            q_start_bit <= 0;\n        else\n            q_start_bit <= 1;\n    end\nend\n\n// FSM_SEQ block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        write_buf_0 <= 0;\n        write_buf_1 <= 0;\n        DAT_oe_o <= 0;\n        crc_en <= 0;\n        crc_rst <= 1;\n        transf_cnt <= 0;\n        rd <= 0;\n        last_din <= 0;\n        crc_c <= 0;\n        crc_in <= 0;\n        DAT_dat_o <= 0;\n        crc_status <= 7;\n        crc_s <= 0;\n        transm_complete <= 0;\n        busy_n <= 1;\n        we <= 0;\n        data_out <= 0;\n        crc_ok <= 0;\n        busy_int <= 0;\n        data_send_index <= 0;\n        out_buff_ptr <= 0;\n        in_buff_ptr <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                crc_rst <= 1;\n                crc_en <= 0;\n                DAT_oe_o <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                transf_cnt <= 0;\n                crc_status <= 7;\n                crc_ok <= 0;\n                busy_int <= 0;\n                \n                if (start_dat == 2'b10) begin\n                    write_buf_0 <= data_in;\n                    rd <= 1;\n                end\n            end\n            \n            WRITE_DAT: begin\n                crc_rst <= 0;\n                DAT_oe_o <= 1;\n                \n                if (transf_cnt == 0) begin\n                    DAT_dat_o <= 0; // Start bit\n                    crc_en <= 0;\n                    transf_cnt <= transf_cnt + 1;\n                end else if (transf_cnt < BIT_BLOCK) begin\n                    crc_en <= 1;\n                    \n                    if (transf_cnt[1:0] == 0) begin\n                        last_din <= sd_data_out[3:0];\n                        sd_data_out <= sd_data_out >> 4;\n                    end\n                    \n                    DAT_dat_o <= last_din;\n                    crc_in <= last_din;\n                    transf_cnt <= transf_cnt + 1;\n                    \n                    if (transf_cnt[4:0] == 28) begin\n                        out_buff_ptr <= ~out_buff_ptr;\n                        if (out_buff_ptr)\n                            sd_data_out <= write_buf_1;\n                        else\n                            sd_data_out <= write_buf_0;\n                    end\n                end\n            end\n            \n            WRITE_CRC: begin\n                if (transf_cnt < BIT_BLOCK + BIT_CRC_CYCLE) begin\n                    if (transf_cnt == BIT_BLOCK) begin\n                        DAT_dat_o <= crc_out[0][15:12];\n                    end else if (transf_cnt == BIT_BLOCK + 4) begin\n                        DAT_dat_o <= crc_out[0][11:8];\n                    end else if (transf_cnt == BIT_BLOCK + 8) begin\n                        DAT_dat_o <= crc_out[0][7:4];\n                    end else if (transf_cnt == BIT_BLOCK + 12) begin\n                        DAT_dat_o <= crc_out[0][3:0];\n                    end\n                    \n                    transf_cnt <= transf_cnt + 1;\n                end else begin\n                    DAT_dat_o <= 4'b1111; // Stop bit\n                    crc_status <= 3'b001;\n                end\n            end\n            \n            WRITE_BUSY: begin\n                transm_complete <= 1;\n                busy_int <= DAT_dat_i[0];\n                busy_n <= ~DAT_dat_i[0];\n                \n                if (crc_s == 3'b010)\n                    crc_ok <= 1;\n                else\n                    crc_ok <= 0;\n            end\n            \n            READ_WAIT: begin\n                DAT_oe_o <= 0;\n                crc_rst <= 0;\n                crc_en <= 1;\n                transf_cnt <= 0;\n            end\n            \n            READ_DAT: begin\n                if (transf_cnt < BIT_BLOCK_REC) begin\n                    data_out <= DAT_dat_i;\n                    crc_in <= DAT_dat_i;\n                    we <= 1;\n                    transf_cnt <= transf_cnt + 1;\n                end else if (transf_cnt < BIT_BLOCK_REC + BIT_CRC_CYCLE) begin\n                    // CRC check logic\n                    if (transf_cnt == BIT_BLOCK_REC + 15) begin\n                        transm_complete <= 1;\n                        busy_n <= 0;\n                    end\n                    transf_cnt <= transf_cnt + 1;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'h0000;\n    end else if (Enable) begin\n        CRC[0] <= CRC[15] ^ BITVAL;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2];\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4] ^ (CRC[15] ^ BITVAL);\n        CRC[6] <= CRC[5];\n        CRC[7] <= CRC[6];\n        CRC[8] <= CRC[7];\n        CRC[9] <= CRC[8];\n        CRC[10] <= CRC[9];\n        CRC[11] <= CRC[10];\n        CRC[12] <= CRC[11] ^ (CRC[15] ^ BITVAL);\n        CRC[13] <= CRC[12];\n        CRC[14] <= CRC[13];\n        CRC[15] <= CRC[14];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 14, "code": "module sd_controller_wb (\n    // Wishbone interface\n    input               wb_clk_i,\n    input               wb_rst_i,\n    input      [31:0]   wb_dat_i,\n    output reg [31:0]   wb_dat_o,\n    input      [7:0]    wb_adr_i,\n    input      [3:0]    wb_sel_i,\n    input               wb_we_i,\n    input               wb_cyc_i,\n    input               wb_stb_i,\n    output reg          wb_ack_o,\n    \n    // Control signals\n    output reg          we_m_tx_bd,\n    output reg          we_m_rx_bd,\n    output reg          new_cmd,\n    output reg          we_ack,\n    output reg          int_ack,\n    output reg          cmd_int_busy,\n    output reg          int_busy,\n    \n    // Data master interface\n    input               write_req_s,\n    input      [15:0]   cmd_set_s,\n    input      [32:0]   cmd_arg_s,\n    \n    // Registers\n    output reg [31:0]   argument_reg,\n    output reg [15:0]   cmd_setting_reg,\n    input      [16:0]   status_reg,\n    input      [31:0]   cmd_resp_1,\n    output reg [7:0]    software_reset_reg,\n    output reg [15:0]   time_out_reg,\n    input      [15:0]   normal_int_status_reg,\n    input      [15:0]   error_int_status_reg,\n    output reg [15:0]   normal_int_signal_enable_reg,\n    output reg [15:0]   error_int_signal_enable_reg,\n    output reg [7:0]    clock_divider,\n    input      [15:0]   Bd_Status_reg,\n    input      [7:0]    Bd_isr_reg,\n    output reg [7:0]    Bd_isr_enable_reg,\n    \n    // Reset signals\n    output reg          Bd_isr_reset,\n    output reg          normal_isr_reset,\n    output reg          error_isr_reset,\n    \n    // BD data\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n// Internal signals\nreg [1:0] bd_write_state;\nreg [31:0] bd_temp_data;\n\n// Register read/write operations\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to default values\n        argument_reg <= 32'h0;\n        cmd_setting_reg <= 16'h0;\n        software_reset_reg <= 8'h0;\n        time_out_reg <= 16'h0;\n        normal_int_signal_enable_reg <= 16'h0;\n        error_int_signal_enable_reg <= 16'h0;\n        clock_divider <= 8'h0;\n        Bd_isr_enable_reg <= 8'h0;\n        \n        // Reset control signals\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        wb_ack_o <= 1'b0;\n        bd_write_state <= 2'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n    end\n    else begin\n        // Default values\n        wb_ack_o <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        \n        // Handle data master interface\n        if (write_req_s) begin\n            cmd_setting_reg <= cmd_set_s;\n            argument_reg <= cmd_arg_s;\n            new_cmd <= 1'b1;\n            we_ack <= 1'b1;\n            cmd_int_busy <= 1'b1;\n        end\n        else begin\n            cmd_int_busy <= 1'b0;\n        end\n        \n        // Wishbone access\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i[7:0])\n                    8'h00: begin\n                        argument_reg <= wb_dat_i;\n                        int_busy <= 1'b1;\n                    end\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_isr_reset <= 1'b1;\n                    8'h34: error_isr_reset <= 1'b1;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1'b1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    \n                    // BD RX/TX handling\n                    8'h60: begin\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                            we_m_rx_bd <= 1'b1;\n                            int_ack <= 1'b0;\n                            bd_write_state <= 2'b11;\n                        end\n                        else begin\n                            bd_temp_data[15:0] <= wb_dat_i[15:0];\n                            we_m_rx_bd <= 1'b1;\n                            int_ack <= 1'b0;\n                            bd_write_state <= 2'b01;\n                        end\n                    end\n                    8'h64: begin\n                        bd_temp_data[31:16] <= wb_dat_i[15:0];\n                        dat_in_m_rx_bd <= bd_temp_data[31:16];\n                        we_m_rx_bd <= 1'b1;\n                        bd_write_state <= 2'b11;\n                    end\n                    8'h80: begin\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                            we_m_tx_bd <= 1'b1;\n                            int_ack <= 1'b0;\n                            bd_write_state <= 2'b11;\n                        end\n                        else begin\n                            bd_temp_data[15:0] <= wb_dat_i[15:0];\n                            we_m_tx_bd <= 1'b1;\n                            int_ack <= 1'b0;\n                            bd_write_state <= 2'b01;\n                        end\n                    end\n                    8'h84: begin\n                        bd_temp_data[31:16] <= wb_dat_i[15:0];\n                        dat_in_m_tx_bd <= bd_temp_data[31:16];\n                        we_m_tx_bd <= 1'b1;\n                        bd_write_state <= 2'b11;\n                    end\n                endcase\n            end\n            else begin\n                // Read operation\n                case (wb_adr_i[7:0])\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= 32'h0; // Controller Setting\n                    8'h20: wb_dat_o <= {16'h0, 12'h200}; // Block Size (512)\n                    8'h24: wb_dat_o <= {24'h0, 4'hf}; // Power Control (3.3V)\n                    8'h28: wb_dat_o <= {24'h0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h0; // Capability\n                    8'h4c: wb_dat_o <= {24'h0, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'h0;\n                endcase\n            end\n            \n            // Handle BD write completion\n            if (bd_write_state == 2'b11) begin\n                we_m_tx_bd <= 1'b0;\n                we_m_rx_bd <= 1'b0;\n                int_ack <= 1'b1;\n                bd_write_state <= 2'b0;\n            end\n            else if (bd_write_state == 2'b01) begin\n                we_m_tx_bd <= 1'b0;\n                we_m_rx_bd <= 1'b0;\n                bd_write_state <= 2'b10;\n            end\n            \n            // Generate acknowledge\n            if (int_ack) begin\n                wb_ack_o <= 1'b1;\n            end\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 15, "code": "module sd_controller_wb (\n    // Wishbone interface\n    input               wb_clk_i,\n    input               wb_rst_i,\n    input      [31:0]   wb_dat_i,\n    output reg [31:0]   wb_dat_o,\n    input      [7:0]    wb_adr_i,\n    input      [3:0]    wb_sel_i,\n    input               wb_we_i,\n    input               wb_cyc_i,\n    input               wb_stb_i,\n    output reg          wb_ack_o,\n    \n    // Control signals\n    output reg          we_m_tx_bd,\n    output reg          we_m_rx_bd,\n    output reg          new_cmd,\n    output reg          we_ack,\n    output reg          int_ack,\n    output              cmd_int_busy,\n    output reg          int_busy,\n    \n    // Data master interface\n    input               write_req_s,\n    input      [15:0]   cmd_set_s,\n    input      [32:0]   cmd_arg_s,\n    \n    // Registers\n    output reg [31:0]   argument_reg,\n    output reg [15:0]   cmd_setting_reg,\n    input      [15:0]   status_reg,\n    input      [31:0]   cmd_resp_1,\n    output reg [7:0]    software_reset_reg,\n    output reg [16:0]   time_out_reg,\n    input      [15:0]   normal_int_status_reg,\n    input      [15:0]   error_int_status_reg,\n    output reg [15:0]   normal_int_signal_enable_reg,\n    output reg [15:0]   error_int_signal_enable_reg,\n    output reg [7:0]    clock_divider,\n    input      [15:0]   Bd_Status_reg,\n    input      [8:0]    Bd_isr_reg,\n    output reg [8:0]    Bd_isr_enable_reg,\n    output reg          Bd_isr_reset,\n    output reg          normal_isr_reset,\n    output reg          error_isr_reset,\n    \n    // BD data\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\nparameter RAM_MEM_WIDTH = 32;\n\n// Internal signals\nreg [1:0] bd_write_state;\nreg [31:0] bd_write_data;\nreg bd_write_upper;\nwire cmd_int_busy = write_req_s;\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to default values\n        argument_reg <= 32'h0;\n        cmd_setting_reg <= 16'h0;\n        software_reset_reg <= 8'h0;\n        time_out_reg <= 16'h0;\n        normal_int_signal_enable_reg <= 16'h0;\n        error_int_signal_enable_reg <= 16'h0;\n        clock_divider <= 8'h0;\n        Bd_isr_enable_reg <= 8'h0;\n        \n        // Reset control signals\n        wb_dat_o <= 32'h0;\n        wb_ack_o <= 1'b0;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        int_busy <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        bd_write_state <= 2'b00;\n        bd_write_data <= 32'h0;\n        bd_write_upper <= 1'b0;\n    end else begin\n        // Default values\n        wb_ack_o <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        \n        // Handle data master interface\n        if (write_req_s) begin\n            argument_reg <= cmd_arg_s;\n            cmd_setting_reg <= cmd_set_s;\n            we_ack <= 1'b1;\n            int_busy <= 1'b1;\n            new_cmd <= 1'b1;\n        end else begin\n            int_busy <= 1'b0;\n        end\n        \n        // Handle Wishbone interface\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: begin\n                        argument_reg <= wb_dat_i;\n                        new_cmd <= 1'b1;\n                        wb_ack_o <= int_ack;\n                    end\n                    8'h04: begin\n                        cmd_setting_reg <= wb_dat_i[15:0];\n                        wb_ack_o <= int_ack;\n                    end\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_isr_reset <= 1'b1;\n                    8'h34: error_isr_reset <= 1'b1;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1'b1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60: begin // BD RX\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                            we_m_rx_bd <= 1'b1;\n                            wb_ack_o <= 1'b1;\n                        end else begin // 16-bit\n                            if (!bd_write_upper) begin\n                                bd_write_data[15:0] <= wb_dat_i[15:0];\n                                bd_write_upper <= 1'b1;\n                                int_ack <= 1'b0;\n                            end else begin\n                                bd_write_data[31:16] <= wb_dat_i[15:0];\n                                dat_in_m_rx_bd <= bd_write_data;\n                                we_m_rx_bd <= 1'b1;\n                                bd_write_upper <= 1'b0;\n                                int_ack <= 1'b1;\n                                wb_ack_o <= 1'b1;\n                            end\n                        end\n                    end\n                    8'h80: begin // BD TX\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                            we_m_tx_bd <= 1'b1;\n                            wb_ack_o <= 1'b1;\n                        end else begin // 16-bit\n                            if (!bd_write_upper) begin\n                                bd_write_data[15:0] <= wb_dat_i[15:0];\n                                bd_write_upper <= 1'b1;\n                                int_ack <= 1'b0;\n                            end else begin\n                                bd_write_data[31:16] <= wb_dat_i[15:0];\n                                dat_in_m_tx_bd <= bd_write_data;\n                                we_m_tx_bd <= 1'b1;\n                                bd_write_upper <= 1'b0;\n                                int_ack <= 1'b1;\n                                wb_ack_o <= 1'b1;\n                            end\n                        end\n                    end\n                    default: wb_ack_o <= 1'b1;\n                endcase\n            end else begin\n                // Read operation\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= {16'h0, 16'h0}; // Controller Setting\n                    8'h20: wb_dat_o <= {16'h0, 16'h0200}; // Block Size (fixed 512)\n                    8'h24: wb_dat_o <= {24'h0, 8'h0f}; // Power Control (fixed 3.3V)\n                    8'h28: wb_dat_o <= {24'h0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= {16'h0, 16'h0}; // Capability\n                    8'h4c: wb_dat_o <= {24'h0, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'h0;\n                endcase\n                wb_ack_o <= 1'b1;\n            end\n        end\n        \n        // Reset write enables after one cycle\n        if (we_m_tx_bd) we_m_tx_bd <= 1'b0;\n        if (we_m_rx_bd) we_m_rx_bd <= 1'b0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 1, "code": "module sd_cmd_serial_host (\n    input SD_CLK_IN,\n    input RST_IN,\n    input [15:0] SETTING_IN,\n    input [39:0] CMD_IN,\n    input REQ_IN,\n    input ACK_IN,\n    input cmd_dat_i,\n    \n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [15:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n// Parameters\nparameter INIT_DELAY = `SIM ? 2 : 64;\nparameter NCR = 2;\nparameter SEND_SIZE = 48;\nparameter SIZE = 10;\nparameter CONTENT_SIZE = 40;\nparameter Read_Delay = 7;\nparameter EIGHT_PAD = 8;\n\n// FSM states\nparameter INIT     = 10'b0000000001;\nparameter IDLE     = 10'b0000000010;\nparameter WRITE_WR = 10'b0000000100;\nparameter DLY_WR   = 10'b0000001000;\nparameter READ_WR  = 10'b0000010000;\nparameter DLY_READ = 10'b0000100000;\nparameter ACK_WR   = 10'b0001000000;\nparameter WRITE_WO = 10'b0010000000;\nparameter DLY_WO   = 10'b0100000000;\nparameter ACK_WO   = 10'b1000000000;\n\n// Internal registers\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg Write_Read;\nreg Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST;\nreg [6:0] CRC_IN;\nwire [6:0] CRC_VAL;\nreg CRC_Enable;\nreg CRC_OUT;\nreg CRC_Check_On;\nreg Crc_Buffering;\nreg CRC_Valid;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg [9:0] state;\nreg [9:0] next_state;\nreg block_write;\nreg block_read;\nreg [1:0] word_select;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\n\n// Submodule instantiation\nsd_crc_7 crc7 (\n    .BITVAL(CRC_OUT),\n    .Enable(CRC_Enable),\n    .CLK(SD_CLK_IN),\n    .RST(CRC_RST),\n    .CRC(CRC_VAL)\n);\n\n// FSM_COMBO: Combinational logic for next state\nalways @(*) begin\n    case (state)\n        INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n        IDLE: begin\n            if (Write_Read) next_state = WRITE_WR;\n            else if (Write_Only) next_state = WRITE_WO;\n            else next_state = IDLE;\n        end\n        WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n        WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n        DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n        DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n        READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n        DLY_READ: next_state = (Ack_internal_in) ? ACK_WR : DLY_READ;\n        ACK_WO: next_state = IDLE;\n        ACK_WR: next_state = IDLE;\n        default: next_state = INIT;\n    endcase\nend\n\n// FSM_SEQ: Sequential state update\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC: Synchronize REQ_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC: Synchronize ACK_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Delay_Cycler <= 0;\n        Response_Size <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        CRC_Check_On <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else begin\n        if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            \n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\nend\n\n// FSM_OUT\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            \n            IDLE: begin\n                cmd_oe_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                st_dat_t <= 0;\n                word_select_counter <= 0;\n            end\n            \n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000000000000001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    st_dat_t <= block_read ? 2'b10 : (block_write ? 2'b01 : 2'b00);\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Delay_Cnt < 3'b111) begin\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                \n                Crc_Buffering <= 0;\n            end\n            \n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0100;\n                    STATUS[5] <= 0;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            \n            READ_WR: begin\n                Delay_Cnt <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Cmd_Cnt == 1) begin\n                    STATUS[3:0] <= 4'b0101;\n                    REQ_OUT <= 1;\n                    Out_Buff[39] <= 0;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Cmd_Cnt < Response_Size) begin\n                    Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                    CRC_OUT <= cmd_dat_i;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                    CRC_Enable <= 0;\n                end else begin\n                    if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                        CRC_Enable <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                        CRC_Enable <= 0;\n                    end\n                    \n                    if (block_read && block_write) begin\n                        st_dat_t <= 2'b11;\n                    end else if (block_write) begin\n                        st_dat_t <= 2'b01;\n                    end\n                end\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            \n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0110;\n                    STATUS[5] <= CRC_Valid;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                CMD_OUT <= Out_Buff;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            \n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            \n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\n// ACK_OUT generation\nalways @(*) begin\n    ACK_OUT = FSM_ACK & DECODER_ACK;\nend\n\nendmodule\n\n// CRC-7 submodule\nmodule sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 0;\n    end else if (Enable) begin\n        CRC[0] <= BITVAL ^ CRC[6];\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= BITVAL ^ CRC[6] ^ CRC[2];\n        CRC[4] <= BITVAL ^ CRC[6] ^ CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n// Parameters\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'h0C1A;\nparameter ACMD13 = 16'h0D1A;\nparameter ACMD51 = 16'h331A;\nparameter SIZE = 9;\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\n\n// Internal signals\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\n`ifdef RAM_MEM_WIDTH_32\n    reg [1:0] bd_cnt;\n    parameter READ_CYCLE = 2;\n    parameter BD_EMPTY = BD_SIZE / 2;\n`else\n    reg [2:0] bd_cnt;\n    parameter READ_CYCLE = 4;\n    parameter BD_EMPTY = BD_SIZE / 4;\n`endif\n\n// FSM sequential logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM combinational logic\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (free_tx_bd != BD_EMPTY) begin\n                next_state = GET_TX_BD;\n            end else if (free_rx_bd != BD_EMPTY) begin\n                next_state = GET_RX_BD;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        \n        GET_TX_BD: begin\n            if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_TX_BD;\n            end\n        end\n        \n        GET_RX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_RX_BD;\n            end\n        end\n        \n        SEND_CMD: begin\n            if (send_done) begin\n                next_state = RECIVE_CMD;\n            end else begin\n                next_state = SEND_CMD;\n            end\n        end\n        \n        RECIVE_CMD: begin\n            if (rec_done) begin\n                next_state = DATA_TRANSFER;\n            end else if (rec_failed) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        \n        DATA_TRANSFER: begin\n            if (trans_done) begin\n                next_state = IDLE;\n            end else if (trans_failed) begin\n                next_state = STOP;\n            end else begin\n                next_state = DATA_TRANSFER;\n            end\n        end\n        \n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        \n        STOP_SEND: begin\n            if (send_done) begin\n                next_state = IDLE;\n            end else begin\n                next_state = STOP_SEND;\n            end\n        end\n        \n        default: begin\n            next_state = IDLE;\n        end\n    endcase\nend\n\n// Output logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        re_s_tx <= 0;\n        a_cmp_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        sys_adr <= 0;\n        ack_transfer <= 0;\n        Dat_Int_Status <= 0;\n        CIDAT <= 0;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                re_s_tx <= 0;\n                re_s_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                ack_transfer <= 0;\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                bd_cnt <= 0;\n                resend_try_cnt <= 0;\n            end\n            \n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                if (ack_i_s_tx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    `ifdef RAM_MEM_WIDTH_32\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_tx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                        end\n                    `else\n                        case (bd_cnt)\n                            0: sys_adr[15:0] <= dat_in_tx;\n                            1: sys_adr[31:16] <= dat_in_tx;\n                            2: cmd_arg[15:0] <= dat_in_tx;\n                            3: begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        endcase\n                    `endif\n                end\n                cmd_set <= CMD24;\n                tx_cycle <= 1;\n            end\n            \n            GET_RX_BD: begin\n                re_s_rx <= 1;\n                if (ack_i_s_rx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    `ifdef RAM_MEM_WIDTH_32\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_rx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_rx;\n                        end\n                    `else\n                        case (bd_cnt)\n                            0: sys_adr[15:0] <= dat_in_rx;\n                            1: sys_adr[31:16] <= dat_in_rx;\n                            2: cmd_arg[15:0] <= dat_in_rx;\n                            3: cmd_arg[31:16] <= dat_in_rx;\n                        endcase\n                    `endif\n                end\n                case (transfer_type)\n                    2'b00: cmd_set <= CMD17;\n                    2'b01: cmd_set <= ACMD13;\n                    default: cmd_set <= ACMD51;\n                endcase\n                rx_cycle <= 1;\n            end\n            \n            SEND_CMD: begin\n                if (tx_cycle) begin\n                    d_write <= 1;\n                end else if (rx_cycle) begin\n                    d_read <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n            \n            RECIVE_CMD: begin\n                if (rx_cycle) begin\n                    start_rx_fifo <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    if (cmd_tsf_err) begin\n                        rec_failed <= 1;\n                    end else if (card_status[0] == 1 || \n                               (card_status[4:1] == 4 || \n                                card_status[4:1] == 5 || \n                                card_status[4:1] == 6)) begin\n                        rec_done <= 1;\n                    end\n                end\n            end\n            \n            DATA_TRANSFER: begin\n                if (tx_cycle && tx_empt) begin\n                    trans_failed <= 1;\n                end else if (rx_cycle && rx_full) begin\n                    trans_failed <= 1;\n                end\n                \n                if (transm_complete) begin\n                    ack_transfer <= 1;\n                    if (crc_ok) begin\n                        trans_done <= 1;\n                        if (tx_cycle) begin\n                            a_cmp_tx <= 1;\n                        end else if (rx_cycle) begin\n                            a_cmp_rx <= 1;\n                        end\n                    end else begin\n                        trans_failed <= 1;\n                    end\n                end\n            end\n            \n            STOP: begin\n                cmd_set <= CMD12;\n                rec_done <= 0;\n                rec_failed <= 0;\n                send_done <= 0;\n                trans_failed <= 0;\n                trans_done <= 0;\n                d_read <= 1;\n                d_write <= 1;\n                start_rx_fifo <= 0;\n                start_tx_fifo <= 0;\n            end\n            \n            STOP_SEND: begin\n                resend_try_cnt <= resend_try_cnt + 1;\n                if (resend_try_cnt == RESEND_MAX_CNT) begin\n                    Dat_Int_Status[1] <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n        endcase\n        \n        if (Dat_Int_Status_rst) begin\n            Dat_Int_Status <= 0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 7, "code": "module sd_data_master (\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n// Parameters\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'h0C1A;\nparameter ACMD13 = 16'h0D1A;\nparameter ACMD51 = 16'h331A;\nparameter SIZE = 9;\n\nparameter IDLE         = 9'b000000001;\nparameter GET_TX_BD    = 9'b000000010;\nparameter GET_RX_BD    = 9'b000000100;\nparameter SEND_CMD     = 9'b000001000;\nparameter RECIVE_CMD   = 9'b000010000;\nparameter DATA_TRANSFER= 9'b000100000;\nparameter STOP         = 9'b001000000;\nparameter STOP_SEND    = 9'b010000000;\n\nparameter RESEND_MAX_CNT = 3;\n\n// Internal signals\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\n\n`ifdef RAM_MEM_WIDTH_32\n    parameter READ_CYCLE = 2;\n    reg [1:0] bd_cnt;\n    parameter BD_EMPTY = BD_SIZE / 2;\n`else\n    parameter READ_CYCLE = 4;\n    reg [2:0] bd_cnt;\n    parameter BD_EMPTY = BD_SIZE / 4;\n`endif\n\n// FSM sequential logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM combinational logic\nalways @(*) begin\n    next_state = state;\n    case (state)\n        IDLE: begin\n            if (free_tx_bd != BD_EMPTY) begin\n                next_state = GET_TX_BD;\n            end else if (free_rx_bd != BD_EMPTY) begin\n                next_state = GET_RX_BD;\n            end\n        end\n        GET_TX_BD: begin\n            if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                next_state = SEND_CMD;\n            end\n        end\n        GET_RX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1) begin\n                next_state = SEND_CMD;\n            end\n        end\n        SEND_CMD: begin\n            if (send_done == 1) begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        RECIVE_CMD: begin\n            if (rec_done == 1) begin\n                next_state = DATA_TRANSFER;\n            end else if (rec_failed == 1) begin\n                next_state = SEND_CMD;\n            end\n        end\n        DATA_TRANSFER: begin\n            if (trans_done == 1) begin\n                next_state = IDLE;\n            end else if (trans_failed == 1) begin\n                next_state = STOP;\n            end\n        end\n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        STOP_SEND: begin\n            if (send_done == 1) begin\n                next_state = IDLE;\n            end\n        end\n    endcase\nend\n\n// Output logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        re_s_tx <= 0;\n        a_cmp_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        sys_adr <= 0;\n        ack_transfer <= 0;\n        Dat_Int_Status <= 0;\n        CIDAT <= 0;\n        \n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n    end else begin\n        // Default values\n        re_s_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_tx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        ack_transfer <= 0;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        \n        if (Dat_Int_Status_rst) begin\n            Dat_Int_Status <= 0;\n        end\n        \n        case (state)\n            IDLE: begin\n                resend_try_cnt <= 0;\n                bd_cnt <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n            end\n            \n            GET_TX_BD: begin\n                tx_cycle <= 1;\n                re_s_tx <= 1;\n                \n                if (ack_i_s_tx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    if (bd_cnt == 0) begin\n                        sys_adr <= dat_in_tx;\n                    end else if (bd_cnt == 1) begin\n                        cmd_arg <= dat_in_tx;\n                        start_tx_fifo <= 1;\n                    end\n                end\n                \n                if (bd_cnt > READ_CYCLE - 1 && tx_full) begin\n                    cmd_set <= CMD24;\n                end\n            end\n            \n            GET_RX_BD: begin\n                rx_cycle <= 1;\n                re_s_rx <= 1;\n                \n                if (ack_i_s_rx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    if (bd_cnt == 0) begin\n                        sys_adr <= dat_in_rx;\n                    end else if (bd_cnt == 1) begin\n                        cmd_arg <= dat_in_rx;\n                    end\n                end\n                \n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                end\n            end\n            \n            SEND_CMD: begin\n                if (tx_cycle) begin\n                    d_write <= 1;\n                end else if (rx_cycle) begin\n                    d_read <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n            \n            RECIVE_CMD: begin\n                if (rx_cycle) begin\n                    start_rx_fifo <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    if (cmd_tsf_err) begin\n                        rec_failed <= 1;\n                    end else if (card_status[0] == 1 || (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) begin\n                        rec_done <= 1;\n                    end\n                end\n            end\n            \n            DATA_TRANSFER: begin\n                if (tx_cycle) begin\n                    if (tx_empt) begin\n                        trans_failed <= 1;\n                        Dat_Int_Status[0] <= 1; // Underrun error\n                    end\n                end else if (rx_cycle) begin\n                    if (rx_full) begin\n                        trans_failed <= 1;\n                        Dat_Int_Status[1] <= 1; // Overrun error\n                    end\n                end\n                \n                transm_complete_q <= transm_complete;\n                if (transm_complete && !transm_complete_q) begin\n                    ack_transfer <= 1;\n                    if (crc_ok) begin\n                        trans_done <= 1;\n                        if (tx_cycle) begin\n                            a_cmp_tx <= 1;\n                        end else begin\n                            a_cmp_rx <= 1;\n                        end\n                    end else begin\n                        trans_failed <= 1;\n                        Dat_Int_Status[2] <= 1; // CRC error\n                    end\n                end\n            end\n            \n            STOP: begin\n                cmd_set <= CMD12;\n                rec_done <= 0;\n                rec_failed <= 0;\n                send_done <= 0;\n                trans_failed <= 0;\n                trans_done <= 0;\n                d_read <= 1;\n                d_write <= 1;\n                start_rx_fifo <= 0;\n                start_tx_fifo <= 0;\n            end\n            \n            STOP_SEND: begin\n                resend_try_cnt <= resend_try_cnt + 1;\n                if (resend_try_cnt == RESEND_MAX_CNT) begin\n                    Dat_Int_Status[1] <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 16, "code": "module sd_controller_wb (\n    // Wishbone interface\n    input               wb_clk_i,\n    input               wb_rst_i,\n    input       [31:0]  wb_dat_i,\n    output reg  [32:0]  wb_dat_o,\n    input       [7:0]   wb_adr_i,\n    input       [3:0]   wb_sel_i,\n    input               wb_we_i,\n    input               wb_cyc_i,\n    input               wb_stb_i,\n    output reg          wb_ack_o,\n    \n    // Control signals\n    output reg          we_m_tx_bd,\n    output reg          we_m_rx_bd,\n    output reg          new_cmd,\n    output reg          we_ack,\n    output reg          int_ack,\n    output reg          cmd_int_busy,\n    output reg          int_busy,\n    \n    // Data master interface\n    input               write_req_s,\n    input       [15:0]  cmd_set_s,\n    input       [32:0]  cmd_arg_s,\n    \n    // Registers\n    output reg  [32:0]  argument_reg,\n    output reg  [15:0]  cmd_setting_reg,\n    input       [15:0]  status_reg,\n    input       [32:0]  cmd_resp_1,\n    output reg  [7:0]   software_reset_reg,\n    output reg  [15:0]  time_out_reg,\n    input       [15:0]  normal_int_status_reg,\n    input       [15:0]  error_int_status_reg,\n    output reg  [15:0]  normal_int_signal_enable_reg,\n    output reg  [15:0]  error_int_signal_enable_reg,\n    output reg  [7:0]   clock_divider,\n    input       [15:0]  Bd_Status_reg,\n    input       [7:0]   Bd_isr_reg,\n    output reg  [7:0]   Bd_isr_enable_reg,\n    \n    // Interrupt reset signals\n    output reg          Bd_isr_reset,\n    output reg          normal_isr_reset,\n    output reg          error_isr_reset,\n    \n    // BD data\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\nparameter RAM_MEM_WIDTH = 32; // Default to 32-bit width\n\n// Internal signals\nreg [1:0] bd_write_state;\nreg [31:0] bd_temp_data;\n\n// Register read/write operations\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to default values\n        argument_reg <= 32'h0;\n        cmd_setting_reg <= 16'h0;\n        software_reset_reg <= 8'h0;\n        time_out_reg <= 16'h0;\n        normal_int_signal_enable_reg <= 16'h0;\n        error_int_signal_enable_reg <= 16'h0;\n        clock_divider <= 8'h0;\n        Bd_isr_enable_reg <= 8'h0;\n        \n        // Reset control signals\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        wb_ack_o <= 1'b0;\n        bd_write_state <= 2'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n    end\n    else begin\n        // Default values\n        wb_ack_o <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        \n        // Handle data master interface\n        if (write_req_s) begin\n            cmd_setting_reg <= cmd_set_s;\n            argument_reg <= cmd_arg_s;\n            we_ack <= 1'b1;\n            cmd_int_busy <= 1'b1;\n            int_busy <= 1'b1;\n            new_cmd <= 1'b1;\n        end\n        else begin\n            cmd_int_busy <= 1'b0;\n        end\n        \n        // Handle Wishbone interface\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: begin\n                        argument_reg <= wb_dat_i;\n                        int_busy <= 1'b1;\n                    end\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_isr_reset <= 1'b1;\n                    8'h34: error_isr_reset <= 1'b1;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1'b1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    \n                    // BD RX/TX handling\n                    8'h60: begin // BD RX\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                            we_m_rx_bd <= 1'b1;\n                            int_ack <= 1'b0;\n                            wb_ack_o <= 1'b1;\n                        end\n                        else begin // 16-bit\n                            if (bd_write_state == 2'b00) begin\n                                bd_temp_data[15:0] <= wb_dat_i[15:0];\n                                bd_write_state <= 2'b01;\n                                int_ack <= 1'b0;\n                            end\n                            else begin\n                                dat_in_m_rx_bd <= {wb_dat_i[15:0], bd_temp_data[15:0]};\n                                we_m_rx_bd <= 1'b1;\n                                bd_write_state <= 2'b00;\n                                wb_ack_o <= 1'b1;\n                            end\n                        end\n                    end\n                    \n                    8'h80: begin // BD TX\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                            we_m_tx_bd <= 1'b1;\n                            int_ack <= 1'b0;\n                            wb_ack_o <= 1'b1;\n                        end\n                        else begin // 16-bit\n                            if (bd_write_state == 2'b00) begin\n                                bd_temp_data[15:0] <= wb_dat_i[15:0];\n                                bd_write_state <= 2'b01;\n                                int_ack <= 1'b0;\n                            end\n                            else begin\n                                dat_in_m_tx_bd <= {wb_dat_i[15:0], bd_temp_data[15:0]};\n                                we_m_tx_bd <= 1'b1;\n                                bd_write_state <= 2'b00;\n                                wb_ack_o <= 1'b1;\n                            end\n                        end\n                    end\n                endcase\n            end\n            else begin\n                // Read operation\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= 32'h0; // Controller Setting (not used)\n                    8'h20: wb_dat_o <= {16'h0, 16'h0200}; // Block Size (fixed to 512)\n                    8'h24: wb_dat_o <= {24'h0, 8'h0F}; // Power Control (fixed to 3.3V)\n                    8'h28: wb_dat_o <= {24'h0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h0; // Capability (not used)\n                    8'h4c: wb_dat_o <= {24'h0, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'h0;\n                endcase\n                wb_ack_o <= 1'b1;\n            end\n        end\n        \n        // Clear BD write signals after one cycle\n        if (we_m_rx_bd) begin\n            we_m_rx_bd <= 1'b0;\n            int_ack <= 1'b1;\n        end\n        if (we_m_tx_bd) begin\n            we_m_tx_bd <= 1'b0;\n            int_ack <= 1'b1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 19, "code": "module sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n// State definitions\nlocalparam IDLE    = 3'b001;\nlocalparam SETUP   = 3'b010;\nlocalparam EXECUTE = 3'b100;\n\n// Status bit positions\nlocalparam dat_ava = 6;\nlocalparam crc_valid = 5;\n\n// Response sizes\nlocalparam small_rsp = 7'b0101000;\nlocalparam big_rsp = 7'b1111111;\n\n// Internal signals\nreg [2:0] state, next_state;\nreg [3:0] debounce;\nreg card_present;\nreg ack_q, ack_in_int;\nreg req_q, req_in_int;\nreg index_check_enable;\nreg CRC_check_enable;\nreg complete;\nreg [15:0] Watchdog_Cnt;\nreg [6:0] response_size;\nreg [7:0] status;\nreg CICMD;\nreg CTE, CIE, CCRCE, EI, CC;\n\n// Debounce logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0;\n        card_present <= 1'b0;\n    end else begin\n        if (!card_detect) begin\n            if (debounce != 4'b1111)\n                debounce <= debounce + 1'b1;\n        end else begin\n            debounce <= 4'b0;\n        end\n        card_present <= (debounce == 4'b1111) ? 1'b1 : 1'b0;\n    end\nend\n\n// Synchronizers\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        ack_q <= 1'b0;\n        ack_in_int <= 1'b0;\n        req_q <= 1'b0;\n        req_in_int <= 1'b0;\n    end else begin\n        ack_q <= ack_in;\n        ack_in_int <= ack_q;\n        req_q <= req_in;\n        req_in_int <= req_q;\n    end\nend\n\n// FSM state register\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I)\n        state <= IDLE;\n    else\n        state <= next_state;\nend\n\n// FSM next state logic\nalways @(*) begin\n    case (state)\n        IDLE: next_state = New_CMD ? SETUP : IDLE;\n        SETUP: next_state = ack_in_int ? EXECUTE : SETUP;\n        EXECUTE: next_state = complete ? IDLE : EXECUTE;\n        default: next_state = IDLE;\n    endcase\nend\n\n// FSM output logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        // Reset all outputs\n        CRC_check_enable <= 1'b0;\n        complete <= 1'b0;\n        RESP_1_REG <= 32'b0;\n        ERR_INT_REG <= 5'b0;\n        NORMAL_INT_REG <= 16'b0;\n        STATUS_REG <= 16'b0;\n        status <= 8'b0;\n        cmd_out <= 40'b0;\n        settings <= 16'b0;\n        response_size <= 7'b0;\n        req_out <= 1'b0;\n        index_check_enable <= 1'b0;\n        ack_out <= 1'b0;\n        Watchdog_Cnt <= 16'b0;\n        CCRCE <= 1'b0;\n        EI <= 1'b0;\n        CC <= 1'b0;\n        go_idle_o <= 1'b0;\n        CICMD <= 1'b0;\n        CTE <= 1'b0;\n        CIE <= 1'b0;\n    end else begin\n        // Interrupt reset handling\n        if (ERR_INT_RST)\n            ERR_INT_REG <= 5'b0;\n        if (NORMAL_INT_RST)\n            NORMAL_INT_REG <= 16'b0;\n        \n        // Card presence interrupts\n        NORMAL_INT_REG[1] <= card_present;\n        NORMAL_INT_REG[2] <= ~card_present;\n        \n        complete <= 1'b0;\n        \n        case (state)\n            IDLE: begin\n                go_idle_o <= 1'b0;\n                req_out <= 1'b0;\n                ack_out <= 1'b0;\n                CICMD <= 1'b0;\n                \n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1'b1;\n                end\n            end\n            \n            SETUP: begin\n                NORMAL_INT_REG <= 16'b0;\n                ERR_INT_REG <= 5'b0;\n                index_check_enable <= CMD_SET_REG[4]; // CICE\n                CRC_check_enable <= CMD_SET_REG[3];   // CRCE\n                \n                // Compose command\n                cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                \n                // Determine response size\n                case (CMD_SET_REG[1:0]) // RTS\n                    2'b10, 2'b11: response_size <= small_rsp;\n                    2'b01: response_size <= big_rsp;\n                    default: response_size <= 7'b0;\n                endcase\n                \n                // Compose settings\n                settings <= {\n                    CMD_SET_REG[7:6],    // WORD_SELECT\n                    data_read,\n                    data_write,\n                    3'b111,              // Delay\n                    CMD_SET_REG[3],      // CRCE\n                    response_size\n                };\n                \n                Watchdog_Cnt <= 16'b0;\n                CICMD <= 1'b1;\n            end\n            \n            EXECUTE: begin\n                Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                \n                // Timeout handling\n                if (Watchdog_Cnt > TIMEOUT_REG) begin\n                    CTE <= 1'b1;\n                    EI <= 1'b1;\n                    if (ack_in)\n                        complete <= 1'b1;\n                    go_idle_o <= 1'b1;\n                end\n                \n                // Request handling\n                if (ack_in_int)\n                    req_out <= 1'b1;\n                \n                // Status handling\n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1'b1;\n                    \n                    if (status[dat_ava]) begin\n                        complete <= 1'b1;\n                        EI <= 1'b0;\n                        \n                        // CRC check\n                        if (CRC_check_enable && !status[crc_valid]) begin\n                            CCRCE <= 1'b1;\n                            EI <= 1'b1;\n                        end\n                        \n                        // Index check\n                        if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                            CIE <= 1'b1;\n                            EI <= 1'b1;\n                        end\n                        \n                        CC <= 1'b1;\n                        \n                        // Store response if needed\n                        if (response_size != 7'b0)\n                            RESP_1_REG <= cmd_in[31:0];\n                    end\n                end\n            end\n        endcase\n        \n        // Update interrupt registers\n        ERR_INT_REG <= {1'b0, CIE, 1'b0, CCRCE, CTE};\n        NORMAL_INT_REG <= {EI, 14'b0, CC};\n        STATUS_REG <= {15'b0, CICMD};\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 20, "code": "module sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n    // State definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal signals\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg ack_q, ack_in_int;\n    reg req_q, req_in_int;\n    reg index_check_enable;\n    reg CRC_check_enable;\n    reg complete;\n    reg [15:0] Watchdog_Cnt;\n    reg [6:0] response_size;\n    reg [7:0] status;\n    reg CTE, CCRCE, CIE, EI, CC;\n\n    // Response size constants\n    localparam small_rsp = 7'b0101000;\n    localparam big_rsp = 7'b1111111;\n\n    // Status bits\n    wire dat_ava = status[6];\n    wire crc_valid = status[5];\n\n    // Debounce logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            ack_q <= 1'b0;\n            ack_in_int <= 1'b0;\n            req_q <= 1'b0;\n            req_in_int <= 1'b0;\n        end else begin\n            ack_q <= ack_in;\n            ack_in_int <= ack_q;\n            req_q <= req_in;\n            req_in_int <= req_q;\n        end\n    end\n\n    // FSM state transition\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // FSM next state logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = New_CMD ? SETUP : IDLE;\n            SETUP: next_state = ack_in_int ? EXECUTE : SETUP;\n            EXECUTE: next_state = complete ? IDLE : EXECUTE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM output logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            // Reset all outputs and internal registers\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            CCRCE <= 1'b0;\n            EI <= 1'b0;\n            CC <= 1'b0;\n            go_idle_o <= 1'b0;\n            CTE <= 1'b0;\n            CIE <= 1'b0;\n        end else begin\n            // Default assignments\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n            \n            // Interrupt reset handling\n            if (ERR_INT_RST) ERR_INT_REG <= 5'b0;\n            if (NORMAL_INT_RST) NORMAL_INT_REG <= 16'b0;\n            \n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    STATUS_REG[0] <= 1'b0; // CICMD\n                    \n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                \n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4]; // CICE\n                    CRC_check_enable <= CMD_SET_REG[3];   // CRCE\n                    \n                    // Compose cmd_out\n                    cmd_out[39:38] <= 2'b01;\n                    cmd_out[37:32] <= CMD_SET_REG[13:8];  // CMDI\n                    cmd_out[31:0] <= ARG_REG;\n                    \n                    // Determine response size\n                    case (CMD_SET_REG[1:0]) // RTS\n                        2'b10, 2'b11: response_size <= small_rsp;\n                        2'b01: response_size <= big_rsp;\n                        default: response_size <= 7'b0;\n                    endcase\n                    \n                    // Compose settings\n                    settings[14:13] <= CMD_SET_REG[7:6];  // WORD_SELECT\n                    settings[12] <= data_read;\n                    settings[11] <= data_write;\n                    settings[10:8] <= 3'b111;             // Delay\n                    settings[7] <= CMD_SET_REG[3];        // CRCE\n                    settings[6:0] <= response_size;\n                    \n                    Watchdog_Cnt <= 16'b0;\n                    STATUS_REG[0] <= 1'b1; // CICMD\n                end\n                \n                EXECUTE: begin\n                    // Watchdog counter\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                    \n                    // Timeout handling\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        CTE <= 1'b1;\n                        EI <= 1'b1;\n                        if (ack_in) complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    \n                    // Request handling\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end\n                    \n                    // Status handling\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        \n                        if (dat_ava) begin\n                            complete <= 1'b1;\n                            EI <= 1'b0;\n                            \n                            // CRC check\n                            if (CRC_check_enable && !crc_valid) begin\n                                CCRCE <= 1'b1;\n                                EI <= 1'b1;\n                            end\n                            \n                            // Index check\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                CIE <= 1'b1;\n                                EI <= 1'b1;\n                            end\n                            \n                            CC <= 1'b1;\n                            \n                            // Store response if needed\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n            \n            // Update interrupt registers\n            ERR_INT_REG[3] <= CIE;\n            ERR_INT_REG[1] <= CCRCE;\n            ERR_INT_REG[0] <= CTE;\n            \n            NORMAL_INT_REG[15] <= EI;\n            NORMAL_INT_REG[0] <= CC;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 8, "code": "module sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n// Parameters\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'h0C1A;\nparameter ACMD13 = 16'h0D1A;\nparameter ACMD51 = 16'h331A;\n\nparameter SIZE = 9;\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\n\nparameter RESEND_MAX_CNT = 3;\n\n// Internal signals\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\n\n`ifdef RAM_MEM_WIDTH_32\n    parameter READ_CYCLE = 2;\n    reg [1:0] bd_cnt;\n    parameter BD_EMPTY = BD_SIZE / 2;\n`else\n    parameter READ_CYCLE = 4;\n    reg [2:0] bd_cnt;\n    parameter BD_EMPTY = BD_SIZE / 4;\n`endif\n\n// FSM sequential logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM combinational logic\nalways @(*) begin\n    next_state = state;\n    case (state)\n        IDLE: begin\n            if (free_tx_bd != BD_EMPTY) begin\n                next_state = GET_TX_BD;\n            end else if (free_rx_bd != BD_EMPTY) begin\n                next_state = GET_RX_BD;\n            end\n        end\n        GET_TX_BD: begin\n            if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                next_state = SEND_CMD;\n            end\n        end\n        GET_RX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1) begin\n                next_state = SEND_CMD;\n            end\n        end\n        SEND_CMD: begin\n            if (send_done) begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        RECIVE_CMD: begin\n            if (rec_done) begin\n                next_state = DATA_TRANSFER;\n            end else if (rec_failed) begin\n                next_state = SEND_CMD;\n            end\n        end\n        DATA_TRANSFER: begin\n            if (trans_done) begin\n                next_state = IDLE;\n            end else if (trans_failed) begin\n                next_state = STOP;\n            end\n        end\n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        STOP_SEND: begin\n            if (send_done) begin\n                next_state = IDLE;\n            end\n        end\n    endcase\nend\n\n// Output logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all outputs\n        re_s_tx <= 0;\n        a_cmp_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        sys_adr <= 0;\n        ack_transfer <= 0;\n        Dat_Int_Status <= 0;\n        CIDAT <= 0;\n        \n        // Reset internal signals\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n    end else begin\n        // Default values\n        re_s_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_tx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        ack_transfer <= 0;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        \n        // State-specific logic\n        case (state)\n            IDLE: begin\n                bd_cnt <= 0;\n                resend_try_cnt <= 0;\n            end\n            \n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                if (ack_i_s_tx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    `ifdef RAM_MEM_WIDTH_32\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_tx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                        end\n                    `else\n                        case (bd_cnt)\n                            0: sys_adr[15:0] <= dat_in_tx;\n                            1: sys_adr[31:16] <= dat_in_tx;\n                            2: cmd_arg[15:0] <= dat_in_tx;\n                            3: begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        endcase\n                    `endif\n                end\n                cmd_set <= CMD24;\n                tx_cycle <= 1;\n            end\n            \n            GET_RX_BD: begin\n                re_s_rx <= 1;\n                if (ack_i_s_rx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    `ifdef RAM_MEM_WIDTH_32\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_rx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_rx;\n                        end\n                    `else\n                        case (bd_cnt)\n                            0: sys_adr[15:0] <= dat_in_rx;\n                            1: sys_adr[31:16] <= dat_in_rx;\n                            2: cmd_arg[15:0] <= dat_in_rx;\n                            3: cmd_arg[31:16] <= dat_in_rx;\n                        endcase\n                    `endif\n                end\n                \n                case (transfer_type)\n                    2'b00: cmd_set <= CMD17;\n                    2'b01: cmd_set <= ACMD13;\n                    default: cmd_set <= ACMD51;\n                endcase\n                rx_cycle <= 1;\n            end\n            \n            SEND_CMD: begin\n                if (tx_cycle) d_write <= 1;\n                if (rx_cycle) d_read <= 1;\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n            \n            RECIVE_CMD: begin\n                if (rx_cycle) start_rx_fifo <= 1;\n                \n                if (!cmd_busy) begin\n                    if (cmd_tsf_err) begin\n                        rec_failed <= 1;\n                    end else if (card_status[0] == 1 || \n                               (card_status[4:1] == 4 || \n                                card_status[4:1] == 5 || \n                                card_status[4:1] == 6)) begin\n                        rec_done <= 1;\n                    end\n                end\n            end\n            \n            DATA_TRANSFER: begin\n                if (tx_cycle && tx_empt) begin\n                    trans_failed <= 1;\n                    Dat_Int_Status[0] <= 1; // Underrun error\n                end\n                \n                if (rx_cycle && rx_full) begin\n                    trans_failed <= 1;\n                    Dat_Int_Status[1] <= 1; // Overrun error\n                end\n                \n                if (transm_complete) begin\n                    if (crc_ok) begin\n                        trans_done <= 1;\n                        ack_transfer <= 1;\n                        if (tx_cycle) a_cmp_tx <= 1;\n                        if (rx_cycle) a_cmp_rx <= 1;\n                    end else begin\n                        trans_failed <= 1;\n                        Dat_Int_Status[2] <= 1; // CRC error\n                    end\n                end\n            end\n            \n            STOP: begin\n                cmd_set <= CMD12;\n                d_read <= 1;\n                d_write <= 1;\n            end\n            \n            STOP_SEND: begin\n                resend_try_cnt <= resend_try_cnt + 1;\n                if (resend_try_cnt == RESEND_MAX_CNT) begin\n                    Dat_Int_Status[1] <= 1; // Overrun error\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n        endcase\n        \n        // Handle transmission complete signal\n        transm_complete_q <= transm_complete;\n        internal_transm_complete <= transm_complete && !transm_complete_q;\n        \n        // Reset Dat_Int_Status if requested\n        if (Dat_Int_Status_rst) begin\n            Dat_Int_Status <= 0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 9, "code": "module sd_data_master (\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n// Parameters\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'h0C1A;\nparameter ACMD13 = 16'h0D1A;\nparameter ACMD51 = 16'h331A;\nparameter SIZE = 9;\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\nparameter RESEND_MAX_CNT = 3;\n\n// Internal signals\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [8:0] state;\nreg [8:0] next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr_reg;\nreg [31:0] cmd_arg_reg;\nreg [15:0] cmd_set_reg;\nreg CIDAT_reg;\n\n// State machine\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (free_tx_bd != BD_EMPTY) begin\n                next_state = GET_TX_BD;\n            end else if (free_rx_bd != BD_EMPTY) begin\n                next_state = GET_RX_BD;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        \n        GET_TX_BD: begin\n            if (bd_cnt > READ_CYCLE - 1 && tx_full) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_TX_BD;\n            end\n        end\n        \n        GET_RX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_RX_BD;\n            end\n        end\n        \n        SEND_CMD: begin\n            if (send_done) begin\n                next_state = RECIVE_CMD;\n            end else begin\n                next_state = SEND_CMD;\n            end\n        end\n        \n        RECIVE_CMD: begin\n            if (rec_done) begin\n                next_state = DATA_TRANSFER;\n            end else if (rec_failed) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        \n        DATA_TRANSFER: begin\n            if (trans_done) begin\n                next_state = IDLE;\n            end else if (trans_failed) begin\n                next_state = STOP;\n            end else begin\n                next_state = DATA_TRANSFER;\n            end\n        end\n        \n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        \n        STOP_SEND: begin\n            if (send_done) begin\n                next_state = IDLE;\n            end else begin\n                next_state = STOP_SEND;\n            end\n        end\n        \n        default: next_state = IDLE;\n    endcase\nend\n\n// Output logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all outputs\n        re_s_tx <= 0;\n        a_cmp_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        sys_adr <= 0;\n        ack_transfer <= 0;\n        Dat_Int_Status <= 0;\n        CIDAT <= 0;\n        \n        // Reset internal signals\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n    end else begin\n        // Default outputs\n        re_s_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_tx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        ack_transfer <= 0;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        \n        // State-specific outputs\n        case (state)\n            IDLE: begin\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                bd_cnt <= 0;\n            end\n            \n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                tx_cycle <= 1;\n                \n                if (ack_i_s_tx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    \n                    if (RAM_MEM_WIDTH == 32) begin\n                        case (bd_cnt)\n                            0: sys_adr <= dat_in_tx;\n                            1: begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        endcase\n                    end else begin // 16-bit\n                        case (bd_cnt)\n                            0: sys_adr[15:0] <= dat_in_tx;\n                            1: sys_adr[31:16] <= dat_in_tx;\n                            2: cmd_arg[15:0] <= dat_in_tx;\n                            3: begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        endcase\n                    end\n                end\n                \n                cmd_set <= CMD24;\n            end\n            \n            GET_RX_BD: begin\n                re_s_rx <= 1;\n                rx_cycle <= 1;\n                \n                if (ack_i_s_rx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    \n                    if (RAM_MEM_WIDTH == 32) begin\n                        case (bd_cnt)\n                            0: sys_adr <= dat_in_rx;\n                            1: cmd_arg <= dat_in_rx;\n                        endcase\n                    end else begin // 16-bit\n                        case (bd_cnt)\n                            0: sys_adr[15:0] <= dat_in_rx;\n                            1: sys_adr[31:16] <= dat_in_rx;\n                            2: cmd_arg[15:0] <= dat_in_rx;\n                            3: cmd_arg[31:16] <= dat_in_rx;\n                        endcase\n                    end\n                end\n                \n                case (transfer_type)\n                    2'b00: cmd_set <= CMD17;\n                    2'b01: cmd_set <= ACMD13;\n                    default: cmd_set <= ACMD51;\n                endcase\n            end\n            \n            SEND_CMD: begin\n                if (tx_cycle) begin\n                    d_write <= 1;\n                end else if (rx_cycle) begin\n                    d_read <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n            \n            RECIVE_CMD: begin\n                if (rx_cycle) begin\n                    start_rx_fifo <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    if (cmd_tsf_err) begin\n                        rec_failed <= 1;\n                    end else if (card_status[0] == 1 || \n                               (card_status[4:1] == 4 || \n                                card_status[4:1] == 5 || \n                                card_status[4:1] == 6)) begin\n                        rec_done <= 1;\n                    end\n                end\n            end\n            \n            DATA_TRANSFER: begin\n                if (tx_cycle && tx_empt) begin\n                    trans_failed <= 1;\n                end else if (rx_cycle && rx_full) begin\n                    trans_failed <= 1;\n                end\n                \n                if (transm_complete && !transm_complete_q) begin\n                    if (crc_ok) begin\n                        trans_done <= 1;\n                        if (tx_cycle) begin\n                            a_cmp_tx <= 1;\n                        end else if (rx_cycle) begin\n                            a_cmp_rx <= 1;\n                        end\n                    end else begin\n                        trans_failed <= 1;\n                    end\n                end\n                \n                transm_complete_q <= transm_complete;\n            end\n            \n            STOP: begin\n                cmd_set <= CMD12;\n                rec_done <= 0;\n                rec_failed <= 0;\n                send_done <= 0;\n                trans_failed <= 0;\n                trans_done <= 0;\n                d_read <= 1;\n                d_write <= 1;\n                start_rx_fifo <= 0;\n                start_tx_fifo <= 0;\n            end\n            \n            STOP_SEND: begin\n                resend_try_cnt <= resend_try_cnt + 1;\n                \n                if (resend_try_cnt == RESEND_MAX_CNT) begin\n                    Dat_Int_Status[1] <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n        endcase\n        \n        // Update Dat_Int_Status\n        if (Dat_Int_Status_rst) begin\n            Dat_Int_Status <= 0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 14, "code": "module sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    \n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\nparameter SD_BUS_W = 4;\nparameter BIT_BLOCK = 512;\nparameter CRC_OFF = 16;\nparameter BIT_BLOCK_REC = 512;\nparameter BIT_CRC_CYCLE = 16;\nparameter LITTLE_ENDIAN = 1;\nparameter BIG_ENDIAN = 0;\nparameter SD_BUS_WIDTH_1 = 1;\nparameter SD_BUS_WIDTH_4 = 4;\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out [SD_BUS_W-1:0];\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// State definitions\nlocalparam IDLE       = 6'b000001;\nlocalparam WRITE_DAT  = 6'b000010;\nlocalparam WRITE_CRC  = 6'b000100;\nlocalparam WRITE_BUSY = 6'b001000;\nlocalparam READ_WAIT  = 6'b010000;\nlocalparam READ_DAT   = 6'b100000;\n\n// CRC generation modules\ngenerate\ngenvar i;\nfor (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n    sd_crc_16 crc_inst (\n        .BITVAL(crc_in[i]),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out[i])\n    );\nend\nendgenerate\n\n// ACK_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        ack_transfer_int <= 0;\n        ack_q <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// FSM_COMBO block\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b10) next_state = WRITE_DAT;\n            else if (start_dat == 2'b01) next_state = READ_WAIT;\n            else next_state = IDLE;\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == BIT_BLOCK) next_state = WRITE_CRC;\n            else next_state = WRITE_DAT;\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b001) next_state = WRITE_BUSY;\n            else next_state = WRITE_CRC;\n        end\n        WRITE_BUSY: begin\n            if (!busy_int) next_state = IDLE;\n            else next_state = WRITE_BUSY;\n        end\n        READ_WAIT: begin\n            if (!DAT_dat_i[0]) next_state = READ_DAT;\n            else next_state = READ_WAIT;\n        end\n        READ_DAT: begin\n            if (transf_cnt == BIT_BLOCK_REC) next_state = IDLE;\n            else next_state = READ_DAT;\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// START_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else begin\n        if (!DAT_dat_i[0] && state == READ_WAIT)\n            q_start_bit <= 0;\n        else\n            q_start_bit <= 1;\n    end\nend\n\n// FSM_SEQ block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        write_buf_0 <= 0;\n        write_buf_1 <= 0;\n        DAT_oe_o <= 0;\n        crc_en <= 0;\n        crc_rst <= 1;\n        transf_cnt <= 0;\n        rd <= 0;\n        last_din <= 0;\n        crc_c <= 0;\n        crc_in <= 0;\n        DAT_dat_o <= 0;\n        crc_status <= 7;\n        crc_s <= 0;\n        transm_complete <= 0;\n        busy_n <= 1;\n        we <= 0;\n        data_out <= 0;\n        crc_ok <= 0;\n        busy_int <= 0;\n        data_send_index <= 0;\n        out_buff_ptr <= 0;\n        in_buff_ptr <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                crc_rst <= 1;\n                crc_en <= 0;\n                DAT_oe_o <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                transf_cnt <= 0;\n                crc_status <= 7;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n                \n                if (start_dat == 2'b10) begin\n                    write_buf_0 <= data_in;\n                    rd <= 1;\n                end\n            end\n            \n            WRITE_DAT: begin\n                crc_rst <= 0;\n                DAT_oe_o <= 1;\n                busy_n <= 0;\n                \n                if (transf_cnt == 0) begin\n                    DAT_dat_o <= 4'b0000; // Start bit\n                    crc_en <= 0;\n                end else if (transf_cnt < BIT_BLOCK) begin\n                    crc_en <= 1;\n                    if (transf_cnt[1:0] == 2'b00) begin\n                        last_din <= sd_data_out[3:0];\n                        DAT_dat_o <= sd_data_out[3:0];\n                        crc_in <= sd_data_out[3:0];\n                    end else if (transf_cnt[1:0] == 2'b01) begin\n                        last_din <= sd_data_out[7:4];\n                        DAT_dat_o <= sd_data_out[7:4];\n                        crc_in <= sd_data_out[7:4];\n                    end else if (transf_cnt[1:0] == 2'b10) begin\n                        last_din <= sd_data_out[11:8];\n                        DAT_dat_o <= sd_data_out[11:8];\n                        crc_in <= sd_data_out[11:8];\n                    end else begin\n                        last_din <= sd_data_out[15:12];\n                        DAT_dat_o <= sd_data_out[15:12];\n                        crc_in <= sd_data_out[15:12];\n                        \n                        if (transf_cnt[4:0] == 28) begin\n                            out_buff_ptr <= ~out_buff_ptr;\n                            if (out_buff_ptr)\n                                sd_data_out <= write_buf_1;\n                            else\n                                sd_data_out <= write_buf_0;\n                        end\n                    end\n                end\n                \n                transf_cnt <= transf_cnt + 1;\n                \n                if (transf_cnt[1:0] == 2'b11 && transf_cnt < BIT_BLOCK-4) begin\n                    if (in_buff_ptr)\n                        write_buf_1 <= data_in;\n                    else\n                        write_buf_0 <= data_in;\n                    in_buff_ptr <= ~in_buff_ptr;\n                    rd <= 1;\n                end else begin\n                    rd <= 0;\n                end\n            end\n            \n            WRITE_CRC: begin\n                if (transf_cnt < BIT_CRC_CYCLE) begin\n                    if (transf_cnt >= 2) begin\n                        if (transf_cnt < 6)\n                            crc_s[transf_cnt-2] <= DAT_dat_i[0];\n                        DAT_dat_o <= {crc_out[0][transf_cnt-2], crc_out[1][transf_cnt-2],\n                                     crc_out[2][transf_cnt-2], crc_out[3][transf_cnt-2]};\n                    end\n                    transf_cnt <= transf_cnt + 1;\n                end else begin\n                    crc_status <= (crc_s == 3'b010) ? 3'b001 : 3'b000;\n                end\n            end\n            \n            WRITE_BUSY: begin\n                transm_complete <= 1;\n                crc_ok <= (crc_status == 3'b001);\n                busy_int <= DAT_dat_i[0];\n                busy_n <= !DAT_dat_i[0];\n            end\n            \n            READ_WAIT: begin\n                crc_rst <= 0;\n                crc_en <= 1;\n                DAT_oe_o <= 0;\n                busy_n <= 0;\n                transf_cnt <= 0;\n            end\n            \n            READ_DAT: begin\n                if (transf_cnt < BIT_BLOCK_REC) begin\n                    crc_in <= DAT_dat_i;\n                    if (transf_cnt[1:0] == 2'b00)\n                        data_out[3:0] <= DAT_dat_i;\n                    else if (transf_cnt[1:0] == 2'b01)\n                        data_out[7:4] <= DAT_dat_i;\n                    else if (transf_cnt[1:0] == 2'b10)\n                        data_out[11:8] <= DAT_dat_i;\n                    else begin\n                        data_out[15:12] <= DAT_dat_i;\n                        we <= 1;\n                    end\n                    \n                    transf_cnt <= transf_cnt + 1;\n                end else begin\n                    we <= 0;\n                    // CRC checking\n                    if (SD_BUS_W == 4) begin\n                        crc_ok <= (DAT_dat_i[0] == crc_out[0][transf_cnt-BIT_BLOCK_REC]) &&\n                                 (DAT_dat_i[1] == crc_out[1][transf_cnt-BIT_BLOCK_REC]) &&\n                                 (DAT_dat_i[2] == crc_out[2][transf_cnt-BIT_BLOCK_REC]) &&\n                                 (DAT_dat_i[3] == crc_out[3][transf_cnt-BIT_BLOCK_REC]);\n                    end else begin\n                        crc_ok <= (DAT_dat_i[0] == crc_out[0][transf_cnt-BIT_BLOCK_REC]);\n                    end\n                    \n                    if (transf_cnt == BIT_BLOCK_REC + BIT_CRC_CYCLE - 1)\n                        transm_complete <= 1;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'h0000;\n    end else if (Enable) begin\n        CRC[0] <= CRC[15] ^ BITVAL;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2];\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4] ^ (CRC[15] ^ BITVAL);\n        CRC[6] <= CRC[5];\n        CRC[7] <= CRC[6];\n        CRC[8] <= CRC[7];\n        CRC[9] <= CRC[8];\n        CRC[10] <= CRC[9];\n        CRC[11] <= CRC[10];\n        CRC[12] <= CRC[11] ^ (CRC[15] ^ BITVAL);\n        CRC[13] <= CRC[12];\n        CRC[14] <= CRC[13];\n        CRC[15] <= CRC[14];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 17, "code": "module sd_controller_wb (\n    // Wishbone interface\n    input               wb_clk_i,\n    input               wb_rst_i,\n    input      [31:0]   wb_dat_i,\n    output reg [31:0]   wb_dat_o,\n    input      [7:0]    wb_adr_i,\n    input      [3:0]    wb_sel_i,\n    input               wb_we_i,\n    input               wb_cyc_i,\n    input               wb_stb_i,\n    output reg          wb_ack_o,\n    \n    // Control signals\n    output reg          we_m_tx_bd,\n    output reg          we_m_rx_bd,\n    output reg          new_cmd,\n    output reg          we_ack,\n    output reg          int_ack,\n    output reg          cmd_int_busy,\n    output reg          int_busy,\n    \n    // Data master interface\n    input               write_req_s,\n    input      [15:0]   cmd_set_s,\n    input      [32:0]   cmd_arg_s,\n    \n    // Registers\n    output reg [31:0]   argument_reg,\n    output reg [15:0]   cmd_setting_reg,\n    input      [15:0]   status_reg,\n    input      [31:0]   cmd_resp_1,\n    output reg [7:0]    software_reset_reg,\n    output reg [16:0]   time_out_reg,\n    input      [15:0]   normal_int_status_reg,\n    input      [15:0]   error_int_status_reg,\n    output reg [15:0]   normal_int_signal_enable_reg,\n    output reg [15:0]   error_int_signal_enable_reg,\n    output reg [7:0]    clock_divider,\n    input      [15:0]   Bd_Status_reg,\n    input      [8:0]    Bd_isr_reg,\n    output reg [8:0]    Bd_isr_enable_reg,\n    \n    // Interrupt reset signals\n    output reg          Bd_isr_reset,\n    output reg          normal_isr_reset,\n    output reg          error_isr_reset,\n    \n    // BD data\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\nparameter RAM_MEM_WIDTH = 32; // Default to 32-bit width\n\n// Internal signals\nreg [1:0] bd_write_state;\nreg [31:0] bd_temp_data;\n\n// Register read/write operations\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to default values\n        argument_reg <= 32'h0;\n        cmd_setting_reg <= 16'h0;\n        software_reset_reg <= 8'h0;\n        time_out_reg <= 16'h0;\n        normal_int_signal_enable_reg <= 16'h0;\n        error_int_signal_enable_reg <= 16'h0;\n        clock_divider <= 8'h0;\n        Bd_isr_enable_reg <= 8'h0;\n        \n        // Reset control signals\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        wb_ack_o <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        bd_write_state <= 2'b00;\n        bd_temp_data <= 32'h0;\n    end else begin\n        // Default values\n        wb_ack_o <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        \n        // Handle data master interface\n        if (write_req_s) begin\n            argument_reg <= cmd_arg_s;\n            cmd_setting_reg <= cmd_set_s;\n            new_cmd <= 1'b1;\n            we_ack <= 1'b1;\n            cmd_int_busy <= 1'b1;\n        end else begin\n            cmd_int_busy <= 1'b0;\n        end\n        \n        // Handle Wishbone interface\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i[7:0])\n                    8'h00: begin // Argument register\n                        argument_reg <= wb_dat_i;\n                        int_busy <= 1'b1;\n                    end\n                    8'h04: begin // Command setting register\n                        cmd_setting_reg <= wb_dat_i[15:0];\n                    end\n                    8'h28: begin // Software reset register\n                        software_reset_reg <= wb_dat_i[7:0];\n                    end\n                    8'h2c: begin // Timeout register\n                        time_out_reg <= wb_dat_i[15:0];\n                    end\n                    8'h30: begin // Normal interrupt status register\n                        normal_isr_reset <= 1'b1;\n                    end\n                    8'h34: begin // Error interrupt status register\n                        error_isr_reset <= 1'b1;\n                    end\n                    8'h38: begin // Normal interrupt enable register\n                        normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    end\n                    8'h3c: begin // Error interrupt enable register\n                        error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    end\n                    8'h4c: begin // Clock divider register\n                        clock_divider <= wb_dat_i[7:0];\n                    end\n                    8'h54: begin // Data interrupt status register\n                        Bd_isr_reset <= 1'b1;\n                    end\n                    8'h58: begin // Data interrupt enable register\n                        Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    end\n                    8'h60: begin // BD RX register\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                            we_m_rx_bd <= 1'b1;\n                            int_ack <= 1'b0;\n                            wb_ack_o <= 1'b1;\n                        end else begin // 16-bit\n                            case (bd_write_state)\n                                2'b00: begin\n                                    bd_temp_data[15:0] <= wb_dat_i[15:0];\n                                    bd_write_state <= 2'b01;\n                                    int_ack <= 1'b0;\n                                end\n                                2'b01: begin\n                                    bd_temp_data[31:16] <= wb_dat_i[15:0];\n                                    dat_in_m_rx_bd <= bd_temp_data[15:0];\n                                    we_m_rx_bd <= 1'b1;\n                                    bd_write_state <= 2'b10;\n                                end\n                                2'b10: begin\n                                    dat_in_m_rx_bd <= bd_temp_data[31:16];\n                                    we_m_rx_bd <= 1'b1;\n                                    bd_write_state <= 2'b11;\n                                end\n                                2'b11: begin\n                                    we_m_rx_bd <= 1'b0;\n                                    int_ack <= 1'b1;\n                                    wb_ack_o <= 1'b1;\n                                    bd_write_state <= 2'b00;\n                                end\n                            endcase\n                        end\n                    end\n                    8'h80: begin // BD TX register\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                            we_m_tx_bd <= 1'b1;\n                            int_ack <= 1'b0;\n                            wb_ack_o <= 1'b1;\n                        end else begin // 16-bit\n                            case (bd_write_state)\n                                2'b00: begin\n                                    bd_temp_data[15:0] <= wb_dat_i[15:0];\n                                    bd_write_state <= 2'b01;\n                                    int_ack <= 1'b0;\n                                end\n                                2'b01: begin\n                                    bd_temp_data[31:16] <= wb_dat_i[15:0];\n                                    dat_in_m_tx_bd <= bd_temp_data[15:0];\n                                    we_m_tx_bd <= 1'b1;\n                                    bd_write_state <= 2'b10;\n                                end\n                                2'b10: begin\n                                    dat_in_m_tx_bd <= bd_temp_data[31:16];\n                                    we_m_tx_bd <= 1'b1;\n                                    bd_write_state <= 2'b11;\n                                end\n                                2'b11: begin\n                                    we_m_tx_bd <= 1'b0;\n                                    int_ack <= 1'b1;\n                                    wb_ack_o <= 1'b1;\n                                    bd_write_state <= 2'b00;\n                                end\n                            endcase\n                        end\n                    end\n                    default: begin\n                        wb_ack_o <= 1'b1;\n                    end\n                endcase\n            end else begin\n                // Read operation\n                case (wb_adr_i[7:0])\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= 32'h0; // Controller setting (not used)\n                    8'h20: wb_dat_o <= {16'h0, 16'h0200}; // Block size (fixed at 512)\n                    8'h24: wb_dat_o <= {24'h0, 8'h0f}; // Power control (3.3V)\n                    8'h28: wb_dat_o <= {24'h0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h0; // Capability (not used)\n                    8'h4c: wb_dat_o <= {24'h0, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'h0;\n                endcase\n                wb_ack_o <= 1'b1;\n            end\n        end\n        \n        // Reset write enables after one cycle\n        if (we_m_rx_bd) we_m_rx_bd <= 1'b0;\n        if (we_m_tx_bd) we_m_tx_bd <= 1'b0;\n        \n        // Reset interrupt busy after command is processed\n        if (int_busy && !write_req_s) int_busy <= 1'b0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    // Input ports\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n\n    // Output ports\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n// Parameters\nparameter CMD24 = 16'h181A;  // Write single block\nparameter CMD17 = 16'h111A;  // Read single block\nparameter CMD12 = 16'h0C1A;  // Stop transmission\nparameter ACMD13 = 16'h0D1A; // SD status\nparameter ACMD51 = 16'h331A; // Read SCR register\n\nparameter SIZE = 9;\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\n\nparameter RESEND_MAX_CNT = 3;\n\n// Internal signals\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\n\n`ifdef RAM_MEM_WIDTH_32\n    parameter READ_CYCLE = 2;\n    reg [1:0] bd_cnt;\n    parameter BD_EMPTY = BD_SIZE / 2;\n`else\n    parameter READ_CYCLE = 4;\n    reg [2:0] bd_cnt;\n    parameter BD_EMPTY = BD_SIZE / 4;\n`endif\n\n// FSM sequential logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM combinational logic\nalways @(*) begin\n    next_state = state;\n    case (state)\n        IDLE: begin\n            if (free_tx_bd != BD_EMPTY) begin\n                next_state = GET_TX_BD;\n            end else if (free_rx_bd != BD_EMPTY) begin\n                next_state = GET_RX_BD;\n            end\n        end\n        GET_TX_BD: begin\n            if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                next_state = SEND_CMD;\n            end\n        end\n        GET_RX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1) begin\n                next_state = SEND_CMD;\n            end\n        end\n        SEND_CMD: begin\n            if (send_done) begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        RECIVE_CMD: begin\n            if (rec_done) begin\n                next_state = DATA_TRANSFER;\n            end else if (rec_failed) begin\n                next_state = SEND_CMD;\n            end\n        end\n        DATA_TRANSFER: begin\n            if (trans_done) begin\n                next_state = IDLE;\n            end else if (trans_failed) begin\n                next_state = STOP;\n            end\n        end\n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        STOP_SEND: begin\n            if (send_done) begin\n                next_state = IDLE;\n            end\n        end\n    endcase\nend\n\n// FSM output logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all outputs\n        re_s_tx <= 0;\n        a_cmp_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        sys_adr <= 0;\n        ack_transfer <= 0;\n        Dat_Int_Status <= 0;\n        CIDAT <= 0;\n        \n        // Reset internal signals\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n    end else begin\n        // Default values\n        re_s_tx <= 0;\n        re_s_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        ack_transfer <= 0;\n        a_cmp_tx <= 0;\n        a_cmp_rx <= 0;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        \n        // State-specific outputs\n        case (state)\n            IDLE: begin\n                bd_cnt <= 0;\n                resend_try_cnt <= 0;\n            end\n            \n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                if (ack_i_s_tx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    `ifdef RAM_MEM_WIDTH_32\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_tx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                        end\n                    `else\n                        case (bd_cnt)\n                            0: sys_adr[15:0] <= dat_in_tx;\n                            1: sys_adr[31:16] <= dat_in_tx;\n                            2: cmd_arg[15:0] <= dat_in_tx;\n                            3: begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        endcase\n                    `endif\n                end\n                cmd_set <= CMD24;\n                tx_cycle <= 1;\n            end\n            \n            GET_RX_BD: begin\n                re_s_rx <= 1;\n                if (ack_i_s_rx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    `ifdef RAM_MEM_WIDTH_32\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_rx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_rx;\n                        end\n                    `else\n                        case (bd_cnt)\n                            0: sys_adr[15:0] <= dat_in_rx;\n                            1: sys_adr[31:16] <= dat_in_rx;\n                            2: cmd_arg[15:0] <= dat_in_rx;\n                            3: cmd_arg[31:16] <= dat_in_rx;\n                        endcase\n                    `endif\n                end\n                \n                case (transfer_type)\n                    2'b00: cmd_set <= CMD17;\n                    2'b01: cmd_set <= ACMD13;\n                    default: cmd_set <= ACMD51;\n                endcase\n                rx_cycle <= 1;\n            end\n            \n            SEND_CMD: begin\n                if (tx_cycle) begin\n                    d_write <= 1;\n                end else if (rx_cycle) begin\n                    d_read <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n            \n            RECIVE_CMD: begin\n                if (rx_cycle) begin\n                    start_rx_fifo <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    if (cmd_tsf_err) begin\n                        rec_failed <= 1;\n                    end else if (card_status[0] == 1 || \n                               (card_status[4:1] == 4 || \n                                card_status[4:1] == 5 || \n                                card_status[4:1] == 6)) begin\n                        rec_done <= 1;\n                    end\n                end\n            end\n            \n            DATA_TRANSFER: begin\n                if (tx_cycle) begin\n                    if (tx_empt) begin\n                        trans_failed <= 1;\n                    end\n                end else if (rx_cycle) begin\n                    if (rx_full) begin\n                        trans_failed <= 1;\n                    end\n                end\n                \n                if (transm_complete) begin\n                    ack_transfer <= 1;\n                    if (crc_ok) begin\n                        trans_done <= 1;\n                        if (tx_cycle) begin\n                            a_cmp_tx <= 1;\n                        end else begin\n                            a_cmp_rx <= 1;\n                        end\n                    end else begin\n                        trans_failed <= 1;\n                    end\n                end\n            end\n            \n            STOP: begin\n                cmd_set <= CMD12;\n                rec_done <= 0;\n                rec_failed <= 0;\n                send_done <= 0;\n                trans_failed <= 0;\n                trans_done <= 0;\n                d_read <= 1;\n                d_write <= 1;\n                start_rx_fifo <= 0;\n                start_tx_fifo <= 0;\n            end\n            \n            STOP_SEND: begin\n                resend_try_cnt <= resend_try_cnt + 1;\n                if (resend_try_cnt == RESEND_MAX_CNT) begin\n                    Dat_Int_Status[1] <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n        endcase\n        \n        // Update transmission complete tracking\n        transm_complete_q <= transm_complete;\n        internal_transm_complete <= transm_complete && !transm_complete_q;\n        \n        // Reset Dat_Int_Status if requested\n        if (Dat_Int_Status_rst) begin\n            Dat_Int_Status <= 0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 11, "code": "module sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n// Parameters\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'h0C1A;\nparameter ACMD13 = 16'h0D1A;\nparameter ACMD51 = 16'h331A;\nparameter SIZE = 9;\n\n// FSM states\nparameter IDLE         = 9'b000000001;\nparameter GET_TX_BD    = 9'b000000010;\nparameter GET_RX_BD    = 9'b000000100;\nparameter SEND_CMD     = 9'b000001000;\nparameter RECIVE_CMD   = 9'b000010000;\nparameter DATA_TRANSFER= 9'b000100000;\nparameter STOP         = 9'b001000000;\nparameter STOP_SEND    = 9'b010000000;\n\n// Internal signals\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [8:0] state;\nreg [8:0] next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\n`ifdef RAM_MEM_WIDTH_32\n    reg [1:0] bd_cnt;\n    parameter READ_CYCLE = 2;\n    parameter BD_EMPTY = BD_SIZE / 2;\n`else\n    reg [2:0] bd_cnt;\n    parameter READ_CYCLE = 4;\n    parameter BD_EMPTY = BD_SIZE / 4;\n`endif\n\n// FSM sequential logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM combinational logic\nalways @(*) begin\n    next_state = state;\n    case (state)\n        IDLE: begin\n            if (free_tx_bd != BD_EMPTY) begin\n                next_state = GET_TX_BD;\n            end else if (free_rx_bd != BD_EMPTY) begin\n                next_state = GET_RX_BD;\n            end\n        end\n        GET_TX_BD: begin\n            if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                next_state = SEND_CMD;\n            end\n        end\n        GET_RX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1) begin\n                next_state = SEND_CMD;\n            end\n        end\n        SEND_CMD: begin\n            if (send_done) begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        RECIVE_CMD: begin\n            if (rec_done) begin\n                next_state = DATA_TRANSFER;\n            end else if (rec_failed) begin\n                next_state = SEND_CMD;\n            end\n        end\n        DATA_TRANSFER: begin\n            if (trans_done) begin\n                next_state = IDLE;\n            end else if (trans_failed) begin\n                next_state = STOP;\n            end\n        end\n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        STOP_SEND: begin\n            if (send_done) begin\n                next_state = IDLE;\n            end\n        end\n    endcase\nend\n\n// FSM output logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all outputs\n        re_s_tx <= 0;\n        a_cmp_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        sys_adr <= 0;\n        ack_transfer <= 0;\n        Dat_Int_Status <= 0;\n        CIDAT <= 0;\n        \n        // Reset internal signals\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n    end else begin\n        // Default outputs\n        re_s_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_tx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        ack_transfer <= 0;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        \n        // Track transmission complete\n        transm_complete_q <= transm_complete;\n        if (transm_complete && !transm_complete_q) begin\n            internal_transm_complete <= 1;\n        end\n        \n        // Handle Dat_Int_Status reset\n        if (Dat_Int_Status_rst) begin\n            Dat_Int_Status <= 0;\n        end\n        \n        case (state)\n            IDLE: begin\n                bd_cnt <= 0;\n                resend_try_cnt <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n            end\n            \n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                if (ack_i_s_tx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    `ifdef RAM_MEM_WIDTH_32\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_tx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                        end\n                    `else\n                        case (bd_cnt)\n                            0: sys_adr[15:0] <= dat_in_tx;\n                            1: sys_adr[31:16] <= dat_in_tx;\n                            2: cmd_arg[15:0] <= dat_in_tx;\n                            3: begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        endcase\n                    `endif\n                end\n                cmd_set <= CMD24;\n                tx_cycle <= 1;\n            end\n            \n            GET_RX_BD: begin\n                re_s_rx <= 1;\n                if (ack_i_s_rx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    `ifdef RAM_MEM_WIDTH_32\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_rx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_rx;\n                        end\n                    `else\n                        case (bd_cnt)\n                            0: sys_adr[15:0] <= dat_in_rx;\n                            1: sys_adr[31:16] <= dat_in_rx;\n                            2: cmd_arg[15:0] <= dat_in_rx;\n                            3: cmd_arg[31:16] <= dat_in_rx;\n                        endcase\n                    `endif\n                end\n                \n                case (transfer_type)\n                    2'b00: cmd_set <= CMD17;\n                    2'b01: cmd_set <= ACMD13;\n                    default: cmd_set <= ACMD51;\n                endcase\n                rx_cycle <= 1;\n            end\n            \n            SEND_CMD: begin\n                if (tx_cycle) begin\n                    d_write <= 1;\n                end else if (rx_cycle) begin\n                    d_read <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n            \n            RECIVE_CMD: begin\n                if (rx_cycle) begin\n                    start_rx_fifo <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    if (cmd_tsf_err) begin\n                        rec_failed <= 1;\n                    end else begin\n                        // Check card status\n                        if (card_status[0] == 1 || \n                            (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) begin\n                            rec_done <= 1;\n                        end else begin\n                            rec_failed <= 1;\n                        end\n                    end\n                end\n            end\n            \n            DATA_TRANSFER: begin\n                if (tx_cycle) begin\n                    if (tx_empt) begin\n                        trans_failed <= 1;\n                        Dat_Int_Status[0] <= 1; // Underrun error\n                    end\n                end else if (rx_cycle) begin\n                    if (rx_full) begin\n                        trans_failed <= 1;\n                        Dat_Int_Status[1] <= 1; // Overrun error\n                    end\n                end\n                \n                if (internal_transm_complete) begin\n                    if (crc_ok) begin\n                        trans_done <= 1;\n                        ack_transfer <= 1;\n                        if (tx_cycle) begin\n                            a_cmp_tx <= 1;\n                        end else begin\n                            a_cmp_rx <= 1;\n                        end\n                        Dat_Int_Status[7] <= 1; // Transfer complete\n                    end else begin\n                        trans_failed <= 1;\n                        Dat_Int_Status[2] <= 1; // CRC error\n                    end\n                    internal_transm_complete <= 0;\n                end\n            end\n            \n            STOP: begin\n                cmd_set <= CMD12;\n                rec_done <= 0;\n                rec_failed <= 0;\n                send_done <= 0;\n                trans_failed <= 0;\n                trans_done <= 0;\n                d_read <= 1;\n                d_write <= 1;\n                start_rx_fifo <= 0;\n                start_tx_fifo <= 0;\n            end\n            \n            STOP_SEND: begin\n                resend_try_cnt <= resend_try_cnt + 1;\n                if (resend_try_cnt == RESEND_MAX_CNT) begin\n                    Dat_Int_Status[1] <= 1; // Overrun error\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n// Parameters\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'hC1A;\nparameter ACMD13 = 16'hD1A;\nparameter ACMD51 = 16'h331A;\nparameter SIZE = 9;\n\nparameter IDLE         = 9'b000000001;\nparameter GET_TX_BD    = 9'b000000010;\nparameter GET_RX_BD    = 9'b000000100;\nparameter SEND_CMD     = 9'b000001000;\nparameter RECIVE_CMD   = 9'b000010000;\nparameter DATA_TRANSFER= 9'b000100000;\nparameter STOP         = 9'b001000000;\nparameter STOP_SEND    = 9'b010000000;\n\n// Internal signals\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [8:0] state;\nreg [8:0] next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\n\n`ifdef RAM_MEM_WIDTH_32\n    reg [1:0] bd_cnt;\n    parameter READ_CYCLE = 2;\n    parameter BD_EMPTY = BD_SIZE / 2;\n`else\n    reg [2:0] bd_cnt;\n    parameter READ_CYCLE = 4;\n    parameter BD_EMPTY = BD_SIZE / 4;\n`endif\n\n// FSM sequential logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM combinational logic\nalways @(*) begin\n    next_state = state;\n    case (state)\n        IDLE: begin\n            if (free_tx_bd != BD_EMPTY) begin\n                next_state = GET_TX_BD;\n            end else if (free_rx_bd != BD_EMPTY) begin\n                next_state = GET_RX_BD;\n            end\n        end\n        GET_TX_BD: begin\n            if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                next_state = SEND_CMD;\n            end\n        end\n        GET_RX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1) begin\n                next_state = SEND_CMD;\n            end\n        end\n        SEND_CMD: begin\n            if (send_done == 1) begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        RECIVE_CMD: begin\n            if (rec_done == 1) begin\n                next_state = DATA_TRANSFER;\n            end else if (rec_failed == 1) begin\n                next_state = SEND_CMD;\n            end\n        end\n        DATA_TRANSFER: begin\n            if (trans_done == 1) begin\n                next_state = IDLE;\n            end else if (trans_failed == 1) begin\n                next_state = STOP;\n            end\n        end\n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        STOP_SEND: begin\n            if (send_done == 1) begin\n                next_state = IDLE;\n            end\n        end\n    endcase\nend\n\n// Output logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        re_s_tx <= 0;\n        a_cmp_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        sys_adr <= 0;\n        ack_transfer <= 0;\n        Dat_Int_Status <= 0;\n        CIDAT <= 0;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n    end else begin\n        // Default values\n        re_s_tx <= 0;\n        re_s_rx <= 0;\n        we_req <= 0;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        ack_transfer <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        a_cmp_tx <= 0;\n        a_cmp_rx <= 0;\n\n        if (Dat_Int_Status_rst) begin\n            Dat_Int_Status <= 0;\n        end\n\n        case (state)\n            IDLE: begin\n                bd_cnt <= 0;\n                resend_try_cnt <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n            end\n            \n            GET_TX_BD: begin\n                tx_cycle <= 1;\n                re_s_tx <= 1;\n                \n                if (ack_i_s_tx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    \n                    `ifdef RAM_MEM_WIDTH_32\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_tx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                            cmd_set <= CMD24;\n                        end\n                    `else\n                        case (bd_cnt)\n                            0: sys_adr[15:0] <= dat_in_tx;\n                            1: sys_adr[31:16] <= dat_in_tx;\n                            2: cmd_arg[15:0] <= dat_in_tx;\n                            3: begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                                cmd_set <= CMD24;\n                            end\n                        endcase\n                    `endif\n                end\n            end\n            \n            GET_RX_BD: begin\n                rx_cycle <= 1;\n                re_s_rx <= 1;\n                \n                if (ack_i_s_rx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    \n                    `ifdef RAM_MEM_WIDTH_32\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_rx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_rx;\n                            case (transfer_type)\n                                2'b00: cmd_set <= CMD17;\n                                2'b01: cmd_set <= ACMD13;\n                                default: cmd_set <= ACMD51;\n                            endcase\n                        end\n                    `else\n                        case (bd_cnt)\n                            0: sys_adr[15:0] <= dat_in_rx;\n                            1: sys_adr[31:16] <= dat_in_rx;\n                            2: cmd_arg[15:0] <= dat_in_rx;\n                            3: begin\n                                cmd_arg[31:16] <= dat_in_rx;\n                                case (transfer_type)\n                                    2'b00: cmd_set <= CMD17;\n                                    2'b01: cmd_set <= ACMD13;\n                                    default: cmd_set <= ACMD51;\n                                endcase\n                            end\n                        endcase\n                    `endif\n                end\n            end\n            \n            SEND_CMD: begin\n                if (tx_cycle) d_write <= 1;\n                if (rx_cycle) d_read <= 1;\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n            \n            RECIVE_CMD: begin\n                if (rx_cycle) start_rx_fifo <= 1;\n                \n                if (!cmd_busy) begin\n                    if (cmd_tsf_err) begin\n                        rec_failed <= 1;\n                    end else if (card_status[0] == 1 || (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) begin\n                        rec_done <= 1;\n                    end\n                end\n            end\n            \n            DATA_TRANSFER: begin\n                if (tx_cycle && tx_empt) begin\n                    trans_failed <= 1;\n                    Dat_Int_Status[0] <= 1;\n                end\n                \n                if (rx_cycle && rx_full) begin\n                    trans_failed <= 1;\n                    Dat_Int_Status[0] <= 1;\n                end\n                \n                if (transm_complete) begin\n                    ack_transfer <= 1;\n                    if (crc_ok) begin\n                        trans_done <= 1;\n                        if (tx_cycle) a_cmp_tx <= 1;\n                        if (rx_cycle) a_cmp_rx <= 1;\n                    end else begin\n                        trans_failed <= 1;\n                        Dat_Int_Status[1] <= 1;\n                    end\n                end\n            end\n            \n            STOP: begin\n                cmd_set <= CMD12;\n                rec_done <= 0;\n                rec_failed <= 0;\n                send_done <= 0;\n                trans_failed <= 0;\n                trans_done <= 0;\n                d_read <= 1;\n                d_write <= 1;\n                start_rx_fifo <= 0;\n                start_tx_fifo <= 0;\n            end\n            \n            STOP_SEND: begin\n                resend_try_cnt <= resend_try_cnt + 1;\n                if (resend_try_cnt == RESEND_MAX_CNT) begin\n                    Dat_Int_Status[1] <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n        endcase\n        \n        // Track transmission complete\n        transm_complete_q <= transm_complete;\n        if (transm_complete && !transm_complete_q) begin\n            internal_transm_complete <= 1;\n        end else begin\n            internal_transm_complete <= 0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 15, "code": "module sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    \n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\nparameter SD_BUS_W = 4;\nparameter BIT_BLOCK = 512;\nparameter CRC_OFF = 16;\nparameter BIT_BLOCK_REC = 512;\nparameter BIT_CRC_CYCLE = 16;\nparameter LITTLE_ENDIAN = 1;\nparameter BIG_ENDIAN = 0;\nparameter SD_BUS_WIDTH_1 = 0;\nparameter SD_BUS_WIDTH_4 = 1;\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out [0:SD_BUS_W-1];\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// State definitions\nlocalparam IDLE       = 6'b000001;\nlocalparam WRITE_DAT  = 6'b000010;\nlocalparam WRITE_CRC  = 6'b000100;\nlocalparam WRITE_BUSY = 6'b001000;\nlocalparam READ_WAIT  = 6'b010000;\nlocalparam READ_DAT   = 6'b100000;\n\n// CRC generation modules\ngenerate\n    genvar i;\n    for (i = 0; i < SD_BUS_W; i = i + 1) begin : CRC_GEN\n        sd_crc_16 crc_inst (\n            .BITVAL(crc_in[i]),\n            .Enable(crc_en),\n            .CLK(sd_clk),\n            .RST(crc_rst),\n            .CRC(crc_out[i])\n        );\n    end\nendgenerate\n\n// ACK_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        ack_q <= 1'b0;\n        ack_transfer_int <= 1'b0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// FSM_COMBO block\nalways @(*) begin\n    next_state = state;\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b10) next_state = WRITE_DAT;\n            else if (start_dat == 2'b01) next_state = READ_WAIT;\n            else next_state = IDLE;\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == BIT_BLOCK) next_state = WRITE_CRC;\n            else next_state = WRITE_DAT;\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b001) next_state = WRITE_BUSY;\n            else next_state = WRITE_CRC;\n        end\n        WRITE_BUSY: begin\n            if (!busy_int) next_state = IDLE;\n            else next_state = WRITE_BUSY;\n        end\n        READ_WAIT: begin\n            if (!DAT_dat_i[0]) next_state = READ_DAT;\n            else next_state = READ_WAIT;\n        end\n        READ_DAT: begin\n            if (transf_cnt == BIT_BLOCK_REC + BIT_CRC_CYCLE) next_state = IDLE;\n            else next_state = READ_DAT;\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// START_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        q_start_bit <= 1'b1;\n    end else begin\n        if (!DAT_dat_i[0] && state == READ_WAIT)\n            q_start_bit <= 1'b0;\n        else\n            q_start_bit <= 1'b1;\n    end\nend\n\n// FSM_SEQ block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        write_buf_0 <= 32'b0;\n        write_buf_1 <= 32'b0;\n        DAT_oe_o <= 1'b0;\n        crc_en <= 1'b0;\n        crc_rst <= 1'b1;\n        transf_cnt <= 11'b0;\n        rd <= 1'b0;\n        last_din <= 4'b0;\n        crc_c <= 5'b0;\n        crc_in <= 4'b0;\n        DAT_dat_o <= 4'b0;\n        crc_status <= 3'b111;\n        crc_s <= 3'b0;\n        transm_complete <= 1'b0;\n        busy_n <= 1'b1;\n        we <= 1'b0;\n        data_out <= 4'b0;\n        crc_ok <= 1'b0;\n        busy_int <= 1'b0;\n        data_send_index <= 3'b0;\n        out_buff_ptr <= 1'b0;\n        in_buff_ptr <= 1'b0;\n        sd_data_out <= 32'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                crc_rst <= 1'b1;\n                crc_en <= 1'b0;\n                DAT_oe_o <= 1'b0;\n                transm_complete <= 1'b0;\n                busy_n <= 1'b1;\n                transf_cnt <= 11'b0;\n                crc_status <= 3'b111;\n                crc_c <= 5'b0;\n                data_send_index <= 3'b0;\n                out_buff_ptr <= 1'b0;\n                in_buff_ptr <= 1'b0;\n                \n                if (start_dat == 2'b10) begin\n                    write_buf_0 <= data_in;\n                    rd <= 1'b1;\n                end\n            end\n            \n            WRITE_DAT: begin\n                crc_rst <= 1'b0;\n                DAT_oe_o <= 1'b1;\n                \n                if (transf_cnt == 0) begin\n                    // Start bit\n                    DAT_dat_o <= 4'b0;\n                    crc_en <= 1'b0;\n                    transf_cnt <= transf_cnt + 1;\n                end else if (transf_cnt < BIT_BLOCK) begin\n                    if (transf_cnt[1:0] == 2'b00) begin\n                        if (out_buff_ptr == 0)\n                            sd_data_out <= write_buf_0;\n                        else\n                            sd_data_out <= write_buf_1;\n                    end\n                    \n                    if (transf_cnt[1:0] == 2'b01) begin\n                        last_din <= sd_data_out[3:0];\n                        DAT_dat_o <= sd_data_out[3:0];\n                        crc_in <= sd_data_out[3:0];\n                        crc_en <= 1'b1;\n                        sd_data_out <= {4'b0, sd_data_out[31:4]};\n                    end else begin\n                        crc_en <= 1'b0;\n                    end\n                    \n                    if (transf_cnt[4:0] == 5'b11111) begin\n                        out_buff_ptr <= ~out_buff_ptr;\n                        if (in_buff_ptr == out_buff_ptr) begin\n                            if (out_buff_ptr == 0)\n                                write_buf_1 <= data_in;\n                            else\n                                write_buf_0 <= data_in;\n                            rd <= 1'b1;\n                        end else begin\n                            rd <= 1'b0;\n                        end\n                        in_buff_ptr <= ~in_buff_ptr;\n                    end\n                    \n                    transf_cnt <= transf_cnt + 1;\n                end\n            end\n            \n            WRITE_CRC: begin\n                if (transf_cnt < BIT_BLOCK + BIT_CRC_CYCLE) begin\n                    if (transf_cnt == BIT_BLOCK) begin\n                        // Send CRC\n                        DAT_dat_o <= crc_out[0][15:12];\n                        crc_c <= 5'b1;\n                    end else if (crc_c < 4) begin\n                        DAT_dat_o <= crc_out[0][15 - crc_c*4 -:4];\n                        crc_c <= crc_c + 1;\n                    end\n                    \n                    if (transf_cnt == BIT_BLOCK + BIT_CRC_CYCLE - 1) begin\n                        // Stop bit\n                        DAT_dat_o <= 4'b1111;\n                        crc_status <= 3'b001;\n                    end\n                    \n                    transf_cnt <= transf_cnt + 1;\n                end\n            end\n            \n            WRITE_BUSY: begin\n                DAT_oe_o <= 1'b0;\n                transm_complete <= 1'b1;\n                busy_int <= DAT_dat_i[0];\n                busy_n <= ~DAT_dat_i[0];\n                \n                if (!DAT_dat_i[0]) begin\n                    crc_ok <= (crc_s == 3'b010);\n                end\n            end\n            \n            READ_WAIT: begin\n                crc_rst <= 1'b0;\n                crc_en <= 1'b1;\n                DAT_oe_o <= 1'b0;\n                transf_cnt <= 11'b0;\n            end\n            \n            READ_DAT: begin\n                if (transf_cnt < BIT_BLOCK_REC + BIT_CRC_CYCLE) begin\n                    if (transf_cnt >= 1 && transf_cnt <= BIT_BLOCK_REC) begin\n                        data_out <= DAT_dat_i;\n                        we <= 1'b1;\n                        crc_in <= DAT_dat_i;\n                    end else begin\n                        we <= 1'b0;\n                    end\n                    \n                    if (transf_cnt > BIT_BLOCK_REC && transf_cnt <= BIT_BLOCK_REC + BIT_CRC_CYCLE) begin\n                        // CRC check\n                        if (transf_cnt == BIT_BLOCK_REC + BIT_CRC_CYCLE) begin\n                            transm_complete <= 1'b1;\n                            busy_n <= 1'b0;\n                            crc_ok <= (crc_out[0] == {DAT_dat_i, last_din});\n                        end\n                    end\n                    \n                    transf_cnt <= transf_cnt + 1;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'b0;\n    end else if (Enable) begin\n        CRC[0] <= BITVAL ^ CRC[15];\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2];\n        CRC[4] <= CRC[3];\n        CRC[5] <= BITVAL ^ CRC[15] ^ CRC[4];\n        CRC[6] <= CRC[5];\n        CRC[7] <= CRC[6];\n        CRC[8] <= CRC[7];\n        CRC[9] <= CRC[8];\n        CRC[10] <= CRC[9];\n        CRC[11] <= CRC[10];\n        CRC[12] <= BITVAL ^ CRC[15] ^ CRC[11];\n        CRC[13] <= CRC[12];\n        CRC[14] <= CRC[13];\n        CRC[15] <= CRC[14];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 16, "code": "module sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    \n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\nparameter SD_BUS_W = 4;\nparameter BIT_BLOCK = 512;\nparameter CRC_OFF = 16;\nparameter BIT_BLOCK_REC = 512;\nparameter BIT_CRC_CYCLE = 16;\nparameter LITTLE_ENDIAN = 1;\nparameter BIG_ENDIAN = 0;\nparameter SD_BUS_WIDTH_1 = 1;\nparameter SD_BUS_WIDTH_4 = 4;\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out [0:SD_BUS_W-1];\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// State definitions\nlocalparam IDLE       = 6'b000001;\nlocalparam WRITE_DAT  = 6'b000010;\nlocalparam WRITE_CRC  = 6'b000100;\nlocalparam WRITE_BUSY = 6'b001000;\nlocalparam READ_WAIT  = 6'b010000;\nlocalparam READ_DAT   = 6'b100000;\n\n// CRC generation instances\ngenerate\ngenvar i;\nfor (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n    sd_crc_16 crc_inst (\n        .BITVAL(crc_in[i]),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out[i])\n    );\nend\nendgenerate\n\n// ACK_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        ack_q <= 1'b0;\n        ack_transfer_int <= 1'b0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// FSM_COMBO block\nalways @(*) begin\n    next_state = state;\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b10) next_state = WRITE_DAT;\n            else if (start_dat == 2'b01) next_state = READ_WAIT;\n            else next_state = IDLE;\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == BIT_BLOCK) next_state = WRITE_CRC;\n            else next_state = WRITE_DAT;\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b001) next_state = WRITE_BUSY;\n            else next_state = WRITE_CRC;\n        end\n        WRITE_BUSY: begin\n            if (!busy_int) next_state = IDLE;\n            else next_state = WRITE_BUSY;\n        end\n        READ_WAIT: begin\n            if (!DAT_dat_i[0]) next_state = READ_DAT;\n            else next_state = READ_WAIT;\n        end\n        READ_DAT: begin\n            if (transf_cnt == BIT_BLOCK_REC) next_state = IDLE;\n            else next_state = READ_DAT;\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// START_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        q_start_bit <= 1'b1;\n    end else begin\n        if (!DAT_dat_i[0] && (state == READ_WAIT))\n            q_start_bit <= 1'b0;\n        else\n            q_start_bit <= 1'b1;\n    end\nend\n\n// FSM_SEQ block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        write_buf_0 <= 32'b0;\n        write_buf_1 <= 32'b0;\n        DAT_oe_o <= 1'b0;\n        crc_en <= 1'b0;\n        crc_rst <= 1'b1;\n        transf_cnt <= 11'b0;\n        rd <= 1'b0;\n        last_din <= 4'b0;\n        crc_c <= 5'b0;\n        crc_in <= 4'b0;\n        DAT_dat_o <= 4'b0;\n        crc_status <= 3'b111;\n        crc_s <= 3'b0;\n        transm_complete <= 1'b0;\n        busy_n <= 1'b1;\n        we <= 1'b0;\n        data_out <= 4'b0;\n        crc_ok <= 1'b0;\n        busy_int <= 1'b0;\n        data_send_index <= 3'b0;\n        out_buff_ptr <= 1'b0;\n        in_buff_ptr <= 1'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                crc_rst <= 1'b1;\n                crc_en <= 1'b0;\n                DAT_oe_o <= 1'b0;\n                transm_complete <= 1'b0;\n                busy_n <= 1'b1;\n                transf_cnt <= 11'b0;\n                crc_c <= 5'b0;\n                crc_status <= 3'b111;\n                busy_int <= 1'b0;\n                \n                if (start_dat == 2'b10) begin\n                    write_buf_0 <= data_in;\n                    rd <= 1'b1;\n                end\n            end\n            \n            WRITE_DAT: begin\n                crc_rst <= 1'b0;\n                DAT_oe_o <= 1'b1;\n                \n                if (transf_cnt == 0) begin\n                    DAT_dat_o <= 4'b0; // Start bit\n                    crc_en <= 1'b0;\n                end else begin\n                    if (transf_cnt[1:0] == 2'b00) begin\n                        last_din <= sd_data_out[31:28];\n                        crc_in <= sd_data_out[31:28];\n                        sd_data_out <= {sd_data_out[27:0], 4'b0};\n                        data_send_index <= data_send_index + 1;\n                        crc_en <= 1'b1;\n                    end else begin\n                        crc_en <= 1'b0;\n                    end\n                    \n                    DAT_dat_o <= last_din;\n                    \n                    if (data_send_index == 7) begin\n                        out_buff_ptr <= ~out_buff_ptr;\n                        if (out_buff_ptr)\n                            sd_data_out <= write_buf_1;\n                        else\n                            sd_data_out <= write_buf_0;\n                        data_send_index <= 0;\n                    end\n                end\n                \n                transf_cnt <= transf_cnt + 1;\n                \n                if (transf_cnt[1:0] == 2'b11 && transf_cnt < BIT_BLOCK-1) begin\n                    if (in_buff_ptr) begin\n                        write_buf_1 <= data_in;\n                    end else begin\n                        write_buf_0 <= data_in;\n                    end\n                    in_buff_ptr <= ~in_buff_ptr;\n                    rd <= 1'b1;\n                end else begin\n                    rd <= 1'b0;\n                end\n            end\n            \n            WRITE_CRC: begin\n                if (transf_cnt < BIT_BLOCK + BIT_CRC_CYCLE) begin\n                    if (transf_cnt == BIT_BLOCK) begin\n                        DAT_dat_o <= crc_out[0][15:12];\n                    end else if (transf_cnt == BIT_BLOCK+1) begin\n                        DAT_dat_o <= crc_out[0][11:8];\n                    end else if (transf_cnt == BIT_BLOCK+2) begin\n                        DAT_dat_o <= crc_out[0][7:4];\n                    end else if (transf_cnt == BIT_BLOCK+3) begin\n                        DAT_dat_o <= crc_out[0][3:0];\n                    end else if (transf_cnt == BIT_BLOCK+4) begin\n                        DAT_dat_o <= 4'b1111; // Stop bit\n                    end\n                    \n                    transf_cnt <= transf_cnt + 1;\n                end else begin\n                    crc_status <= 3'b001;\n                end\n            end\n            \n            WRITE_BUSY: begin\n                DAT_oe_o <= 1'b0;\n                transm_complete <= 1'b1;\n                \n                if (crc_s == 3'b010) // CRC OK\n                    crc_ok <= 1'b1;\n                else\n                    crc_ok <= 1'b0;\n                \n                busy_int <= DAT_dat_i[0];\n                busy_n <= ~DAT_dat_i[0];\n            end\n            \n            READ_WAIT: begin\n                crc_rst <= 1'b0;\n                crc_en <= 1'b1;\n                DAT_oe_o <= 1'b0;\n                transf_cnt <= 11'b0;\n            end\n            \n            READ_DAT: begin\n                if (transf_cnt < BIT_BLOCK_REC) begin\n                    crc_in <= DAT_dat_i;\n                    data_out <= DAT_dat_i;\n                    we <= 1'b1;\n                    transf_cnt <= transf_cnt + 1;\n                end else begin\n                    we <= 1'b0;\n                    // CRC check would go here\n                    if (transf_cnt < BIT_BLOCK_REC + BIT_CRC_CYCLE) begin\n                        transf_cnt <= transf_cnt + 1;\n                    end else begin\n                        transm_complete <= 1'b1;\n                        busy_n <= 1'b0;\n                    end\n                end\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n    // CRC-16 implementation would go here\n    // This is a placeholder for the actual CRC calculation logic\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            // CRC calculation logic would go here\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 18, "code": "module sd_controller_wb (\n    // Wishbone interface\n    input               wb_clk_i,\n    input               wb_rst_i,\n    input      [31:0]   wb_dat_i,\n    output reg [31:0]   wb_dat_o,\n    input      [7:0]    wb_adr_i,\n    input      [3:0]    wb_sel_i,\n    input               wb_we_i,\n    input               wb_cyc_i,\n    input               wb_stb_i,\n    output reg          wb_ack_o,\n    \n    // Control signals\n    output reg          we_m_tx_bd,\n    output reg          we_m_rx_bd,\n    output reg          new_cmd,\n    output reg          we_ack,\n    output reg          int_ack,\n    output reg          cmd_int_busy,\n    output reg          int_busy,\n    \n    // Data master interface\n    input               write_req_s,\n    input      [15:0]   cmd_set_s,\n    input      [32:0]   cmd_arg_s,\n    \n    // Registers\n    output reg [31:0]   argument_reg,\n    output reg [15:0]   cmd_setting_reg,\n    input      [15:0]   status_reg,\n    input      [31:0]   cmd_resp_1,\n    output reg [7:0]    software_reset_reg,\n    output reg [16:0]   time_out_reg,\n    input      [15:0]   normal_int_status_reg,\n    input      [15:0]   error_int_status_reg,\n    output reg [15:0]   normal_int_signal_enable_reg,\n    output reg [15:0]   error_int_signal_enable_reg,\n    output reg [7:0]    clock_divider,\n    input      [15:0]   Bd_Status_reg,\n    input      [8:0]    Bd_isr_reg,\n    output reg [8:0]    Bd_isr_enable_reg,\n    output reg          Bd_isr_reset,\n    output reg          normal_isr_reset,\n    output reg          error_isr_reset,\n    \n    // BD data\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\nparameter RAM_MEM_WIDTH = 32; // Default to 32-bit width\n\n// Internal signals\nreg [1:0] bd_write_state;\nreg [31:0] bd_write_data;\nreg bd_write_upper;\n\n// Reset and initialization\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to default values\n        argument_reg <= 32'h0000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        \n        // Reset control signals\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        wb_ack_o <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        \n        // Reset BD write state\n        bd_write_state <= 2'b00;\n        bd_write_data <= 32'h0000;\n        bd_write_upper <= 1'b0;\n    end\n    else begin\n        // Default values\n        wb_ack_o <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        \n        // Handle data master write requests\n        if (write_req_s) begin\n            argument_reg <= cmd_arg_s;\n            cmd_setting_reg <= cmd_set_s;\n            new_cmd <= 1'b1;\n            we_ack <= 1'b1;\n            cmd_int_busy <= 1'b1;\n        end\n        else begin\n            cmd_int_busy <= 1'b0;\n        end\n        \n        // Wishbone access\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o && int_ack) begin\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: begin // Argument register\n                        argument_reg <= wb_dat_i;\n                        int_busy <= 1'b1;\n                    end\n                    8'h04: begin // Command setting register\n                        cmd_setting_reg <= wb_dat_i[15:0];\n                    end\n                    8'h28: begin // Software reset register\n                        software_reset_reg <= wb_dat_i[7:0];\n                    end\n                    8'h2c: begin // Timeout register\n                        time_out_reg <= wb_dat_i[15:0];\n                    end\n                    8'h30: begin // Normal interrupt status register\n                        normal_isr_reset <= 1'b1;\n                    end\n                    8'h34: begin // Error interrupt status register\n                        error_isr_reset <= 1'b1;\n                    end\n                    8'h38: begin // Normal interrupt enable register\n                        normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    end\n                    8'h3c: begin // Error interrupt enable register\n                        error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    end\n                    8'h4c: begin // Clock divider register\n                        clock_divider <= wb_dat_i[7:0];\n                    end\n                    8'h54: begin // Data interrupt status register\n                        Bd_isr_reset <= 1'b1;\n                    end\n                    8'h58: begin // Data interrupt enable register\n                        Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    end\n                    8'h60: begin // BD RX\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                            we_m_rx_bd <= 1'b1;\n                            wb_ack_o <= 1'b1;\n                        end\n                        else begin // 16-bit\n                            if (!bd_write_upper) begin\n                                bd_write_data[15:0] <= wb_dat_i[15:0];\n                                bd_write_upper <= 1'b1;\n                                int_ack <= 1'b0;\n                            end\n                            else begin\n                                dat_in_m_rx_bd <= {wb_dat_i[15:0], bd_write_data[15:0]};\n                                we_m_rx_bd <= 1'b1;\n                                bd_write_upper <= 1'b0;\n                                int_ack <= 1'b1;\n                                wb_ack_o <= 1'b1;\n                            end\n                        end\n                    end\n                    8'h80: begin // BD TX\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                            we_m_tx_bd <= 1'b1;\n                            wb_ack_o <= 1'b1;\n                        end\n                        else begin // 16-bit\n                            if (!bd_write_upper) begin\n                                bd_write_data[15:0] <= wb_dat_i[15:0];\n                                bd_write_upper <= 1'b1;\n                                int_ack <= 1'b0;\n                            end\n                            else begin\n                                dat_in_m_tx_bd <= {wb_dat_i[15:0], bd_write_data[15:0]};\n                                we_m_tx_bd <= 1'b1;\n                                bd_write_upper <= 1'b0;\n                                int_ack <= 1'b1;\n                                wb_ack_o <= 1'b1;\n                            end\n                        end\n                    end\n                    default: wb_ack_o <= 1'b1;\n                endcase\n            end\n            else begin\n                // Read operation\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0000, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= 32'h0000; // Controller setting (not used)\n                    8'h20: wb_dat_o <= {16'h0000, 16'h0200}; // Block size (fixed to 512)\n                    8'h24: wb_dat_o <= {24'h000000, 8'h0f}; // Power control (fixed to 3.3V)\n                    8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0000, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h0000; // Capability (not used)\n                    8'h4c: wb_dat_o <= {24'h000000, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'h0000;\n                endcase\n                wb_ack_o <= 1'b1;\n            end\n        end\n        \n        // Reset write enable signals after one clock cycle\n        if (we_m_rx_bd) we_m_rx_bd <= 1'b0;\n        if (we_m_tx_bd) we_m_tx_bd <= 1'b0;\n        \n        // Reset interrupt busy after command is processed\n        if (int_busy && !wb_cyc_i) int_busy <= 1'b0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 13, "code": "module sd_data_master (\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n// Parameters\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'hC1A;\nparameter ACMD13 = 16'hD1A;\nparameter ACMD51 = 16'h331A;\nparameter SIZE = 9;\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\nparameter RESEND_MAX_CNT = 3;\n\n// Internal signals\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\nreg [2:0] bd_cnt;\n\n// State machine\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (free_tx_bd != (BD_SIZE/2)) begin\n                next_state = GET_TX_BD;\n            end else if (free_rx_bd != (BD_SIZE/2)) begin\n                next_state = GET_RX_BD;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        GET_TX_BD: begin\n            if (bd_cnt > (RAM_MEM_WIDTH == 32 ? 1 : 3) && tx_full) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_TX_BD;\n            end\n        end\n        GET_RX_BD: begin\n            if (bd_cnt >= (RAM_MEM_WIDTH == 32 ? 1 : 3)) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_RX_BD;\n            end\n        end\n        SEND_CMD: begin\n            if (send_done) begin\n                next_state = RECIVE_CMD;\n            end else begin\n                next_state = SEND_CMD;\n            end\n        end\n        RECIVE_CMD: begin\n            if (rec_done) begin\n                next_state = DATA_TRANSFER;\n            end else if (rec_failed) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        DATA_TRANSFER: begin\n            if (trans_done) begin\n                next_state = IDLE;\n            end else if (trans_failed) begin\n                next_state = STOP;\n            end else begin\n                next_state = DATA_TRANSFER;\n            end\n        end\n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        STOP_SEND: begin\n            if (send_done) begin\n                next_state = IDLE;\n            end else begin\n                next_state = STOP_SEND;\n            end\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// Output logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all outputs\n        re_s_tx <= 0;\n        a_cmp_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        sys_adr <= 0;\n        ack_transfer <= 0;\n        Dat_Int_Status <= 0;\n        CIDAT <= 0;\n        \n        // Reset internal signals\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n    end else begin\n        // Default outputs\n        re_s_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_tx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        ack_transfer <= 0;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        \n        // Handle Dat_Int_Status reset\n        if (Dat_Int_Status_rst) begin\n            Dat_Int_Status <= 0;\n        end\n        \n        case (state)\n            IDLE: begin\n                // Reset cycle flags\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                bd_cnt <= 0;\n            end\n            \n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                if (ack_i_s_tx) begin\n                    if (RAM_MEM_WIDTH == 32) begin\n                        case (bd_cnt)\n                            0: sys_adr <= dat_in_tx;\n                            1: begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                                cmd_set <= CMD24;\n                                tx_cycle <= 1;\n                            end\n                        endcase\n                    end else begin\n                        case (bd_cnt)\n                            0: sys_adr[15:0] <= dat_in_tx;\n                            1: sys_adr[31:16] <= dat_in_tx;\n                            2: cmd_arg[15:0] <= dat_in_tx;\n                            3: begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                                cmd_set <= CMD24;\n                                tx_cycle <= 1;\n                            end\n                        endcase\n                    end\n                    bd_cnt <= bd_cnt + 1;\n                end\n            end\n            \n            GET_RX_BD: begin\n                re_s_rx <= 1;\n                if (ack_i_s_rx) begin\n                    if (RAM_MEM_WIDTH == 32) begin\n                        case (bd_cnt)\n                            0: sys_adr <= dat_in_rx;\n                            1: begin\n                                cmd_arg <= dat_in_rx;\n                                case (transfer_type)\n                                    2'b00: cmd_set <= CMD17;\n                                    2'b01: cmd_set <= ACMD13;\n                                    default: cmd_set <= ACMD51;\n                                endcase\n                                rx_cycle <= 1;\n                            end\n                        endcase\n                    end else begin\n                        case (bd_cnt)\n                            0: sys_adr[15:0] <= dat_in_rx;\n                            1: sys_adr[31:16] <= dat_in_rx;\n                            2: cmd_arg[15:0] <= dat_in_rx;\n                            3: begin\n                                cmd_arg[31:16] <= dat_in_rx;\n                                case (transfer_type)\n                                    2'b00: cmd_set <= CMD17;\n                                    2'b01: cmd_set <= ACMD13;\n                                    default: cmd_set <= ACMD51;\n                                endcase\n                                rx_cycle <= 1;\n                            end\n                        endcase\n                    end\n                    bd_cnt <= bd_cnt + 1;\n                end\n            end\n            \n            SEND_CMD: begin\n                if (tx_cycle) d_write <= 1;\n                if (rx_cycle) d_read <= 1;\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n            \n            RECIVE_CMD: begin\n                if (rx_cycle) start_rx_fifo <= 1;\n                \n                if (!cmd_busy) begin\n                    if (cmd_tsf_err) begin\n                        rec_failed <= 1;\n                    end else if (card_status[0] && (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) begin\n                        rec_done <= 1;\n                    end\n                end\n            end\n            \n            DATA_TRANSFER: begin\n                if (tx_cycle && tx_empt) begin\n                    trans_failed <= 1;\n                    Dat_Int_Status[0] <= 1; // Underrun error\n                end\n                \n                if (rx_cycle && rx_full) begin\n                    trans_failed <= 1;\n                    Dat_Int_Status[1] <= 1; // Overrun error\n                end\n                \n                if (transm_complete) begin\n                    if (crc_ok) begin\n                        trans_done <= 1;\n                        ack_transfer <= 1;\n                        if (tx_cycle) a_cmp_tx <= 1;\n                        if (rx_cycle) a_cmp_rx <= 1;\n                        Dat_Int_Status[7] <= 1; // Transfer complete\n                    end else begin\n                        trans_failed <= 1;\n                        Dat_Int_Status[2] <= 1; // CRC error\n                    end\n                end\n            end\n            \n            STOP: begin\n                cmd_set <= CMD12;\n                rec_done <= 0;\n                rec_failed <= 0;\n                send_done <= 0;\n                trans_failed <= 0;\n                trans_done <= 0;\n                d_read <= 1;\n                d_write <= 1;\n                start_rx_fifo <= 0;\n                start_tx_fifo <= 0;\n            end\n            \n            STOP_SEND: begin\n                resend_try_cnt <= resend_try_cnt + 1;\n                if (resend_try_cnt == RESEND_MAX_CNT) begin\n                    Dat_Int_Status[1] <= 1; // Overrun error\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n        endcase\n        \n        // Track transmission complete\n        transm_complete_q <= transm_complete;\n        if (transm_complete && !transm_complete_q) begin\n            internal_transm_complete <= 1;\n        end else begin\n            internal_transm_complete <= 0;\n        end\n        \n        // Update CIDAT based on busy_n\n        CIDAT <= ~busy_n;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 14, "code": "module sd_data_master (\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n// Parameters\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'h0C1A;\nparameter ACMD13 = 16'h0D1A;\nparameter ACMD51 = 16'h331A;\nparameter SIZE = 9;\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\nparameter RESEND_MAX_CNT = 3;\n\n// Internal signals\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\n`ifdef RAM_MEM_WIDTH_32\n    reg [1:0] bd_cnt;\n    parameter READ_CYCLE = 2;\n    parameter BD_EMPTY = BD_SIZE / 2;\n`else\n    reg [2:0] bd_cnt;\n    parameter READ_CYCLE = 4;\n    parameter BD_EMPTY = BD_SIZE / 4;\n`endif\n\n// FSM sequential logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM combinational logic\nalways @(*) begin\n    next_state = state;\n    case (state)\n        IDLE: begin\n            if (free_tx_bd != BD_EMPTY) begin\n                next_state = GET_TX_BD;\n            end else if (free_rx_bd != BD_EMPTY) begin\n                next_state = GET_RX_BD;\n            end\n        end\n        GET_TX_BD: begin\n            if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                next_state = SEND_CMD;\n            end\n        end\n        GET_RX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1) begin\n                next_state = SEND_CMD;\n            end\n        end\n        SEND_CMD: begin\n            if (send_done) begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        RECIVE_CMD: begin\n            if (rec_done) begin\n                next_state = DATA_TRANSFER;\n            end else if (rec_failed) begin\n                next_state = SEND_CMD;\n            end\n        end\n        DATA_TRANSFER: begin\n            if (trans_done) begin\n                next_state = IDLE;\n            end else if (trans_failed) begin\n                next_state = STOP;\n            end\n        end\n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        STOP_SEND: begin\n            if (send_done) begin\n                next_state = IDLE;\n            end\n        end\n    endcase\nend\n\n// Output logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all outputs\n        re_s_tx <= 0;\n        a_cmp_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        sys_adr <= 0;\n        ack_transfer <= 0;\n        Dat_Int_Status <= 0;\n        CIDAT <= 0;\n        \n        // Reset internal signals\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n    end else begin\n        // Default values\n        re_s_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_tx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        ack_transfer <= 0;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        \n        // State-specific behavior\n        case (state)\n            IDLE: begin\n                bd_cnt <= 0;\n                resend_try_cnt <= 0;\n            end\n            \n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                if (ack_i_s_tx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    if (bd_cnt == 0) begin\n                        sys_adr <= dat_in_tx;\n                    end else if (bd_cnt == 1) begin\n                        cmd_arg <= dat_in_tx;\n                        start_tx_fifo <= 1;\n                    end\n                end\n                cmd_set <= CMD24;\n                tx_cycle <= 1;\n            end\n            \n            GET_RX_BD: begin\n                re_s_rx <= 1;\n                if (ack_i_s_rx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    if (bd_cnt == 0) begin\n                        sys_adr <= dat_in_rx;\n                    end else if (bd_cnt == 1) begin\n                        cmd_arg <= dat_in_rx;\n                    end\n                end\n                case (transfer_type)\n                    2'b00: cmd_set <= CMD17;\n                    2'b01: cmd_set <= ACMD13;\n                    default: cmd_set <= ACMD51;\n                endcase\n                rx_cycle <= 1;\n            end\n            \n            SEND_CMD: begin\n                if (tx_cycle) begin\n                    d_write <= 1;\n                end else if (rx_cycle) begin\n                    d_read <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n            \n            RECIVE_CMD: begin\n                if (rx_cycle) begin\n                    start_rx_fifo <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    if (cmd_tsf_err) begin\n                        rec_failed <= 1;\n                    end else if (card_status[0] == 1 || \n                               (card_status[4:1] == 4 || \n                                card_status[4:1] == 5 || \n                                card_status[4:1] == 6)) begin\n                        rec_done <= 1;\n                    end\n                end\n            end\n            \n            DATA_TRANSFER: begin\n                if (tx_cycle && tx_empt) begin\n                    trans_failed <= 1;\n                end else if (rx_cycle && rx_full) begin\n                    trans_failed <= 1;\n                end\n                \n                if (transm_complete) begin\n                    ack_transfer <= 1;\n                    if (crc_ok) begin\n                        trans_done <= 1;\n                        if (tx_cycle) begin\n                            a_cmp_tx <= 1;\n                        end else if (rx_cycle) begin\n                            a_cmp_rx <= 1;\n                        end\n                    end else begin\n                        trans_failed <= 1;\n                    end\n                end\n            end\n            \n            STOP: begin\n                cmd_set <= CMD12;\n                d_read <= 1;\n                d_write <= 1;\n            end\n            \n            STOP_SEND: begin\n                resend_try_cnt <= resend_try_cnt + 1;\n                if (resend_try_cnt == RESEND_MAX_CNT) begin\n                    Dat_Int_Status[1] <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n        endcase\n        \n        // Update transmission complete tracking\n        transm_complete_q <= transm_complete;\n        internal_transm_complete <= transm_complete && !transm_complete_q;\n        \n        // Handle Dat_Int_Status reset\n        if (Dat_Int_Status_rst) begin\n            Dat_Int_Status <= 0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    \n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out [SD_BUS_W-1:0];\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// State definitions\nlocalparam IDLE       = 6'b000001;\nlocalparam WRITE_DAT  = 6'b000010;\nlocalparam WRITE_CRC  = 6'b000100;\nlocalparam WRITE_BUSY = 6'b001000;\nlocalparam READ_WAIT  = 6'b010000;\nlocalparam READ_DAT   = 6'b100000;\n\n// CRC generation instances\ngenerate\ngenvar i;\nfor (i = 0; i < SD_BUS_W; i = i + 1) begin : CRC_GEN\n    sd_crc_16 crc_inst (\n        .BITVAL(crc_in[i]),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out[i])\n    );\nend\nendgenerate\n\n// ACK_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        ack_transfer_int <= 1'b0;\n        ack_q <= 1'b0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// FSM_COMBO block\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b10) next_state = WRITE_DAT;\n            else if (start_dat == 2'b01) next_state = READ_WAIT;\n            else next_state = IDLE;\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == SD_BUS_W) next_state = WRITE_CRC;\n            else next_state = WRITE_DAT;\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b001) next_state = WRITE_BUSY;\n            else next_state = WRITE_CRC;\n        end\n        WRITE_BUSY: begin\n            if (!busy_int) next_state = IDLE;\n            else next_state = WRITE_BUSY;\n        end\n        READ_WAIT: begin\n            if (!DAT_dat_i[0]) next_state = READ_DAT;\n            else next_state = READ_WAIT;\n        end\n        READ_DAT: begin\n            if (transf_cnt == SD_BUS_W) next_state = IDLE;\n            else next_state = READ_DAT;\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// START_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        q_start_bit <= 1'b1;\n    end else begin\n        if (!DAT_dat_i[0] && state == READ_WAIT)\n            q_start_bit <= 1'b0;\n        else\n            q_start_bit <= 1'b1;\n    end\nend\n\n// FSM_SEQ block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        write_buf_0 <= 32'b0;\n        write_buf_1 <= 32'b0;\n        DAT_oe_o <= 1'b0;\n        crc_en <= 1'b0;\n        crc_rst <= 1'b1;\n        transf_cnt <= 11'b0;\n        rd <= 1'b0;\n        last_din <= 4'b0;\n        crc_c <= 5'b0;\n        crc_in <= {SD_BUS_W{1'b0}};\n        DAT_dat_o <= {SD_BUS_W{1'b0}};\n        crc_status <= 3'b111;\n        crc_s <= 3'b0;\n        transm_complete <= 1'b0;\n        busy_n <= 1'b1;\n        we <= 1'b0;\n        data_out <= {SD_BUS_W{1'b0}};\n        crc_ok <= 1'b0;\n        busy_int <= 1'b0;\n        data_send_index <= 3'b0;\n        out_buff_ptr <= 1'b0;\n        in_buff_ptr <= 1'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                crc_rst <= 1'b1;\n                crc_en <= 1'b0;\n                DAT_oe_o <= 1'b0;\n                transm_complete <= 1'b0;\n                busy_n <= 1'b1;\n                transf_cnt <= 11'b0;\n                crc_c <= 5'b0;\n                crc_status <= 3'b111;\n                busy_int <= 1'b0;\n                \n                if (start_dat == 2'b10) begin\n                    write_buf_0 <= data_in;\n                    write_buf_1 <= data_in;\n                    out_buff_ptr <= 1'b0;\n                    in_buff_ptr <= 1'b0;\n                    rd <= 1'b1;\n                end\n            end\n            \n            WRITE_DAT: begin\n                crc_rst <= 1'b0;\n                DAT_oe_o <= 1'b1;\n                rd <= 1'b0;\n                \n                if (transf_cnt == 0) begin\n                    DAT_dat_o <= {SD_BUS_W{1'b0}}; // Start bit\n                    crc_en <= 1'b0;\n                end else begin\n                    if (transf_cnt[2:0] == 3'b000) begin\n                        if (out_buff_ptr) sd_data_out <= write_buf_1;\n                        else sd_data_out <= write_buf_0;\n                        out_buff_ptr <= ~out_buff_ptr;\n                        rd <= 1'b1;\n                    end else begin\n                        rd <= 1'b0;\n                    end\n                    \n                    last_din <= sd_data_out[3:0];\n                    crc_in <= sd_data_out[3:0];\n                    DAT_dat_o <= sd_data_out[3:0];\n                    sd_data_out <= {4'b0, sd_data_out[31:4]};\n                    crc_en <= 1'b1;\n                end\n                \n                transf_cnt <= transf_cnt + 1;\n            end\n            \n            WRITE_CRC: begin\n                if (transf_cnt < 16) begin\n                    DAT_dat_o <= crc_out[0][15 - transf_cnt[3:0]];\n                    transf_cnt <= transf_cnt + 1;\n                end else begin\n                    DAT_dat_o <= {SD_BUS_W{1'b1}}; // Stop bit\n                    crc_status <= 3'b001;\n                end\n            end\n            \n            WRITE_BUSY: begin\n                DAT_oe_o <= 1'b0;\n                transm_complete <= 1'b1;\n                busy_int <= DAT_dat_i[0];\n                busy_n <= ~DAT_dat_i[0];\n                \n                if (crc_s == 3'b010) crc_ok <= 1'b1;\n                else crc_ok <= 1'b0;\n            end\n            \n            READ_WAIT: begin\n                crc_rst <= 1'b0;\n                crc_en <= 1'b1;\n                DAT_oe_o <= 1'b0;\n                transf_cnt <= 11'b0;\n            end\n            \n            READ_DAT: begin\n                if (transf_cnt < 512*8/SD_BUS_W) begin\n                    crc_in <= DAT_dat_i;\n                    data_out <= DAT_dat_i;\n                    we <= 1'b1;\n                    transf_cnt <= transf_cnt + 1;\n                end else begin\n                    we <= 1'b0;\n                    if (transf_cnt < (512*8/SD_BUS_W + 16)) begin\n                        // CRC check logic would go here\n                        transf_cnt <= transf_cnt + 1;\n                    end else begin\n                        transm_complete <= 1'b1;\n                        busy_n <= 1'b0;\n                    end\n                end\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'b0;\n    end else if (Enable) begin\n        CRC[0] <= CRC[15] ^ BITVAL;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2];\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4] ^ (CRC[15] ^ BITVAL);\n        CRC[6] <= CRC[5];\n        CRC[7] <= CRC[6];\n        CRC[8] <= CRC[7];\n        CRC[9] <= CRC[8];\n        CRC[10] <= CRC[9];\n        CRC[11] <= CRC[10];\n        CRC[12] <= CRC[11] ^ (CRC[15] ^ BITVAL);\n        CRC[13] <= CRC[12];\n        CRC[14] <= CRC[13];\n        CRC[15] <= CRC[14];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 19, "code": "module sd_controller_wb (\n    // Wishbone interface\n    input               wb_clk_i,\n    input               wb_rst_i,\n    input      [31:0]   wb_dat_i,\n    output reg [31:0]   wb_dat_o,\n    input      [7:0]    wb_adr_i,\n    input      [3:0]    wb_sel_i,\n    input               wb_we_i,\n    input               wb_cyc_i,\n    input               wb_stb_i,\n    output reg          wb_ack_o,\n    \n    // Control signals\n    output reg          we_m_tx_bd,\n    output reg          we_m_rx_bd,\n    output reg          new_cmd,\n    output reg          we_ack,\n    output reg          int_ack,\n    output reg          cmd_int_busy,\n    output reg          int_busy,\n    \n    // Data master interface\n    input               write_req_s,\n    input      [15:0]   cmd_set_s,\n    input      [32:0]   cmd_arg_s,\n    \n    // Registers\n    output reg [31:0]   argument_reg,\n    output reg [15:0]   cmd_setting_reg,\n    input      [15:0]   status_reg,\n    input      [31:0]   cmd_resp_1,\n    output reg [7:0]    software_reset_reg,\n    output reg [16:0]   time_out_reg,\n    input      [15:0]   normal_int_status_reg,\n    input      [15:0]   error_int_status_reg,\n    output reg [15:0]   normal_int_signal_enable_reg,\n    output reg [15:0]   error_int_signal_enable_reg,\n    output reg [7:0]    clock_divider,\n    input      [15:0]   Bd_Status_reg,\n    input      [8:0]    Bd_isr_reg,\n    output reg [8:0]    Bd_isr_enable_reg,\n    \n    // Interrupt reset signals\n    output reg          Bd_isr_reset,\n    output reg          normal_isr_reset,\n    output reg          error_isr_reset,\n    \n    // BD data\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\nparameter RAM_MEM_WIDTH = 32; // Default to 32-bit width\n\n// Internal signals\nreg [1:0] bd_write_state;\nreg [31:0] bd_temp_data;\n\n// Register read/write operations\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to default values\n        argument_reg <= 32'h0;\n        cmd_setting_reg <= 16'h0;\n        software_reset_reg <= 8'h0;\n        time_out_reg <= 16'h0;\n        normal_int_signal_enable_reg <= 16'h0;\n        error_int_signal_enable_reg <= 16'h0;\n        clock_divider <= 8'h0;\n        Bd_isr_enable_reg <= 8'h0;\n        \n        // Reset control signals\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        wb_ack_o <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        bd_write_state <= 2'b0;\n    end\n    else begin\n        // Default values\n        wb_ack_o <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        \n        // Handle data master interface\n        if (write_req_s) begin\n            argument_reg <= cmd_arg_s;\n            cmd_setting_reg <= cmd_set_s;\n            new_cmd <= 1'b1;\n            we_ack <= 1'b1;\n            cmd_int_busy <= 1'b1;\n        end else begin\n            cmd_int_busy <= 1'b0;\n        end\n        \n        // Handle Wishbone interface\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: begin // Argument register\n                        argument_reg <= wb_dat_i;\n                        int_busy <= 1'b1;\n                    end\n                    8'h04: begin // Command setting register\n                        cmd_setting_reg <= wb_dat_i[15:0];\n                    end\n                    8'h28: begin // Software reset\n                        software_reset_reg <= wb_dat_i[7:0];\n                    end\n                    8'h2c: begin // Timeout register\n                        time_out_reg <= wb_dat_i[15:0];\n                    end\n                    8'h30: begin // Normal interrupt status\n                        normal_isr_reset <= 1'b1;\n                    end\n                    8'h34: begin // Error interrupt status\n                        error_isr_reset <= 1'b1;\n                    end\n                    8'h38: begin // Normal interrupt enable\n                        normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    end\n                    8'h3c: begin // Error interrupt enable\n                        error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    end\n                    8'h4c: begin // Clock divider\n                        clock_divider <= wb_dat_i[7:0];\n                    end\n                    8'h54: begin // Data interrupt status\n                        Bd_isr_reset <= 1'b1;\n                    end\n                    8'h58: begin // Data interrupt enable\n                        Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    end\n                    8'h60: begin // BD RX\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                            we_m_rx_bd <= 1'b1;\n                            wb_ack_o <= 1'b1;\n                        end else begin\n                            if (bd_write_state == 2'b00) begin\n                                bd_temp_data[15:0] <= wb_dat_i[15:0];\n                                bd_write_state <= 2'b01;\n                                int_ack <= 1'b0;\n                            end else begin\n                                dat_in_m_rx_bd <= wb_dat_i[15:0];\n                                we_m_rx_bd <= 1'b1;\n                                bd_write_state <= 2'b00;\n                                int_ack <= 1'b1;\n                                wb_ack_o <= 1'b1;\n                            end\n                        end\n                    end\n                    8'h80: begin // BD TX\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                            we_m_tx_bd <= 1'b1;\n                            wb_ack_o <= 1'b1;\n                        end else begin\n                            if (bd_write_state == 2'b00) begin\n                                bd_temp_data[15:0] <= wb_dat_i[15:0];\n                                bd_write_state <= 2'b01;\n                                int_ack <= 1'b0;\n                            end else begin\n                                dat_in_m_tx_bd <= wb_dat_i[15:0];\n                                we_m_tx_bd <= 1'b1;\n                                bd_write_state <= 2'b00;\n                                int_ack <= 1'b1;\n                                wb_ack_o <= 1'b1;\n                            end\n                        end\n                    end\n                endcase\n                \n                // For non-BD writes, acknowledge immediately\n                if (!(wb_adr_i == 8'h60 || wb_adr_i == 8'h80) || (RAM_MEM_WIDTH == 32 && (wb_adr_i == 8'h60 || wb_adr_i == 8'h80))) begin\n                    wb_ack_o <= 1'b1;\n                end\n            end\n            else begin\n                // Read operation\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= 32'h0; // Controller setting (not used)\n                    8'h20: wb_dat_o <= {20'h0, 12'h200}; // Block size (fixed to 512)\n                    8'h24: wb_dat_o <= {24'h0, 8'h0f}; // Power control (fixed to 3.3V)\n                    8'h28: wb_dat_o <= {24'h0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h0; // Capability (not used)\n                    8'h4c: wb_dat_o <= {24'h0, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {23'h0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {23'h0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'h0;\n                endcase\n                wb_ack_o <= 1'b1;\n            end\n        end\n        \n        // Reset write enables after one cycle\n        if (we_m_tx_bd) we_m_tx_bd <= 1'b0;\n        if (we_m_rx_bd) we_m_rx_bd <= 1'b0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sdc_controller (\n    // Wishbone Slave Interface\n    input               wb_clk_i,\n    input               wb_rst_i,\n    input       [3:0]   wb_sel_i,\n    input       [31:0]  wb_dat_i,\n    output      [31:0]  wb_dat_o,\n    input       [7:0]   wb_adr_i,\n    input               wb_we_i,\n    input               wb_cyc_i,\n    input               wb_stb_i,\n    output              wb_ack_o,\n    \n    // Wishbone Master Interface\n    output      [31:0]  m_wb_adr_o,\n    output              m_wb_sel_o,\n    output              m_wb_we_o,\n    output      [31:0]  m_wb_dat_o,\n    input       [31:0]  m_wb_dat_i,\n    output              m_wb_cyc_o,\n    output              m_wb_stb_o,\n    input               m_wb_ack_i,\n    output      [2:0]   m_wb_cti_o,\n    output      [1:0]   m_wb_bte_o,\n    \n    // SD Card Interface\n    input               sd_cmd_dat_i,\n    output              sd_cmd_out_o,\n    output              sd_cmd_oe_o,\n    input       [3:0]   sd_dat_dat_i,\n    output      [3:0]   sd_dat_out_o,\n    output              sd_dat_oe_o,\n    output              sd_clk_o_pad,\n    input               sd_clk_i_pad,\n    input               card_detect,\n    \n    // Interrupts\n    output              int_a,\n    output              int_b,\n    output              int_c\n);\n\n    // Internal signals\n    wire        [31:0]  argument_reg;\n    wire        [15:0]  cmd_setting_reg;\n    wire        [15:0]  status_reg;\n    wire        [31:0]  cmd_resp_1;\n    wire        [7:0]   software_reset_reg;\n    wire        [15:0]  time_out_reg;\n    wire        [15:0]  normal_int_status_reg;\n    wire        [15:0]  error_int_status_reg;\n    wire        [15:0]  normal_int_signal_enable_reg;\n    wire        [15:0]  error_int_signal_enable_reg;\n    wire        [8:0]   clock_divider;\n    wire        [15:0]  Bd_Status_reg;\n    wire        [7:0]   Bd_isr_reg;\n    wire        [7:0]   Bd_isr_enable_reg;\n    wire                bd_isr_reset;\n    wire                normal_isr_reset;\n    wire                error_isr_reset;\n    wire                new_cmd;\n    wire                we_ack;\n    wire                cmd_int_busy;\n    wire                write_req_s;\n    wire        [15:0]  cmd_set_s;\n    wire        [31:0]  cmd_arg_s;\n    wire                we_m_tx_bd;\n    wire                we_m_rx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n    \n    // Data Master signals\n    wire                d_write;\n    wire                d_read;\n    wire                start_tx_fifo;\n    wire                start_rx_fifo;\n    wire        [31:0]  sys_adr;\n    wire                ack_transfer;\n    wire                CIDAT;\n    \n    // FIFO signals\n    wire                tx_empt;\n    wire                tx_full;\n    wire                rx_full;\n    wire                busy_n;\n    wire                transm_complete;\n    wire                crc_ok;\n    wire        [1:0]   transfer_type;\n    \n    // BD signals\n    wire [BD_WIDTH-1:0] free_tx_bd;\n    wire [BD_WIDTH-1:0] free_rx_bd;\n    wire                re_s_tx;\n    wire                a_cmp_tx;\n    wire                re_s_rx;\n    wire                a_cmp_rx;\n    wire                ack_i_s_tx;\n    wire                ack_i_s_rx;\n    wire [RAM_MEM_WIDTH-1:0] dat_out_s_tx;\n    wire [RAM_MEM_WIDTH-1:0] dat_out_s_rx;\n    \n    // Clock signals\n    wire                sd_clk_i;\n    wire                sd_clk_o;\n    \n    // Assign clock based on configuration\n`ifdef SDC_CLK_BUS_CLK\n    assign sd_clk_i = wb_clk_i;\n`else\n    assign sd_clk_i = sd_clk_i_pad;\n`endif\n\n`ifdef SDC_CLK_DYNAMIC\n    assign sd_clk_o = sd_clk_div;\n`else\n    assign sd_clk_o = sd_clk_i;\n`endif\n\n    assign sd_clk_o_pad = sd_clk_o;\n    \n    // Instantiate submodules\n    sd_controller_wb u_wb_interface (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n    \n    sd_cmd_master u_cmd_master (\n        .CLK_PAD_IO(sd_clk_o),\n        .RST_PAD_I(wb_rst_i | software_reset_reg[0]),\n        .New_CMD(new_cmd),\n        .data_write(d_write),\n        .data_read(d_read),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(),\n        .go_idle_o(),\n        .cmd_out(),\n        .req_out(write_req_s),\n        .ack_out(we_ack),\n        .req_in(),\n        .ack_in(),\n        .cmd_in(),\n        .serial_status(),\n        .card_detect(card_detect)\n    );\n    \n    sd_data_master u_data_master (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .dat_in_tx(dat_out_s_tx),\n        .free_tx_bd(free_tx_bd),\n        .ack_i_s_tx(ack_i_s_tx),\n        .dat_in_rx(dat_out_s_rx),\n        .free_rx_bd(free_rx_bd),\n        .ack_i_s_rx(ack_i_s_rx),\n        .cmd_busy(cmd_int_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(),\n        .card_status(status_reg[4:0]),\n        .tx_empt(tx_empt),\n        .tx_full(tx_full),\n        .rx_full(rx_full),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok),\n        .Dat_Int_Status_rst(bd_isr_reset),\n        .transfer_type(transfer_type),\n        .re_s_tx(re_s_tx),\n        .a_cmp_tx(a_cmp_tx),\n        .re_s_rx(re_s_rx),\n        .a_cmp_rx(a_cmp_rx),\n        .we_req(),\n        .d_write(d_write),\n        .d_read(d_read),\n        .cmd_arg(cmd_arg_s),\n        .cmd_set(cmd_set_s),\n        .start_tx_fifo(start_tx_fifo),\n        .start_rx_fifo(start_rx_fifo),\n        .sys_adr(sys_adr),\n        .ack_transfer(ack_transfer),\n        .Dat_Int_Status(Bd_isr_reg),\n        .CIDAT(CIDAT)\n    );\n    \n    tx_bd u_tx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_tx_bd),\n        .dat_in_m(dat_in_m_tx_bd),\n        .free_bd(free_tx_bd),\n        .re_s(re_s_tx),\n        .ack_o_s(ack_i_s_tx),\n        .a_cmp(a_cmp_tx),\n        .dat_out_s(dat_out_s_tx)\n    );\n    \n    rx_bd u_rx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_rx_bd),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(free_rx_bd),\n        .re_s(re_s_rx),\n        .ack_o_s(ack_i_s_rx),\n        .a_cmp(a_cmp_rx),\n        .dat_out_s(dat_out_s_rx)\n    );\n    \n    sd_fifo_tx_filler u_tx_fifo (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(),\n        .m_wb_we_o(),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(),\n        .m_wb_stb_o(),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(),\n        .m_wb_bte_o(),\n        .en(start_tx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_o(),\n        .rd(),\n        .empty(tx_empt),\n        .fe(tx_full)\n    );\n    \n    sd_fifo_rx_filler u_rx_fifo (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(start_rx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_i(),\n        .wr(),\n        .full(rx_full)\n    );\n    \n    assign m_wb_sel_o = 4'b1111;\n    \n    // Interrupt generation\n`ifdef SDC_IRQ_ENABLE\n    assign int_a = |(normal_int_status_reg & normal_int_signal_enable_reg);\n    assign int_b = |(error_int_status_reg & error_int_signal_enable_reg);\n    assign int_c = |(Bd_isr_reg & Bd_isr_enable_reg);\n`else\n    assign int_a = 1'b0;\n    assign int_b = 1'b0;\n    assign int_c = 1'b0;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 2, "code": "module sd_cmd_serial_host (\n    input SD_CLK_IN,\n    input RST_IN,\n    input [15:0] SETTING_IN,\n    input [39:0] CMD_IN,\n    input REQ_IN,\n    input ACK_IN,\n    input cmd_dat_i,\n    \n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [15:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n// Parameters\nparameter INIT_DELAY = `SIM ? 2 : 64;\nparameter NCR = 2;\nparameter SEND_SIZE = 48;\nparameter SIZE = 10;\nparameter CONTENT_SIZE = 40;\nparameter Read_Delay = 7;\nparameter EIGHT_PAD = 8;\n\n// FSM states\nparameter INIT     = 10'b0000000001;\nparameter IDLE     = 10'b0000000010;\nparameter WRITE_WR = 10'b0000000100;\nparameter DLY_WR   = 10'b0000001000;\nparameter READ_WR  = 10'b0000010000;\nparameter DLY_READ = 10'b0000100000;\nparameter ACK_WR   = 10'b0001000000;\nparameter WRITE_WO = 10'b0010000000;\nparameter DLY_WO   = 10'b0100000000;\nparameter ACK_WO   = 10'b1000000000;\n\n// Internal registers\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg Write_Read;\nreg Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST;\nreg [6:0] CRC_IN;\nwire [6:0] CRC_VAL;\nreg CRC_Enable;\nreg CRC_OUT;\nreg CRC_Check_On;\nreg Crc_Buffering;\nreg CRC_Valid;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg [9:0] state;\nreg [9:0] next_state;\nreg block_write;\nreg block_read;\nreg [1:0] word_select;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\n\n// CRC module instantiation\nsd_crc_7 crc7 (\n    .BITVAL(CRC_OUT),\n    .Enable(CRC_Enable),\n    .CLK(SD_CLK_IN),\n    .RST(CRC_RST),\n    .CRC(CRC_VAL)\n);\n\n// FSM_COMBO: Combinational logic for next state\nalways @(*) begin\n    case (state)\n        INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n        IDLE: begin\n            if (Write_Read) next_state = WRITE_WR;\n            else if (Write_Only) next_state = WRITE_WO;\n            else next_state = IDLE;\n        end\n        WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n        WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n        DLY_WR: begin\n            if (Delay_Cnt >= NCR && !cmd_dat_i) next_state = READ_WR;\n            else next_state = DLY_WR;\n        end\n        DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n        READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n        DLY_READ: next_state = (Ack_internal_in) ? ACK_WR : DLY_READ;\n        ACK_WO: next_state = IDLE;\n        ACK_WR: next_state = IDLE;\n        default: next_state = INIT;\n    endcase\nend\n\n// FSM_SEQ: Sequential state update\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC: Synchronize REQ_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC: Synchronize ACK_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Delay_Cycler <= 0;\n        Response_Size <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        CRC_Check_On <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else begin\n        if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            \n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\nend\n\n// FSM_OUT\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            \n            IDLE: begin\n                cmd_oe_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                st_dat_t <= 0;\n                word_select_counter <= 0;\n            end\n            \n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                        CRC_OUT <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                        CRC_OUT <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    st_dat_t <= block_read ? 2'b10 : (block_write ? 2'b01 : 2'b00);\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Delay_Cnt < 3'b111) begin\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                \n                Crc_Buffering <= 0;\n            end\n            \n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0100;\n                    STATUS[5] <= 0;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            \n            READ_WR: begin\n                Delay_Cnt <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Cmd_Cnt == 1) begin\n                    STATUS[3:0] <= 4'b0101;\n                    REQ_OUT <= 1;\n                    Out_Buff[39] <= 0;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Cmd_Cnt < Response_Size) begin\n                    Out_Buff[38 - Cmd_Cnt] <= cmd_dat_i;\n                    CRC_OUT <= cmd_dat_i;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                    CRC_Enable <= 0;\n                end else begin\n                    if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                        CRC_Enable <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                        CRC_Enable <= 0;\n                    end\n                    \n                    if (block_read && block_write) begin\n                        st_dat_t <= 2'b11;\n                    end else if (block_write) begin\n                        st_dat_t <= 2'b01;\n                    end\n                end\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            \n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0110;\n                    STATUS[5] <= CRC_Valid;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                CMD_OUT <= Out_Buff;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            \n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            \n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\n// ACK_OUT generation\nalways @(*) begin\n    ACK_OUT = FSM_ACK & DECODER_ACK;\nend\n\nendmodule\n\n// CRC-7 module\nmodule sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 0;\n    end else if (Enable) begin\n        CRC[0] <= BITVAL ^ CRC[6];\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= BITVAL ^ CRC[2] ^ CRC[6];\n        CRC[4] <= BITVAL ^ CRC[3] ^ CRC[6];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 20, "code": "module sd_controller_wb (\n    // Wishbone interface\n    input  wire         wb_clk_i,\n    input  wire         wb_rst_i,\n    input  wire [31:0]  wb_dat_i,\n    output reg  [31:0]  wb_dat_o,\n    input  wire [7:0]   wb_adr_i,\n    input  wire [3:0]   wb_sel_i,\n    input  wire         wb_we_i,\n    input  wire         wb_cyc_i,\n    input  wire         wb_stb_i,\n    output reg          wb_ack_o,\n    \n    // Control signals\n    output reg          we_m_tx_bd,\n    output reg          we_m_rx_bd,\n    output reg          new_cmd,\n    output reg          we_ack,\n    output reg          int_ack,\n    output reg          cmd_int_busy,\n    output reg          int_busy,\n    \n    // Data master interface\n    input  wire         write_req_s,\n    input  wire [15:0]  cmd_set_s,\n    input  wire [32:0]  cmd_arg_s,\n    \n    // Registers\n    output reg  [31:0]  argument_reg,\n    output reg  [15:0]  cmd_setting_reg,\n    input  wire [15:0]  status_reg,\n    input  wire [32:0]  cmd_resp_1,\n    output reg  [7:0]   software_reset_reg,\n    output reg  [16:0]  time_out_reg,\n    input  wire [15:0]  normal_int_status_reg,\n    input  wire [15:0]  error_int_status_reg,\n    output reg  [15:0]  normal_int_signal_enable_reg,\n    output reg  [15:0]  error_int_signal_enable_reg,\n    output reg  [7:0]   clock_divider,\n    input  wire [15:0]  Bd_Status_reg,\n    input  wire [7:0]   Bd_isr_reg,\n    output reg  [7:0]   Bd_isr_enable_reg,\n    \n    // Reset signals\n    output reg          Bd_isr_reset,\n    output reg          normal_isr_reset,\n    output reg          error_isr_reset,\n    \n    // BD data\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\nparameter RAM_MEM_WIDTH = 32; // Default to 32-bit width\n\n// Internal signals\nreg [1:0] bd_write_state;\nreg [31:0] bd_temp_data;\n\n// Assign BD data outputs\nassign dat_in_m_tx_bd = bd_temp_data[RAM_MEM_WIDTH-1:0];\nassign dat_in_m_rx_bd = bd_temp_data[RAM_MEM_WIDTH-1:0];\n\n// Wishbone interface control\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers\n        argument_reg <= 32'h0;\n        cmd_setting_reg <= 16'h0;\n        software_reset_reg <= 8'h0;\n        time_out_reg <= 16'h0;\n        normal_int_signal_enable_reg <= 16'h0;\n        error_int_signal_enable_reg <= 16'h0;\n        clock_divider <= 8'h0;\n        Bd_isr_enable_reg <= 8'h0;\n        \n        // Reset control signals\n        wb_ack_o <= 1'b0;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        bd_write_state <= 2'b00;\n        bd_temp_data <= 32'h0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n    end\n    else begin\n        // Default values\n        wb_ack_o <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        \n        // Handle data master interface\n        if (write_req_s) begin\n            argument_reg <= cmd_arg_s;\n            cmd_setting_reg <= cmd_set_s;\n            new_cmd <= 1'b1;\n            we_ack <= 1'b1;\n            cmd_int_busy <= 1'b1;\n        end else begin\n            cmd_int_busy <= 1'b0;\n        end\n        \n        // Handle Wishbone access\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i[7:0])\n                    8'h00: begin // Argument register\n                        argument_reg <= wb_dat_i;\n                        int_busy <= 1'b1;\n                    end\n                    8'h04: begin // Command setting register\n                        cmd_setting_reg <= wb_dat_i[15:0];\n                    end\n                    8'h28: begin // Software reset register\n                        software_reset_reg <= wb_dat_i[7:0];\n                    end\n                    8'h2c: begin // Timeout register\n                        time_out_reg <= wb_dat_i[15:0];\n                    end\n                    8'h30: begin // Normal interrupt status register\n                        normal_isr_reset <= 1'b1;\n                    end\n                    8'h34: begin // Error interrupt status register\n                        error_isr_reset <= 1'b1;\n                    end\n                    8'h38: begin // Normal interrupt enable register\n                        normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    end\n                    8'h3c: begin // Error interrupt enable register\n                        error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    end\n                    8'h4c: begin // Clock divider register\n                        clock_divider <= wb_dat_i[7:0];\n                    end\n                    8'h54: begin // Data interrupt status register\n                        Bd_isr_reset <= 1'b1;\n                    end\n                    8'h58: begin // Data interrupt enable register\n                        Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    end\n                    8'h60: begin // BD RX register\n                        case (bd_write_state)\n                            2'b00: begin\n                                bd_temp_data[15:0] <= wb_dat_i[15:0];\n                                we_m_rx_bd <= 1'b1;\n                                int_ack <= 1'b0;\n                                bd_write_state <= (RAM_MEM_WIDTH == 32) ? 2'b10 : 2'b01;\n                            end\n                            2'b01: begin\n                                bd_temp_data[31:16] <= wb_dat_i[15:0];\n                                bd_write_state <= 2'b10;\n                            end\n                            2'b10: begin\n                                we_m_rx_bd <= 1'b0;\n                                int_ack <= 1'b1;\n                                bd_write_state <= 2'b00;\n                                wb_ack_o <= 1'b1;\n                            end\n                        endcase\n                    end\n                    8'h80: begin // BD TX register\n                        case (bd_write_state)\n                            2'b00: begin\n                                bd_temp_data[15:0] <= wb_dat_i[15:0];\n                                we_m_tx_bd <= 1'b1;\n                                int_ack <= 1'b0;\n                                bd_write_state <= (RAM_MEM_WIDTH == 32) ? 2'b10 : 2'b01;\n                            end\n                            2'b01: begin\n                                bd_temp_data[31:16] <= wb_dat_i[15:0];\n                                bd_write_state <= 2'b10;\n                            end\n                            2'b10: begin\n                                we_m_tx_bd <= 1'b0;\n                                int_ack <= 1'b1;\n                                bd_write_state <= 2'b00;\n                                wb_ack_o <= 1'b1;\n                            end\n                        endcase\n                    end\n                endcase\n                \n                // For non-BD writes, generate immediate ack\n                if (wb_adr_i[7:0] != 8'h60 && wb_adr_i[7:0] != 8'h80) begin\n                    wb_ack_o <= 1'b1;\n                end\n            end\n            else begin\n                // Read operation\n                case (wb_adr_i[7:0])\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= 32'h0; // Controller setting (not used)\n                    8'h20: wb_dat_o <= {16'h0, 16'h0200}; // Block size (fixed to 512)\n                    8'h24: wb_dat_o <= {24'h0, 8'h0f}; // Power control (fixed to 3.3V)\n                    8'h28: wb_dat_o <= {24'h0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h0; // Capability (not used)\n                    8'h4c: wb_dat_o <= {24'h0, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'h0;\n                endcase\n                wb_ack_o <= 1'b1;\n            end\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 15, "code": "module sd_data_master (\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n// Parameters\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'h0C1A;\nparameter ACMD13 = 16'h0D1A;\nparameter ACMD51 = 16'h331A;\nparameter SIZE = 9;\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\nparameter RESEND_MAX_CNT = 3;\n\n// Internal signals\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [SIZE-1:0] state, next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\nreg [2:0] bd_cnt;\n\n// State machine\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (free_tx_bd != (BD_SIZE/2)) begin\n                next_state = GET_TX_BD;\n            end else if (free_rx_bd != (BD_SIZE/2)) begin\n                next_state = GET_RX_BD;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        GET_TX_BD: begin\n            if (bd_cnt > (RAM_MEM_WIDTH == 32 ? 1 : 3) && tx_full) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_TX_BD;\n            end\n        end\n        GET_RX_BD: begin\n            if (bd_cnt >= (RAM_MEM_WIDTH == 32 ? 1 : 3)) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_RX_BD;\n            end\n        end\n        SEND_CMD: begin\n            if (send_done) begin\n                next_state = RECIVE_CMD;\n            end else begin\n                next_state = SEND_CMD;\n            end\n        end\n        RECIVE_CMD: begin\n            if (rec_done) begin\n                next_state = DATA_TRANSFER;\n            end else if (rec_failed) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        DATA_TRANSFER: begin\n            if (trans_done) begin\n                next_state = IDLE;\n            end else if (trans_failed) begin\n                next_state = STOP;\n            end else begin\n                next_state = DATA_TRANSFER;\n            end\n        end\n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        STOP_SEND: begin\n            if (send_done) begin\n                next_state = IDLE;\n            end else begin\n                next_state = STOP_SEND;\n            end\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// Output logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all outputs\n        re_s_tx <= 0;\n        a_cmp_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        sys_adr <= 0;\n        ack_transfer <= 0;\n        Dat_Int_Status <= 0;\n        CIDAT <= 0;\n        \n        // Reset internal signals\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n    end else begin\n        // Default outputs\n        re_s_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_tx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        ack_transfer <= 0;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        \n        // Handle Dat_Int_Status reset\n        if (Dat_Int_Status_rst) begin\n            Dat_Int_Status <= 0;\n        end\n        \n        case (state)\n            IDLE: begin\n                // Reset cycle flags\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                bd_cnt <= 0;\n            end\n            \n            GET_TX_BD: begin\n                tx_cycle <= 1;\n                re_s_tx <= 1;\n                \n                if (ack_i_s_tx) begin\n                    if (RAM_MEM_WIDTH == 32) begin\n                        case (bd_cnt)\n                            0: sys_adr <= dat_in_tx;\n                            1: begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        endcase\n                    end else begin\n                        case (bd_cnt)\n                            0: sys_adr[15:0] <= dat_in_tx;\n                            1: sys_adr[31:16] <= dat_in_tx;\n                            2: cmd_arg[15:0] <= dat_in_tx;\n                            3: begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        endcase\n                    end\n                    \n                    bd_cnt <= bd_cnt + 1;\n                end\n                \n                cmd_set <= CMD24;\n            end\n            \n            GET_RX_BD: begin\n                rx_cycle <= 1;\n                re_s_rx <= 1;\n                \n                if (ack_i_s_rx) begin\n                    if (RAM_MEM_WIDTH == 32) begin\n                        case (bd_cnt)\n                            0: sys_adr <= dat_in_rx;\n                            1: cmd_arg <= dat_in_rx;\n                        endcase\n                    end else begin\n                        case (bd_cnt)\n                            0: sys_adr[15:0] <= dat_in_rx;\n                            1: sys_adr[31:16] <= dat_in_rx;\n                            2: cmd_arg[15:0] <= dat_in_rx;\n                            3: cmd_arg[31:16] <= dat_in_rx;\n                        endcase\n                    end\n                    \n                    bd_cnt <= bd_cnt + 1;\n                end\n                \n                case (transfer_type)\n                    2'b00: cmd_set <= CMD17;\n                    2'b01: cmd_set <= ACMD13;\n                    default: cmd_set <= ACMD51;\n                endcase\n            end\n            \n            SEND_CMD: begin\n                if (tx_cycle) d_write <= 1;\n                if (rx_cycle) d_read <= 1;\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n            \n            RECIVE_CMD: begin\n                if (rx_cycle) start_rx_fifo <= 1;\n                \n                if (!cmd_busy) begin\n                    if (cmd_tsf_err) begin\n                        rec_failed <= 1;\n                    end else if (card_status[0] && (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) begin\n                        rec_done <= 1;\n                    end\n                end\n            end\n            \n            DATA_TRANSFER: begin\n                if (tx_cycle && tx_empt) begin\n                    trans_failed <= 1;\n                    Dat_Int_Status[0] <= 1; // Underrun error\n                end\n                \n                if (rx_cycle && rx_full) begin\n                    trans_failed <= 1;\n                    Dat_Int_Status[1] <= 1; // Overrun error\n                end\n                \n                if (transm_complete) begin\n                    if (crc_ok) begin\n                        trans_done <= 1;\n                        ack_transfer <= 1;\n                        if (tx_cycle) a_cmp_tx <= 1;\n                        if (rx_cycle) a_cmp_rx <= 1;\n                    end else begin\n                        trans_failed <= 1;\n                        Dat_Int_Status[2] <= 1; // CRC error\n                    end\n                end\n            end\n            \n            STOP: begin\n                cmd_set <= CMD12;\n                d_read <= 1;\n                d_write <= 1;\n            end\n            \n            STOP_SEND: begin\n                resend_try_cnt <= resend_try_cnt + 1;\n                \n                if (resend_try_cnt == RESEND_MAX_CNT) begin\n                    Dat_Int_Status[1] <= 1; // Overrun error\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                        resend_try_cnt <= 0;\n                    end\n                end\n            end\n        endcase\n        \n        // Track transmission complete\n        transm_complete_q <= transm_complete;\n        if (transm_complete && !transm_complete_q) begin\n            internal_transm_complete <= 1;\n        end else begin\n            internal_transm_complete <= 0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 18, "code": "module sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    \n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\nparameter SD_BUS_W = 4;\nparameter BIT_BLOCK = 512;\nparameter CRC_OFF = 16;\nparameter BIT_BLOCK_REC = 512;\nparameter BIT_CRC_CYCLE = 16;\nparameter LITTLE_ENDIAN = 1;\nparameter BIG_ENDIAN = 0;\nparameter SD_BUS_WIDTH_1 = 1;\nparameter SD_BUS_WIDTH_4 = 4;\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out [0:SD_BUS_W-1];\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// States\nlocalparam IDLE       = 6'b000001;\nlocalparam WRITE_DAT  = 6'b000010;\nlocalparam WRITE_CRC  = 6'b000100;\nlocalparam WRITE_BUSY = 6'b001000;\nlocalparam READ_WAIT  = 6'b010000;\nlocalparam READ_DAT   = 6'b100000;\n\n// CRC generation instances\ngenerate\ngenvar i;\nfor (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n    sd_crc_16 crc_inst (\n        .BITVAL(crc_in[i]),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out[i])\n    );\nend\nendgenerate\n\n// ACK_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        ack_transfer_int <= 0;\n        ack_q <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// FSM_COMBO block\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b10) next_state = WRITE_DAT;\n            else if (start_dat == 2'b01) next_state = READ_WAIT;\n            else next_state = IDLE;\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == BIT_BLOCK) next_state = WRITE_CRC;\n            else next_state = WRITE_DAT;\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b001) next_state = WRITE_BUSY;\n            else next_state = WRITE_CRC;\n        end\n        WRITE_BUSY: begin\n            if (!busy_int) next_state = IDLE;\n            else next_state = WRITE_BUSY;\n        end\n        READ_WAIT: begin\n            if (!DAT_dat_i[0] && state == READ_WAIT) next_state = READ_DAT;\n            else next_state = READ_WAIT;\n        end\n        READ_DAT: begin\n            if (transf_cnt == BIT_BLOCK_REC) next_state = IDLE;\n            else next_state = READ_DAT;\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// START_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else begin\n        if (!DAT_dat_i[0] && state == READ_WAIT)\n            q_start_bit <= 0;\n        else\n            q_start_bit <= 1;\n    end\nend\n\n// FSM_SEQ block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        write_buf_0 <= 0;\n        write_buf_1 <= 0;\n        DAT_oe_o <= 0;\n        crc_en <= 0;\n        crc_rst <= 1;\n        transf_cnt <= 0;\n        rd <= 0;\n        last_din <= 0;\n        crc_c <= 0;\n        crc_in <= 0;\n        DAT_dat_o <= 0;\n        crc_status <= 7;\n        crc_s <= 0;\n        transm_complete <= 0;\n        busy_n <= 1;\n        we <= 0;\n        data_out <= 0;\n        crc_ok <= 0;\n        busy_int <= 0;\n        data_send_index <= 0;\n        out_buff_ptr <= 0;\n        in_buff_ptr <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                crc_rst <= 1;\n                crc_en <= 0;\n                DAT_oe_o <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                transf_cnt <= 0;\n                crc_c <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n                \n                if (start_dat == 2'b10) begin\n                    write_buf_0 <= data_in;\n                    rd <= 1;\n                end\n            end\n            \n            WRITE_DAT: begin\n                crc_rst <= 0;\n                DAT_oe_o <= 1;\n                busy_n <= 0;\n                \n                if (transf_cnt == 0) begin\n                    DAT_dat_o <= 0; // Start bit\n                    crc_en <= 0;\n                end else begin\n                    if (transf_cnt % 32 == 0) begin\n                        if (out_buff_ptr == 0) begin\n                            sd_data_out <= write_buf_1;\n                            out_buff_ptr <= 1;\n                            if (in_buff_ptr == 0) begin\n                                write_buf_1 <= data_in;\n                                in_buff_ptr <= 1;\n                                rd <= 1;\n                            end else begin\n                                rd <= 0;\n                            end\n                        end else begin\n                            sd_data_out <= write_buf_0;\n                            out_buff_ptr <= 0;\n                            if (in_buff_ptr == 1) begin\n                                write_buf_0 <= data_in;\n                                in_buff_ptr <= 0;\n                                rd <= 1;\n                            end else begin\n                                rd <= 0;\n                            end\n                        end\n                    end\n                    \n                    last_din <= sd_data_out[31:28];\n                    crc_in <= sd_data_out[31:28];\n                    DAT_dat_o <= sd_data_out[31:28];\n                    sd_data_out <= {sd_data_out[27:0], 4'b0};\n                    crc_en <= 1;\n                end\n                \n                transf_cnt <= transf_cnt + 1;\n            end\n            \n            WRITE_CRC: begin\n                if (crc_c < 16) begin\n                    DAT_dat_o <= crc_out[0][15 - crc_c];\n                    crc_c <= crc_c + 1;\n                end else begin\n                    DAT_dat_o <= 1; // Stop bit\n                    crc_status <= 3'b001;\n                end\n            end\n            \n            WRITE_BUSY: begin\n                transm_complete <= 1;\n                busy_int <= DAT_dat_i[0];\n                if (crc_s == 3'b010) crc_ok <= 1;\n                else crc_ok <= 0;\n            end\n            \n            READ_WAIT: begin\n                crc_rst <= 0;\n                crc_en <= 1;\n                DAT_oe_o <= 0;\n                busy_n <= 0;\n            end\n            \n            READ_DAT: begin\n                if (transf_cnt < BIT_BLOCK_REC) begin\n                    data_out <= DAT_dat_i;\n                    crc_in <= DAT_dat_i;\n                    we <= 1;\n                end else begin\n                    we <= 0;\n                    // CRC check logic would go here\n                end\n                \n                transf_cnt <= transf_cnt + 1;\n                \n                if (transf_cnt == BIT_BLOCK_REC + BIT_CRC_CYCLE) begin\n                    transm_complete <= 1;\n                    busy_n <= 0;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'h0000;\n    end else if (Enable) begin\n        CRC[0] <= CRC[15] ^ BITVAL;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2];\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4] ^ (CRC[15] ^ BITVAL);\n        CRC[6] <= CRC[5];\n        CRC[7] <= CRC[6];\n        CRC[8] <= CRC[7];\n        CRC[9] <= CRC[8];\n        CRC[10] <= CRC[9];\n        CRC[11] <= CRC[10];\n        CRC[12] <= CRC[11] ^ (CRC[15] ^ BITVAL);\n        CRC[13] <= CRC[12];\n        CRC[14] <= CRC[13];\n        CRC[15] <= CRC[14];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 3, "code": "module sd_cmd_serial_host (\n    input SD_CLK_IN,\n    input RST_IN,\n    input [15:0] SETTING_IN,\n    input [39:0] CMD_IN,\n    input REQ_IN,\n    input ACK_IN,\n    input cmd_dat_i,\n    \n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [15:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n// Parameters\nparameter INIT_DELAY = `SIM ? 2 : 64;\nparameter NCR = 2;\nparameter SEND_SIZE = 48;\nparameter SIZE = 10;\nparameter CONTENT_SIZE = 40;\nparameter Read_Delay = 7;\nparameter EIGHT_PAD = 8;\n\n// States\nparameter INIT      = 10'b0000000001;\nparameter IDLE      = 10'b0000000010;\nparameter WRITE_WR  = 10'b0000000100;\nparameter DLY_WR    = 10'b0000001000;\nparameter READ_WR   = 10'b0000010000;\nparameter DLY_READ  = 10'b0000100000;\nparameter ACK_WR    = 10'b0001000000;\nparameter WRITE_WO  = 10'b0010000000;\nparameter DLY_WO    = 10'b0100000000;\nparameter ACK_WO    = 10'b1000000000;\n\n// Internal registers\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg Write_Read;\nreg Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST;\nreg [6:0] CRC_IN;\nwire [6:0] CRC_VAL;\nreg CRC_Enable;\nreg CRC_OUT;\nreg CRC_Check_On;\nreg Crc_Buffering;\nreg CRC_Valid;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg [9:0] state;\nreg [9:0] next_state;\nreg block_write;\nreg block_read;\nreg [1:0] word_select;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\n\n// Instantiate CRC module\nsd_crc_7 crc7 (\n    .BITVAL(CRC_OUT),\n    .Enable(CRC_Enable),\n    .CLK(SD_CLK_IN),\n    .RST(CRC_RST),\n    .CRC(CRC_VAL)\n);\n\n// FSM_COMBO: Combinational logic for next state\nalways @(*) begin\n    case (state)\n        INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n        IDLE: begin\n            if (Write_Read) next_state = WRITE_WR;\n            else if (Write_Only) next_state = WRITE_WO;\n            else next_state = IDLE;\n        end\n        WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n        WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n        DLY_WR: begin\n            if (Delay_Cnt >= NCR && !cmd_dat_i) next_state = READ_WR;\n            else next_state = DLY_WR;\n        end\n        DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n        READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n        DLY_READ: next_state = (Ack_internal_in) ? ACK_WR : DLY_READ;\n        ACK_WO: next_state = IDLE;\n        ACK_WR: next_state = IDLE;\n        default: next_state = INIT;\n    endcase\nend\n\n// FSM_SEQ: Sequential state update\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC: Synchronize REQ_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC: Synchronize ACK_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Delay_Cycler <= 0;\n        Response_Size <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        CRC_Check_On <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else begin\n        if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            \n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\nend\n\n// FSM_OUT\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            \n            IDLE: begin\n                cmd_oe_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                st_dat_t <= 0;\n                word_select_counter <= 0;\n            end\n            \n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000000000000001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    st_dat_t <= block_read ? 2'b10 : (block_write ? 2'b01 : 2'b00);\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Delay_Cnt < 3'b111) begin\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                \n                Crc_Buffering <= 0;\n            end\n            \n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0100;\n                    STATUS[5] <= 0;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            \n            READ_WR: begin\n                Delay_Cnt <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Cmd_Cnt == 1) begin\n                    STATUS[3:0] <= 4'b0101;\n                    REQ_OUT <= 1;\n                    Out_Buff[39] <= 0;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Cmd_Cnt < Response_Size) begin\n                    Out_Buff[38 - Cmd_Cnt] <= cmd_dat_i;\n                    CRC_OUT <= cmd_dat_i;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                    CRC_Enable <= 0;\n                end else begin\n                    if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                        CRC_Enable <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                        CRC_Enable <= 0;\n                    end\n                    \n                    if (block_read && block_write) begin\n                        st_dat_t <= 2'b11;\n                    end else if (block_write) begin\n                        st_dat_t <= 2'b01;\n                    end\n                end\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            \n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0110;\n                    STATUS[5] <= CRC_Valid;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                CMD_OUT <= Out_Buff;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            \n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            \n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\n// ACK_OUT generation\nalways @(*) begin\n    ACK_OUT = FSM_ACK & DECODER_ACK;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 19, "code": "module sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    \n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\nparameter SD_BUS_W = 4;\nparameter BIT_BLOCK = 512;\nparameter CRC_OFF = 16;\nparameter BIT_BLOCK_REC = 512;\nparameter BIT_CRC_CYCLE = 16;\nparameter LITTLE_ENDIAN = 1;\nparameter BIG_ENDIAN = 0;\nparameter SD_BUS_WIDTH_1 = 1;\nparameter SD_BUS_WIDTH_4 = 4;\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out [0:SD_BUS_W-1];\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// State definitions\nlocalparam IDLE       = 6'b000001;\nlocalparam WRITE_DAT  = 6'b000010;\nlocalparam WRITE_CRC  = 6'b000100;\nlocalparam WRITE_BUSY = 6'b001000;\nlocalparam READ_WAIT  = 6'b010000;\nlocalparam READ_DAT   = 6'b100000;\n\n// CRC generation modules\ngenvar i;\ngenerate\n    for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n        sd_crc_16 crc_inst (\n            .BITVAL(crc_in[i]),\n            .Enable(crc_en),\n            .CLK(sd_clk),\n            .RST(crc_rst),\n            .CRC(crc_out[i])\n        );\n    end\nendgenerate\n\n// ACK_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        ack_transfer_int <= 0;\n        ack_q <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// FSM_COMBO block\nalways @(*) begin\n    next_state = state;\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b10) next_state = WRITE_DAT;\n            else if (start_dat == 2'b01) next_state = READ_WAIT;\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == BIT_BLOCK) next_state = WRITE_CRC;\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b001) next_state = WRITE_BUSY;\n        end\n        WRITE_BUSY: begin\n            if (!busy_int) next_state = IDLE;\n        end\n        READ_WAIT: begin\n            if (!DAT_dat_i[0]) next_state = READ_DAT;\n        end\n        READ_DAT: begin\n            if (transf_cnt == BIT_BLOCK_REC + BIT_CRC_CYCLE) next_state = IDLE;\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// START_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else begin\n        if (!DAT_dat_i[0] && state == READ_WAIT)\n            q_start_bit <= 0;\n        else\n            q_start_bit <= 1;\n    end\nend\n\n// FSM_SEQ block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        write_buf_0 <= 0;\n        write_buf_1 <= 0;\n        DAT_oe_o <= 0;\n        crc_en <= 0;\n        crc_rst <= 1;\n        transf_cnt <= 0;\n        rd <= 0;\n        last_din <= 0;\n        crc_c <= 0;\n        crc_in <= 0;\n        DAT_dat_o <= 0;\n        crc_status <= 7;\n        crc_s <= 0;\n        transm_complete <= 0;\n        busy_n <= 1;\n        we <= 0;\n        data_out <= 0;\n        crc_ok <= 0;\n        busy_int <= 0;\n        data_send_index <= 0;\n        out_buff_ptr <= 0;\n        in_buff_ptr <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                crc_rst <= 1;\n                crc_en <= 0;\n                DAT_oe_o <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                transf_cnt <= 0;\n                crc_c <= 0;\n                crc_status <= 7;\n                busy_int <= 0;\n                \n                if (start_dat == 2'b10) begin\n                    write_buf_0 <= data_in;\n                    rd <= 1;\n                end\n            end\n            \n            WRITE_DAT: begin\n                crc_rst <= 0;\n                DAT_oe_o <= 1;\n                busy_n <= 0;\n                \n                if (transf_cnt == 0) begin\n                    DAT_dat_o <= 0; // Start bit\n                    crc_en <= 0;\n                end else begin\n                    crc_en <= 1;\n                    if (transf_cnt[1:0] == 2'b00) begin\n                        last_din <= sd_data_out[3:0];\n                        DAT_dat_o <= sd_data_out[3:0];\n                        crc_in <= sd_data_out[3:0];\n                        sd_data_out <= {4'b0, sd_data_out[31:4]};\n                    end\n                end\n                \n                if (transf_cnt[1:0] == 2'b11) begin\n                    if (transf_cnt[10:2] == 127) begin\n                        out_buff_ptr <= ~out_buff_ptr;\n                        if (out_buff_ptr)\n                            sd_data_out <= write_buf_1;\n                        else\n                            sd_data_out <= write_buf_0;\n                    end\n                end\n                \n                transf_cnt <= transf_cnt + 1;\n            end\n            \n            WRITE_CRC: begin\n                if (transf_cnt < BIT_BLOCK + BIT_CRC_CYCLE) begin\n                    if (transf_cnt[3:0] < 16) begin\n                        DAT_dat_o <= {crc_out[0][transf_cnt[3:0]], crc_out[1][transf_cnt[3:0]], \n                                     crc_out[2][transf_cnt[3:0]], crc_out[3][transf_cnt[3:0]]};\n                    end else begin\n                        DAT_dat_o <= 4'b1111; // Stop bits\n                    end\n                    transf_cnt <= transf_cnt + 1;\n                end else begin\n                    crc_status <= 3'b001;\n                end\n            end\n            \n            WRITE_BUSY: begin\n                transm_complete <= 1;\n                busy_int <= DAT_dat_i[0];\n                busy_n <= ~DAT_dat_i[0];\n                crc_ok <= (crc_s == 3'b010);\n            end\n            \n            READ_WAIT: begin\n                DAT_oe_o <= 0;\n                crc_rst <= 0;\n                crc_en <= 1;\n                transf_cnt <= 0;\n            end\n            \n            READ_DAT: begin\n                if (transf_cnt < BIT_BLOCK_REC) begin\n                    data_out <= DAT_dat_i;\n                    crc_in <= DAT_dat_i;\n                    we <= 1;\n                end else if (transf_cnt < BIT_BLOCK_REC + BIT_CRC_CYCLE) begin\n                    // CRC checking logic would go here\n                end\n                \n                if (transf_cnt == BIT_BLOCK_REC + BIT_CRC_CYCLE - 1) begin\n                    transm_complete <= 1;\n                    busy_n <= 0;\n                    // CRC verification would go here\n                end\n                \n                transf_cnt <= transf_cnt + 1;\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 0;\n        end else if (Enable) begin\n            CRC[0] <= CRC[15] ^ BITVAL;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2];\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4] ^ CRC[15] ^ BITVAL;\n            CRC[6] <= CRC[5];\n            CRC[7] <= CRC[6];\n            CRC[8] <= CRC[7];\n            CRC[9] <= CRC[8];\n            CRC[10] <= CRC[9];\n            CRC[11] <= CRC[10];\n            CRC[12] <= CRC[11] ^ CRC[15] ^ BITVAL;\n            CRC[13] <= CRC[12];\n            CRC[14] <= CRC[13];\n            CRC[15] <= CRC[14];\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 16, "code": "module sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    \n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n// Parameters\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'h0C1A;\nparameter ACMD13 = 16'h0D1A;\nparameter ACMD51 = 16'h331A;\nparameter SIZE = 9;\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\nparameter RESEND_MAX_CNT = 3;\n\n// Internal signals\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [8:0] state;\nreg [8:0] next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\nreg [2:0] bd_cnt;\n\n// State machine\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (free_tx_bd != (RAM_MEM_WIDTH == 32 ? BD_SIZE/2 : BD_SIZE/4))\n                next_state = GET_TX_BD;\n            else if (free_rx_bd != (RAM_MEM_WIDTH == 32 ? BD_SIZE/2 : BD_SIZE/4))\n                next_state = GET_RX_BD;\n            else\n                next_state = IDLE;\n        end\n        GET_TX_BD: begin\n            if (bd_cnt > (RAM_MEM_WIDTH == 32 ? 1 : 3) && tx_full)\n                next_state = SEND_CMD;\n            else\n                next_state = GET_TX_BD;\n        end\n        GET_RX_BD: begin\n            if (bd_cnt >= (RAM_MEM_WIDTH == 32 ? 1 : 3))\n                next_state = SEND_CMD;\n            else\n                next_state = GET_RX_BD;\n        end\n        SEND_CMD: begin\n            if (send_done)\n                next_state = RECIVE_CMD;\n            else\n                next_state = SEND_CMD;\n        end\n        RECIVE_CMD: begin\n            if (rec_done)\n                next_state = DATA_TRANSFER;\n            else if (rec_failed)\n                next_state = SEND_CMD;\n            else\n                next_state = RECIVE_CMD;\n        end\n        DATA_TRANSFER: begin\n            if (trans_done)\n                next_state = IDLE;\n            else if (trans_failed)\n                next_state = STOP;\n            else\n                next_state = DATA_TRANSFER;\n        end\n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        STOP_SEND: begin\n            if (send_done)\n                next_state = IDLE;\n            else\n                next_state = STOP_SEND;\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// Output logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all outputs\n        re_s_tx <= 0;\n        a_cmp_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        sys_adr <= 0;\n        ack_transfer <= 0;\n        Dat_Int_Status <= 0;\n        CIDAT <= 0;\n        \n        // Reset internal signals\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n    end else begin\n        // Default values\n        re_s_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_tx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        ack_transfer <= 0;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        \n        // Track transmission complete\n        transm_complete_q <= transm_complete;\n        if (transm_complete && !transm_complete_q) begin\n            internal_transm_complete <= 1;\n            ack_transfer <= 1;\n        end\n        \n        case (state)\n            IDLE: begin\n                bd_cnt <= 0;\n                resend_try_cnt <= 0;\n            end\n            \n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                if (ack_i_s_tx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        case (bd_cnt)\n                            0: sys_adr <= dat_in_tx;\n                            1: begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        endcase\n                    end else begin\n                        case (bd_cnt)\n                            0: sys_adr[15:0] <= dat_in_tx;\n                            1: sys_adr[31:16] <= dat_in_tx;\n                            2: cmd_arg[15:0] <= dat_in_tx;\n                            3: begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        endcase\n                    end\n                end\n                cmd_set <= CMD24;\n                tx_cycle <= 1;\n            end\n            \n            GET_RX_BD: begin\n                re_s_rx <= 1;\n                if (ack_i_s_rx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        case (bd_cnt)\n                            0: sys_adr <= dat_in_rx;\n                            1: cmd_arg <= dat_in_rx;\n                        endcase\n                    end else begin\n                        case (bd_cnt)\n                            0: sys_adr[15:0] <= dat_in_rx;\n                            1: sys_adr[31:16] <= dat_in_rx;\n                            2: cmd_arg[15:0] <= dat_in_rx;\n                            3: cmd_arg[31:16] <= dat_in_rx;\n                        endcase\n                    end\n                end\n                \n                case (transfer_type)\n                    2'b00: cmd_set <= CMD17;\n                    2'b01: cmd_set <= ACMD13;\n                    default: cmd_set <= ACMD51;\n                endcase\n                rx_cycle <= 1;\n            end\n            \n            SEND_CMD: begin\n                if (tx_cycle) d_write <= 1;\n                if (rx_cycle) d_read <= 1;\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n            \n            RECIVE_CMD: begin\n                if (rx_cycle) start_rx_fifo <= 1;\n                \n                if (!cmd_busy) begin\n                    if (cmd_tsf_err) begin\n                        rec_failed <= 1;\n                    end else if (card_status[0] || (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) begin\n                        rec_done <= 1;\n                    end\n                end\n            end\n            \n            DATA_TRANSFER: begin\n                if (tx_cycle && tx_empt) begin\n                    trans_failed <= 1;\n                    Dat_Int_Status[0] <= 1; // Underrun error\n                end\n                \n                if (rx_cycle && rx_full) begin\n                    trans_failed <= 1;\n                    Dat_Int_Status[0] <= 1; // Overrun error\n                end\n                \n                if (internal_transm_complete) begin\n                    if (!crc_ok) begin\n                        trans_failed <= 1;\n                        Dat_Int_Status[2] <= 1; // CRC error\n                    end else begin\n                        trans_done <= 1;\n                        if (tx_cycle) a_cmp_tx <= 1;\n                        if (rx_cycle) a_cmp_rx <= 1;\n                    end\n                    internal_transm_complete <= 0;\n                end\n            end\n            \n            STOP: begin\n                cmd_set <= CMD12;\n                d_read <= 1;\n                d_write <= 1;\n            end\n            \n            STOP_SEND: begin\n                resend_try_cnt <= resend_try_cnt + 1;\n                if (resend_try_cnt == RESEND_MAX_CNT) begin\n                    Dat_Int_Status[1] <= 1; // Command timeout\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n        endcase\n        \n        if (Dat_Int_Status_rst) begin\n            Dat_Int_Status <= 0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 17, "code": "module sd_data_master (\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n// Parameters\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'hC1A;\nparameter ACMD13 = 16'hD1A;\nparameter ACMD51 = 16'h331A;\nparameter SIZE = 9;\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\nparameter RESEND_MAX_CNT = 3;\n\n// Internal signals\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\nreg [2:0] bd_cnt;\n\n// State machine\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (free_tx_bd != BD_EMPTY) begin\n                next_state = GET_TX_BD;\n            end else if (free_rx_bd != BD_EMPTY) begin\n                next_state = GET_RX_BD;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        GET_TX_BD: begin\n            if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_TX_BD;\n            end\n        end\n        GET_RX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_RX_BD;\n            end\n        end\n        SEND_CMD: begin\n            if (send_done == 1) begin\n                next_state = RECIVE_CMD;\n            end else begin\n                next_state = SEND_CMD;\n            end\n        end\n        RECIVE_CMD: begin\n            if (rec_done == 1) begin\n                next_state = DATA_TRANSFER;\n            end else if (rec_failed == 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        DATA_TRANSFER: begin\n            if (trans_done == 1) begin\n                next_state = IDLE;\n            end else if (trans_failed == 1) begin\n                next_state = STOP;\n            end else begin\n                next_state = DATA_TRANSFER;\n            end\n        end\n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        STOP_SEND: begin\n            if (send_done == 1) begin\n                next_state = IDLE;\n            end else begin\n                next_state = STOP_SEND;\n            end\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// Output logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all outputs\n        re_s_tx <= 0;\n        a_cmp_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        sys_adr <= 0;\n        ack_transfer <= 0;\n        Dat_Int_Status <= 0;\n        CIDAT <= 0;\n        \n        // Reset internal signals\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n    end else begin\n        // Default outputs\n        re_s_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_tx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        ack_transfer <= 0;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        \n        // Handle Dat_Int_Status reset\n        if (Dat_Int_Status_rst) begin\n            Dat_Int_Status <= 0;\n        end\n        \n        case (state)\n            IDLE: begin\n                // Reset cycle flags\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                bd_cnt <= 0;\n            end\n            \n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                if (ack_i_s_tx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_tx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                        end\n                    end else begin // 16-bit\n                        if (bd_cnt < 2) begin\n                            sys_adr <= {sys_adr[31:16], dat_in_tx};\n                        end else if (bd_cnt < 4) begin\n                            cmd_arg <= {cmd_arg[31:16], dat_in_tx};\n                            if (bd_cnt == 3) begin\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                end\n                cmd_set <= CMD24;\n                tx_cycle <= 1;\n            end\n            \n            GET_RX_BD: begin\n                re_s_rx <= 1;\n                if (ack_i_s_rx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_rx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_rx;\n                        end\n                    end else begin // 16-bit\n                        if (bd_cnt < 2) begin\n                            sys_adr <= {sys_adr[31:16], dat_in_rx};\n                        end else if (bd_cnt < 4) begin\n                            cmd_arg <= {cmd_arg[31:16], dat_in_rx};\n                        end\n                    end\n                end\n                \n                case (transfer_type)\n                    2'b00: cmd_set <= CMD17;\n                    2'b01: cmd_set <= ACMD13;\n                    default: cmd_set <= ACMD51;\n                endcase\n                rx_cycle <= 1;\n            end\n            \n            SEND_CMD: begin\n                if (tx_cycle) begin\n                    d_write <= 1;\n                end else if (rx_cycle) begin\n                    d_read <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n            \n            RECIVE_CMD: begin\n                if (rx_cycle) begin\n                    start_rx_fifo <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    if (cmd_tsf_err) begin\n                        rec_failed <= 1;\n                    end else if (card_status[0] == 1 || \n                               (card_status[4:1] == 4 || \n                                card_status[4:1] == 5 || \n                                card_status[4:1] == 6)) begin\n                        rec_done <= 1;\n                    end\n                end\n            end\n            \n            DATA_TRANSFER: begin\n                if (tx_cycle && tx_empt) begin\n                    trans_failed <= 1;\n                    Dat_Int_Status[0] <= 1; // Underrun error\n                end else if (rx_cycle && rx_full) begin\n                    trans_failed <= 1;\n                    Dat_Int_Status[2] <= 1; // Overrun error\n                end\n                \n                if (transm_complete) begin\n                    ack_transfer <= 1;\n                    if (crc_ok) begin\n                        trans_done <= 1;\n                        if (tx_cycle) begin\n                            a_cmp_tx <= 1;\n                        end else begin\n                            a_cmp_rx <= 1;\n                        end\n                    end else begin\n                        trans_failed <= 1;\n                        Dat_Int_Status[3] <= 1; // CRC error\n                    end\n                end\n            end\n            \n            STOP: begin\n                cmd_set <= CMD12;\n                d_read <= 1;\n                d_write <= 1;\n            end\n            \n            STOP_SEND: begin\n                resend_try_cnt <= resend_try_cnt + 1;\n                if (resend_try_cnt == RESEND_MAX_CNT) begin\n                    Dat_Int_Status[1] <= 1; // Command timeout\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n        endcase\n        \n        // Track transmission complete\n        transm_complete_q <= transm_complete;\n        internal_transm_complete <= transm_complete && !transm_complete_q;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    // Input ports\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    \n    // Output ports\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n// Parameters\nparameter CMD24 = 16'h181A;  // Write single block\nparameter CMD17 = 16'h111A;  // Read single block\nparameter CMD12 = 16'h0C1A;  // Stop transmission\nparameter ACMD13 = 16'h0D1A; // SD status\nparameter ACMD51 = 16'h331A; // Read SCR\n\nparameter SIZE = 9;\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\n\n// Internal signals\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\n\n`ifdef RAM_MEM_WIDTH_32\n    reg [1:0] bd_cnt;\n    parameter READ_CYCLE = 2;\n    parameter BD_EMPTY = BD_SIZE / 2;\n`else\n    reg [2:0] bd_cnt;\n    parameter READ_CYCLE = 4;\n    parameter BD_EMPTY = BD_SIZE / 4;\n`endif\n\n// FSM sequential logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM combinational logic\nalways @(*) begin\n    next_state = state;\n    \n    case (state)\n        IDLE: begin\n            if (free_tx_bd != BD_EMPTY) begin\n                next_state = GET_TX_BD;\n            end else if (free_rx_bd != BD_EMPTY) begin\n                next_state = GET_RX_BD;\n            end\n        end\n        \n        GET_TX_BD: begin\n            if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                next_state = SEND_CMD;\n            end\n        end\n        \n        GET_RX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1) begin\n                next_state = SEND_CMD;\n            end\n        end\n        \n        SEND_CMD: begin\n            if (send_done) begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        \n        RECIVE_CMD: begin\n            if (rec_done) begin\n                next_state = DATA_TRANSFER;\n            end else if (rec_failed) begin\n                next_state = SEND_CMD;\n            end\n        end\n        \n        DATA_TRANSFER: begin\n            if (trans_done) begin\n                next_state = IDLE;\n            end else if (trans_failed) begin\n                next_state = STOP;\n            end\n        end\n        \n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        \n        STOP_SEND: begin\n            if (send_done) begin\n                next_state = IDLE;\n            end\n        end\n        \n        default: begin\n            next_state = IDLE;\n        end\n    endcase\nend\n\n// Output logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all outputs\n        re_s_tx <= 0;\n        a_cmp_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        sys_adr <= 0;\n        ack_transfer <= 0;\n        Dat_Int_Status <= 0;\n        CIDAT <= 0;\n        \n        // Reset internal signals\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n    end else begin\n        // Default values\n        re_s_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_tx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        ack_transfer <= 0;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        \n        // State-specific outputs\n        case (state)\n            IDLE: begin\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                resend_try_cnt <= 0;\n                bd_cnt <= 0;\n            end\n            \n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                tx_cycle <= 1;\n                \n                if (ack_i_s_tx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    \n                    `ifdef RAM_MEM_WIDTH_32\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_tx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                        end\n                    `else\n                        case (bd_cnt)\n                            0: sys_adr[15:0] <= dat_in_rx;\n                            1: sys_adr[31:16] <= dat_in_rx;\n                            2: cmd_arg[15:0] <= dat_in_rx;\n                            3: begin\n                                cmd_arg[31:16] <= dat_in_rx;\n                                start_tx_fifo <= 1;\n                            end\n                        endcase\n                    `endif\n                end\n                \n                cmd_set <= CMD24;\n            end\n            \n            GET_RX_BD: begin\n                re_s_rx <= 1;\n                rx_cycle <= 1;\n                \n                if (ack_i_s_rx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    \n                    `ifdef RAM_MEM_WIDTH_32\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_rx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_rx;\n                        end\n                    `else\n                        case (bd_cnt)\n                            0: sys_adr[15:0] <= dat_in_rx;\n                            1: sys_adr[31:16] <= dat_in_rx;\n                            2: cmd_arg[15:0] <= dat_in_rx;\n                            3: cmd_arg[31:16] <= dat_in_rx;\n                        endcase\n                    `endif\n                end\n                \n                case (transfer_type)\n                    2'b00: cmd_set <= CMD17;\n                    2'b01: cmd_set <= ACMD13;\n                    default: cmd_set <= ACMD51;\n                endcase\n            end\n            \n            SEND_CMD: begin\n                if (tx_cycle) begin\n                    d_write <= 1;\n                end else if (rx_cycle) begin\n                    d_read <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n            \n            RECIVE_CMD: begin\n                if (rx_cycle) begin\n                    start_rx_fifo <= 1;\n                end\n                \n                if (!cmd_busy) begin\n                    if (cmd_tsf_err) begin\n                        rec_failed <= 1;\n                    end else if (card_status[0] || (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) begin\n                        rec_done <= 1;\n                    end\n                end\n            end\n            \n            DATA_TRANSFER: begin\n                if (tx_cycle && tx_empt) begin\n                    trans_failed <= 1;\n                    Dat_Int_Status[0] <= 1; // Underrun error\n                end else if (rx_cycle && rx_full) begin\n                    trans_failed <= 1;\n                    Dat_Int_Status[0] <= 1; // Overrun error\n                end\n                \n                transm_complete_q <= transm_complete;\n                if (transm_complete && !transm_complete_q) begin\n                    ack_transfer <= 1;\n                    if (crc_ok) begin\n                        trans_done <= 1;\n                        if (tx_cycle) begin\n                            a_cmp_tx <= 1;\n                        end else if (rx_cycle) begin\n                            a_cmp_rx <= 1;\n                        end\n                    end else begin\n                        trans_failed <= 1;\n                        Dat_Int_Status[2] <= 1; // CRC error\n                    end\n                end\n            end\n            \n            STOP: begin\n                cmd_set <= CMD12;\n                d_read <= 1;\n                d_write <= 1;\n            end\n            \n            STOP_SEND: begin\n                resend_try_cnt <= resend_try_cnt + 1;\n                if (resend_try_cnt == RESEND_MAX_CNT) begin\n                    Dat_Int_Status[1] <= 1; // Command timeout\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n        endcase\n        \n        // Update Dat_Int_Status\n        if (Dat_Int_Status_rst) begin\n            Dat_Int_Status <= 0;\n        end\n        \n        // Update CIDAT\n        CIDAT <= busy_n;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 4, "code": "module sd_cmd_serial_host (\n    input SD_CLK_IN,\n    input RST_IN,\n    input [15:0] SETTING_IN,\n    input [39:0] CMD_IN,\n    input REQ_IN,\n    input ACK_IN,\n    input cmd_dat_i,\n    \n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n// Internal parameters\nparameter INIT_DELAY = 64;\nparameter NCR = 2;\nparameter SEND_SIZE = 48;\nparameter SIZE = 10;\nparameter CONTENT_SIZE = 40;\nparameter Read_Delay = 7;\nparameter EIGHT_PAD = 8;\n\n// FSM states\nparameter INIT     = 10'b0000000001;\nparameter IDLE     = 10'b0000000010;\nparameter WRITE_WR = 10'b0000000100;\nparameter DLY_WR   = 10'b0000001000;\nparameter READ_WR  = 10'b0000010000;\nparameter DLY_READ = 10'b0000100000;\nparameter ACK_WR   = 10'b0001000000;\nparameter WRITE_WO = 10'b0010000000;\nparameter DLY_WO   = 10'b0100000000;\nparameter ACK_WO   = 10'b1000000000;\n\n// Internal registers\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg Write_Read;\nreg Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST;\nreg [6:0] CRC_IN;\nwire [6:0] CRC_VAL;\nreg CRC_Enable;\nreg CRC_OUT;\nreg CRC_Check_On;\nreg Crc_Buffering;\nreg CRC_Valid;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg [9:0] state;\nreg [9:0] next_state;\nreg block_write;\nreg block_read;\nreg [1:0] word_select;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\n\n// Instantiate CRC module\nsd_crc_7 crc7 (\n    .BITVAL(CRC_OUT),\n    .Enable(CRC_Enable),\n    .CLK(SD_CLK_IN),\n    .RST(CRC_RST),\n    .CRC(CRC_VAL)\n);\n\n// FSM_COMBO: Combinational logic for next state\nalways @(*) begin\n    case (state)\n        INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n        IDLE: begin\n            if (Write_Read) next_state = WRITE_WR;\n            else if (Write_Only) next_state = WRITE_WO;\n            else next_state = IDLE;\n        end\n        WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n        WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n        DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n        DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n        READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n        DLY_READ: next_state = (Ack_internal_in) ? ACK_WR : DLY_READ;\n        ACK_WO: next_state = IDLE;\n        ACK_WR: next_state = IDLE;\n        default: next_state = INIT;\n    endcase\nend\n\n// FSM_SEQ: Sequential state update\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC: Synchronize REQ_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC: Synchronize ACK_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Delay_Cycler <= 0;\n        Response_Size <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        CRC_Check_On <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else begin\n        if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            \n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            \n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\nend\n\n// FSM_OUT: Output logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            \n            IDLE: begin\n                cmd_oe_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                st_dat_t <= 0;\n                word_select_counter <= 0;\n            end\n            \n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000000000000001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                        st_dat_t <= (block_read && block_write) ? 2'b11 : \n                                   (block_write) ? 2'b01 : \n                                   (block_read) ? 2'b10 : 2'b00;\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                        st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Delay_Cnt < 3'b111) begin\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                \n                Crc_Buffering <= 0;\n            end\n            \n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0100;\n                    STATUS[5] <= 0;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            \n            READ_WR: begin\n                Delay_Cnt <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Cmd_Cnt == 1) begin\n                    STATUS[3:0] <= 4'b0101;\n                    REQ_OUT <= 1;\n                    Out_Buff[39] <= 0;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Cmd_Cnt < Response_Size) begin\n                    Out_Buff[38 - Cmd_Cnt] <= cmd_dat_i;\n                    CRC_OUT <= cmd_dat_i;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                    CRC_Enable <= 0;\n                end else begin\n                    if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                        CRC_Enable <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                        CRC_Enable <= 0;\n                    end\n                    \n                    if (block_read && block_write) begin\n                        st_dat_t <= 2'b11;\n                    end else if (block_write) begin\n                        st_dat_t <= 2'b01;\n                    end\n                end\n                \n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            \n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0110;\n                    STATUS[5] <= CRC_Valid;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                CMD_OUT <= Out_Buff;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            \n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            \n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\n// ACK_OUT generation\nalways @(*) begin\n    ACK_OUT = FSM_ACK & DECODER_ACK;\nend\n\nendmodule\n\n// CRC-7 module\nmodule sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 0;\n    end else if (Enable) begin\n        CRC[0] <= BITVAL ^ CRC[6];\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= BITVAL ^ CRC[6] ^ CRC[2];\n        CRC[4] <= BITVAL ^ CRC[6] ^ CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 2, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input         wb_clk_i,\n    input         wb_rst_i,\n    input  [3:0]  wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0]  wb_adr_i,\n    input         wb_we_i,\n    input         wb_cyc_i,\n    input         wb_stb_i,\n    output        wb_ack_o,\n    \n    // Wishbone Master Interface\n    output [31:0] m_wb_adr_o,\n    output        m_wb_sel_o,\n    output        m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    \n    // SD Card Interface\n    input         sd_cmd_dat_i,\n    output        sd_cmd_out_o,\n    output        sd_cmd_oe_o,\n    input  [3:0]  sd_dat_dat_i,\n    output [3:0]  sd_dat_out_o,\n    output        sd_dat_oe_o,\n    output        sd_clk_o_pad,\n    input         sd_clk_i_pad,\n    input         card_detect,\n    \n    // Interrupts\n    output        int_a,\n    output        int_b,\n    output        int_c\n);\n\n    // Internal signals\n    wire        we_m_tx_bd;\n    wire        we_m_rx_bd;\n    wire        new_cmd;\n    wire        we_ack;\n    wire        cmd_int_busy;\n    wire        int_busy;\n    wire        write_req_s;\n    wire [15:0] cmd_set_s;\n    wire [31:0] cmd_arg_s;\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0]  software_reset_reg;\n    wire [16:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0]  clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0]  Bd_isr_reg;\n    wire [7:0]  Bd_isr_enable_reg;\n    wire        bd_isr_reset;\n    wire        normal_isr_reset;\n    wire        error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n    \n    // Data master signals\n    wire        re_s_tx;\n    wire        a_cmp_tx;\n    wire        re_s_rx;\n    wire        a_cmp_rx;\n    wire        we_req;\n    wire        d_write;\n    wire        d_read;\n    wire [31:0] cmd_arg;\n    wire [16:0] cmd_set;\n    wire        start_tx_fifo;\n    wire        start_rx_fifo;\n    wire [31:0] sys_adr;\n    wire        ack_transfer;\n    wire [7:0]  Dat_Int_Status;\n    wire        CIDAT;\n    \n    // FIFO signals\n    wire        tx_empt;\n    wire        tx_full;\n    wire        rx_full;\n    wire        busy_n;\n    wire        transm_complete;\n    wire        crc_ok;\n    \n    // CMD master signals\n    wire        go_idle_o;\n    wire [39:0] cmd_out;\n    wire        req_out;\n    wire        ack_out;\n    wire [7:0]  serial_status;\n    \n    // Clock signals\n    wire        sd_clk_i;\n    wire        sd_clk_o;\n    \n    // Assign clock outputs\n    assign sd_clk_o_pad = sd_clk_o;\n    \n    // Assign master select (always all bytes valid)\n    assign m_wb_sel_o = 4'b1111;\n    \n    // Instantiate Wishbone interface\n    sd_controller_wb wb_interface (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        \n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        \n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n    \n    // Instantiate clock divider\n    sd_clock_divider clk_div (\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i | software_reset_reg[0]),\n        .SD_CLK(sd_clk_o)\n    );\n    \n    // Instantiate command master\n    sd_cmd_master cmd_master (\n        .CLK_PAD_IO(sd_clk_o),\n        .RST_PAD_I(wb_rst_i | software_reset_reg[0] | go_idle_o),\n        .New_CMD(new_cmd),\n        .data_write(d_write),\n        .data_read(d_read),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(cmd_set),\n        .go_idle_o(go_idle_o),\n        .cmd_out(cmd_out),\n        .req_out(req_out),\n        .ack_out(ack_out),\n        .req_in(write_req_s),\n        .ack_in(we_ack),\n        .cmd_in({sd_cmd_dat_i, 39'b0}), // Only LSB is used\n        .serial_status(serial_status),\n        .card_detect(card_detect)\n    );\n    \n    // Instantiate command serial host\n    sd_cmd_serial_host cmd_serial (\n        .SD_CLK_IN(sd_clk_o),\n        .RST_IN(wb_rst_i | software_reset_reg[0]),\n        .SETTING_IN(cmd_set),\n        .CMD_IN(cmd_out),\n        .REQ_IN(req_out),\n        .ACK_IN(ack_out),\n        .cmd_dat_i(sd_cmd_dat_i),\n        .CMD_OUT(), // Not used in this context\n        .ACK_OUT(ack_out),\n        .REQ_OUT(req_out),\n        .STATUS(serial_status),\n        .cmd_oe_o(sd_cmd_oe_o),\n        .cmd_out_o(sd_cmd_out_o),\n        .st_dat_t() // Not used in this context\n    );\n    \n    // Instantiate data master\n    sd_data_master data_master (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .dat_in_tx(dat_in_m_tx_bd),\n        .free_tx_bd(Bd_Status_reg[7:0]),\n        .ack_i_s_tx(a_cmp_tx),\n        .dat_in_rx(dat_in_m_rx_bd),\n        .free_rx_bd(Bd_Status_reg[15:8]),\n        .ack_i_s_rx(a_cmp_rx),\n        .cmd_busy(cmd_int_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(1'b0), // Not implemented\n        .card_status(status_reg[4:0]),\n        .tx_empt(tx_empt),\n        .tx_full(tx_full),\n        .rx_full(rx_full),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok),\n        .Dat_Int_Status_rst(bd_isr_reset),\n        .transfer_type(cmd_setting_reg[1:0]),\n        \n        .re_s_tx(re_s_tx),\n        .a_cmp_tx(a_cmp_tx),\n        .re_s_rx(re_s_rx),\n        .a_cmp_rx(a_cmp_rx),\n        .we_req(we_req),\n        .d_write(d_write),\n        .d_read(d_read),\n        .cmd_arg(cmd_arg),\n        .cmd_set(cmd_set),\n        .start_tx_fifo(start_tx_fifo),\n        .start_rx_fifo(start_rx_fifo),\n        .sys_adr(sys_adr),\n        .ack_transfer(ack_transfer),\n        .Dat_Int_Status(Dat_Int_Status),\n        .CIDAT(CIDAT)\n    );\n    \n    // Instantiate TX BD\n    tx_bd tx_buffer_descriptor (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_tx_bd),\n        .dat_in_m(dat_in_m_tx_bd),\n        .free_bd(Bd_Status_reg[7:0]),\n        .re_s(re_s_tx),\n        .ack_o_s(a_cmp_tx),\n        .a_cmp(a_cmp_tx),\n        .dat_out_s() // Not used in this context\n    );\n    \n    // Instantiate RX BD\n    rx_bd rx_buffer_descriptor (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_rx_bd),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(Bd_Status_reg[15:8]),\n        .re_s(re_s_rx),\n        .ack_o_s(a_cmp_rx),\n        .a_cmp(a_cmp_rx),\n        .dat_out_s() // Not used in this context\n    );\n    \n    // Instantiate TX FIFO filler\n    sd_fifo_tx_filler tx_fifo (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(start_tx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_o(), // Not used in this context\n        .rd(1'b0), // Not used in this context\n        .empty(tx_empt),\n        .fe(tx_full)\n    );\n    \n    // Instantiate RX FIFO filler\n    sd_fifo_rx_filler rx_fifo (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(start_rx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_i(sd_dat_dat_i),\n        .wr(1'b0), // Not used in this context\n        .full(rx_full)\n    );\n    \n    // Instantiate data serial host\n    sd_data_serial_host data_serial (\n        .sd_clk(sd_clk_o),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .data_in(32'b0), // Not used in this context\n        .start_dat({d_read, d_write}),\n        .ack_transfer(ack_transfer),\n        .DAT_dat_i(sd_dat_dat_i),\n        .rd(), // Not used in this context\n        .data_out(), // Not used in this context\n        .we(), // Not used in this context\n        .DAT_oe_o(sd_dat_oe_o),\n        .DAT_dat_o(sd_dat_out_o),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok)\n    );\n    \n    // Interrupt generation\n    assign int_a = |(normal_int_status_reg & normal_int_signal_enable_reg);\n    assign int_b = |(error_int_status_reg & error_int_signal_enable_reg);\n    assign int_c = |(Bd_isr_reg & Bd_isr_enable_reg);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 5, "code": "module sd_cmd_serial_host (\n    input SD_CLK_IN,\n    input RST_IN,\n    input [15:0] SETTING_IN,\n    input [39:0] CMD_IN,\n    input REQ_IN,\n    input ACK_IN,\n    input cmd_dat_i,\n    \n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n// Internal parameters\nparameter INIT_DELAY = 64;\nparameter NCR = 2;\nparameter SEND_SIZE = 48;\nparameter SIZE = 10;\nparameter CONTENT_SIZE = 40;\nparameter Read_Delay = 7;\nparameter EIGHT_PAD = 8;\n\n// FSM states\nparameter INIT     = 10'b0000000001;\nparameter IDLE     = 10'b0000000010;\nparameter WRITE_WR = 10'b0000000100;\nparameter DLY_WR   = 10'b0000001000;\nparameter READ_WR  = 10'b0000010000;\nparameter DLY_READ = 10'b0000100000;\nparameter ACK_WR   = 10'b0001000000;\nparameter WRITE_WO = 10'b0010000000;\nparameter DLY_WO   = 10'b0100000000;\nparameter ACK_WO   = 10'b1000000000;\n\n// Internal registers\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg Write_Read;\nreg Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST;\nreg [6:0] CRC_IN;\nwire [6:0] CRC_VAL;\nreg CRC_Enable;\nreg CRC_OUT;\nreg CRC_Check_On;\nreg Crc_Buffering;\nreg CRC_Valid;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg [9:0] state;\nreg [9:0] next_state;\nreg block_write;\nreg block_read;\nreg [1:0] word_select;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\n\n// Instantiate CRC module\nsd_crc_7 crc7 (\n    .BITVAL(CRC_OUT),\n    .Enable(CRC_Enable),\n    .CLK(SD_CLK_IN),\n    .RST(CRC_RST),\n    .CRC(CRC_VAL)\n);\n\n// FSM_COMBO: Combinational logic for next state\nalways @(*) begin\n    case (state)\n        INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n        IDLE: next_state = (Write_Read) ? WRITE_WR : \n                          (Write_Only) ? WRITE_WO : IDLE;\n        WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n        WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n        DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n        DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n        READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n        DLY_READ: next_state = (Ack_internal_in) ? ACK_WR : DLY_READ;\n        ACK_WO: next_state = IDLE;\n        ACK_WR: next_state = IDLE;\n        default: next_state = INIT;\n    endcase\nend\n\n// FSM_SEQ: Sequential state update\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC: Synchronize REQ_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC: Synchronize ACK_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Delay_Cycler <= 0;\n        Response_Size <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        CRC_Check_On <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else if (Req_internal_in) begin\n        Response_Size <= SETTING_IN[6:0];\n        CRC_Check_On <= SETTING_IN[7];\n        Delay_Cycler <= SETTING_IN[10:8];\n        block_write <= SETTING_IN[11];\n        block_read <= SETTING_IN[12];\n        word_select <= SETTING_IN[14:13];\n        In_Buff <= CMD_IN;\n        if (SETTING_IN[6:0] > 0) begin\n            Write_Read <= 1;\n            Write_Only <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 1;\n        end\n        DECODER_ACK <= 0;\n    end else begin\n        Write_Read <= 0;\n        Write_Only <= 0;\n        DECODER_ACK <= 1;\n    end\nend\n\n// FSM_OUT: Output logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            \n            IDLE: begin\n                cmd_oe_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                st_dat_t <= 0;\n                word_select_counter <= 0;\n            end\n            \n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000000000000001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                        if (block_read) begin\n                            st_dat_t <= 2'b10;\n                        end\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                        if (block_read) begin\n                            st_dat_t <= 2'b10;\n                        end\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Delay_Cnt < 3'b111) begin\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                \n                Crc_Buffering <= 0;\n            end\n            \n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0100;\n                    STATUS[5] <= 0;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            \n            READ_WR: begin\n                Delay_Cnt <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Cmd_Cnt == 1) begin\n                    STATUS[3:0] <= 4'b0101;\n                    REQ_OUT <= 1;\n                    Out_Buff[39] <= 0;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Cmd_Cnt < Response_Size) begin\n                    Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                    CRC_OUT <= cmd_dat_i;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                    CRC_Enable <= 0;\n                end else begin\n                    if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                        CRC_Enable <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                        CRC_Enable <= 0;\n                    end\n                    \n                    if (block_read && block_write) begin\n                        st_dat_t <= 2'b11;\n                    end else if (block_write) begin\n                        st_dat_t <= 2'b01;\n                    end\n                end\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            \n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0110;\n                    STATUS[5] <= CRC_Valid;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                CMD_OUT <= Out_Buff;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            \n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            \n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\n// ACK_OUT assignment\nalways @(*) begin\n    ACK_OUT = FSM_ACK & DECODER_ACK;\nend\n\nendmodule\n\n// CRC-7 module\nmodule sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 0;\n    end else if (Enable) begin\n        CRC[0] <= BITVAL ^ CRC[6];\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= BITVAL ^ CRC[6] ^ CRC[2];\n        CRC[4] <= BITVAL ^ CRC[6] ^ CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 6, "code": "module sd_cmd_serial_host (\n    input SD_CLK_IN,\n    input RST_IN,\n    input [15:0] SETTING_IN,\n    input [39:0] CMD_IN,\n    input REQ_IN,\n    input ACK_IN,\n    input cmd_dat_i,\n    \n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [15:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n// Parameters\nparameter INIT_DELAY = `SIM ? 2 : 64;\nparameter NCR = 2;\nparameter SEND_SIZE = 48;\nparameter SIZE = 10;\nparameter CONTENT_SIZE = 40;\nparameter Read_Delay = 7;\nparameter EIGHT_PAD = 8;\n\n// FSM states\nparameter INIT     = 10'b0000000001;\nparameter IDLE     = 10'b0000000010;\nparameter WRITE_WR = 10'b0000000100;\nparameter DLY_WR   = 10'b0000001000;\nparameter READ_WR  = 10'b0000010000;\nparameter DLY_READ = 10'b0000100000;\nparameter ACK_WR   = 10'b0001000000;\nparameter WRITE_WO = 10'b0010000000;\nparameter DLY_WO   = 10'b0100000000;\nparameter ACK_WO   = 10'b1000000000;\n\n// Internal registers\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg Write_Read;\nreg Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST;\nreg [6:0] CRC_IN;\nwire [6:0] CRC_VAL;\nreg CRC_Enable;\nreg CRC_OUT;\nreg CRC_Check_On;\nreg Crc_Buffering;\nreg CRC_Valid;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nreg block_write;\nreg block_read;\nreg [1:0] word_select;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\n\n// CRC module instantiation\nsd_crc_7 crc7 (\n    .BITVAL(CRC_OUT),\n    .Enable(CRC_Enable),\n    .CLK(SD_CLK_IN),\n    .RST(CRC_RST),\n    .CRC(CRC_VAL)\n);\n\n// FSM_COMBO: Combinational logic for next state\nalways @(*) begin\n    case (state)\n        INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n        IDLE: begin\n            if (Write_Read)\n                next_state = WRITE_WR;\n            else if (Write_Only)\n                next_state = WRITE_WO;\n            else\n                next_state = IDLE;\n        end\n        WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n        WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n        DLY_WR: begin\n            if (Delay_Cnt >= NCR && !cmd_dat_i)\n                next_state = READ_WR;\n            else\n                next_state = DLY_WR;\n        end\n        DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n        READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n        DLY_READ: next_state = (Ack_internal_in) ? ACK_WR : DLY_READ;\n        ACK_WO: next_state = IDLE;\n        ACK_WR: next_state = IDLE;\n        default: next_state = INIT;\n    endcase\nend\n\n// FSM_SEQ: Sequential state update\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN)\n        state <= INIT;\n    else\n        state <= next_state;\nend\n\n// REQ_SYNC: Synchronize REQ_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC: Synchronize ACK_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Delay_Cycler <= 0;\n        Response_Size <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        CRC_Check_On <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else begin\n        if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            \n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            \n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\nend\n\n// FSM_OUT: Output logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            \n            IDLE: begin\n                cmd_oe_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                st_dat_t <= 0;\n                word_select_counter <= 0;\n            end\n            \n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000000000000001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    \n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9)\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                        if (block_read)\n                            st_dat_t <= 2'b10;\n                        else\n                            st_dat_t <= 0;\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    \n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    \n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9)\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                        if (block_read)\n                            st_dat_t <= 2'b10;\n                        else if (block_write)\n                            st_dat_t <= 2'b01;\n                        else\n                            st_dat_t <= 0;\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    \n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Delay_Cnt < 3'b111)\n                    Delay_Cnt <= Delay_Cnt + 1;\n                \n                Crc_Buffering <= 0;\n            end\n            \n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0100;\n                    STATUS[5] <= 0;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            \n            READ_WR: begin\n                Delay_Cnt <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Cmd_Cnt == 1) begin\n                    STATUS[3:0] <= 4'b0101;\n                    REQ_OUT <= 1;\n                    Out_Buff[39] <= 0;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Cmd_Cnt < Response_Size) begin\n                    Out_Buff[38 - Cmd_Cnt] <= cmd_dat_i;\n                    CRC_OUT <= cmd_dat_i;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                    CRC_Enable <= 0;\n                end else begin\n                    if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                        CRC_Enable <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                        CRC_Enable <= 0;\n                    end\n                    \n                    if (block_read && block_write)\n                        st_dat_t <= 2'b11;\n                    else if (block_write)\n                        st_dat_t <= 2'b01;\n                end\n                \n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            \n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0110;\n                    STATUS[5] <= CRC_Valid;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                CMD_OUT <= Out_Buff;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            \n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            \n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\n// ACK_OUT generation\nalways @(*) begin\n    ACK_OUT = FSM_ACK & DECODER_ACK;\nend\n\nendmodule\n\n// CRC-7 module\nmodule sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 0;\n    end else if (Enable) begin\n        CRC[0] <= CRC[6] ^ BITVAL;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ CRC[6] ^ BITVAL;\n        CRC[4] <= CRC[3] ^ CRC[6] ^ BITVAL;\n        CRC[5] <= CRC[4] ^ CRC[6] ^ BITVAL;\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 7, "code": "module sd_cmd_serial_host (\n    input SD_CLK_IN,\n    input RST_IN,\n    input [15:0] SETTING_IN,\n    input [39:0] CMD_IN,\n    input REQ_IN,\n    input ACK_IN,\n    input cmd_dat_i,\n    \n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n// Internal constants\nparameter INIT_DELAY = 64;\nparameter NCR = 2;\nparameter SEND_SIZE = 48;\nparameter SIZE = 10;\nparameter CONTENT_SIZE = 40;\nparameter Read_Delay = 7;\nparameter EIGHT_PAD = 8;\n\n// FSM states\nparameter INIT     = 10'b0000000001;\nparameter IDLE     = 10'b0000000010;\nparameter WRITE_WR = 10'b0000000100;\nparameter DLY_WR   = 10'b0000001000;\nparameter READ_WR  = 10'b0000010000;\nparameter DLY_READ = 10'b0000100000;\nparameter ACK_WR   = 10'b0001000000;\nparameter WRITE_WO = 10'b0010000000;\nparameter DLY_WO   = 10'b0100000000;\nparameter ACK_WO   = 10'b1000000000;\n\n// Internal registers\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg Write_Read;\nreg Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST;\nreg [6:0] CRC_IN;\nwire [6:0] CRC_VAL;\nreg CRC_Enable;\nreg CRC_OUT;\nreg CRC_Check_On;\nreg Crc_Buffering;\nreg CRC_Valid;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg [9:0] state;\nreg [9:0] next_state;\nreg block_write;\nreg block_read;\nreg [1:0] word_select;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\n\n// CRC submodule\nsd_crc_7 crc7 (\n    .BITVAL(CRC_OUT),\n    .Enable(CRC_Enable),\n    .CLK(SD_CLK_IN),\n    .RST(CRC_RST),\n    .CRC(CRC_VAL)\n);\n\n// FSM_COMBO: Combinational logic for next state\nalways @(*) begin\n    case (state)\n        INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n        IDLE: begin\n            if (Write_Read)\n                next_state = WRITE_WR;\n            else if (Write_Only)\n                next_state = WRITE_WO;\n            else\n                next_state = IDLE;\n        end\n        WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n        WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n        DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n        DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n        READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n        DLY_READ: next_state = (Ack_internal_in) ? ACK_WR : DLY_READ;\n        ACK_WO: next_state = IDLE;\n        ACK_WR: next_state = IDLE;\n        default: next_state = INIT;\n    endcase\nend\n\n// FSM_SEQ: Sequential state update\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC: Synchronize REQ_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC: Synchronize ACK_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Delay_Cycler <= 0;\n        Response_Size <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        CRC_Check_On <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else begin\n        if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            \n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\nend\n\n// FSM_OUT: Output logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            \n            IDLE: begin\n                cmd_oe_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                st_dat_t <= 0;\n                word_select_counter <= 0;\n            end\n            \n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000000000000001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                        if (block_read) begin\n                            st_dat_t <= 2'b10;\n                        end\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                        if (block_read) begin\n                            st_dat_t <= 2'b10;\n                        end\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Delay_Cnt < 3'b111) begin\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                \n                Crc_Buffering <= 0;\n            end\n            \n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0100;\n                    STATUS[5] <= 0;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            \n            READ_WR: begin\n                Delay_Cnt <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Cmd_Cnt == 1) begin\n                    STATUS[3:0] <= 4'b0101;\n                    REQ_OUT <= 1;\n                    Out_Buff[39] <= 0;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Cmd_Cnt < Response_Size) begin\n                    Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                    CRC_OUT <= cmd_dat_i;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                    CRC_Enable <= 0;\n                end else begin\n                    if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                        CRC_Enable <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                        CRC_Enable <= 0;\n                    end\n                    \n                    if (block_read && block_write) begin\n                        st_dat_t <= 2'b11;\n                    end else if (block_write) begin\n                        st_dat_t <= 2'b01;\n                    end\n                end\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            \n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0110;\n                    STATUS[5] <= CRC_Valid;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                CMD_OUT <= Out_Buff;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            \n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            \n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\n// ACK_OUT assignment\nalways @(*) begin\n    ACK_OUT = FSM_ACK & DECODER_ACK;\nend\n\nendmodule\n\n// CRC-7 submodule\nmodule sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nreg [6:0] CRCREG;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRCREG <= 0;\n        CRC <= 0;\n    end else if (Enable) begin\n        CRCREG[0] <= BITVAL ^ CRCREG[6];\n        CRCREG[1] <= CRCREG[0];\n        CRCREG[2] <= CRCREG[1];\n        CRCREG[3] <= BITVAL ^ CRCREG[6] ^ CRCREG[2];\n        CRCREG[4] <= BITVAL ^ CRCREG[6] ^ CRCREG[3];\n        CRCREG[5] <= BITVAL ^ CRCREG[6] ^ CRCREG[4];\n        CRCREG[6] <= BITVAL ^ CRCREG[5];\n        CRC <= CRCREG;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 20, "code": "module sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    \n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\nparameter SD_BUS_W = 4;\nparameter BIT_BLOCK = 512;\nparameter CRC_OFF = 16;\nparameter BIT_BLOCK_REC = 512;\nparameter BIT_CRC_CYCLE = 16;\nparameter LITTLE_ENDIAN = 1;\nparameter BIG_ENDIAN = 0;\nparameter SD_BUS_WIDTH_1 = 1;\nparameter SD_BUS_WIDTH_4 = 4;\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out [0:SD_BUS_W-1];\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// States\nlocalparam IDLE       = 6'b000001;\nlocalparam WRITE_DAT  = 6'b000010;\nlocalparam WRITE_CRC  = 6'b000100;\nlocalparam WRITE_BUSY = 6'b001000;\nlocalparam READ_WAIT  = 6'b010000;\nlocalparam READ_DAT   = 6'b100000;\n\n// CRC generation blocks\ngenerate\ngenvar i;\nfor (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n    sd_crc_16 crc_inst (\n        .BITVAL(crc_in[i]),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out[i])\n    );\nend\nendgenerate\n\n// ACK_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        ack_q <= 1'b0;\n        ack_transfer_int <= 1'b0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// FSM_COMBO block\nalways @(*) begin\n    next_state = state;\n    case (state)\n        IDLE: begin\n            if (start_dat[1] & ~start_dat[0]) next_state = WRITE_DAT;\n            else if (start_dat[0] & ~start_dat[1]) next_state = READ_WAIT;\n            else next_state = IDLE;\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == BIT_BLOCK) next_state = WRITE_CRC;\n            else next_state = WRITE_DAT;\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b001) next_state = WRITE_BUSY;\n            else next_state = WRITE_CRC;\n        end\n        WRITE_BUSY: begin\n            if (~busy_int) next_state = IDLE;\n            else next_state = WRITE_BUSY;\n        end\n        READ_WAIT: begin\n            if (~DAT_dat_i[0]) next_state = READ_DAT;\n            else if (transf_cnt > 11'd1000) next_state = IDLE;\n            else next_state = READ_WAIT;\n        end\n        READ_DAT: begin\n            if (transf_cnt == BIT_BLOCK_REC + BIT_CRC_CYCLE) next_state = IDLE;\n            else next_state = READ_DAT;\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// START_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        q_start_bit <= 1'b1;\n    end else begin\n        if (~DAT_dat_i[0] & (state == READ_WAIT)) begin\n            q_start_bit <= 1'b0;\n        end else begin\n            q_start_bit <= 1'b1;\n        end\n    end\nend\n\n// FSM_SEQ block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        write_buf_0 <= 32'b0;\n        write_buf_1 <= 32'b0;\n        DAT_oe_o <= 1'b0;\n        crc_en <= 1'b0;\n        crc_rst <= 1'b1;\n        transf_cnt <= 11'b0;\n        rd <= 1'b0;\n        last_din <= 4'b0;\n        crc_c <= 5'b0;\n        crc_in <= 4'b0;\n        DAT_dat_o <= 4'b0;\n        crc_status <= 3'b111;\n        crc_s <= 3'b0;\n        transm_complete <= 1'b0;\n        busy_n <= 1'b1;\n        we <= 1'b0;\n        data_out <= 4'b0;\n        crc_ok <= 1'b0;\n        busy_int <= 1'b0;\n        data_send_index <= 3'b0;\n        out_buff_ptr <= 1'b0;\n        in_buff_ptr <= 1'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                crc_rst <= 1'b1;\n                crc_en <= 1'b0;\n                DAT_oe_o <= 1'b0;\n                transf_cnt <= 11'b0;\n                transm_complete <= 1'b0;\n                busy_n <= 1'b1;\n                crc_ok <= 1'b0;\n                busy_int <= 1'b0;\n                data_send_index <= 3'b0;\n                out_buff_ptr <= 1'b0;\n                in_buff_ptr <= 1'b0;\n                \n                if (start_dat[1] & ~start_dat[0]) begin\n                    write_buf_0 <= data_in;\n                    rd <= 1'b1;\n                end else begin\n                    rd <= 1'b0;\n                end\n            end\n            \n            WRITE_DAT: begin\n                crc_rst <= 1'b0;\n                DAT_oe_o <= 1'b1;\n                \n                if (transf_cnt == 0) begin\n                    DAT_dat_o <= 4'b0; // Start bit\n                    crc_en <= 1'b0;\n                end else if (transf_cnt <= BIT_BLOCK) begin\n                    if (transf_cnt[1:0] == 2'b00) begin\n                        if (out_buff_ptr) begin\n                            last_din <= write_buf_1[31:28];\n                            write_buf_1 <= {write_buf_1[27:0], 4'b0};\n                        end else begin\n                            last_din <= write_buf_0[31:28];\n                            write_buf_0 <= {write_buf_0[27:0], 4'b0};\n                        end\n                        \n                        if (transf_cnt[4:0] == 5'b11100) begin\n                            out_buff_ptr <= ~out_buff_ptr;\n                            if (~out_buff_ptr) begin\n                                write_buf_1 <= data_in;\n                                rd <= 1'b1;\n                            end else begin\n                                write_buf_0 <= data_in;\n                                rd <= 1'b1;\n                            end\n                        end else begin\n                            rd <= 1'b0;\n                        end\n                    end\n                    \n                    DAT_dat_o <= last_din;\n                    crc_in <= last_din;\n                    crc_en <= 1'b1;\n                end\n                \n                transf_cnt <= transf_cnt + 1;\n            end\n            \n            WRITE_CRC: begin\n                if (transf_cnt < BIT_BLOCK + BIT_CRC_CYCLE) begin\n                    if (transf_cnt[1:0] == 2'b00) begin\n                        case (data_send_index)\n                            0: DAT_dat_o <= crc_out[0][15:12];\n                            1: DAT_dat_o <= crc_out[0][11:8];\n                            2: DAT_dat_o <= crc_out[0][7:4];\n                            3: DAT_dat_o <= crc_out[0][3:0];\n                            default: DAT_dat_o <= 4'b1111;\n                        endcase\n                        data_send_index <= data_send_index + 1;\n                    end\n                    transf_cnt <= transf_cnt + 1;\n                end else begin\n                    DAT_dat_o <= 4'b1111; // Stop bit\n                    crc_status <= 3'b001;\n                end\n            end\n            \n            WRITE_BUSY: begin\n                transm_complete <= 1'b1;\n                busy_int <= DAT_dat_i[0];\n                busy_n <= ~DAT_dat_i[0];\n                \n                if (crc_s == 3'b010) begin\n                    crc_ok <= 1'b1;\n                end else begin\n                    crc_ok <= 1'b0;\n                end\n            end\n            \n            READ_WAIT: begin\n                crc_rst <= 1'b0;\n                crc_en <= 1'b1;\n                DAT_oe_o <= 1'b0;\n                we <= 1'b0;\n            end\n            \n            READ_DAT: begin\n                if (transf_cnt < BIT_BLOCK_REC) begin\n                    data_out <= DAT_dat_i;\n                    crc_in <= DAT_dat_i;\n                    we <= 1'b1;\n                end else if (transf_cnt < BIT_BLOCK_REC + BIT_CRC_CYCLE) begin\n                    we <= 1'b0;\n                    // CRC checking would go here\n                end else begin\n                    transm_complete <= 1'b1;\n                    busy_n <= 1'b0;\n                end\n                \n                transf_cnt <= transf_cnt + 1;\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule sd_crc_16 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'b0;\n    end else if (Enable) begin\n        CRC[0] <= CRC[15] ^ BITVAL;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2];\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4] ^ (CRC[15] ^ BITVAL);\n        CRC[6] <= CRC[5];\n        CRC[7] <= CRC[6];\n        CRC[8] <= CRC[7];\n        CRC[9] <= CRC[8];\n        CRC[10] <= CRC[9];\n        CRC[11] <= CRC[10];\n        CRC[12] <= CRC[11] ^ (CRC[15] ^ BITVAL);\n        CRC[13] <= CRC[12];\n        CRC[14] <= CRC[13];\n        CRC[15] <= CRC[14];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    // Input ports\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n\n    // Output ports\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n// Parameters\nparameter CMD24 = 16'h181A;  // Write single block\nparameter CMD17 = 16'h111A;  // Read single block\nparameter CMD12 = 16'hC1A;   // Stop transmission\nparameter ACMD13 = 16'hD1A;  // SD status\nparameter ACMD51 = 16'h331A; // Read SCR register\n\nparameter SIZE = 9;\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\n\nparameter RESEND_MAX_CNT = 3;\n\n// Internal signals\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\n\n`ifdef RAM_MEM_WIDTH_32\n    parameter READ_CYCLE = 2;\n    reg [1:0] bd_cnt;\n    wire [BD_WIDTH-1:0] BD_EMPTY = BD_SIZE / 2;\n`else\n    parameter READ_CYCLE = 4;\n    reg [2:0] bd_cnt;\n    wire [BD_WIDTH-1:0] BD_EMPTY = BD_SIZE / 4;\n`endif\n\n// FSM sequential logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM combinational logic\nalways @(*) begin\n    next_state = state;\n    \n    case (state)\n        IDLE: begin\n            if (free_tx_bd != BD_EMPTY) begin\n                next_state = GET_TX_BD;\n            end else if (free_rx_bd != BD_EMPTY) begin\n                next_state = GET_RX_BD;\n            end\n        end\n        \n        GET_TX_BD: begin\n            if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                next_state = SEND_CMD;\n            end\n        end\n        \n        GET_RX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1) begin\n                next_state = SEND_CMD;\n            end\n        end\n        \n        SEND_CMD: begin\n            if (send_done) begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        \n        RECIVE_CMD: begin\n            if (rec_done) begin\n                next_state = DATA_TRANSFER;\n            end else if (rec_failed) begin\n                next_state = SEND_CMD;\n            end\n        end\n        \n        DATA_TRANSFER: begin\n            if (trans_done) begin\n                next_state = IDLE;\n            end else if (trans_failed) begin\n                next_state = STOP;\n            end\n        end\n        \n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        \n        STOP_SEND: begin\n            if (send_done) begin\n                next_state = IDLE;\n            end\n        end\n        \n        default: next_state = IDLE;\n    endcase\nend\n\n// Output logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all outputs\n        re_s_tx <= 0;\n        a_cmp_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        sys_adr <= 0;\n        ack_transfer <= 0;\n        Dat_Int_Status <= 0;\n        CIDAT <= 0;\n        \n        // Reset internal signals\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n    end else begin\n        // Default values\n        re_s_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_tx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        ack_transfer <= 0;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        \n        // Handle Dat_Int_Status reset\n        if (Dat_Int_Status_rst) begin\n            Dat_Int_Status <= 0;\n        end\n        \n        case (state)\n            IDLE: begin\n                bd_cnt <= 0;\n                resend_try_cnt <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n            end\n            \n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                if (ack_i_s_tx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    if (bd_cnt == 0) begin\n                        sys_adr <= dat_in_tx;\n                    end else if (bd_cnt == 1) begin\n                        cmd_arg <= dat_in_tx;\n                        start_tx_fifo <= 1;\n                    end\n                end\n                \n                if (bd_cnt > READ_CYCLE - 1 && tx_full) begin\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n            end\n            \n            GET_RX_BD: begin\n                re_s_rx <= 1;\n                if (ack_i_s_rx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    if (bd_cnt == 0) begin\n                        sys_adr <= dat_in_rx;\n                    end else if (bd_cnt == 1) begin\n                        cmd_arg <= dat_in_rx;\n                    end\n                end\n                \n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n            end\n            \n            SEND_CMD: begin\n                if (tx_cycle) d_write <= 1;\n                if (rx_cycle) d_read <= 1;\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n            \n            RECIVE_CMD: begin\n                if (rx_cycle) start_rx_fifo <= 1;\n                \n                if (!cmd_busy) begin\n                    if (cmd_tsf_err) begin\n                        rec_failed <= 1;\n                    end else if (card_status[0] == 1 && \n                               (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) begin\n                        rec_done <= 1;\n                    end\n                end\n            end\n            \n            DATA_TRANSFER: begin\n                if (tx_cycle && tx_empt) begin\n                    trans_failed <= 1;\n                    Dat_Int_Status[0] <= 1; // Underrun error\n                end\n                \n                if (rx_cycle && rx_full) begin\n                    trans_failed <= 1;\n                    Dat_Int_Status[1] <= 1; // Overrun error\n                end\n                \n                if (transm_complete) begin\n                    if (crc_ok) begin\n                        trans_done <= 1;\n                        ack_transfer <= 1;\n                        if (tx_cycle) a_cmp_tx <= 1;\n                        if (rx_cycle) a_cmp_rx <= 1;\n                    end else begin\n                        trans_failed <= 1;\n                        Dat_Int_Status[2] <= 1; // CRC error\n                    end\n                end\n            end\n            \n            STOP: begin\n                cmd_set <= CMD12;\n                d_read <= 1;\n                d_write <= 1;\n            end\n            \n            STOP_SEND: begin\n                resend_try_cnt <= resend_try_cnt + 1;\n                \n                if (resend_try_cnt == RESEND_MAX_CNT) begin\n                    Dat_Int_Status[1] <= 1; // Overrun error\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n        endcase\n        \n        // Track transmission complete\n        transm_complete_q <= transm_complete;\n        internal_transm_complete <= transm_complete && !transm_complete_q;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 3, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input               wb_clk_i,\n    input               wb_rst_i,\n    input        [3:0]  wb_sel_i,\n    input        [31:0] wb_dat_i,\n    output       [31:0] wb_dat_o,\n    input        [7:0]  wb_adr_i,\n    input               wb_we_i,\n    input               wb_cyc_i,\n    input               wb_stb_i,\n    output              wb_ack_o,\n    \n    // Wishbone Master Interface\n    output       [31:0] m_wb_adr_o,\n    output              m_wb_sel_o,\n    output              m_wb_we_o,\n    output       [31:0] m_wb_dat_o,\n    input        [31:0] m_wb_dat_i,\n    output              m_wb_cyc_o,\n    output              m_wb_stb_o,\n    input               m_wb_ack_i,\n    output       [2:0]  m_wb_cti_o,\n    output       [1:0]  m_wb_bte_o,\n    \n    // SD Card Interface\n    input               sd_cmd_dat_i,\n    output              sd_cmd_out_o,\n    output              sd_cmd_oe_o,\n    input        [3:0]  sd_dat_dat_i,\n    output       [3:0]  sd_dat_out_o,\n    output              sd_dat_oe_o,\n    output              sd_clk_o_pad,\n    input               sd_clk_i_pad,\n    input               card_detect,\n    \n    // Interrupts\n    output              int_a,\n    output              int_b,\n    output              int_c\n);\n\n    // Internal signals\n    wire        [31:0] argument_reg;\n    wire        [15:0] cmd_setting_reg;\n    wire        [15:0] status_reg;\n    wire        [31:0] cmd_resp_1;\n    wire         [7:0] software_reset_reg;\n    wire        [15:0] time_out_reg;\n    wire        [15:0] normal_int_status_reg;\n    wire        [15:0] error_int_status_reg;\n    wire        [15:0] normal_int_signal_enable_reg;\n    wire        [15:0] error_int_signal_enable_reg;\n    wire         [7:0] clock_divider;\n    wire        [15:0] Bd_Status_reg;\n    wire         [7:0] Bd_isr_reg;\n    wire         [7:0] Bd_isr_enable_reg;\n    \n    wire               we_m_tx_bd;\n    wire               we_m_rx_bd;\n    wire               new_cmd;\n    wire               we_ack;\n    wire               int_ack;\n    wire               cmd_int_busy;\n    wire               write_req_s;\n    wire        [15:0] cmd_set_s;\n    wire        [31:0] cmd_arg_s;\n    wire               bd_isr_reset;\n    wire               normal_isr_reset;\n    wire               error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n    \n    // Data master signals\n    wire               re_s_tx;\n    wire               a_cmp_tx;\n    wire               re_s_rx;\n    wire               a_cmp_rx;\n    wire               d_write;\n    wire               d_read;\n    wire        [31:0] cmd_arg;\n    wire        [15:0] cmd_set;\n    wire               start_tx_fifo;\n    wire               start_rx_fifo;\n    wire        [31:0] sys_adr;\n    wire               ack_transfer;\n    wire         [7:0] Dat_Int_Status;\n    wire               CIDAT;\n    \n    // FIFO signals\n    wire               tx_empt;\n    wire               tx_full;\n    wire               rx_full;\n    wire               busy_n;\n    wire               transm_complete;\n    wire               crc_ok;\n    \n    // Clock divider signals\n    wire               sd_clk_o;\n    \n    // Instantiate sd_controller_wb\n    sd_controller_wb u_wb_controller (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        \n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        \n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n    \n    // Instantiate sd_clock_divider\n    sd_clock_divider u_clock_divider (\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i | software_reset_reg[0]),\n        .SD_CLK(sd_clk_o)\n    );\n    \n    assign sd_clk_o_pad = sd_clk_o;\n    \n    // Instantiate sd_cmd_master\n    sd_cmd_master u_cmd_master (\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i | software_reset_reg[0]),\n        .New_CMD(new_cmd),\n        .data_write(d_write),\n        .data_read(d_read),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(),\n        .go_idle_o(),\n        .cmd_out(),\n        .req_out(),\n        .ack_out(),\n        .req_in(),\n        .ack_in(),\n        .cmd_in(),\n        .serial_status(),\n        .card_detect(card_detect)\n    );\n    \n    // Instantiate sd_data_master\n    sd_data_master u_data_master (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .dat_in_tx(dat_in_m_tx_bd),\n        .free_tx_bd(Bd_Status_reg[7:0]),\n        .ack_i_s_tx(a_cmp_tx),\n        .dat_in_rx(dat_in_m_rx_bd),\n        .free_rx_bd(Bd_Status_reg[15:8]),\n        .ack_i_s_rx(a_cmp_rx),\n        .cmd_busy(cmd_int_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(),\n        .card_status(status_reg[4:0]),\n        .tx_empt(tx_empt),\n        .tx_full(tx_full),\n        .rx_full(rx_full),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok),\n        .Dat_Int_Status_rst(bd_isr_reset),\n        .transfer_type(),\n        \n        .re_s_tx(re_s_tx),\n        .a_cmp_tx(a_cmp_tx),\n        .re_s_rx(re_s_rx),\n        .a_cmp_rx(a_cmp_rx),\n        .we_req(write_req_s),\n        .d_write(d_write),\n        .d_read(d_read),\n        .cmd_arg(cmd_arg_s),\n        .cmd_set(cmd_set_s),\n        .start_tx_fifo(start_tx_fifo),\n        .start_rx_fifo(start_rx_fifo),\n        .sys_adr(sys_adr),\n        .ack_transfer(ack_transfer),\n        .Dat_Int_Status(Dat_Int_Status),\n        .CIDAT(CIDAT)\n    );\n    \n    // Instantiate tx_bd\n    sd_bd u_tx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_tx_bd),\n        .dat_in_m(dat_in_m_tx_bd),\n        .free_bd(Bd_Status_reg[7:0]),\n        .re_s(re_s_tx),\n        .ack_o_s(a_cmp_tx),\n        .a_cmp(a_cmp_tx),\n        .dat_out_s()\n    );\n    \n    // Instantiate rx_bd\n    sd_bd u_rx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_rx_bd),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(Bd_Status_reg[15:8]),\n        .re_s(re_s_rx),\n        .ack_o_s(a_cmp_rx),\n        .a_cmp(a_cmp_rx),\n        .dat_out_s()\n    );\n    \n    // Instantiate sd_fifo_tx_filler\n    sd_fifo_tx_filler u_tx_filler (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(start_tx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_o(),\n        .rd(),\n        .empty(tx_empt),\n        .fe(tx_full)\n    );\n    \n    // Instantiate sd_fifo_rx_filler\n    sd_fifo_rx_filler u_rx_filler (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(),\n        .m_wb_we_o(),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(),\n        .m_wb_stb_o(),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(),\n        .m_wb_bte_o(),\n        .en(start_rx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_i(sd_dat_dat_i),\n        .wr(),\n        .full(rx_full)\n    );\n    \n    // Interrupt generation\n    assign int_a = |(normal_int_status_reg & normal_int_signal_enable_reg);\n    assign int_b = |(error_int_status_reg & error_int_signal_enable_reg);\n    assign int_c = |(Bd_isr_reg & Bd_isr_enable_reg);\n    \n    // Master interface byte select\n    assign m_wb_sel_o = 4'b1111;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 8, "code": "module sd_cmd_serial_host (\n    input SD_CLK_IN,\n    input RST_IN,\n    input [15:0] SETTING_IN,\n    input [39:0] CMD_IN,\n    input REQ_IN,\n    input ACK_IN,\n    input cmd_dat_i,\n    \n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [15:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n// Parameters\nparameter INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\nparameter NCR = 2;\nparameter SEND_SIZE = 48;\nparameter SIZE = 10;\nparameter CONTENT_SIZE = 40;\nparameter Read_Delay = 7;\nparameter EIGHT_PAD = 8;\n\n// States\nparameter INIT     = 10'b0000000001;\nparameter IDLE     = 10'b0000000010;\nparameter WRITE_WR = 10'b0000000100;\nparameter DLY_WR   = 10'b0000001000;\nparameter READ_WR  = 10'b0000010000;\nparameter DLY_READ = 10'b0000100000;\nparameter ACK_WR   = 10'b0001000000;\nparameter WRITE_WO = 10'b0010000000;\nparameter DLY_WO   = 10'b0100000000;\nparameter ACK_WO   = 10'b1000000000;\n\n// Internal registers\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg Write_Read;\nreg Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST;\nreg [6:0] CRC_IN;\nwire [6:0] CRC_VAL;\nreg CRC_Enable;\nreg CRC_OUT;\nreg CRC_Check_On;\nreg Crc_Buffering;\nreg CRC_Valid;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg [9:0] state;\nreg [9:0] next_state;\nreg block_write;\nreg block_read;\nreg [1:0] word_select;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\n\n// Submodule instantiation\nsd_crc_7 crc7 (\n    .BITVAL(CRC_OUT),\n    .Enable(CRC_Enable),\n    .CLK(SD_CLK_IN),\n    .RST(CRC_RST),\n    .CRC(CRC_VAL)\n);\n\n// FSM_COMBO: Combinational logic for next state\nalways @(*) begin\n    case (state)\n        INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n        IDLE: begin\n            if (Write_Read) next_state = WRITE_WR;\n            else if (Write_Only) next_state = WRITE_WO;\n            else next_state = IDLE;\n        end\n        WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n        WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n        DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n        DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n        READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n        DLY_READ: next_state = (Ack_internal_in) ? ACK_WR : DLY_READ;\n        ACK_WO: next_state = IDLE;\n        ACK_WR: next_state = IDLE;\n        default: next_state = INIT;\n    endcase\nend\n\n// FSM_SEQ: Sequential state update\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC: Synchronize REQ_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC: Synchronize ACK_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Delay_Cycler <= 0;\n        Response_Size <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        CRC_Check_On <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else begin\n        if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            \n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\nend\n\n// FSM_OUT\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            \n            IDLE: begin\n                cmd_oe_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                st_dat_t <= 0;\n                word_select_counter <= 0;\n            end\n            \n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000000000000001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                        if (block_write) st_dat_t <= 2'b01;\n                        else st_dat_t <= 2'b00;\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                        if (block_read) st_dat_t <= 2'b10;\n                        else st_dat_t <= 2'b00;\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Delay_Cnt < 3'b111) begin\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                \n                Crc_Buffering <= 0;\n            end\n            \n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0100;\n                    STATUS[5] <= 0;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            \n            READ_WR: begin\n                Delay_Cnt <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Cmd_Cnt == 1) begin\n                    STATUS[3:0] <= 4'b0101;\n                    REQ_OUT <= 1;\n                    Out_Buff[39] <= 0;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Cmd_Cnt < Response_Size) begin\n                    Out_Buff[38 - Cmd_Cnt] <= cmd_dat_i;\n                    CRC_OUT <= cmd_dat_i;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                    CRC_Enable <= 0;\n                end else begin\n                    if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                        CRC_Enable <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                        CRC_Enable <= 0;\n                    end\n                    \n                    if (block_read && block_write) begin\n                        st_dat_t <= 2'b11;\n                    end else if (block_write) begin\n                        st_dat_t <= 2'b01;\n                    end\n                end\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            \n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0110;\n                    STATUS[5] <= CRC_Valid;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                CMD_OUT <= Out_Buff;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            \n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            \n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\n// ACK_OUT generation\nalways @(*) begin\n    ACK_OUT = FSM_ACK & DECODER_ACK;\nend\n\nendmodule\n\n// CRC-7 submodule\nmodule sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 0;\n    end else if (Enable) begin\n        CRC[0] <= BITVAL ^ CRC[6];\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= BITVAL ^ CRC[6] ^ CRC[2];\n        CRC[4] <= BITVAL ^ CRC[6] ^ CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 4, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input         wb_clk_i,\n    input         wb_rst_i,\n    input  [3:0]  wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0]  wb_adr_i,\n    input         wb_we_i,\n    input         wb_cyc_i,\n    input         wb_stb_i,\n    output        wb_ack_o,\n    \n    // Wishbone Master Interface\n    output [31:0] m_wb_adr_o,\n    output        m_wb_sel_o,\n    output        m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    \n    // SDC IO\n    input         sd_cmd_dat_i,\n    output        sd_cmd_out_o,\n    output        sd_cmd_oe_o,\n    input  [3:0]  sd_dat_dat_i,\n    output [3:0]  sd_dat_out_o,\n    output        sd_dat_oe_o,\n    output        sd_clk_o_pad,\n    input         sd_clk_i_pad,\n    input         card_detect,\n    \n    // Interrupts\n    output        int_a,\n    output        int_b,\n    output        int_c\n);\n\n    // Internal signals\n    wire        we_m_tx_bd;\n    wire        we_m_rx_bd;\n    wire        new_cmd;\n    wire        we_ack;\n    wire        int_ack;\n    wire        cmd_int_busy;\n    wire        int_busy;\n    wire        write_req_s;\n    wire [15:0] cmd_set_s;\n    wire [31:0] cmd_arg_s;\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0]  software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0]  clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0]  Bd_isr_reg;\n    wire [7:0]  Bd_isr_enable_reg;\n    wire        bd_isr_reset;\n    wire        normal_isr_reset;\n    wire        error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n    \n    // Data master signals\n    wire        re_s_tx;\n    wire        a_cmp_tx;\n    wire        re_s_rx;\n    wire        a_cmp_rx;\n    wire        we_req;\n    wire        d_write;\n    wire        d_read;\n    wire [31:0] cmd_arg;\n    wire [15:0] cmd_set;\n    wire        start_tx_fifo;\n    wire        start_rx_fifo;\n    wire [31:0] sys_adr;\n    wire        ack_transfer;\n    wire [7:0]  Dat_Int_Status;\n    wire        CIDAT;\n    \n    // FIFO signals\n    wire        tx_empt;\n    wire        tx_full;\n    wire        rx_full;\n    wire        busy_n;\n    wire        transm_complete;\n    wire        crc_ok;\n    \n    // SD Clock signals\n    wire        sd_clk_i;\n    wire        sd_clk_o;\n    \n    // Assign SD clock\n    assign sd_clk_o_pad = sd_clk_o;\n    \n    // Instantiate sd_controller_wb\n    sd_controller_wb u_sd_controller_wb (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        \n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n    \n    // Instantiate sd_clock_divider\n    sd_clock_divider u_sd_clock_divider (\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i | software_reset_reg[0]),\n        .SD_CLK(sd_clk_o)\n    );\n    \n    // Instantiate sd_cmd_master\n    sd_cmd_master u_sd_cmd_master (\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i | software_reset_reg[0]),\n        .New_CMD(new_cmd),\n        .data_write(d_write),\n        .data_read(d_read),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(),\n        .go_idle_o(),\n        .cmd_out(),\n        .req_out(),\n        .ack_out(),\n        .req_in(),\n        .ack_in(),\n        .cmd_in(),\n        .serial_status(),\n        .card_detect(card_detect)\n    );\n    \n    // Instantiate sd_cmd_serial_host\n    sd_cmd_serial_host u_sd_cmd_serial_host (\n        .SD_CLK_IN(sd_clk_o),\n        .RST_IN(wb_rst_i | software_reset_reg[0]),\n        .SETTING_IN(cmd_setting_reg),\n        .CMD_IN(),\n        .REQ_IN(),\n        .ACK_IN(),\n        .cmd_dat_i(sd_cmd_dat_i),\n        .CMD_OUT(),\n        .ACK_OUT(),\n        .REQ_OUT(),\n        .STATUS(),\n        .cmd_oe_o(sd_cmd_oe_o),\n        .cmd_out_o(sd_cmd_out_o),\n        .st_dat_t()\n    );\n    \n    // Instantiate sd_data_master\n    sd_data_master u_sd_data_master (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .dat_in_tx(),\n        .free_tx_bd(),\n        .ack_i_s_tx(),\n        .dat_in_rx(),\n        .free_rx_bd(),\n        .ack_i_s_rx(),\n        .cmd_busy(cmd_int_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(),\n        .card_status(),\n        .tx_empt(tx_empt),\n        .tx_full(tx_full),\n        .rx_full(rx_full),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok),\n        .Dat_Int_Status_rst(bd_isr_reset),\n        .transfer_type(),\n        .re_s_tx(re_s_tx),\n        .a_cmp_tx(a_cmp_tx),\n        .re_s_rx(re_s_rx),\n        .a_cmp_rx(a_cmp_rx),\n        .we_req(we_req),\n        .d_write(d_write),\n        .d_read(d_read),\n        .cmd_arg(cmd_arg),\n        .cmd_set(cmd_set),\n        .start_tx_fifo(start_tx_fifo),\n        .start_rx_fifo(start_rx_fifo),\n        .sys_adr(sys_adr),\n        .ack_transfer(ack_transfer),\n        .Dat_Int_Status(Dat_Int_Status),\n        .CIDAT(CIDAT)\n    );\n    \n    // Instantiate tx_bd\n    sd_bd u_tx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_tx_bd),\n        .dat_in_m(dat_in_m_tx_bd),\n        .free_bd(),\n        .re_s(re_s_tx),\n        .ack_o_s(),\n        .a_cmp(a_cmp_tx),\n        .dat_out_s()\n    );\n    \n    // Instantiate rx_bd\n    sd_bd u_rx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_rx_bd),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(),\n        .re_s(re_s_rx),\n        .ack_o_s(),\n        .a_cmp(a_cmp_rx),\n        .dat_out_s()\n    );\n    \n    // Instantiate sd_fifo_tx_filler\n    sd_fifo_tx_filler u_sd_fifo_tx_filler (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(),\n        .m_wb_we_o(),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(),\n        .m_wb_stb_o(),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(),\n        .m_wb_bte_o(),\n        .en(start_tx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_o(),\n        .rd(),\n        .empty(tx_empt),\n        .fe(tx_full)\n    );\n    \n    // Instantiate sd_fifo_rx_filler\n    sd_fifo_rx_filler u_sd_fifo_rx_filler (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(),\n        .m_wb_we_o(),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(),\n        .m_wb_stb_o(),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(),\n        .m_wb_bte_o(),\n        .en(start_rx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_i(sd_dat_dat_i),\n        .wr(),\n        .full(rx_full)\n    );\n    \n    // Assign master Wishbone interface outputs\n    assign m_wb_adr_o = start_tx_fifo ? u_sd_fifo_tx_filler.m_wb_adr_o : \n                      (start_rx_fifo ? u_sd_fifo_rx_filler.m_wb_adr_o : 32'b0);\n    assign m_wb_we_o = start_tx_fifo ? u_sd_fifo_tx_filler.m_wb_we_o : \n                     (start_rx_fifo ? u_sd_fifo_rx_filler.m_wb_we_o : 1'b0);\n    assign m_wb_cyc_o = start_tx_fifo ? u_sd_fifo_tx_filler.m_wb_cyc_o : \n                      (start_rx_fifo ? u_sd_fifo_rx_filler.m_wb_cyc_o : 1'b0);\n    assign m_wb_stb_o = start_tx_fifo ? u_sd_fifo_tx_filler.m_wb_stb_o : \n                      (start_rx_fifo ? u_sd_fifo_rx_filler.m_wb_stb_o : 1'b0);\n    assign m_wb_cti_o = start_tx_fifo ? u_sd_fifo_tx_filler.m_wb_cti_o : \n                      (start_rx_fifo ? u_sd_fifo_rx_filler.m_wb_cti_o : 3'b0);\n    assign m_wb_bte_o = start_tx_fifo ? u_sd_fifo_tx_filler.m_wb_bte_o : \n                      (start_rx_fifo ? u_sd_fifo_rx_filler.m_wb_bte_o : 2'b0);\n    assign m_wb_sel_o = 4'b1111;\n    \n    // Assign interrupts\n    assign int_a = |(normal_int_status_reg & normal_int_signal_enable_reg);\n    assign int_b = |(error_int_status_reg & error_int_signal_enable_reg);\n    assign int_c = |(Bd_isr_reg & Bd_isr_enable_reg);\n    \n    // Assign data output enable\n    assign sd_dat_oe_o = d_write;\n    assign sd_dat_out_o = d_write ? 4'b1111 : 4'b0000;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 9, "code": "module sd_cmd_serial_host (\n    input SD_CLK_IN,\n    input RST_IN,\n    input [15:0] SETTING_IN,\n    input [39:0] CMD_IN,\n    input REQ_IN,\n    input ACK_IN,\n    input cmd_dat_i,\n    \n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [15:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n// Parameters\nparameter INIT_DELAY = `SIM ? 2 : 64;\nparameter NCR = 2;\nparameter SEND_SIZE = 48;\nparameter SIZE = 10;\nparameter CONTENT_SIZE = 40;\nparameter Read_Delay = 7;\nparameter EIGHT_PAD = 8;\n\n// State definitions\nlocalparam INIT     = 10'b0000000001;\nlocalparam IDLE     = 10'b0000000010;\nlocalparam WRITE_WR = 10'b0000000100;\nlocalparam DLY_WR   = 10'b0000001000;\nlocalparam READ_WR  = 10'b0000010000;\nlocalparam DLY_READ = 10'b0000100000;\nlocalparam ACK_WR   = 10'b0001000000;\nlocalparam WRITE_WO = 10'b0010000000;\nlocalparam DLY_WO   = 10'b0100000000;\nlocalparam ACK_WO   = 10'b1000000000;\n\n// Internal registers\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg Write_Read;\nreg Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST;\nreg [6:0] CRC_IN;\nwire [6:0] CRC_VAL;\nreg CRC_Enable;\nreg CRC_OUT;\nreg CRC_Check_On;\nreg Crc_Buffering;\nreg CRC_Valid;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg [9:0] state;\nreg [9:0] next_state;\nreg block_write;\nreg block_read;\nreg [1:0] word_select;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\n\n// Instantiate CRC module\nsd_crc_7 crc7(\n    .BITVAL(CRC_OUT),\n    .Enable(CRC_Enable),\n    .CLK(SD_CLK_IN),\n    .RST(CRC_RST),\n    .CRC(CRC_VAL)\n);\n\n// FSM_COMBO: Combinational logic for next state\nalways @(*) begin\n    case (state)\n        INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n        IDLE: begin\n            if (Write_Read) next_state = WRITE_WR;\n            else if (Write_Only) next_state = WRITE_WO;\n            else next_state = IDLE;\n        end\n        WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n        WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n        DLY_WR: begin\n            if (Delay_Cnt >= NCR && !cmd_dat_i) next_state = READ_WR;\n            else next_state = DLY_WR;\n        end\n        DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n        READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n        DLY_READ: next_state = (Ack_internal_in) ? ACK_WR : DLY_READ;\n        ACK_WO: next_state = IDLE;\n        ACK_WR: next_state = IDLE;\n        default: next_state = INIT;\n    endcase\nend\n\n// FSM_SEQ: Sequential state update\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC: Synchronize REQ_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC: Synchronize ACK_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Delay_Cycler <= 0;\n        Response_Size <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        CRC_Check_On <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else begin\n        if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            \n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\nend\n\n// FSM_OUT\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            \n            IDLE: begin\n                cmd_oe_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                st_dat_t <= 0;\n                word_select_counter <= 0;\n            end\n            \n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000000000000001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                        if (block_read) st_dat_t <= 2'b10;\n                        else st_dat_t <= 0;\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                        st_dat_t <= block_read ? 2'b10 : 0;\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Delay_Cnt < 3'b111) begin\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                \n                Crc_Buffering <= 0;\n            end\n            \n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0100;\n                    STATUS[5] <= 0;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            \n            READ_WR: begin\n                Delay_Cnt <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Cmd_Cnt == 1) begin\n                    STATUS[3:0] <= 4'b0101;\n                    REQ_OUT <= 1;\n                    Out_Buff[39] <= 0;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Cmd_Cnt < Response_Size) begin\n                    Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                    CRC_OUT <= cmd_dat_i;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                    CRC_Enable <= 0;\n                end else begin\n                    if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                        CRC_Enable <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                        CRC_Enable <= 0;\n                    end\n                    \n                    if (block_read && block_write) begin\n                        st_dat_t <= 2'b11;\n                    end else if (block_write) begin\n                        st_dat_t <= 2'b01;\n                    end\n                end\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            \n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0110;\n                    STATUS[5] <= CRC_Valid;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                CMD_OUT <= Out_Buff;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            \n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            \n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\n// ACK_OUT generation\nalways @(*) begin\n    ACK_OUT = FSM_ACK & DECODER_ACK;\nend\n\nendmodule\n\n// CRC-7 module\nmodule sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 0;\n    end else if (Enable) begin\n        CRC[0] <= BITVAL ^ CRC[6];\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= BITVAL ^ CRC[6] ^ CRC[2];\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 10, "code": "module sd_cmd_serial_host (\n    input SD_CLK_IN,\n    input RST_IN,\n    input [15:0] SETTING_IN,\n    input [39:0] CMD_IN,\n    input REQ_IN,\n    input ACK_IN,\n    input cmd_dat_i,\n    \n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [15:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n// Parameters\nparameter INIT_DELAY = `SIM ? 2 : 64;\nparameter NCR = 2;\nparameter SEND_SIZE = 48;\nparameter SIZE = 10;\nparameter CONTENT_SIZE = 40;\nparameter Read_Delay = 7;\nparameter EIGHT_PAD = 8;\n\n// States\nparameter INIT     = 10'b0000000001;\nparameter IDLE     = 10'b0000000010;\nparameter WRITE_WR = 10'b0000000100;\nparameter DLY_WR   = 10'b0000001000;\nparameter READ_WR  = 10'b0000010000;\nparameter DLY_READ = 10'b0000100000;\nparameter ACK_WR   = 10'b0001000000;\nparameter WRITE_WO = 10'b0010000000;\nparameter DLY_WO   = 10'b0100000000;\nparameter ACK_WO   = 10'b1000000000;\n\n// Internal registers\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg Write_Read;\nreg Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST;\nreg [6:0] CRC_IN;\nwire [6:0] CRC_VAL;\nreg CRC_Enable;\nreg CRC_OUT;\nreg CRC_Check_On;\nreg Crc_Buffering;\nreg CRC_Valid;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg [9:0] state;\nreg [9:0] next_state;\nreg block_write;\nreg block_read;\nreg [1:0] word_select;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\n\n// CRC submodule\nsd_crc_7 crc7 (\n    .BITVAL(CRC_OUT),\n    .Enable(CRC_Enable),\n    .CLK(SD_CLK_IN),\n    .RST(CRC_RST),\n    .CRC(CRC_VAL)\n);\n\n// FSM_COMBO: Combinational logic for next state\nalways @(*) begin\n    case (state)\n        INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n        IDLE: begin\n            if (Write_Read) next_state = WRITE_WR;\n            else if (Write_Only) next_state = WRITE_WO;\n            else next_state = IDLE;\n        end\n        WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n        WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n        DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n        DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n        READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n        DLY_READ: next_state = (Ack_internal_in) ? ACK_WR : DLY_READ;\n        ACK_WO: next_state = IDLE;\n        ACK_WR: next_state = IDLE;\n        default: next_state = INIT;\n    endcase\nend\n\n// FSM_SEQ: Sequential state update\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC: Synchronize REQ_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 1'b0;\n        Req_internal_in <= 1'b0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC: Synchronize ACK_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 1'b0;\n        Ack_internal_in <= 1'b0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Delay_Cycler <= 3'b0;\n        Response_Size <= 7'b0;\n        DECODER_ACK <= 1'b0;\n        Write_Read <= 1'b0;\n        Write_Only <= 1'b0;\n        CRC_Check_On <= 1'b0;\n        In_Buff <= 40'b0;\n        block_write <= 1'b0;\n        block_read <= 1'b0;\n        word_select <= 2'b0;\n    end else begin\n        if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            \n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1'b1;\n                Write_Only <= 1'b0;\n            end else begin\n                Write_Read <= 1'b0;\n                Write_Only <= 1'b1;\n            end\n            \n            DECODER_ACK <= 1'b0;\n        end else begin\n            Write_Read <= 1'b0;\n            Write_Only <= 1'b0;\n            DECODER_ACK <= 1'b1;\n        end\n    end\nend\n\n// FSM_OUT: Output logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 1'b0;\n        word_select_counter <= 5'b0;\n        Delay_Cnt <= 3'b0;\n        cmd_oe_o <= 1'b1;\n        cmd_out_o <= 1'b1;\n        Out_Buff <= 40'b0;\n        FSM_ACK <= 1'b1;\n        REQ_OUT <= 1'b0;\n        CRC_RST <= 1'b1;\n        CRC_OUT <= 1'b0;\n        CRC_IN <= 7'b0;\n        CMD_OUT <= 40'b0;\n        Crc_Buffering <= 1'b0;\n        STATUS <= 16'b0;\n        CRC_Valid <= 1'b0;\n        Cmd_Cnt <= 8'b0;\n        st_dat_t <= 2'b0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1'b1;\n                cmd_out_o <= 1'b1;\n            end\n            \n            IDLE: begin\n                cmd_oe_o <= 1'b0;\n                Delay_Cnt <= 3'b0;\n                Cmd_Cnt <= 8'b0;\n                CRC_RST <= 1'b1;\n                CRC_Enable <= 1'b0;\n                CMD_OUT <= 40'b0;\n                st_dat_t <= 2'b0;\n                word_select_counter <= 5'b0;\n            end\n            \n            WRITE_WR: begin\n                FSM_ACK <= 1'b0;\n                CRC_RST <= 1'b0;\n                CRC_Enable <= 1'b1;\n                \n                if (Cmd_Cnt == 8'b0) begin\n                    STATUS <= 16'b0000000000000001;\n                    REQ_OUT <= 1'b1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 1'b0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1'b1;\n                    \n                    if (Cmd_Cnt > 8) begin\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 10)];\n                        end\n                        cmd_out_o <= (Cmd_Cnt < 48) ? In_Buff[39 - (Cmd_Cnt - 10)] : 1'b1;\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        CRC_OUT <= CRC_VAL[7 - Cmd_Cnt];\n                        cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                        if (block_read) st_dat_t <= 2'b10;\n                        else if (block_write) st_dat_t <= 2'b01;\n                        else st_dat_t <= 2'b00;\n                    end else begin\n                        cmd_out_o <= 1'b1;\n                    end\n                    \n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1'b1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            WRITE_WO: begin\n                FSM_ACK <= 1'b0;\n                CRC_RST <= 1'b0;\n                CRC_Enable <= 1'b1;\n                \n                if (Cmd_Cnt == 8'b0) begin\n                    STATUS[3:0] <= 4'b0010;\n                    REQ_OUT <= 1'b1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 1'b0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1'b1;\n                    \n                    if (Cmd_Cnt > 8) begin\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 10)];\n                        end\n                        cmd_out_o <= (Cmd_Cnt < 48) ? In_Buff[39 - (Cmd_Cnt - 10)] : 1'b1;\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        CRC_OUT <= CRC_VAL[7 - Cmd_Cnt];\n                        cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                        if (block_read) st_dat_t <= 2'b10;\n                        else if (block_write) st_dat_t <= 2'b01;\n                        else st_dat_t <= 2'b00;\n                    end else begin\n                        cmd_out_o <= 1'b1;\n                    end\n                    \n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1'b1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            DLY_WR: begin\n                if (Delay_Cnt == 3'b0) begin\n                    STATUS[3:0] <= 4'b0011;\n                    REQ_OUT <= 1'b1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 1'b0;\n                end\n                \n                CRC_Enable <= 1'b0;\n                CRC_RST <= 1'b1;\n                Cmd_Cnt <= 8'b00000001;\n                cmd_oe_o <= 1'b0;\n                \n                if (Delay_Cnt < 3'b111) begin\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                \n                Crc_Buffering <= 1'b0;\n            end\n            \n            DLY_WO: begin\n                if (Delay_Cnt == 3'b0) begin\n                    STATUS[3:0] <= 4'b0100;\n                    STATUS[5] <= 1'b0;\n                    STATUS[6] <= 1'b1;\n                    REQ_OUT <= 1'b1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 1'b0;\n                end\n                \n                CRC_Enable <= 1'b0;\n                CRC_RST <= 1'b1;\n                Cmd_Cnt <= 8'b0;\n                cmd_oe_o <= 1'b0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 1'b0;\n            end\n            \n            READ_WR: begin\n                Delay_Cnt <= 3'b0;\n                CRC_RST <= 1'b0;\n                CRC_Enable <= 1'b1;\n                cmd_oe_o <= 1'b0;\n                \n                if (Cmd_Cnt == 8'b00000001) begin\n                    STATUS[3:0] <= 4'b0101;\n                    REQ_OUT <= 1'b1;\n                    Out_Buff[39] <= 1'b0;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 1'b0;\n                end\n                \n                if (Cmd_Cnt < Response_Size) begin\n                    case (word_select)\n                        2'b00: Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        2'b01: Out_Buff[31 - (Cmd_Cnt - 8)] <= cmd_dat_i;\n                        2'b10: Out_Buff[23 - (Cmd_Cnt - 16)] <= cmd_dat_i;\n                        2'b11: Out_Buff[15 - (Cmd_Cnt - 24)] <= cmd_dat_i;\n                    endcase\n                    CRC_OUT <= cmd_dat_i;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                    CRC_Enable <= 1'b0;\n                end else begin\n                    if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                        CRC_Valid <= 1'b0;\n                        CRC_Enable <= 1'b0;\n                    end else begin\n                        CRC_Valid <= 1'b1;\n                        CRC_Enable <= 1'b0;\n                    end\n                    \n                    if (block_read && block_write) begin\n                        st_dat_t <= 2'b11;\n                    end else if (block_write) begin\n                        st_dat_t <= 2'b01;\n                    end\n                end\n                \n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            \n            DLY_READ: begin\n                if (Delay_Cnt == 3'b0) begin\n                    STATUS[3:0] <= 4'b0110;\n                    STATUS[5] <= CRC_Valid;\n                    STATUS[6] <= 1'b1;\n                    REQ_OUT <= 1'b1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 1'b0;\n                end\n                \n                CRC_Enable <= 1'b0;\n                CRC_RST <= 1'b1;\n                Cmd_Cnt <= 8'b0;\n                cmd_oe_o <= 1'b0;\n                CMD_OUT <= Out_Buff;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            \n            ACK_WO: begin\n                FSM_ACK <= 1'b1;\n            end\n            \n            ACK_WR: begin\n                FSM_ACK <= 1'b1;\n                REQ_OUT <= 1'b0;\n            end\n        endcase\n    end\nend\n\n// ACK_OUT generation\nalways @(*) begin\n    ACK_OUT = FSM_ACK & DECODER_ACK;\nend\n\nendmodule\n\n// CRC-7 submodule\nmodule sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nreg [6:0] CRC_temp;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        CRC_temp[0] = BITVAL ^ CRC[6];\n        CRC_temp[1] = CRC[0];\n        CRC_temp[2] = CRC[1];\n        CRC_temp[3] = CRC[2];\n        CRC_temp[4] = CRC[3];\n        CRC_temp[5] = CRC[4];\n        CRC_temp[6] = CRC[5] ^ CRC_temp[0];\n        CRC <= CRC_temp;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 5, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input         wb_clk_i,\n    input         wb_rst_i,\n    input  [3:0]  wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0]  wb_adr_i,\n    input         wb_we_i,\n    input         wb_cyc_i,\n    input         wb_stb_i,\n    output        wb_ack_o,\n    \n    // Wishbone Master Interface\n    output [31:0] m_wb_adr_o,\n    output        m_wb_sel_o,\n    output        m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    \n    // SDC IO\n    input         sd_cmd_dat_i,\n    output        sd_cmd_out_o,\n    output        sd_cmd_oe_o,\n    input  [3:0]  sd_dat_dat_i,\n    output [3:0]  sd_dat_out_o,\n    output        sd_dat_oe_o,\n    output        sd_clk_o_pad,\n    input         sd_clk_i_pad,\n    \n    // Interrupts\n    output        int_a,\n    output        int_b,\n    output        int_c,\n    \n    // Card detect\n    input         card_detect\n);\n\n    // Internal signals\n    wire        we_m_tx_bd;\n    wire        we_m_rx_bd;\n    wire        new_cmd;\n    wire        we_ack;\n    wire        int_ack;\n    wire        cmd_int_busy;\n    wire        int_busy;\n    wire        write_req_s;\n    wire [15:0] cmd_set_s;\n    wire [31:0] cmd_arg_s;\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0]  software_reset_reg;\n    wire [16:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0]  clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0]  Bd_isr_reg;\n    wire [7:0]  Bd_isr_enable_reg;\n    wire        bd_isr_reset;\n    wire        normal_isr_reset;\n    wire        error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n    \n    // Data master signals\n    wire        re_s_tx;\n    wire        a_cmp_tx;\n    wire        re_s_rx;\n    wire        a_cmp_rx;\n    wire        we_req;\n    wire        d_write;\n    wire        d_read;\n    wire [31:0] cmd_arg;\n    wire [15:0] cmd_set;\n    wire        start_tx_fifo;\n    wire        start_rx_fifo;\n    wire [31:0] sys_adr;\n    wire        ack_transfer;\n    wire [7:0]  Dat_Int_Status;\n    wire        CIDAT;\n    \n    // FIFO signals\n    wire        tx_empt;\n    wire        tx_full;\n    wire        rx_full;\n    wire        busy_n;\n    wire        transm_complete;\n    wire        crc_ok;\n    \n    // Clock signals\n    wire        sd_clk_i;\n    wire        sd_clk_o;\n    \n    // Assign clock outputs\n    assign sd_clk_o_pad = sd_clk_o;\n    \n    // Assign master select (always all bytes valid)\n    assign m_wb_sel_o = 4'b1111;\n    \n    // Instantiate sd_controller_wb\n    sd_controller_wb wb_interface (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        \n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        \n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n    \n    // Instantiate sd_cmd_master\n    sd_cmd_master cmd_master (\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i | software_reset_reg[0]),\n        .New_CMD(new_cmd),\n        .data_write(d_write),\n        .data_read(d_read),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(),\n        .go_idle_o(),\n        .cmd_out(),\n        .req_out(),\n        .ack_out(),\n        .req_in(),\n        .ack_in(),\n        .cmd_in(),\n        .serial_status(),\n        .card_detect(card_detect)\n    );\n    \n    // Instantiate sd_data_master\n    sd_data_master data_master (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .dat_in_tx(dat_in_m_tx_bd),\n        .free_tx_bd(Bd_Status_reg[7:0]),\n        .ack_i_s_tx(a_cmp_tx),\n        .dat_in_rx(dat_in_m_rx_bd),\n        .free_rx_bd(Bd_Status_reg[15:8]),\n        .ack_i_s_rx(a_cmp_rx),\n        .cmd_busy(cmd_int_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(),\n        .card_status(status_reg[4:0]),\n        .tx_empt(tx_empt),\n        .tx_full(tx_full),\n        .rx_full(rx_full),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok),\n        .Dat_Int_Status_rst(bd_isr_reset),\n        .transfer_type(),\n        \n        .re_s_tx(re_s_tx),\n        .a_cmp_tx(a_cmp_tx),\n        .re_s_rx(re_s_rx),\n        .a_cmp_rx(a_cmp_rx),\n        .we_req(we_req),\n        .d_write(d_write),\n        .d_read(d_read),\n        .cmd_arg(cmd_arg),\n        .cmd_set(cmd_set),\n        .start_tx_fifo(start_tx_fifo),\n        .start_rx_fifo(start_rx_fifo),\n        .sys_adr(sys_adr),\n        .ack_transfer(ack_transfer),\n        .Dat_Int_Status(Dat_Int_Status),\n        .CIDAT(CIDAT)\n    );\n    \n    // Instantiate tx_bd\n    sd_bd tx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_tx_bd),\n        .dat_in_m(dat_in_m_tx_bd),\n        .free_bd(Bd_Status_reg[7:0]),\n        .re_s(re_s_tx),\n        .ack_o_s(a_cmp_tx),\n        .a_cmp(a_cmp_tx),\n        .dat_out_s()\n    );\n    \n    // Instantiate rx_bd\n    sd_bd rx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_rx_bd),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(Bd_Status_reg[15:8]),\n        .re_s(re_s_rx),\n        .ack_o_s(a_cmp_rx),\n        .a_cmp(a_cmp_rx),\n        .dat_out_s()\n    );\n    \n    // Instantiate sd_fifo_tx_filler\n    sd_fifo_tx_filler tx_filler (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(start_tx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_o(),\n        .rd(),\n        .empty(tx_empt),\n        .fe(tx_full)\n    );\n    \n    // Instantiate sd_fifo_rx_filler\n    sd_fifo_rx_filler rx_filler (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(),\n        .m_wb_we_o(),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(),\n        .m_wb_stb_o(),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(),\n        .m_wb_bte_o(),\n        .en(start_rx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_i(sd_dat_dat_i),\n        .wr(),\n        .full(rx_full)\n    );\n    \n    // Instantiate sd_clock_divider\n    sd_clock_divider clk_div (\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i | software_reset_reg[0]),\n        .SD_CLK(sd_clk_o)\n    );\n    \n    // Instantiate sd_cmd_serial_host\n    sd_cmd_serial_host cmd_serial (\n        .SD_CLK_IN(sd_clk_o),\n        .RST_IN(wb_rst_i | software_reset_reg[0]),\n        .SETTING_IN(cmd_setting_reg),\n        .CMD_IN(),\n        .REQ_IN(),\n        .ACK_IN(),\n        .cmd_dat_i(sd_cmd_dat_i),\n        .CMD_OUT(),\n        .ACK_OUT(),\n        .REQ_OUT(),\n        .STATUS(),\n        .cmd_oe_o(sd_cmd_oe_o),\n        .cmd_out_o(sd_cmd_out_o),\n        .st_dat_t()\n    );\n    \n    // Instantiate sd_data_serial_host\n    sd_data_serial_host data_serial (\n        .sd_clk(sd_clk_o),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .data_in(),\n        .start_dat(),\n        .ack_transfer(ack_transfer),\n        .DAT_dat_i(sd_dat_dat_i),\n        .rd(),\n        .data_out(sd_dat_out_o),\n        .we(),\n        .DAT_oe_o(sd_dat_oe_o),\n        .DAT_dat_o(),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok)\n    );\n    \n    // Interrupt generation\n    assign int_a = |(normal_int_status_reg & normal_int_signal_enable_reg);\n    assign int_b = |(error_int_status_reg & error_int_signal_enable_reg);\n    assign int_c = |(Bd_isr_reg & Bd_isr_enable_reg);\n    \nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n// Parameters\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'h0C1A;\nparameter ACMD13 = 16'h0D1A;\nparameter ACMD51 = 16'h331A;\n\nparameter SIZE = 9;\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\n\n// Internal signals\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\n\n`ifdef RAM_MEM_WIDTH_32\n    parameter READ_CYCLE = 2;\n    reg [1:0] bd_cnt;\n    parameter BD_EMPTY = BD_SIZE / 2;\n`else\n    parameter READ_CYCLE = 4;\n    reg [2:0] bd_cnt;\n    parameter BD_EMPTY = BD_SIZE / 4;\n`endif\n\n// FSM sequential logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM combinational logic\nalways @(*) begin\n    next_state = state;\n    case (state)\n        IDLE: begin\n            if (free_tx_bd != BD_EMPTY) begin\n                next_state = GET_TX_BD;\n            end else if (free_rx_bd != BD_EMPTY) begin\n                next_state = GET_RX_BD;\n            end\n        end\n        GET_TX_BD: begin\n            if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                next_state = SEND_CMD;\n            end\n        end\n        GET_RX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1) begin\n                next_state = SEND_CMD;\n            end\n        end\n        SEND_CMD: begin\n            if (send_done == 1) begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        RECIVE_CMD: begin\n            if (rec_done == 1) begin\n                next_state = DATA_TRANSFER;\n            end else if (rec_failed == 1) begin\n                next_state = SEND_CMD;\n            end\n        end\n        DATA_TRANSFER: begin\n            if (trans_done == 1) begin\n                next_state = IDLE;\n            end else if (trans_failed == 1) begin\n                next_state = STOP;\n            end\n        end\n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        STOP_SEND: begin\n            if (send_done == 1) begin\n                next_state = IDLE;\n            end\n        end\n    endcase\nend\n\n// Output logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        re_s_tx <= 0;\n        a_cmp_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        sys_adr <= 0;\n        ack_transfer <= 0;\n        Dat_Int_Status <= 0;\n        CIDAT <= 0;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n    end else begin\n        // Default outputs\n        re_s_tx <= 0;\n        re_s_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        ack_transfer <= 0;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        \n        if (Dat_Int_Status_rst) begin\n            Dat_Int_Status <= 0;\n        end\n\n        case (state)\n            IDLE: begin\n                bd_cnt <= 0;\n                resend_try_cnt <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n            end\n            \n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                if (ack_i_s_tx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    `ifdef RAM_MEM_WIDTH_32\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_tx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                        end\n                    `else\n                        case (bd_cnt)\n                            0: sys_adr[15:0] <= dat_in_tx;\n                            1: sys_adr[31:16] <= dat_in_tx;\n                            2: cmd_arg[15:0] <= dat_in_tx;\n                            3: begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        endcase\n                    `endif\n                end\n                cmd_set <= CMD24;\n                tx_cycle <= 1;\n            end\n            \n            GET_RX_BD: begin\n                re_s_rx <= 1;\n                if (ack_i_s_rx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    `ifdef RAM_MEM_WIDTH_32\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_rx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_rx;\n                        end\n                    `else\n                        case (bd_cnt)\n                            0: sys_adr[15:0] <= dat_in_rx;\n                            1: sys_adr[31:16] <= dat_in_rx;\n                            2: cmd_arg[15:0] <= dat_in_rx;\n                            3: cmd_arg[31:16] <= dat_in_rx;\n                        endcase\n                    `endif\n                end\n                case (transfer_type)\n                    2'b00: cmd_set <= CMD17;\n                    2'b01: cmd_set <= ACMD13;\n                    default: cmd_set <= ACMD51;\n                endcase\n                rx_cycle <= 1;\n            end\n            \n            SEND_CMD: begin\n                if (tx_cycle) d_write <= 1;\n                if (rx_cycle) d_read <= 1;\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n            \n            RECIVE_CMD: begin\n                if (rx_cycle) start_rx_fifo <= 1;\n                \n                if (!cmd_busy) begin\n                    if (cmd_tsf_err) begin\n                        rec_failed <= 1;\n                    end else begin\n                        if (card_status[0] == 1 || \n                           (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) begin\n                            rec_done <= 1;\n                        end else begin\n                            rec_failed <= 1;\n                        end\n                    end\n                end\n            end\n            \n            DATA_TRANSFER: begin\n                if (tx_cycle && tx_empt) begin\n                    trans_failed <= 1;\n                    Dat_Int_Status[0] <= 1; // Underrun error\n                end\n                if (rx_cycle && rx_full) begin\n                    trans_failed <= 1;\n                    Dat_Int_Status[1] <= 1; // Overrun error\n                end\n                \n                if (transm_complete) begin\n                    if (crc_ok) begin\n                        trans_done <= 1;\n                        ack_transfer <= 1;\n                        if (tx_cycle) a_cmp_tx <= 1;\n                        if (rx_cycle) a_cmp_rx <= 1;\n                    end else begin\n                        trans_failed <= 1;\n                        Dat_Int_Status[2] <= 1; // CRC error\n                    end\n                end\n            end\n            \n            STOP: begin\n                cmd_set <= CMD12;\n                rec_done <= 0;\n                rec_failed <= 0;\n                send_done <= 0;\n                trans_failed <= 0;\n                trans_done <= 0;\n                d_read <= 1;\n                d_write <= 1;\n                start_rx_fifo <= 0;\n                start_tx_fifo <= 0;\n            end\n            \n            STOP_SEND: begin\n                resend_try_cnt <= resend_try_cnt + 1;\n                if (resend_try_cnt == RESEND_MAX_CNT) begin\n                    Dat_Int_Status[1] <= 1; // Overrun error\n                end\n                \n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            end\n        endcase\n        \n        // Track transmission complete\n        transm_complete_q <= transm_complete;\n        if (transm_complete && !transm_complete_q) begin\n            internal_transm_complete <= 1;\n        end else begin\n            internal_transm_complete <= 0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 11, "code": "module sd_cmd_serial_host (\n    input SD_CLK_IN,\n    input RST_IN,\n    input [15:0] SETTING_IN,\n    input [39:0] CMD_IN,\n    input REQ_IN,\n    input ACK_IN,\n    input cmd_dat_i,\n    \n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [15:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n// Parameters\nparameter INIT_DELAY = 64;\nparameter NCR = 2;\nparameter SEND_SIZE = 48;\nparameter SIZE = 10;\nparameter CONTENT_SIZE = 40;\nparameter Read_Delay = 7;\nparameter EIGHT_PAD = 8;\n\n// States\nparameter INIT     = 10'b0000000001;\nparameter IDLE     = 10'b0000000010;\nparameter WRITE_WR = 10'b0000000100;\nparameter DLY_WR   = 10'b0000001000;\nparameter READ_WR  = 10'b0000010000;\nparameter DLY_READ = 10'b0000100000;\nparameter ACK_WR   = 10'b0001000000;\nparameter WRITE_WO = 10'b0010000000;\nparameter DLY_WO   = 10'b0100000000;\nparameter ACK_WO   = 10'b1000000000;\n\n// Internal registers\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg Write_Read;\nreg Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST;\nreg [6:0] CRC_IN;\nwire [6:0] CRC_VAL;\nreg CRC_Enable;\nreg CRC_OUT;\nreg CRC_Check_On;\nreg Crc_Buffering;\nreg CRC_Valid;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg [9:0] state;\nreg [9:0] next_state;\nreg block_write;\nreg block_read;\nreg [1:0] word_select;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\n\n// Instantiate CRC module\nsd_crc_7 crc7 (\n    .BITVAL(CRC_OUT),\n    .Enable(CRC_Enable),\n    .CLK(SD_CLK_IN),\n    .RST(CRC_RST),\n    .CRC(CRC_VAL)\n);\n\n// FSM_COMBO: Combinational logic for next state\nalways @(*) begin\n    case (state)\n        INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n        IDLE: begin\n            if (Write_Read)\n                next_state = WRITE_WR;\n            else if (Write_Only)\n                next_state = WRITE_WO;\n            else\n                next_state = IDLE;\n        end\n        WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n        WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n        DLY_WR: begin\n            if (Delay_Cnt >= NCR && !cmd_dat_i)\n                next_state = READ_WR;\n            else\n                next_state = DLY_WR;\n        end\n        DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n        READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n        DLY_READ: next_state = (Ack_internal_in) ? ACK_WR : DLY_READ;\n        ACK_WO: next_state = IDLE;\n        ACK_WR: next_state = IDLE;\n        default: next_state = INIT;\n    endcase\nend\n\n// FSM_SEQ: Sequential logic for state transition\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC: Synchronize REQ_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC: Synchronize ACK_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Delay_Cycler <= 0;\n        Response_Size <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        CRC_Check_On <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else if (Req_internal_in) begin\n        Response_Size <= SETTING_IN[6:0];\n        CRC_Check_On <= SETTING_IN[7];\n        Delay_Cycler <= SETTING_IN[10:8];\n        block_write <= SETTING_IN[11];\n        block_read <= SETTING_IN[12];\n        word_select <= SETTING_IN[14:13];\n        In_Buff <= CMD_IN;\n        \n        if (SETTING_IN[6:0] > 0) begin\n            Write_Read <= 1;\n            Write_Only <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 1;\n        end\n        \n        DECODER_ACK <= 0;\n    end else begin\n        Write_Read <= 0;\n        Write_Only <= 0;\n        DECODER_ACK <= 1;\n    end\nend\n\n// FSM_OUT\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            \n            IDLE: begin\n                cmd_oe_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                st_dat_t <= 0;\n                word_select_counter <= 0;\n            end\n            \n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000000000000001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    \n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                        if (block_read) begin\n                            st_dat_t <= 2'b10;\n                        end\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    \n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    \n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                        if (block_write) begin\n                            st_dat_t <= 2'b01;\n                        end\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    \n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Delay_Cnt < 3'b111) begin\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                \n                Crc_Buffering <= 0;\n            end\n            \n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0100;\n                    STATUS[5] <= 0;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            \n            READ_WR: begin\n                Delay_Cnt <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Cmd_Cnt == 1) begin\n                    STATUS[3:0] <= 4'b0101;\n                    REQ_OUT <= 1;\n                    Out_Buff[39] <= 0;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Cmd_Cnt < Response_Size) begin\n                    Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                    CRC_OUT <= cmd_dat_i;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                    CRC_Enable <= 0;\n                end else begin\n                    if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                        CRC_Enable <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                        CRC_Enable <= 0;\n                    end\n                    \n                    if (block_read && block_write) begin\n                        st_dat_t <= 2'b11;\n                    end else if (block_write) begin\n                        st_dat_t <= 2'b01;\n                    end\n                end\n                \n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            \n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0110;\n                    STATUS[5] <= CRC_Valid;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                CMD_OUT <= Out_Buff;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            \n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            \n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\n// ACK_OUT assignment\nalways @(*) begin\n    ACK_OUT = FSM_ACK & DECODER_ACK;\nend\n\nendmodule\n\n// CRC-7 module\nmodule sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nreg [6:0] CRC_temp;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 0;\n    end else if (Enable) begin\n        CRC_temp[0] = BITVAL ^ CRC[6];\n        CRC_temp[1] = CRC[0];\n        CRC_temp[2] = CRC[1];\n        CRC_temp[3] = CRC[2];\n        CRC_temp[4] = CRC[3];\n        CRC_temp[5] = CRC[4];\n        CRC_temp[6] = CRC[5] ^ CRC_temp[0];\n        CRC <= CRC_temp;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 6, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input         wb_clk_i,\n    input         wb_rst_i,\n    input  [3:0]  wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0]  wb_adr_i,\n    input         wb_we_i,\n    input         wb_cyc_i,\n    input         wb_stb_i,\n    output        wb_ack_o,\n    \n    // Wishbone Master Interface\n    output [31:0] m_wb_adr_o,\n    output        m_wb_sel_o,\n    output        m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    \n    // SD Card Interface\n    input         sd_cmd_dat_i,\n    output        sd_cmd_out_o,\n    output        sd_cmd_oe_o,\n    input  [3:0]  sd_dat_dat_i,\n    output [3:0]  sd_dat_out_o,\n    output        sd_dat_oe_o,\n    output        sd_clk_o_pad,\n    input         sd_clk_i_pad,\n    \n    // Interrupts\n    output        int_a,\n    output        int_b,\n    output        int_c,\n    \n    // Card detect\n    input         card_detect\n);\n\n    // Internal signals\n    wire        we_m_tx_bd;\n    wire        we_m_rx_bd;\n    wire        new_cmd;\n    wire        we_ack;\n    wire        cmd_int_busy;\n    wire        write_req_s;\n    wire [15:0] cmd_set_s;\n    wire [31:0] cmd_arg_s;\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0]  software_reset_reg;\n    wire [16:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0]  clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0]  Bd_isr_reg;\n    wire [7:0]  Bd_isr_enable_reg;\n    wire        bd_isr_reset;\n    wire        normal_isr_reset;\n    wire        error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n    \n    // Data master signals\n    wire        re_s_tx;\n    wire        a_cmp_tx;\n    wire        re_s_rx;\n    wire        a_cmp_rx;\n    wire        we_req;\n    wire        d_write;\n    wire        d_read;\n    wire [31:0] cmd_arg;\n    wire [15:0] cmd_set;\n    wire        start_tx_fifo;\n    wire        start_rx_fifo;\n    wire [31:0] sys_adr;\n    wire        ack_transfer;\n    wire [7:0]  Dat_Int_Status;\n    wire        CIDAT;\n    \n    // FIFO signals\n    wire        tx_empt;\n    wire        tx_full;\n    wire        rx_full;\n    wire        busy_n;\n    wire        transm_complete;\n    wire        crc_ok;\n    \n    // SD clock signals\n    wire        sd_clk;\n    wire        sd_clk_i;\n    wire        sd_clk_o;\n    \n    // Assign SD clock\n    assign sd_clk_o_pad = sd_clk_o;\n    \n    // Instantiate Wishbone interface\n    sd_controller_wb wb_interface (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n    \n    // Instantiate clock divider\n    sd_clock_divider clk_div (\n        .CLK(sd_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i | software_reset_reg[0]),\n        .SD_CLK(sd_clk_o)\n    );\n    \n    // Instantiate command master\n    sd_cmd_master cmd_master (\n        .CLK_PAD_IO(sd_clk_o),\n        .RST_PAD_I(wb_rst_i | software_reset_reg[0]),\n        .New_CMD(new_cmd),\n        .data_write(d_write),\n        .data_read(d_read),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(cmd_set_s),\n        .go_idle_o(),\n        .cmd_out(),\n        .req_out(write_req_s),\n        .ack_out(we_ack),\n        .req_in(),\n        .ack_in(),\n        .cmd_in(),\n        .serial_status(),\n        .card_detect(card_detect)\n    );\n    \n    // Instantiate data master\n    sd_data_master data_master (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .dat_in_tx(dat_in_m_tx_bd),\n        .free_tx_bd(Bd_Status_reg[7:0]),\n        .ack_i_s_tx(a_cmp_tx),\n        .dat_in_rx(dat_in_m_rx_bd),\n        .free_rx_bd(Bd_Status_reg[15:8]),\n        .ack_i_s_rx(a_cmp_rx),\n        .cmd_busy(cmd_int_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(),\n        .card_status(),\n        .tx_empt(tx_empt),\n        .tx_full(tx_full),\n        .rx_full(rx_full),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok),\n        .Dat_Int_Status_rst(bd_isr_reset),\n        .transfer_type(),\n        .re_s_tx(re_s_tx),\n        .a_cmp_tx(a_cmp_tx),\n        .re_s_rx(re_s_rx),\n        .a_cmp_rx(a_cmp_rx),\n        .we_req(we_req),\n        .d_write(d_write),\n        .d_read(d_read),\n        .cmd_arg(cmd_arg),\n        .cmd_set(cmd_set),\n        .start_tx_fifo(start_tx_fifo),\n        .start_rx_fifo(start_rx_fifo),\n        .sys_adr(sys_adr),\n        .ack_transfer(ack_transfer),\n        .Dat_Int_Status(Dat_Int_Status),\n        .CIDAT(CIDAT)\n    );\n    \n    // Instantiate TX BD\n    sd_bd tx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_tx_bd),\n        .dat_in_m(dat_in_m_tx_bd),\n        .free_bd(Bd_Status_reg[7:0]),\n        .re_s(re_s_tx),\n        .ack_o_s(a_cmp_tx),\n        .a_cmp(a_cmp_tx),\n        .dat_out_s()\n    );\n    \n    // Instantiate RX BD\n    sd_bd rx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_rx_bd),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(Bd_Status_reg[15:8]),\n        .re_s(re_s_rx),\n        .ack_o_s(a_cmp_rx),\n        .a_cmp(a_cmp_rx),\n        .dat_out_s()\n    );\n    \n    // Instantiate TX FIFO\n    sd_fifo_tx_filler tx_fifo (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(start_tx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_o(),\n        .rd(),\n        .empty(tx_empt),\n        .fe(tx_full)\n    );\n    \n    // Instantiate RX FIFO\n    sd_fifo_rx_filler rx_fifo (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(),\n        .m_wb_we_o(),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(),\n        .m_wb_stb_o(),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(),\n        .m_wb_bte_o(),\n        .en(start_rx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_i(sd_dat_dat_i),\n        .wr(),\n        .full(rx_full)\n    );\n    \n    // Instantiate command serial host\n    sd_cmd_serial_host cmd_serial (\n        .SD_CLK_IN(sd_clk_o),\n        .RST_IN(wb_rst_i | software_reset_reg[0]),\n        .SETTING_IN(cmd_set_s),\n        .CMD_IN(),\n        .REQ_IN(write_req_s),\n        .ACK_IN(we_ack),\n        .cmd_dat_i(sd_cmd_dat_i),\n        .CMD_OUT(),\n        .ACK_OUT(),\n        .REQ_OUT(),\n        .STATUS(),\n        .cmd_oe_o(sd_cmd_oe_o),\n        .cmd_out_o(sd_cmd_out_o),\n        .st_dat_t()\n    );\n    \n    // Instantiate data serial host\n    sd_data_serial_host data_serial (\n        .sd_clk(sd_clk_o),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .data_in(),\n        .start_dat({d_write, d_read}),\n        .ack_transfer(ack_transfer),\n        .DAT_dat_i(sd_dat_dat_i),\n        .rd(),\n        .data_out(sd_dat_out_o),\n        .we(),\n        .DAT_oe_o(sd_dat_oe_o),\n        .DAT_dat_o(),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok)\n    );\n    \n    // Interrupt generation\n    assign int_a = |(normal_int_status_reg & normal_int_signal_enable_reg);\n    assign int_b = |(error_int_status_reg & error_int_signal_enable_reg);\n    assign int_c = |(Bd_isr_reg & Bd_isr_enable_reg);\n    \n    // Master select\n    assign m_wb_sel_o = 4'b1111;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 7, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input         wb_clk_i,\n    input         wb_rst_i,\n    input  [3:0]  wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0]  wb_adr_i,\n    input         wb_we_i,\n    input         wb_cyc_i,\n    input         wb_stb_i,\n    output        wb_ack_o,\n    \n    // Wishbone Master Interface\n    output [31:0] m_wb_adr_o,\n    output        m_wb_sel_o,\n    output        m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    \n    // SDC IO\n    input         sd_cmd_dat_i,\n    output        sd_cmd_out_o,\n    output        sd_cmd_oe_o,\n    input  [3:0]  sd_dat_dat_i,\n    output [3:0]  sd_dat_out_o,\n    output        sd_dat_oe_o,\n    output        sd_clk_o_pad,\n    input         sd_clk_i_pad,\n    input         card_detect,\n    \n    // Interrupts\n    output        int_a,\n    output        int_b,\n    output        int_c\n);\n\n    // Internal signals\n    wire        we_m_tx_bd;\n    wire        we_m_rx_bd;\n    wire        new_cmd;\n    wire        we_ack;\n    wire        int_ack;\n    wire        cmd_int_busy;\n    wire        int_busy;\n    wire        write_req_s;\n    wire [15:0] cmd_set_s;\n    wire [31:0] cmd_arg_s;\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0]  software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0]  clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0]  Bd_isr_reg;\n    wire [7:0]  Bd_isr_enable_reg;\n    wire        bd_isr_reset;\n    wire        normal_isr_reset;\n    wire        error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n    \n    // Data master signals\n    wire        data_write;\n    wire        data_read;\n    wire        start_tx_fifo;\n    wire        start_rx_fifo;\n    wire [31:0] sys_adr;\n    wire        ack_transfer;\n    wire        CIDAT;\n    \n    // FIFO signals\n    wire        tx_empt;\n    wire        tx_full;\n    wire        rx_full;\n    wire        busy_n;\n    wire        transm_complete;\n    wire        crc_ok;\n    \n    // Serial host signals\n    wire [7:0]  serial_status;\n    wire        go_idle_o;\n    wire [39:0] cmd_out;\n    wire        req_out;\n    wire        ack_out;\n    wire        req_in;\n    wire        ack_in;\n    wire [39:0] cmd_in;\n    \n    // BD signals\n    wire [BD_WIDTH-1:0] free_tx_bd;\n    wire [BD_WIDTH-1:0] free_rx_bd;\n    wire                re_s_tx;\n    wire                a_cmp_tx;\n    wire                re_s_rx;\n    wire                a_cmp_rx;\n    wire [RAM_MEM_WIDTH-1:0] dat_out_s_tx;\n    wire [RAM_MEM_WIDTH-1:0] dat_out_s_rx;\n    wire                ack_i_s_tx;\n    wire                ack_i_s_rx;\n    \n    // Clock signals\n    wire        sd_clk_i;\n    wire        sd_clk_o;\n    \n    // Assign clock based on configuration\n    assign sd_clk_i = SDC_CLK_SEP ? sd_clk_i_pad : wb_clk_i;\n    assign sd_clk_o = SDC_CLK_DYNAMIC ? sd_clk_div : (SDC_CLK_BUS_CLK ? wb_clk_i : sd_clk_i);\n    assign sd_clk_o_pad = sd_clk_o;\n    \n    // Assign master select\n    assign m_wb_sel_o = 4'b1111;\n    \n    // Interrupt assignments\n    assign int_a = SDC_IRQ_ENABLE ? |(normal_int_status_reg & normal_int_signal_enable_reg) : 1'b0;\n    assign int_b = SDC_IRQ_ENABLE ? |(error_int_status_reg & error_int_signal_enable_reg) : 1'b0;\n    assign int_c = SDC_IRQ_ENABLE ? |(Bd_isr_reg & Bd_isr_enable_reg) : 1'b0;\n    \n    // Instantiate submodules\n    sd_controller_wb u_wb_controller (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n    \n    sd_clock_divider u_clock_divider (\n        .CLK(sd_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i | software_reset_reg[0]),\n        .SD_CLK(sd_clk_div)\n    );\n    \n    sd_cmd_master u_cmd_master (\n        .CLK_PAD_IO(sd_clk_o),\n        .RST_PAD_I(wb_rst_i | software_reset_reg[0] | go_idle_o),\n        .New_CMD(new_cmd),\n        .data_write(data_write),\n        .data_read(data_read),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(cmd_set_s),\n        .go_idle_o(go_idle_o),\n        .cmd_out(cmd_out),\n        .req_out(req_out),\n        .ack_out(ack_out),\n        .req_in(req_in),\n        .ack_in(ack_in),\n        .cmd_in(cmd_in),\n        .serial_status(serial_status),\n        .card_detect(card_detect)\n    );\n    \n    sd_cmd_serial_host u_cmd_serial_host (\n        .SD_CLK_IN(sd_clk_o),\n        .RST_IN(wb_rst_i | software_reset_reg[0] | go_idle_o),\n        .SETTING_IN(cmd_set_s),\n        .CMD_IN(cmd_out),\n        .REQ_IN(req_out),\n        .ACK_IN(ack_out),\n        .cmd_dat_i(sd_cmd_dat_i),\n        .CMD_OUT(cmd_in),\n        .ACK_OUT(ack_in),\n        .REQ_OUT(req_in),\n        .STATUS(serial_status),\n        .cmd_oe_o(sd_cmd_oe_o),\n        .cmd_out_o(sd_cmd_out_o),\n        .st_dat_t()\n    );\n    \n    sd_data_master u_data_master (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .dat_in_tx(dat_out_s_tx),\n        .free_tx_bd(free_tx_bd),\n        .ack_i_s_tx(ack_i_s_tx),\n        .dat_in_rx(dat_out_s_rx),\n        .free_rx_bd(free_rx_bd),\n        .ack_i_s_rx(ack_i_s_rx),\n        .cmd_busy(cmd_int_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(),\n        .card_status(),\n        .tx_empt(tx_empt),\n        .tx_full(tx_full),\n        .rx_full(rx_full),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok),\n        .Dat_Int_Status_rst(bd_isr_reset),\n        .transfer_type(),\n        .re_s_tx(re_s_tx),\n        .a_cmp_tx(a_cmp_tx),\n        .re_s_rx(re_s_rx),\n        .a_cmp_rx(a_cmp_rx),\n        .we_req(write_req_s),\n        .d_write(data_write),\n        .d_read(data_read),\n        .cmd_arg(cmd_arg_s),\n        .cmd_set(cmd_set_s),\n        .start_tx_fifo(start_tx_fifo),\n        .start_rx_fifo(start_rx_fifo),\n        .sys_adr(sys_adr),\n        .ack_transfer(ack_transfer),\n        .Dat_Int_Status(Bd_isr_reg),\n        .CIDAT(CIDAT)\n    );\n    \n    sd_data_serial_host u_data_serial_host (\n        .sd_clk(sd_clk_o),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .data_in(),\n        .start_dat({data_write, data_read}),\n        .ack_transfer(ack_transfer),\n        .DAT_dat_i(sd_dat_dat_i),\n        .data_out(),\n        .we(),\n        .DAT_oe_o(sd_dat_oe_o),\n        .DAT_dat_o(sd_dat_out_o),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok)\n    );\n    \n    sd_bd u_tx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_tx_bd),\n        .dat_in_m(dat_in_m_tx_bd),\n        .free_bd(free_tx_bd),\n        .re_s(re_s_tx),\n        .ack_o_s(ack_i_s_tx),\n        .a_cmp(a_cmp_tx),\n        .dat_out_s(dat_out_s_tx)\n    );\n    \n    sd_bd u_rx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_rx_bd),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(free_rx_bd),\n        .re_s(re_s_rx),\n        .ack_o_s(ack_i_s_rx),\n        .a_cmp(a_cmp_rx),\n        .dat_out_s(dat_out_s_rx)\n    );\n    \n    sd_fifo_tx_filler u_tx_fifo (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(start_tx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_o(),\n        .rd(),\n        .empty(tx_empt),\n        .fe(tx_full)\n    );\n    \n    sd_fifo_rx_filler u_rx_fifo (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(),\n        .m_wb_we_o(),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(),\n        .m_wb_stb_o(),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(),\n        .m_wb_bte_o(),\n        .en(start_rx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_i(),\n        .wr(),\n        .full(rx_full)\n    );\n    \n    // Mux for master interface signals\n    assign m_wb_adr_o = start_tx_fifo ? u_tx_fifo.m_wb_adr_o : \n                       (start_rx_fifo ? u_rx_fifo.m_wb_adr_o : 32'b0);\n    assign m_wb_we_o = start_tx_fifo ? u_tx_fifo.m_wb_we_o : \n                      (start_rx_fifo ? u_rx_fifo.m_wb_we_o : 1'b0);\n    assign m_wb_cyc_o = start_tx_fifo ? u_tx_fifo.m_wb_cyc_o : \n                       (start_rx_fifo ? u_rx_fifo.m_wb_cyc_o : 1'b0);\n    assign m_wb_stb_o = start_tx_fifo ? u_tx_fifo.m_wb_stb_o : \n                       (start_rx_fifo ? u_rx_fifo.m_wb_stb_o : 1'b0);\n    assign m_wb_cti_o = start_tx_fifo ? u_tx_fifo.m_wb_cti_o : \n                       (start_rx_fifo ? u_rx_fifo.m_wb_cti_o : 3'b0);\n    assign m_wb_bte_o = start_tx_fifo ? u_tx_fifo.m_wb_bte_o : \n                       (start_rx_fifo ? u_rx_fifo.m_wb_bte_o : 2'b0);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 12, "code": "module sd_cmd_serial_host (\n    input SD_CLK_IN,\n    input RST_IN,\n    input [15:0] SETTING_IN,\n    input [39:0] CMD_IN,\n    input REQ_IN,\n    input ACK_IN,\n    input cmd_dat_i,\n    \n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [15:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n// Internal constants\nparameter INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\nparameter NCR = 2;\nparameter SEND_SIZE = 48;\nparameter SIZE = 10;\nparameter CONTENT_SIZE = 40;\nparameter Read_Delay = 7;\nparameter EIGHT_PAD = 8;\n\n// FSM states\nparameter INIT     = 10'b0000000001;\nparameter IDLE     = 10'b0000000010;\nparameter WRITE_WR = 10'b0000000100;\nparameter DLY_WR   = 10'b0000001000;\nparameter READ_WR  = 10'b0000010000;\nparameter DLY_READ = 10'b0000100000;\nparameter ACK_WR   = 10'b0001000000;\nparameter WRITE_WO = 10'b0010000000;\nparameter DLY_WO   = 10'b0100000000;\nparameter ACK_WO   = 10'b1000000000;\n\n// Internal registers\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg Write_Read;\nreg Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST;\nreg [6:0] CRC_IN;\nwire [6:0] CRC_VAL;\nreg CRC_Enable;\nreg CRC_OUT;\nreg CRC_Check_On;\nreg Crc_Buffering;\nreg CRC_Valid;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg [9:0] state;\nreg [9:0] next_state;\nreg block_write;\nreg block_read;\nreg [1:0] word_select;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\n\n// Instantiate CRC module\nsd_crc_7 crc7 (\n    .BITVAL(CRC_OUT),\n    .Enable(CRC_Enable),\n    .CLK(SD_CLK_IN),\n    .RST(CRC_RST),\n    .CRC(CRC_VAL)\n);\n\n// FSM_COMBO: Combinational logic for next state\nalways @(*) begin\n    case (state)\n        INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n        IDLE: begin\n            if (Write_Read)\n                next_state = WRITE_WR;\n            else if (Write_Only)\n                next_state = WRITE_WO;\n            else\n                next_state = IDLE;\n        end\n        WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n        WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n        DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n        DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n        READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n        DLY_READ: next_state = (Ack_internal_in) ? ACK_WR : DLY_READ;\n        ACK_WO: next_state = IDLE;\n        ACK_WR: next_state = IDLE;\n        default: next_state = INIT;\n    endcase\nend\n\n// FSM_SEQ: Sequential state transition\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC: Synchronize REQ_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 1'b0;\n        Req_internal_in <= 1'b0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC: Synchronize ACK_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 1'b0;\n        Ack_internal_in <= 1'b0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Delay_Cycler <= 3'b0;\n        Response_Size <= 7'b0;\n        DECODER_ACK <= 1'b0;\n        Write_Read <= 1'b0;\n        Write_Only <= 1'b0;\n        CRC_Check_On <= 1'b0;\n        In_Buff <= 40'b0;\n        block_write <= 1'b0;\n        block_read <= 1'b0;\n        word_select <= 2'b0;\n    end else begin\n        if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            \n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1'b1;\n                Write_Only <= 1'b0;\n            end else begin\n                Write_Read <= 1'b0;\n                Write_Only <= 1'b1;\n            end\n            \n            DECODER_ACK <= 1'b0;\n        end else begin\n            Write_Read <= 1'b0;\n            Write_Only <= 1'b0;\n            DECODER_ACK <= 1'b1;\n        end\n    end\nend\n\n// FSM_OUT: Output logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 1'b0;\n        word_select_counter <= 5'b0;\n        Delay_Cnt <= 3'b0;\n        cmd_oe_o <= 1'b1;\n        cmd_out_o <= 1'b1;\n        Out_Buff <= 40'b0;\n        FSM_ACK <= 1'b1;\n        REQ_OUT <= 1'b0;\n        CRC_RST <= 1'b1;\n        CRC_OUT <= 1'b0;\n        CRC_IN <= 7'b0;\n        CMD_OUT <= 40'b0;\n        Crc_Buffering <= 1'b0;\n        STATUS <= 16'b0;\n        CRC_Valid <= 1'b0;\n        Cmd_Cnt <= 8'b0;\n        st_dat_t <= 2'b0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1'b1;\n                cmd_out_o <= 1'b1;\n            end\n            \n            IDLE: begin\n                cmd_oe_o <= 1'b0;\n                Delay_Cnt <= 3'b0;\n                Cmd_Cnt <= 8'b0;\n                CRC_RST <= 1'b1;\n                CRC_Enable <= 1'b0;\n                CMD_OUT <= 40'b0;\n                st_dat_t <= 2'b0;\n                word_select_counter <= 5'b0;\n            end\n            \n            WRITE_WR: begin\n                FSM_ACK <= 1'b0;\n                CRC_RST <= 1'b0;\n                CRC_Enable <= 1'b1;\n                \n                if (Cmd_Cnt == 8'b0) begin\n                    STATUS <= 16'b0000000000000001;\n                    REQ_OUT <= 1'b1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 1'b0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1'b1;\n                    \n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                        CRC_OUT <= CRC_VAL[7 - Cmd_Cnt];\n                        if (block_read && block_write)\n                            st_dat_t <= 2'b11;\n                        else if (block_write)\n                            st_dat_t <= 2'b01;\n                    end else begin\n                        cmd_out_o <= 1'b1;\n                    end\n                    \n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1'b1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            WRITE_WO: begin\n                FSM_ACK <= 1'b0;\n                CRC_RST <= 1'b0;\n                CRC_Enable <= 1'b1;\n                \n                if (Cmd_Cnt == 8'b0) begin\n                    STATUS[3:0] <= 4'b0010;\n                    REQ_OUT <= 1'b1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 1'b0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1'b1;\n                    \n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                        CRC_OUT <= CRC_VAL[7 - Cmd_Cnt];\n                        if (block_read && block_write)\n                            st_dat_t <= 2'b11;\n                        else if (block_write)\n                            st_dat_t <= 2'b01;\n                    end else begin\n                        cmd_out_o <= 1'b1;\n                    end\n                    \n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1'b1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            DLY_WR: begin\n                if (Delay_Cnt == 3'b0) begin\n                    STATUS[3:0] <= 4'b0011;\n                    REQ_OUT <= 1'b1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 1'b0;\n                end\n                \n                CRC_Enable <= 1'b0;\n                CRC_RST <= 1'b1;\n                Cmd_Cnt <= 8'b1;\n                cmd_oe_o <= 1'b0;\n                \n                if (Delay_Cnt < 3'b111)\n                    Delay_Cnt <= Delay_Cnt + 1;\n                \n                Crc_Buffering <= 1'b0;\n            end\n            \n            DLY_WO: begin\n                if (Delay_Cnt == 3'b0) begin\n                    STATUS[3:0] <= 4'b0100;\n                    STATUS[5] <= 1'b0;\n                    STATUS[6] <= 1'b1;\n                    REQ_OUT <= 1'b1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 1'b0;\n                end\n                \n                CRC_Enable <= 1'b0;\n                CRC_RST <= 1'b1;\n                Cmd_Cnt <= 8'b0;\n                cmd_oe_o <= 1'b0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 1'b0;\n            end\n            \n            READ_WR: begin\n                Delay_Cnt <= 3'b0;\n                CRC_RST <= 1'b0;\n                CRC_Enable <= 1'b1;\n                cmd_oe_o <= 1'b0;\n                \n                if (Cmd_Cnt == 8'b1) begin\n                    STATUS[3:0] <= 4'b0101;\n                    REQ_OUT <= 1'b1;\n                    Out_Buff[39] <= 1'b0;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 1'b0;\n                end\n                \n                if (Cmd_Cnt < Response_Size) begin\n                    case (word_select)\n                        2'b00: Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        2'b01: Out_Buff[31 - Cmd_Cnt] <= cmd_dat_i;\n                        2'b10: Out_Buff[23 - Cmd_Cnt] <= cmd_dat_i;\n                        2'b11: Out_Buff[15 - Cmd_Cnt] <= cmd_dat_i;\n                    endcase\n                    CRC_OUT <= cmd_dat_i;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                    CRC_Enable <= 1'b0;\n                end else begin\n                    if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                        CRC_Valid <= 1'b0;\n                        CRC_Enable <= 1'b0;\n                    end else begin\n                        CRC_Valid <= 1'b1;\n                        CRC_Enable <= 1'b0;\n                    end\n                    \n                    if (block_read && block_write)\n                        st_dat_t <= 2'b11;\n                    else if (block_write)\n                        st_dat_t <= 2'b01;\n                end\n                \n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            \n            DLY_READ: begin\n                if (Delay_Cnt == 3'b0) begin\n                    STATUS[3:0] <= 4'b0110;\n                    STATUS[5] <= CRC_Valid;\n                    STATUS[6] <= 1'b1;\n                    REQ_OUT <= 1'b1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 1'b0;\n                end\n                \n                CRC_Enable <= 1'b0;\n                CRC_RST <= 1'b1;\n                Cmd_Cnt <= 8'b0;\n                cmd_oe_o <= 1'b0;\n                CMD_OUT <= Out_Buff;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            \n            ACK_WO: begin\n                FSM_ACK <= 1'b1;\n            end\n            \n            ACK_WR: begin\n                FSM_ACK <= 1'b1;\n                REQ_OUT <= 1'b0;\n            end\n        endcase\n    end\nend\n\n// ACK_OUT assignment\nalways @(*) begin\n    ACK_OUT = FSM_ACK & DECODER_ACK;\nend\n\nendmodule\n\n// CRC-7 module\nmodule sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        CRC[0] <= CRC[6] ^ BITVAL;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ CRC[6] ^ BITVAL;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 13, "code": "module sd_cmd_serial_host (\n    input SD_CLK_IN,\n    input RST_IN,\n    input [15:0] SETTING_IN,\n    input [39:0] CMD_IN,\n    input REQ_IN,\n    input ACK_IN,\n    input cmd_dat_i,\n    \n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [15:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n// Parameters\nparameter INIT_DELAY = 64;\nparameter NCR = 2;\nparameter SEND_SIZE = 48;\nparameter SIZE = 10;\nparameter CONTENT_SIZE = 40;\nparameter Read_Delay = 7;\nparameter EIGHT_PAD = 8;\n\n// States\nparameter INIT     = 10'b0000000001;\nparameter IDLE     = 10'b0000000010;\nparameter WRITE_WR = 10'b0000000100;\nparameter DLY_WR   = 10'b0000001000;\nparameter READ_WR  = 10'b0000010000;\nparameter DLY_READ = 10'b0000100000;\nparameter ACK_WR   = 10'b0001000000;\nparameter WRITE_WO = 10'b0010000000;\nparameter DLY_WO   = 10'b0100000000;\nparameter ACK_WO   = 10'b1000000000;\n\n// Internal registers\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg Write_Read;\nreg Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST;\nreg [6:0] CRC_IN;\nwire [6:0] CRC_VAL;\nreg CRC_Enable;\nreg CRC_OUT;\nreg CRC_Check_On;\nreg Crc_Buffering;\nreg CRC_Valid;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg [9:0] state;\nreg [9:0] next_state;\nreg block_write;\nreg block_read;\nreg [1:0] word_select;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\n\n// Instantiate CRC module\nsd_crc_7 crc7 (\n    .BITVAL(CRC_OUT),\n    .Enable(CRC_Enable),\n    .CLK(SD_CLK_IN),\n    .RST(CRC_RST),\n    .CRC(CRC_VAL)\n);\n\n// FSM_SEQ: Sequential part of FSM\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC: Synchronize REQ_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC: Synchronize ACK_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Delay_Cycler <= 0;\n        Response_Size <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        CRC_Check_On <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else begin\n        if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            \n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            \n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\nend\n\n// FSM_COMBO: Combinational logic for next state\nalways @(*) begin\n    case (state)\n        INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n        IDLE: next_state = (Write_Read) ? WRITE_WR : \n                          (Write_Only) ? WRITE_WO : IDLE;\n        WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n        WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n        DLY_WR: next_state = ((Delay_Cnt >= NCR) && (!cmd_dat_i)) ? READ_WR : DLY_WR;\n        DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n        READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n        DLY_READ: next_state = (Ack_internal_in) ? ACK_WR : DLY_READ;\n        ACK_WO: next_state = IDLE;\n        ACK_WR: next_state = IDLE;\n        default: next_state = INIT;\n    endcase\nend\n\n// FSM_OUT: Output logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            \n            IDLE: begin\n                cmd_oe_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                st_dat_t <= 0;\n                word_select_counter <= 0;\n            end\n            \n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000000000000001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    \n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        CRC_OUT <= CRC_VAL[7 - Cmd_Cnt];\n                        cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                        if (block_read) st_dat_t <= 2'b10;\n                        else if (block_write) st_dat_t <= 2'b01;\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    \n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    \n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        CRC_OUT <= CRC_VAL[7 - Cmd_Cnt];\n                        cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                        if (block_read && block_write) st_dat_t <= 2'b11;\n                        else if (block_write) st_dat_t <= 2'b01;\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    \n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Delay_Cnt < 3'b111) begin\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                \n                Crc_Buffering <= 0;\n            end\n            \n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0100;\n                    STATUS[5] <= 0;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            \n            READ_WR: begin\n                Delay_Cnt <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Cmd_Cnt == 1) begin\n                    STATUS[3:0] <= 4'b0101;\n                    REQ_OUT <= 1;\n                    Out_Buff[39] <= 0;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Cmd_Cnt < Response_Size) begin\n                    Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                    CRC_OUT <= cmd_dat_i;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN[Cmd_Cnt - Response_Size - 1] <= cmd_dat_i;\n                    CRC_Enable <= 0;\n                end else begin\n                    if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                        CRC_Enable <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                        CRC_Enable <= 0;\n                    end\n                    \n                    if (block_read && block_write) begin\n                        st_dat_t <= 2'b11;\n                    end else if (block_write) begin\n                        st_dat_t <= 2'b01;\n                    end\n                end\n                \n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            \n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0110;\n                    STATUS[5] <= CRC_Valid;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                CMD_OUT <= Out_Buff;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            \n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            \n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\n// ACK_OUT generation\nalways @(*) begin\n    ACK_OUT = FSM_ACK & DECODER_ACK;\nend\n\nendmodule\n\n// CRC-7 module\nmodule sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 0;\n    end else if (Enable) begin\n        CRC[0] <= BITVAL ^ CRC[6];\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= BITVAL ^ CRC[6] ^ CRC[2];\n        CRC[4] <= BITVAL ^ CRC[6] ^ CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 14, "code": "module sd_cmd_serial_host (\n    input SD_CLK_IN,\n    input RST_IN,\n    input [15:0] SETTING_IN,\n    input [39:0] CMD_IN,\n    input REQ_IN,\n    input ACK_IN,\n    input cmd_dat_i,\n    \n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [15:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n// Parameters\nparameter INIT_DELAY = 64;\nparameter NCR = 2;\nparameter SEND_SIZE = 48;\nparameter SIZE = 10;\nparameter CONTENT_SIZE = 40;\nparameter Read_Delay = 7;\nparameter EIGHT_PAD = 8;\n\n// States\nparameter INIT     = 10'b0000000001;\nparameter IDLE     = 10'b0000000010;\nparameter WRITE_WR = 10'b0000000100;\nparameter DLY_WR   = 10'b0000001000;\nparameter READ_WR  = 10'b0000010000;\nparameter DLY_READ = 10'b0000100000;\nparameter ACK_WR   = 10'b0001000000;\nparameter WRITE_WO = 10'b0010000000;\nparameter DLY_WO   = 10'b0100000000;\nparameter ACK_WO   = 10'b1000000000;\n\n// Internal registers\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg Write_Read;\nreg Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST;\nreg [6:0] CRC_IN;\nwire [6:0] CRC_VAL;\nreg CRC_Enable;\nreg CRC_OUT;\nreg CRC_Check_On;\nreg Crc_Buffering;\nreg CRC_Valid;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg [9:0] state;\nreg [9:0] next_state;\nreg block_write;\nreg block_read;\nreg [1:0] word_select;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\n\n// Instantiate CRC module\nsd_crc_7 crc7 (\n    .BITVAL(CRC_OUT),\n    .Enable(CRC_Enable),\n    .CLK(SD_CLK_IN),\n    .RST(CRC_RST),\n    .CRC(CRC_VAL)\n);\n\n// FSM_COMBO: Combinational logic for next state\nalways @(*) begin\n    case (state)\n        INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n        IDLE: begin\n            if (Write_Read) next_state = WRITE_WR;\n            else if (Write_Only) next_state = WRITE_WO;\n            else next_state = IDLE;\n        end\n        WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n        WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n        DLY_WR: begin\n            if (Delay_Cnt >= NCR && !cmd_dat_i) next_state = READ_WR;\n            else next_state = DLY_WR;\n        end\n        DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n        READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n        DLY_READ: next_state = (Ack_internal_in) ? ACK_WR : DLY_READ;\n        ACK_WO: next_state = IDLE;\n        ACK_WR: next_state = IDLE;\n        default: next_state = INIT;\n    endcase\nend\n\n// FSM_SEQ: Sequential state update\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC: Synchronize REQ_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC: Synchronize ACK_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Delay_Cycler <= 0;\n        Response_Size <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        CRC_Check_On <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else begin\n        if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            \n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            \n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\nend\n\n// FSM_OUT\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            \n            IDLE: begin\n                cmd_oe_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                st_dat_t <= 0;\n                word_select_counter <= 0;\n            end\n            \n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000000000000001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    \n                    if (Cmd_Cnt > 8) begin\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 10)];\n                        end\n                        cmd_out_o <= (Cmd_Cnt > 9) ? In_Buff[39 - (Cmd_Cnt - 10)] : 1;\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        CRC_OUT <= (Cmd_Cnt == 2) ? 0 : CRC_VAL[8 - Cmd_Cnt];\n                        cmd_out_o <= (Cmd_Cnt == 2) ? 0 : CRC_VAL[8 - Cmd_Cnt];\n                        if (Cmd_Cnt == 8) begin\n                            st_dat_t <= (block_read && block_write) ? 2'b11 : \n                                       (block_write) ? 2'b01 : 2'b00;\n                        end\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    \n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    \n                    if (Cmd_Cnt > 8) begin\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 10)];\n                        end\n                        cmd_out_o <= (Cmd_Cnt > 9) ? In_Buff[39 - (Cmd_Cnt - 10)] : 1;\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        CRC_OUT <= (Cmd_Cnt == 2) ? 0 : CRC_VAL[8 - Cmd_Cnt];\n                        cmd_out_o <= (Cmd_Cnt == 2) ? 0 : CRC_VAL[8 - Cmd_Cnt];\n                        if (Cmd_Cnt == 8) begin\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        end\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    \n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Delay_Cnt < 3'b111) begin\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                \n                Crc_Buffering <= 0;\n            end\n            \n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0100;\n                    STATUS[5] <= 0;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            \n            READ_WR: begin\n                Delay_Cnt <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Cmd_Cnt == 1) begin\n                    STATUS[3:0] <= 4'b0101;\n                    REQ_OUT <= 1;\n                    Out_Buff[39] <= 0;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Cmd_Cnt < Response_Size) begin\n                    Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                    CRC_OUT <= cmd_dat_i;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN[Cmd_Cnt - Response_Size - 1] <= cmd_dat_i;\n                    if ((Cmd_Cnt - Response_Size) == 6) begin\n                        CRC_Enable <= 0;\n                    end\n                end else begin\n                    if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                        CRC_Enable <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                        CRC_Enable <= 0;\n                    end\n                    \n                    if (block_read && block_write) begin\n                        st_dat_t <= 2'b11;\n                    end else if (block_write) begin\n                        st_dat_t <= 2'b01;\n                    end\n                end\n                \n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            \n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0110;\n                    STATUS[5] <= CRC_Valid;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                CMD_OUT <= Out_Buff;\n            end\n            \n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            \n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\n// ACK_OUT generation\nalways @(*) begin\n    ACK_OUT = FSM_ACK & DECODER_ACK;\nend\n\nendmodule\n\n// CRC-7 module\nmodule sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nreg [6:0] CRC_Reg;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC_Reg <= 7'b0;\n    end else if (Enable) begin\n        CRC_Reg[0] <= BITVAL ^ CRC_Reg[6];\n        CRC_Reg[1] <= CRC_Reg[0];\n        CRC_Reg[2] <= CRC_Reg[1];\n        CRC_Reg[3] <= BITVAL ^ CRC_Reg[6] ^ CRC_Reg[2];\n        CRC_Reg[4] <= BITVAL ^ CRC_Reg[6] ^ CRC_Reg[3];\n        CRC_Reg[5] <= BITVAL ^ CRC_Reg[6] ^ CRC_Reg[4];\n        CRC_Reg[6] <= BITVAL ^ CRC_Reg[5];\n    end\nend\n\nalways @(*) begin\n    CRC = CRC_Reg;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 8, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input               wb_clk_i,\n    input               wb_rst_i,\n    input        [3:0]  wb_sel_i,\n    input        [31:0] wb_dat_i,\n    output       [31:0] wb_dat_o,\n    input        [7:0]  wb_adr_i,\n    input               wb_we_i,\n    input               wb_cyc_i,\n    input               wb_stb_i,\n    output              wb_ack_o,\n    \n    // Wishbone Master Interface\n    output       [31:0] m_wb_adr_o,\n    output              m_wb_sel_o,\n    output              m_wb_we_o,\n    output       [31:0] m_wb_dat_o,\n    input        [31:0] m_wb_dat_i,\n    output              m_wb_cyc_o,\n    output              m_wb_stb_o,\n    input               m_wb_ack_i,\n    output       [2:0]  m_wb_cti_o,\n    output       [1:0]  m_wb_bte_o,\n    \n    // SDC IO Ports\n    input               sd_cmd_dat_i,\n    output              sd_cmd_out_o,\n    output              sd_cmd_oe_o,\n    input        [3:0]  sd_dat_dat_i,\n    output       [3:0]  sd_dat_out_o,\n    output              sd_dat_oe_o,\n    output              sd_clk_o_pad,\n    input               sd_clk_i_pad,\n    input               card_detect,\n    \n    // Interrupts\n    output              int_a,\n    output              int_b,\n    output              int_c\n);\n\n    // Internal signals\n    wire        [31:0]  argument_reg;\n    wire        [15:0]  cmd_setting_reg;\n    wire        [15:0]  status_reg;\n    wire        [31:0]  cmd_resp_1;\n    wire        [7:0]   software_reset_reg;\n    wire        [15:0]  time_out_reg;\n    wire        [15:0]  normal_int_status_reg;\n    wire        [15:0]  error_int_status_reg;\n    wire        [15:0]  normal_int_signal_enable_reg;\n    wire        [15:0]  error_int_signal_enable_reg;\n    wire        [7:0]   clock_divider;\n    wire        [15:0]  Bd_Status_reg;\n    wire        [7:0]   Bd_isr_reg;\n    wire        [7:0]   Bd_isr_enable_reg;\n    wire                bd_isr_reset;\n    wire                normal_isr_reset;\n    wire                error_isr_reset;\n    wire                new_cmd;\n    wire                we_ack;\n    wire                cmd_int_busy;\n    wire                write_req_s;\n    wire        [15:0]  cmd_set_s;\n    wire        [31:0]  cmd_arg_s;\n    wire                we_m_tx_bd;\n    wire                we_m_rx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n    \n    // SD Clock signals\n    wire                sd_clk_i;\n    wire                sd_clk_o;\n    \n    // SD Command Master signals\n    wire                data_write;\n    wire                data_read;\n    wire                go_idle_o;\n    wire        [39:0]  cmd_out;\n    wire                req_out;\n    wire                ack_out;\n    wire                req_in;\n    wire                ack_in;\n    wire        [39:0]  cmd_in;\n    wire        [7:0]   serial_status;\n    \n    // SD Data Master signals\n    wire                re_s_tx;\n    wire                a_cmp_tx;\n    wire                re_s_rx;\n    wire                a_cmp_rx;\n    wire                start_tx_fifo;\n    wire                start_rx_fifo;\n    wire        [31:0]  sys_adr;\n    wire                ack_transfer;\n    wire        [7:0]   Dat_Int_Status;\n    wire                CIDAT;\n    \n    // SD Data Serial Host signals\n    wire                rd;\n    wire        [3:0]   data_out;\n    wire                we;\n    wire                busy_n;\n    wire                transm_complete;\n    wire                crc_ok;\n    \n    // FIFO signals\n    wire                tx_empt;\n    wire                tx_full;\n    wire                rx_full;\n    \n    // Buffer Descriptor signals\n    wire [BD_WIDTH-1:0] free_tx_bd;\n    wire [BD_WIDTH-1:0] free_rx_bd;\n    wire                ack_o_s_tx;\n    wire                ack_o_s_rx;\n    wire [RAM_MEM_WIDTH-1:0] dat_out_s_tx;\n    wire [RAM_MEM_WIDTH-1:0] dat_out_s_rx;\n    \n    // Assignments\n    assign m_wb_sel_o = 4'b1111;\n    assign Bd_Status_reg = {free_rx_bd, free_tx_bd};\n    assign status_reg[0] = cmd_int_busy ? 1'b1 : status_reg[0];\n    assign status_reg[1] = CIDAT;\n    assign status_reg[15:2] = status_reg[15:2];\n    \n    // Clock selection\n`ifdef SDC_CLK_BUS_CLK\n    assign sd_clk_i = wb_clk_i;\n`elsif SDC_CLK_SEP\n    assign sd_clk_i = sd_clk_i_pad;\n`endif\n\n    assign sd_clk_o_pad = sd_clk_o;\n    \n    // Interrupt assignments\n`ifdef SDC_IRQ_ENABLE\n    assign int_a = |(normal_int_status_reg & normal_int_signal_enable_reg);\n    assign int_b = |(error_int_status_reg & error_int_signal_enable_reg);\n    assign int_c = |(Bd_isr_reg & Bd_isr_enable_reg);\n`else\n    assign int_a = 1'b0;\n    assign int_b = 1'b0;\n    assign int_c = 1'b0;\n`endif\n    \n    // Master Wishbone Interface Mux\n    assign m_wb_cyc_o = start_tx_fifo ? tx_fifo_m_wb_cyc_o : \n                       (start_rx_fifo ? rx_fifo_m_wb_cyc_o : 1'b0);\n    assign m_wb_stb_o = start_tx_fifo ? tx_fifo_m_wb_stb_o : \n                       (start_rx_fifo ? rx_fifo_m_wb_stb_o : 1'b0);\n    assign m_wb_cti_o = start_tx_fifo ? tx_fifo_m_wb_cti_o : \n                       (start_rx_fifo ? rx_fifo_m_wb_cti_o : 3'b0);\n    assign m_wb_bte_o = start_tx_fifo ? tx_fifo_m_wb_bte_o : \n                       (start_rx_fifo ? rx_fifo_m_wb_bte_o : 2'b0);\n    assign m_wb_we_o = start_tx_fifo ? tx_fifo_m_wb_we_o : \n                      (start_rx_fifo ? rx_fifo_m_wb_we_o : 1'b0);\n    assign m_wb_adr_o = start_tx_fifo ? tx_fifo_m_wb_adr_o : \n                       (start_rx_fifo ? rx_fifo_m_wb_adr_o : 32'b0);\n    assign m_wb_dat_o = start_rx_fifo ? rx_fifo_m_wb_dat_o : 32'b0;\n    \n    // Module Instantiations\n    sd_controller_wb u_sd_controller_wb (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n    \n    sd_clock_divider u_sd_clock_divider (\n        .CLK(sd_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i | software_reset_reg[0]),\n        .SD_CLK(sd_clk_o)\n    );\n    \n    sd_cmd_master u_sd_cmd_master (\n        .CLK_PAD_IO(sd_clk_o),\n        .RST_PAD_I(wb_rst_i | software_reset_reg[0] | go_idle_o),\n        .New_CMD(new_cmd),\n        .data_write(data_write),\n        .data_read(data_read),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(),\n        .go_idle_o(go_idle_o),\n        .cmd_out(cmd_out),\n        .req_out(req_out),\n        .ack_out(ack_out),\n        .req_in(req_in),\n        .ack_in(ack_in),\n        .cmd_in(cmd_in),\n        .serial_status(serial_status),\n        .card_detect(card_detect)\n    );\n    \n    sd_cmd_serial_host u_sd_cmd_serial_host (\n        .SD_CLK_IN(sd_clk_o),\n        .RST_IN(wb_rst_i | software_reset_reg[0] | go_idle_o),\n        .SETTING_IN(cmd_setting_reg),\n        .CMD_IN(cmd_out),\n        .REQ_IN(req_out),\n        .ACK_IN(ack_out),\n        .cmd_dat_i(sd_cmd_dat_i),\n        .CMD_OUT(cmd_in),\n        .ACK_OUT(ack_in),\n        .REQ_OUT(req_in),\n        .STATUS(serial_status),\n        .cmd_oe_o(sd_cmd_oe_o),\n        .cmd_out_o(sd_cmd_out_o),\n        .st_dat_t()\n    );\n    \n    sd_data_master u_sd_data_master (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .dat_in_tx(dat_out_s_tx),\n        .free_tx_bd(free_tx_bd),\n        .ack_i_s_tx(ack_o_s_tx),\n        .dat_in_rx(dat_out_s_rx),\n        .free_rx_bd(free_rx_bd),\n        .ack_i_s_rx(ack_o_s_rx),\n        .cmd_busy(cmd_int_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(),\n        .card_status(status_reg[5:1]),\n        .tx_empt(tx_empt),\n        .tx_full(tx_full),\n        .rx_full(rx_full),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok),\n        .Dat_Int_Status_rst(bd_isr_reset),\n        .transfer_type(),\n        .re_s_tx(re_s_tx),\n        .a_cmp_tx(a_cmp_tx),\n        .re_s_rx(re_s_rx),\n        .a_cmp_rx(a_cmp_rx),\n        .we_req(write_req_s),\n        .d_write(data_write),\n        .d_read(data_read),\n        .cmd_arg(cmd_arg_s),\n        .cmd_set(cmd_set_s),\n        .start_tx_fifo(start_tx_fifo),\n        .start_rx_fifo(start_rx_fifo),\n        .sys_adr(sys_adr),\n        .ack_transfer(ack_transfer),\n        .Dat_Int_Status(Bd_isr_reg),\n        .CIDAT(CIDAT)\n    );\n    \n    sd_data_serial_host u_sd_data_serial_host (\n        .sd_clk(sd_clk_o),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .data_in(),\n        .start_dat({data_read, data_write}),\n        .ack_transfer(ack_transfer),\n        .DAT_dat_i(sd_dat_dat_i),\n        .rd(rd),\n        .data_out(data_out),\n        .we(we),\n        .DAT_oe_o(sd_dat_oe_o),\n        .DAT_dat_o(sd_dat_out_o),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok)\n    );\n    \n    sd_bd u_tx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_tx_bd),\n        .dat_in_m(dat_in_m_tx_bd),\n        .free_bd(free_tx_bd),\n        .re_s(re_s_tx),\n        .ack_o_s(ack_o_s_tx),\n        .a_cmp(a_cmp_tx),\n        .dat_out_s(dat_out_s_tx)\n    );\n    \n    sd_bd u_rx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_rx_bd),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(free_rx_bd),\n        .re_s(re_s_rx),\n        .ack_o_s(ack_o_s_rx),\n        .a_cmp(a_cmp_rx),\n        .dat_out_s(dat_out_s_rx)\n    );\n    \n    sd_fifo_tx_filler u_sd_fifo_tx_filler (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(tx_fifo_m_wb_adr_o),\n        .m_wb_we_o(tx_fifo_m_wb_we_o),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(tx_fifo_m_wb_cyc_o),\n        .m_wb_stb_o(tx_fifo_m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(tx_fifo_m_wb_cti_o),\n        .m_wb_bte_o(tx_fifo_m_wb_bte_o),\n        .en(start_tx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_o(),\n        .rd(rd),\n        .empty(tx_empt),\n        .fe(tx_full)\n    );\n    \n    sd_fifo_rx_filler u_sd_fifo_rx_filler (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(rx_fifo_m_wb_adr_o),\n        .m_wb_we_o(rx_fifo_m_wb_we_o),\n        .m_wb_dat_o(rx_fifo_m_wb_dat_o),\n        .m_wb_cyc_o(rx_fifo_m_wb_cyc_o),\n        .m_wb_stb_o(rx_fifo_m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(rx_fifo_m_wb_cti_o),\n        .m_wb_bte_o(rx_fifo_m_wb_bte_o),\n        .en(start_rx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_i(data_out),\n        .wr(we),\n        .full(rx_full)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 15, "code": "module sd_cmd_serial_host (\n    input SD_CLK_IN,\n    input RST_IN,\n    input [15:0] SETTING_IN,\n    input [39:0] CMD_IN,\n    input REQ_IN,\n    input ACK_IN,\n    input cmd_dat_i,\n    \n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [15:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n// Parameters\nparameter INIT_DELAY = `SIM ? 2 : 64;\nparameter NCR = 2;\nparameter SEND_SIZE = 48;\nparameter SIZE = 10;\nparameter CONTENT_SIZE = 40;\nparameter Read_Delay = 7;\nparameter EIGHT_PAD = 8;\n\n// States\nparameter INIT     = 10'b0000000001;\nparameter IDLE     = 10'b0000000010;\nparameter WRITE_WR = 10'b0000000100;\nparameter DLY_WR   = 10'b0000001000;\nparameter READ_WR  = 10'b0000010000;\nparameter DLY_READ = 10'b0000100000;\nparameter ACK_WR   = 10'b0001000000;\nparameter WRITE_WO = 10'b0010000000;\nparameter DLY_WO   = 10'b0100000000;\nparameter ACK_WO   = 10'b1000000000;\n\n// Internal registers\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg Write_Read;\nreg Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST;\nreg [6:0] CRC_IN;\nwire [6:0] CRC_VAL;\nreg CRC_Enable;\nreg CRC_OUT;\nreg CRC_Check_On;\nreg Crc_Buffering;\nreg CRC_Valid;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg [9:0] state;\nreg [9:0] next_state;\nreg block_write;\nreg block_read;\nreg [1:0] word_select;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\n\n// Submodule instantiation\nsd_crc_7 crc7 (\n    .BITVAL(CRC_OUT),\n    .Enable(CRC_Enable),\n    .CLK(SD_CLK_IN),\n    .RST(CRC_RST),\n    .CRC(CRC_VAL)\n);\n\n// FSM_COMBO: Combinational logic for next state\nalways @(*) begin\n    case (state)\n        INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n        IDLE: begin\n            if (Write_Read) next_state = WRITE_WR;\n            else if (Write_Only) next_state = WRITE_WO;\n            else next_state = IDLE;\n        end\n        WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n        WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n        DLY_WR: begin\n            if (Delay_Cnt >= NCR && !cmd_dat_i) next_state = READ_WR;\n            else next_state = DLY_WR;\n        end\n        DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n        READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n        DLY_READ: next_state = (Ack_internal_in) ? ACK_WR : DLY_READ;\n        ACK_WO: next_state = IDLE;\n        ACK_WR: next_state = IDLE;\n        default: next_state = INIT;\n    endcase\nend\n\n// FSM_SEQ: Sequential state update\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC: Synchronize REQ_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC: Synchronize ACK_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Delay_Cycler <= 0;\n        Response_Size <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        CRC_Check_On <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else begin\n        if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            \n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            \n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\nend\n\n// FSM_OUT\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            \n            IDLE: begin\n                cmd_oe_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                st_dat_t <= 0;\n                word_select_counter <= 0;\n            end\n            \n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000000000000001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    \n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                        if (block_read) begin\n                            st_dat_t <= 2'b10;\n                        end\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    \n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    \n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                        if (block_read) begin\n                            st_dat_t <= 2'b10;\n                        end\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    \n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Delay_Cnt < 3'b111) begin\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                \n                Crc_Buffering <= 0;\n            end\n            \n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0100;\n                    STATUS[5] <= 0;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            \n            READ_WR: begin\n                Delay_Cnt <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Cmd_Cnt == 1) begin\n                    STATUS[3:0] <= 4'b0101;\n                    REQ_OUT <= 1;\n                    Out_Buff[39] <= 0;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Cmd_Cnt < Response_Size) begin\n                    Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                    CRC_OUT <= cmd_dat_i;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                    CRC_Enable <= 0;\n                end else begin\n                    if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                        CRC_Enable <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                        CRC_Enable <= 0;\n                    end\n                    \n                    if (block_read && block_write) begin\n                        st_dat_t <= 2'b11;\n                    end else if (block_write) begin\n                        st_dat_t <= 2'b01;\n                    end\n                end\n                \n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            \n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0110;\n                    STATUS[5] <= CRC_Valid;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                CMD_OUT <= Out_Buff;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            \n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            \n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\n// ACK_OUT generation\nalways @(*) begin\n    ACK_OUT = FSM_ACK & DECODER_ACK;\nend\n\nendmodule\n\n// CRC-7 submodule\nmodule sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 0;\n    end else if (Enable) begin\n        CRC[0] <= CRC[6] ^ BITVAL;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ CRC[6] ^ BITVAL;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 9, "code": ".m_wb_cyc_o(rx_m_wb_cyc_o),\n        .m_wb_stb_o(rx_m_wb_stb_o),\n        .m_wb_ack_i(rx_m_wb_ack_i),\n        .m_wb_cti_o(rx_m_wb_cti_o),\n        .m_wb_bte_o(rx_m_wb_bte_o),\n        .en(start_rx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_i(data_out),\n        .we(we),\n        .full(rx_full)\n    );\n    \n    sd_data_serial_host u_data_serial_host (\n        .SD_CLK_IN(sd_clk_o),\n        .RST_IN(wb_rst_i | software_reset_reg[0]),\n        .DAT_IN(tx_dat_o),\n        .DAT_OUT(data_out),\n        .rd(rd),\n        .we(we),\n        .DAT_oe_o(DAT_oe_o),\n        .DAT_dat_o(DAT_dat_o),\n        .DAT_dat_i(sd_dat_dat_i),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok),\n        .transfer_type(st_dat_t)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 10, "code": "_o),\n        .m_wb_bte_o(tx_m_wb_bte_o),\n        .dat_o(tx_dat_o),\n        .empty(tx_empty),\n        .full(tx_full_fifo),\n        .we(we),\n        .start(start_tx_fifo),\n        .sys_adr(sys_adr)\n    );\n    \n    sd_fifo_rx_filler u_sd_fifo_rx_filler (\n        .clk(sd_clk_o),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(rx_m_wb_adr_o),\n        .m_wb_we_o(rx_m_wb_we_o),\n        .m_wb_dat_o(rx_m_wb_dat_o),\n        .m_wb_cyc_o(rx_m_wb_cyc_o),\n        .m_wb_stb_o(rx_m_wb_stb_o),\n        .m_wb_ack_i(rx_m_wb_ack_i),\n        .m_wb_cti_o(rx_m_wb_cti_o),\n        .m_wb_bte_o(rx_m_wb_bte_o),\n        .dat_i(data_out),\n        .full(rx_full_fifo),\n        .rd(rd),\n        .start(start_rx_fifo),\n        .sys_adr(sys_adr)\n    );\n    \nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 11, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input         wb_clk_i,\n    input         wb_rst_i,\n    input  [3:0]  wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0]  wb_adr_i,\n    input         wb_we_i,\n    input         wb_cyc_i,\n    input         wb_stb_i,\n    output        wb_ack_o,\n    \n    // Wishbone Master Interface\n    output [31:0] m_wb_adr_o,\n    output        m_wb_sel_o,\n    output        m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    \n    // SDC IO\n    input         sd_cmd_dat_i,\n    output        sd_cmd_out_o,\n    output        sd_cmd_oe_o,\n    input  [3:0]  sd_dat_dat_i,\n    output [3:0]  sd_dat_out_o,\n    output        sd_dat_oe_o,\n    output        sd_clk_o_pad,\n    input         sd_clk_i_pad,\n    input         card_detect,\n    \n    // Interrupts\n    output        int_a,\n    output        int_b,\n    output        int_c\n);\n\n    // Internal signals\n    wire        we_m_tx_bd;\n    wire        we_m_rx_bd;\n    wire        new_cmd;\n    wire        we_ack;\n    wire        int_ack;\n    wire        cmd_int_busy;\n    wire        int_busy;\n    wire        write_req_s;\n    wire [15:0] cmd_set_s;\n    wire [31:0] cmd_arg_s;\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0]  software_reset_reg;\n    wire [16:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0]  clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0]  Bd_isr_reg;\n    wire [7:0]  Bd_isr_enable_reg;\n    wire        bd_isr_reset;\n    wire        normal_isr_reset;\n    wire        error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n    \n    // Data master signals\n    wire        re_s_tx;\n    wire        a_cmp_tx;\n    wire        re_s_rx;\n    wire        a_cmp_rx;\n    wire        we_req;\n    wire        d_write;\n    wire        d_read;\n    wire [31:0] cmd_arg;\n    wire [15:0] cmd_set;\n    wire        start_tx_fifo;\n    wire        start_rx_fifo;\n    wire [31:0] sys_adr;\n    wire        ack_transfer;\n    wire [7:0]  Dat_Int_Status;\n    wire        CIDAT;\n    \n    // FIFO signals\n    wire        tx_empt;\n    wire        tx_full;\n    wire        rx_full;\n    wire        busy_n;\n    wire        transm_complete;\n    wire        crc_ok;\n    \n    // CMD master signals\n    wire        go_idle_o;\n    wire [39:0] cmd_out;\n    wire        req_out;\n    wire        ack_out;\n    wire        req_in;\n    wire        ack_in;\n    wire [39:0] cmd_in;\n    wire [7:0]  serial_status;\n    \n    // Data serial host signals\n    wire [31:0] data_in;\n    wire [1:0]  start_dat;\n    wire [3:0]  data_out;\n    wire        rd;\n    wire        we;\n    \n    // Clock signals\n    wire        sd_clk_i;\n    wire        sd_clk_o;\n    \n    // Assign clock outputs\n    assign sd_clk_o_pad = sd_clk_o;\n    \n    // Assign master select\n    assign m_wb_sel_o = 4'b1111;\n    \n    // Mux for master interface signals\n    assign m_wb_cyc_o = start_tx_fifo ? tx_filler_cyc : (start_rx_fifo ? rx_filler_cyc : 1'b0);\n    assign m_wb_stb_o = start_tx_fifo ? tx_filler_stb : (start_rx_fifo ? rx_filler_stb : 1'b0);\n    assign m_wb_cti_o = start_tx_fifo ? tx_filler_cti : (start_rx_fifo ? rx_filler_cti : 3'b0);\n    assign m_wb_bte_o = start_tx_fifo ? tx_filler_bte : (start_rx_fifo ? rx_filler_bte : 2'b0);\n    assign m_wb_we_o  = start_tx_fifo ? tx_filler_we  : (start_rx_fifo ? rx_filler_we  : 1'b0);\n    assign m_wb_adr_o = start_tx_fifo ? tx_filler_adr : (start_rx_fifo ? rx_filler_adr : 32'b0);\n    assign m_wb_dat_o = start_rx_fifo ? rx_filler_dat : 32'b0;\n    \n    // Instantiate submodules\n    sd_controller_wb wb_interface (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n    \n    sd_clock_divider clk_div (\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i | software_reset_reg[0]),\n        .SD_CLK(sd_clk_o)\n    );\n    \n    sd_cmd_master cmd_master (\n        .CLK_PAD_IO(sd_clk_o),\n        .RST_PAD_I(wb_rst_i | software_reset_reg[0] | go_idle_o),\n        .New_CMD(new_cmd),\n        .data_write(d_write),\n        .data_read(d_read),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(cmd_set),\n        .go_idle_o(go_idle_o),\n        .cmd_out(cmd_out),\n        .req_out(req_out),\n        .ack_out(ack_out),\n        .req_in(req_in),\n        .ack_in(ack_in),\n        .cmd_in(cmd_in),\n        .serial_status(serial_status),\n        .card_detect(card_detect)\n    );\n    \n    sd_cmd_serial_host cmd_serial (\n        .SD_CLK_IN(sd_clk_o),\n        .RST_IN(wb_rst_i | software_reset_reg[0] | go_idle_o),\n        .SETTING_IN(cmd_set),\n        .CMD_IN(cmd_out),\n        .REQ_IN(req_out),\n        .ACK_IN(ack_out),\n        .cmd_dat_i(sd_cmd_dat_i),\n        .CMD_OUT(cmd_in),\n        .ACK_OUT(ack_in),\n        .REQ_OUT(req_in),\n        .STATUS(serial_status),\n        .cmd_oe_o(sd_cmd_oe_o),\n        .cmd_out_o(sd_cmd_out_o),\n        .st_dat_t(start_dat)\n    );\n    \n    sd_data_master data_master (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .dat_in_tx(dat_in_m_tx_bd),\n        .free_tx_bd(Bd_Status_reg[7:0]),\n        .ack_i_s_tx(a_cmp_tx),\n        .dat_in_rx(dat_in_m_rx_bd),\n        .free_rx_bd(Bd_Status_reg[15:8]),\n        .ack_i_s_rx(a_cmp_rx),\n        .cmd_busy(cmd_int_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(1'b0), // TODO: Connect properly\n        .card_status(status_reg[4:0]),\n        .tx_empt(tx_empt),\n        .tx_full(tx_full),\n        .rx_full(rx_full),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok),\n        .Dat_Int_Status_rst(bd_isr_reset),\n        .transfer_type(start_dat),\n        .re_s_tx(re_s_tx),\n        .a_cmp_tx(a_cmp_tx),\n        .re_s_rx(re_s_rx),\n        .a_cmp_rx(a_cmp_rx),\n        .we_req(we_req),\n        .d_write(d_write),\n        .d_read(d_read),\n        .cmd_arg(cmd_arg),\n        .cmd_set(cmd_set),\n        .start_tx_fifo(start_tx_fifo),\n        .start_rx_fifo(start_rx_fifo),\n        .sys_adr(sys_adr),\n        .ack_transfer(ack_transfer),\n        .Dat_Int_Status(Dat_Int_Status),\n        .CIDAT(CIDAT)\n    );\n    \n    sd_data_serial_host data_serial (\n        .sd_clk(sd_clk_o),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .data_in(data_in),\n        .start_dat(start_dat),\n        .ack_transfer(ack_transfer),\n        .DAT_dat_i(sd_dat_dat_i),\n        .rd(rd),\n        .data_out(data_out),\n        .we(we),\n        .DAT_oe_o(sd_dat_oe_o),\n        .DAT_dat_o(sd_dat_out_o),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok)\n    );\n    \n    // Instantiate TX and RX BD modules\n    tx_bd tx_buffer_descriptor (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_tx_bd),\n        .dat_in_m(dat_in_m_tx_bd),\n        .free_bd(Bd_Status_reg[7:0]),\n        .re_s(re_s_tx),\n        .ack_o_s(a_cmp_tx),\n        .a_cmp(a_cmp_tx),\n        .dat_out_s(data_in)\n    );\n    \n    rx_bd rx_buffer_descriptor (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_rx_bd),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(Bd_Status_reg[15:8]),\n        .re_s(re_s_rx),\n        .ack_o_s(a_cmp_rx),\n        .a_cmp(a_cmp_rx),\n        .dat_out_s(data_out)\n    );\n    \n    // Instantiate FIFO modules\n    sd_fifo_tx_filler tx_fifo (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(tx_filler_adr),\n        .m_wb_we_o(tx_filler_we),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(tx_filler_cyc),\n        .m_wb_stb_o(tx_filler_stb),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(tx_filler_cti),\n        .m_wb_bte_o(tx_filler_bte),\n        .en(start_tx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_o(data_in),\n        .rd(rd),\n        .empty(tx_empt),\n        .fe(tx_full)\n    );\n    \n    sd_fifo_rx_filler rx_fifo (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(rx_filler_adr),\n        .m_wb_we_o(rx_filler_we),\n        .m_wb_dat_o(rx_filler_dat),\n        .m_wb_cyc_o(rx_filler_cyc),\n        .m_wb_stb_o(rx_filler_stb),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(rx_filler_cti),\n        .m_wb_bte_o(rx_filler_bte),\n        .en(start_rx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_i(data_out),\n        .wr(we),\n        .full(rx_full)\n    );\n    \n    // Interrupt generation\n    assign int_a = |(normal_int_status_reg & normal_int_signal_enable_reg);\n    assign int_b = |(error_int_status_reg & error_int_signal_enable_reg);\n    assign int_c = |(Bd_isr_reg & Bd_isr_enable_reg);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 16, "code": "module sd_cmd_serial_host (\n    input SD_CLK_IN,\n    input RST_IN,\n    input [15:0] SETTING_IN,\n    input [39:0] CMD_IN,\n    input REQ_IN,\n    input ACK_IN,\n    input cmd_dat_i,\n    \n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [15:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n// Parameters\nparameter INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\nparameter NCR = 2;\nparameter SEND_SIZE = 48;\nparameter SIZE = 10;\nparameter CONTENT_SIZE = 40;\nparameter Read_Delay = 7;\nparameter EIGHT_PAD = 8;\n\n// FSM states\nparameter INIT     = 10'b0000000001;\nparameter IDLE     = 10'b0000000010;\nparameter WRITE_WR = 10'b0000000100;\nparameter DLY_WR   = 10'b0000001000;\nparameter READ_WR  = 10'b0000010000;\nparameter DLY_READ = 10'b0000100000;\nparameter ACK_WR   = 10'b0001000000;\nparameter WRITE_WO = 10'b0010000000;\nparameter DLY_WO   = 10'b0100000000;\nparameter ACK_WO   = 10'b1000000000;\n\n// Internal registers\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg Write_Read;\nreg Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST;\nreg [6:0] CRC_IN;\nwire [6:0] CRC_VAL;\nreg CRC_Enable;\nreg CRC_OUT;\nreg CRC_Check_On;\nreg Crc_Buffering;\nreg CRC_Valid;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg [9:0] state;\nreg [9:0] next_state;\nreg block_write;\nreg block_read;\nreg [1:0] word_select;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\n\n// Instantiate CRC module\nsd_crc_7 crc7 (\n    .BITVAL(CRC_OUT),\n    .Enable(CRC_Enable),\n    .CLK(SD_CLK_IN),\n    .RST(CRC_RST),\n    .CRC(CRC_VAL)\n);\n\n// FSM_COMBO: Combinational logic for next state\nalways @(*) begin\n    case (state)\n        INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n        IDLE: begin\n            if (Write_Read) next_state = WRITE_WR;\n            else if (Write_Only) next_state = WRITE_WO;\n            else next_state = IDLE;\n        end\n        WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n        WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n        DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n        DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n        READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n        DLY_READ: next_state = (Ack_internal_in) ? ACK_WR : DLY_READ;\n        ACK_WO: next_state = IDLE;\n        ACK_WR: next_state = IDLE;\n        default: next_state = INIT;\n    endcase\nend\n\n// FSM_SEQ: Sequential state update\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC: Synchronize REQ_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 1'b0;\n        Req_internal_in <= 1'b0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC: Synchronize ACK_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 1'b0;\n        Ack_internal_in <= 1'b0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Delay_Cycler <= 3'b0;\n        Response_Size <= 7'b0;\n        DECODER_ACK <= 1'b0;\n        Write_Read <= 1'b0;\n        Write_Only <= 1'b0;\n        CRC_Check_On <= 1'b0;\n        In_Buff <= 40'b0;\n        block_write <= 1'b0;\n        block_read <= 1'b0;\n        word_select <= 2'b0;\n    end else begin\n        if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            \n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1'b1;\n                Write_Only <= 1'b0;\n            end else begin\n                Write_Read <= 1'b0;\n                Write_Only <= 1'b1;\n            end\n            \n            DECODER_ACK <= 1'b0;\n        end else begin\n            Write_Read <= 1'b0;\n            Write_Only <= 1'b0;\n            DECODER_ACK <= 1'b1;\n        end\n    end\nend\n\n// FSM_OUT\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 1'b0;\n        word_select_counter <= 5'b0;\n        Delay_Cnt <= 3'b0;\n        cmd_oe_o <= 1'b1;\n        cmd_out_o <= 1'b1;\n        Out_Buff <= 40'b0;\n        FSM_ACK <= 1'b1;\n        REQ_OUT <= 1'b0;\n        CRC_RST <= 1'b1;\n        CRC_OUT <= 1'b0;\n        CRC_IN <= 7'b0;\n        CMD_OUT <= 40'b0;\n        Crc_Buffering <= 1'b0;\n        STATUS <= 16'b0;\n        CRC_Valid <= 1'b0;\n        Cmd_Cnt <= 8'b0;\n        st_dat_t <= 2'b0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1'b1;\n                cmd_out_o <= 1'b1;\n            end\n            \n            IDLE: begin\n                cmd_oe_o <= 1'b0;\n                Delay_Cnt <= 3'b0;\n                Cmd_Cnt <= 8'b0;\n                CRC_RST <= 1'b1;\n                CRC_Enable <= 1'b0;\n                CMD_OUT <= 40'b0;\n                st_dat_t <= 2'b0;\n                word_select_counter <= 5'b0;\n            end\n            \n            WRITE_WR: begin\n                FSM_ACK <= 1'b0;\n                CRC_RST <= 1'b0;\n                CRC_Enable <= 1'b1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000000000000001;\n                    REQ_OUT <= 1'b1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 1'b0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1'b1;\n                    if (Cmd_Cnt > 8) begin\n                        CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end else begin\n                            cmd_out_o <= 1'b1;\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        CRC_OUT <= CRC_VAL[7 - Cmd_Cnt];\n                        cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                        if (block_read && block_write) begin\n                            st_dat_t <= 2'b11;\n                        end else if (block_write) begin\n                            st_dat_t <= 2'b01;\n                        end\n                    end else begin\n                        cmd_out_o <= 1'b1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1'b1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            WRITE_WO: begin\n                FSM_ACK <= 1'b0;\n                CRC_RST <= 1'b0;\n                CRC_Enable <= 1'b1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0010;\n                    REQ_OUT <= 1'b1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 1'b0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1'b1;\n                    if (Cmd_Cnt > 8) begin\n                        CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end else begin\n                            cmd_out_o <= 1'b1;\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        CRC_OUT <= CRC_VAL[7 - Cmd_Cnt];\n                        cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                        if (block_read) begin\n                            st_dat_t <= 2'b10;\n                        end\n                    end else begin\n                        cmd_out_o <= 1'b1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1'b1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0011;\n                    REQ_OUT <= 1'b1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 1'b0;\n                end\n                \n                CRC_Enable <= 1'b0;\n                CRC_RST <= 1'b1;\n                Cmd_Cnt <= 8'b1;\n                cmd_oe_o <= 1'b0;\n                \n                if (Delay_Cnt < 3'b111) begin\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                \n                Crc_Buffering <= 1'b0;\n            end\n            \n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0100;\n                    STATUS[5] <= 1'b0;\n                    STATUS[6] <= 1'b1;\n                    REQ_OUT <= 1'b1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 1'b0;\n                end\n                \n                CRC_Enable <= 1'b0;\n                CRC_RST <= 1'b1;\n                Cmd_Cnt <= 8'b0;\n                cmd_oe_o <= 1'b0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 1'b0;\n            end\n            \n            READ_WR: begin\n                Delay_Cnt <= 3'b0;\n                CRC_RST <= 1'b0;\n                CRC_Enable <= 1'b1;\n                cmd_oe_o <= 1'b0;\n                \n                if (Cmd_Cnt == 1) begin\n                    STATUS[3:0] <= 4'b0101;\n                    REQ_OUT <= 1'b1;\n                    Out_Buff[39] <= 1'b0;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 1'b0;\n                end\n                \n                if (Cmd_Cnt < Response_Size) begin\n                    case (word_select)\n                        2'b00: Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        2'b01: Out_Buff[31 - Cmd_Cnt] <= cmd_dat_i;\n                        2'b10: Out_Buff[23 - Cmd_Cnt] <= cmd_dat_i;\n                        2'b11: Out_Buff[15 - Cmd_Cnt] <= cmd_dat_i;\n                    endcase\n                    CRC_OUT <= cmd_dat_i;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                    CRC_Enable <= 1'b0;\n                end else begin\n                    if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                        CRC_Valid <= 1'b0;\n                        CRC_Enable <= 1'b0;\n                    end else begin\n                        CRC_Valid <= 1'b1;\n                        CRC_Enable <= 1'b0;\n                    end\n                    \n                    if (block_read && block_write) begin\n                        st_dat_t <= 2'b11;\n                    end else if (block_write) begin\n                        st_dat_t <= 2'b01;\n                    end\n                end\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            \n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0110;\n                    STATUS[5] <= CRC_Valid;\n                    STATUS[6] <= 1'b1;\n                    REQ_OUT <= 1'b1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 1'b0;\n                end\n                \n                CRC_Enable <= 1'b0;\n                CRC_RST <= 1'b1;\n                Cmd_Cnt <= 8'b0;\n                cmd_oe_o <= 1'b0;\n                CMD_OUT <= Out_Buff;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            \n            ACK_WO: begin\n                FSM_ACK <= 1'b1;\n            end\n            \n            ACK_WR: begin\n                FSM_ACK <= 1'b1;\n                REQ_OUT <= 1'b0;\n            end\n        endcase\n    end\nend\n\n// ACK_OUT generation\nalways @(*) begin\n    ACK_OUT = FSM_ACK & DECODER_ACK;\nend\n\nendmodule\n\n// CRC-7 module\nmodule sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        CRC[0] <= CRC[6] ^ BITVAL;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ CRC[6] ^ BITVAL;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 12, "code": "assign m_wb_stb_o = start_tx_fifo ? tx_m_wb_stb_o : \n                   (start_rx_fifo ? rx_m_wb_stb_o : 1'b0);\nassign m_wb_cti_o = start_tx_fifo ? tx_m_wb_cti_o : \n                   (start_rx_fifo ? rx_m_wb_cti_o : 3'b0);\nassign m_wb_bte_o = start_tx_fifo ? tx_m_wb_bte_o : \n                   (start_rx_fifo ? rx_m_wb_bte_o : 2'b0);\n\n// Interrupt generation\nassign int_a = |(normal_int_status_reg & normal_int_signal_enable_reg);\nassign int_b = |(error_int_status_reg & error_int_signal_enable_reg);\nassign int_c = |(Bd_isr_reg & Bd_isr_enable_reg);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 17, "code": "module sd_cmd_serial_host (\n    input SD_CLK_IN,\n    input RST_IN,\n    input [15:0] SETTING_IN,\n    input [39:0] CMD_IN,\n    input REQ_IN,\n    input ACK_IN,\n    input cmd_dat_i,\n    \n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [15:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n// Parameters\nparameter INIT_DELAY = 64;\nparameter NCR = 2;\nparameter SEND_SIZE = 48;\nparameter SIZE = 10;\nparameter CONTENT_SIZE = 40;\nparameter Read_Delay = 7;\nparameter EIGHT_PAD = 8;\n\n// State definitions\nlocalparam INIT     = 10'b0000000001;\nlocalparam IDLE     = 10'b0000000010;\nlocalparam WRITE_WR = 10'b0000000100;\nlocalparam DLY_WR   = 10'b0000001000;\nlocalparam READ_WR  = 10'b0000010000;\nlocalparam DLY_READ = 10'b0000100000;\nlocalparam ACK_WR   = 10'b0001000000;\nlocalparam WRITE_WO = 10'b0010000000;\nlocalparam DLY_WO   = 10'b0100000000;\nlocalparam ACK_WO   = 10'b1000000000;\n\n// Internal registers\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg Write_Read;\nreg Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST;\nreg [6:0] CRC_IN;\nwire [6:0] CRC_VAL;\nreg CRC_Enable;\nreg CRC_OUT;\nreg CRC_Check_On;\nreg Crc_Buffering;\nreg CRC_Valid;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg [9:0] state;\nreg [9:0] next_state;\nreg block_write;\nreg block_read;\nreg [1:0] word_select;\nreg FSM_ACK;\nreg DECODER_ACK;\n\n// Synchronization registers\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\n\n// CRC module instantiation\nsd_crc_7 crc7 (\n    .BITVAL(CRC_OUT),\n    .Enable(CRC_Enable),\n    .CLK(SD_CLK_IN),\n    .RST(CRC_RST),\n    .CRC(CRC_VAL)\n);\n\n// FSM_COMBO: Combinational logic for next state\nalways @(*) begin\n    case (state)\n        INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n        IDLE: begin\n            if (Write_Read)\n                next_state = WRITE_WR;\n            else if (Write_Only)\n                next_state = WRITE_WO;\n            else\n                next_state = IDLE;\n        end\n        WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n        WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n        DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n        DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n        READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n        DLY_READ: next_state = (Ack_internal_in) ? ACK_WR : DLY_READ;\n        ACK_WO: next_state = IDLE;\n        ACK_WR: next_state = IDLE;\n        default: next_state = INIT;\n    endcase\nend\n\n// FSM_SEQ: Sequential state update\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC: Synchronize REQ_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC: Synchronize ACK_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Delay_Cycler <= 0;\n        Response_Size <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        CRC_Check_On <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else begin\n        if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            \n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\nend\n\n// FSM_OUT: Output logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            \n            IDLE: begin\n                cmd_oe_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                st_dat_t <= 0;\n                word_select_counter <= 0;\n            end\n            \n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000000000000001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    st_dat_t <= block_read ? 2'b10 : (block_write ? 2'b01 : 2'b00);\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Delay_Cnt < 3'b111) begin\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                \n                Crc_Buffering <= 0;\n            end\n            \n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0100;\n                    STATUS[5] <= 0;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            \n            READ_WR: begin\n                Delay_Cnt <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Cmd_Cnt == 1) begin\n                    STATUS[3:0] <= 4'b0101;\n                    REQ_OUT <= 1;\n                    Out_Buff[39] <= 0;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Cmd_Cnt < Response_Size) begin\n                    Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                    CRC_OUT <= cmd_dat_i;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                    CRC_Enable <= 0;\n                end else begin\n                    if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                        CRC_Enable <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                        CRC_Enable <= 0;\n                    end\n                    \n                    if (block_read && block_write) begin\n                        st_dat_t <= 2'b11;\n                    end else if (block_write) begin\n                        st_dat_t <= 2'b01;\n                    end\n                end\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            \n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0110;\n                    STATUS[5] <= CRC_Valid;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                CMD_OUT <= Out_Buff;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            \n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            \n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\n// ACK_OUT generation\nalways @(*) begin\n    ACK_OUT <= FSM_ACK & DECODER_ACK;\nend\n\nendmodule\n\n// CRC-7 module\nmodule sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 0;\n    end else if (Enable) begin\n        CRC[0] <= BITVAL ^ CRC[6];\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= BITVAL ^ CRC[6] ^ CRC[2];\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 18, "code": "module sd_cmd_serial_host (\n    input SD_CLK_IN,\n    input RST_IN,\n    input [15:0] SETTING_IN,\n    input [39:0] CMD_IN,\n    input REQ_IN,\n    input ACK_IN,\n    input cmd_dat_i,\n    \n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [15:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n// Parameters\nparameter INIT_DELAY = `SIM ? 2 : 64;\nparameter NCR = 2;\nparameter SEND_SIZE = 48;\nparameter SIZE = 10;\nparameter CONTENT_SIZE = 40;\nparameter Read_Delay = 7;\nparameter EIGHT_PAD = 8;\n\n// States\nparameter INIT     = 10'b0000000001;\nparameter IDLE     = 10'b0000000010;\nparameter WRITE_WR = 10'b0000000100;\nparameter DLY_WR   = 10'b0000001000;\nparameter READ_WR  = 10'b0000010000;\nparameter DLY_READ = 10'b0000100000;\nparameter ACK_WR   = 10'b0001000000;\nparameter WRITE_WO = 10'b0010000000;\nparameter DLY_WO   = 10'b0100000000;\nparameter ACK_WO   = 10'b1000000000;\n\n// Internal registers\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg Write_Read;\nreg Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST;\nreg [6:0] CRC_IN;\nwire [6:0] CRC_VAL;\nreg CRC_Enable;\nreg CRC_OUT;\nreg CRC_Check_On;\nreg Crc_Buffering;\nreg CRC_Valid;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg [9:0] state;\nreg [9:0] next_state;\nreg block_write;\nreg block_read;\nreg [1:0] word_select;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\n\n// CRC module instantiation\nsd_crc_7 crc7 (\n    .BITVAL(CRC_OUT),\n    .Enable(CRC_Enable),\n    .CLK(SD_CLK_IN),\n    .RST(CRC_RST),\n    .CRC(CRC_VAL)\n);\n\n// FSM_COMBO: Combinational logic for next state\nalways @(*) begin\n    case (state)\n        INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n        IDLE: begin\n            if (Write_Read) next_state = WRITE_WR;\n            else if (Write_Only) next_state = WRITE_WO;\n            else next_state = IDLE;\n        end\n        WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n        WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n        DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n        DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n        READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n        DLY_READ: next_state = (Ack_internal_in) ? ACK_WR : DLY_READ;\n        ACK_WO: next_state = IDLE;\n        ACK_WR: next_state = IDLE;\n        default: next_state = INIT;\n    endcase\nend\n\n// FSM_SEQ: Sequential logic for state transition\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC: Synchronize REQ_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC: Synchronize ACK_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Delay_Cycler <= 0;\n        Response_Size <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        CRC_Check_On <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else begin\n        if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            \n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\nend\n\n// FSM_OUT\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            \n            IDLE: begin\n                cmd_oe_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                st_dat_t <= 0;\n                word_select_counter <= 0;\n            end\n            \n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000000000000001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                        if (block_read) st_dat_t <= 2'b10;\n                        else st_dat_t <= 2'b00;\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                        if (block_read) st_dat_t <= 2'b10;\n                        else st_dat_t <= 2'b00;\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Delay_Cnt < 3'b111) begin\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                \n                Crc_Buffering <= 0;\n            end\n            \n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0100;\n                    STATUS[5] <= 0;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            \n            READ_WR: begin\n                Delay_Cnt <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Cmd_Cnt == 1) begin\n                    STATUS[3:0] <= 4'b0101;\n                    REQ_OUT <= 1;\n                    Out_Buff[39] <= 0;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Cmd_Cnt < Response_Size) begin\n                    Out_Buff[38 - Cmd_Cnt] <= cmd_dat_i;\n                    CRC_OUT <= cmd_dat_i;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                    CRC_Enable <= 0;\n                end else begin\n                    if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                        CRC_Enable <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                        CRC_Enable <= 0;\n                    end\n                    \n                    if (block_read && block_write) begin\n                        st_dat_t <= 2'b11;\n                    end else if (block_write) begin\n                        st_dat_t <= 2'b01;\n                    end\n                end\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            \n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0110;\n                    STATUS[5] <= CRC_Valid;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                CMD_OUT <= Out_Buff;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            \n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            \n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\n// ACK_OUT generation\nalways @(*) begin\n    ACK_OUT = FSM_ACK & DECODER_ACK;\nend\n\nendmodule\n\n// CRC-7 module\nmodule sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 0;\n    end else if (Enable) begin\n        CRC[0] <= CRC[6] ^ BITVAL;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ CRC[6] ^ BITVAL;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 13, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input         wb_clk_i,\n    input         wb_rst_i,\n    input  [3:0]  wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0]  wb_adr_i,\n    input         wb_we_i,\n    input         wb_cyc_i,\n    input         wb_stb_i,\n    output        wb_ack_o,\n    \n    // Wishbone Master Interface\n    output [31:0] m_wb_adr_o,\n    output        m_wb_sel_o,\n    output        m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    \n    // SDC IO\n    input         sd_cmd_dat_i,\n    output        sd_cmd_out_o,\n    output        sd_cmd_oe_o,\n    input  [3:0]  sd_dat_dat_i,\n    output [3:0]  sd_dat_out_o,\n    output        sd_dat_oe_o,\n    output        sd_clk_o_pad,\n    input         sd_clk_i_pad,\n    input         card_detect,\n    \n    // Interrupts\n    output        int_a,\n    output        int_b,\n    output        int_c\n);\n\n    // Internal signals\n    wire        we_m_tx_bd;\n    wire        we_m_rx_bd;\n    wire        new_cmd;\n    wire        we_ack;\n    wire        int_ack;\n    wire        cmd_int_busy;\n    wire        int_busy;\n    wire        write_req_s;\n    wire [15:0] cmd_set_s;\n    wire [31:0] cmd_arg_s;\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0]  software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0]  clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0]  Bd_isr_reg;\n    wire [7:0]  Bd_isr_enable_reg;\n    wire        bd_isr_reset;\n    wire        normal_isr_reset;\n    wire        error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n    \n    // Data master signals\n    wire        d_write;\n    wire        d_read;\n    wire        start_tx_fifo;\n    wire        start_rx_fifo;\n    wire [31:0] sys_adr;\n    wire        ack_transfer;\n    wire [7:0]  Dat_Int_Status;\n    wire        CIDAT;\n    \n    // FIFO signals\n    wire        tx_empt;\n    wire        tx_full;\n    wire        rx_full;\n    wire        busy_n;\n    wire        transm_complete;\n    wire        crc_ok;\n    \n    // CMD master signals\n    wire        go_idle_o;\n    wire [39:0] cmd_out;\n    wire        req_out;\n    wire        ack_out;\n    wire        req_in;\n    wire        ack_in;\n    wire [39:0] cmd_in;\n    wire [7:0]  serial_status;\n    \n    // Data serial host signals\n    wire [31:0] data_out;\n    wire        rd;\n    wire        we;\n    wire [3:0]  DAT_dat_o;\n    wire        DAT_oe_o;\n    \n    // BD signals\n    wire [BD_WIDTH-1:0] free_tx_bd;\n    wire [BD_WIDTH-1:0] free_rx_bd;\n    wire        re_s_tx;\n    wire        a_cmp_tx;\n    wire        re_s_rx;\n    wire        a_cmp_rx;\n    wire        ack_i_s_tx;\n    wire        ack_i_s_rx;\n    wire [RAM_MEM_WIDTH-1:0] dat_out_s_tx;\n    wire [RAM_MEM_WIDTH-1:0] dat_out_s_rx;\n    \n    // Clock signals\n    wire        sd_clk_i;\n    wire        sd_clk_o;\n    \n    // Assign clock based on configuration\n    `ifdef SDC_CLK_BUS_CLK\n    assign sd_clk_i = wb_clk_i;\n    `else\n    assign sd_clk_i = sd_clk_i_pad;\n    `endif\n    \n    `ifdef SDC_CLK_DYNAMIC\n    assign sd_clk_o = SD_CLK;\n    `else\n    assign sd_clk_o = sd_clk_i;\n    `endif\n    \n    assign sd_clk_o_pad = sd_clk_o;\n    \n    // Interrupt generation\n    assign int_a = |(normal_int_status_reg & normal_int_signal_enable_reg);\n    assign int_b = |(error_int_status_reg & error_int_signal_enable_reg);\n    assign int_c = |(Bd_isr_reg & Bd_isr_enable_reg);\n    \n    // Master Wishbone Interface Control\n    assign m_wb_sel_o = 4'b1111;\n    assign m_wb_cyc_o = start_tx_fifo ? tx_fifo_m_wb_cyc_o : \n                       (start_rx_fifo ? rx_fifo_m_wb_cyc_o : 1'b0);\n    assign m_wb_stb_o = start_tx_fifo ? tx_fifo_m_wb_stb_o : \n                       (start_rx_fifo ? rx_fifo_m_wb_stb_o : 1'b0);\n    assign m_wb_cti_o = start_tx_fifo ? tx_fifo_m_wb_cti_o : \n                       (start_rx_fifo ? rx_fifo_m_wb_cti_o : 3'b0);\n    assign m_wb_bte_o = start_tx_fifo ? tx_fifo_m_wb_bte_o : \n                       (start_rx_fifo ? rx_fifo_m_wb_bte_o : 2'b0);\n    assign m_wb_we_o = start_tx_fifo ? tx_fifo_m_wb_we_o : \n                      (start_rx_fifo ? rx_fifo_m_wb_we_o : 1'b0);\n    assign m_wb_adr_o = start_tx_fifo ? tx_fifo_m_wb_adr_o : \n                       (start_rx_fifo ? rx_fifo_m_wb_adr_o : 32'b0);\n    assign m_wb_dat_o = rx_fifo_m_wb_dat_o;\n    \n    // Instantiate submodules\n    sd_controller_wb u_wb_controller (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n    \n    sd_clock_divider u_clock_divider (\n        .CLK(sd_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i | software_reset_reg[0]),\n        .SD_CLK(SD_CLK)\n    );\n    \n    sd_cmd_master u_cmd_master (\n        .CLK_PAD_IO(sd_clk_o),\n        .RST_PAD_I(wb_rst_i | software_reset_reg[0] | go_idle_o),\n        .New_CMD(new_cmd),\n        .data_write(d_write),\n        .data_read(d_read),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(cmd_set_s),\n        .go_idle_o(go_idle_o),\n        .cmd_out(cmd_out),\n        .req_out(req_out),\n        .ack_out(ack_out),\n        .req_in(req_in),\n        .ack_in(ack_in),\n        .cmd_in(cmd_in),\n        .serial_status(serial_status),\n        .card_detect(card_detect)\n    );\n    \n    sd_cmd_serial_host u_cmd_serial_host (\n        .SD_CLK_IN(sd_clk_o),\n        .RST_IN(wb_rst_i | software_reset_reg[0] | go_idle_o),\n        .SETTING_IN(cmd_set_s),\n        .CMD_IN(cmd_out),\n        .REQ_IN(req_out),\n        .ACK_IN(ack_out),\n        .cmd_dat_i(sd_cmd_dat_i),\n        .CMD_OUT(cmd_in),\n        .ACK_OUT(ack_in),\n        .REQ_OUT(req_in),\n        .STATUS(serial_status),\n        .cmd_oe_o(sd_cmd_oe_o),\n        .cmd_out_o(sd_cmd_out_o),\n        .st_dat_t()\n    );\n    \n    sd_data_master u_data_master (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .dat_in_tx(dat_out_s_tx),\n        .free_tx_bd(free_tx_bd),\n        .ack_i_s_tx(ack_i_s_tx),\n        .dat_in_rx(dat_out_s_rx),\n        .free_rx_bd(free_rx_bd),\n        .ack_i_s_rx(ack_i_s_rx),\n        .cmd_busy(cmd_int_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(),\n        .card_status(status_reg[4:0]),\n        .tx_empt(tx_empt),\n        .tx_full(tx_full),\n        .rx_full(rx_full),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok),\n        .Dat_Int_Status_rst(bd_isr_reset),\n        .transfer_type(),\n        .re_s_tx(re_s_tx),\n        .a_cmp_tx(a_cmp_tx),\n        .re_s_rx(re_s_rx),\n        .a_cmp_rx(a_cmp_rx),\n        .we_req(write_req_s),\n        .d_write(d_write),\n        .d_read(d_read),\n        .cmd_arg(cmd_arg_s),\n        .cmd_set(cmd_set_s),\n        .start_tx_fifo(start_tx_fifo),\n        .start_rx_fifo(start_rx_fifo),\n        .sys_adr(sys_adr),\n        .ack_transfer(ack_transfer),\n        .Dat_Int_Status(Dat_Int_Status),\n        .CIDAT(CIDAT)\n    );\n    \n    sd_data_serial_host u_data_serial_host (\n        .sd_clk(sd_clk_o),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .data_in(),\n        .start_dat({d_write, d_read}),\n        .ack_transfer(ack_transfer),\n        .DAT_dat_i(sd_dat_dat_i),\n        .rd(rd),\n        .data_out(data_out),\n        .we(we),\n        .DAT_oe_o(sd_dat_oe_o),\n        .DAT_dat_o(sd_dat_out_o),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok)\n    );\n    \n    tx_bd u_tx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_tx_bd),\n        .dat_in_m(dat_in_m_tx_bd),\n        .free_bd(free_tx_bd),\n        .re_s(re_s_tx),\n        .ack_o_s(ack_i_s_tx),\n        .a_cmp(a_cmp_tx),\n        .dat_out_s(dat_out_s_tx)\n    );\n    \n    rx_bd u_rx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_rx_bd),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(free_rx_bd),\n        .re_s(re_s_rx),\n        .ack_o_s(ack_i_s_rx),\n        .a_cmp(a_cmp_rx),\n        .dat_out_s(dat_out_s_rx)\n    );\n    \n    sd_fifo_tx_filler u_tx_fifo (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(tx_fifo_m_wb_adr_o),\n        .m_wb_we_o(tx_fifo_m_wb_we_o),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(tx_fifo_m_wb_cyc_o),\n        .m_wb_stb_o(tx_fifo_m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(tx_fifo_m_wb_cti_o),\n        .m_wb_bte_o(tx_fifo_m_wb_bte_o),\n        .en(start_tx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_o(),\n        .rd(rd),\n        .empty(tx_empt),\n        .fe(tx_full)\n    );\n    \n    sd_fifo_rx_filler u_rx_fifo (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(rx_fifo_m_wb_adr_o),\n        .m_wb_we_o(rx_fifo_m_wb_we_o),\n        .m_wb_dat_o(rx_fifo_m_wb_dat_o),\n        .m_wb_cyc_o(rx_fifo_m_wb_cyc_o),\n        .m_wb_stb_o(rx_fifo_m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(rx_fifo_m_wb_cti_o),\n        .m_wb_bte_o(rx_fifo_m_wb_bte_o),\n        .en(start_rx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_i(data_out),\n        .wr(we),\n        .full(rx_full)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 19, "code": "module sd_cmd_serial_host (\n    input SD_CLK_IN,\n    input RST_IN,\n    input [15:0] SETTING_IN,\n    input [39:0] CMD_IN,\n    input REQ_IN,\n    input ACK_IN,\n    input cmd_dat_i,\n    \n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [15:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n// Parameters\nparameter INIT_DELAY = `SIM ? 2 : 64;\nparameter NCR = 2;\nparameter SEND_SIZE = 48;\nparameter SIZE = 10;\nparameter CONTENT_SIZE = 40;\nparameter Read_Delay = 7;\nparameter EIGHT_PAD = 8;\n\n// FSM states\nparameter INIT     = 10'b0000000001;\nparameter IDLE     = 10'b0000000010;\nparameter WRITE_WR = 10'b0000000100;\nparameter DLY_WR   = 10'b0000001000;\nparameter READ_WR  = 10'b0000010000;\nparameter DLY_READ = 10'b0000100000;\nparameter ACK_WR   = 10'b0001000000;\nparameter WRITE_WO = 10'b0010000000;\nparameter DLY_WO   = 10'b0100000000;\nparameter ACK_WO   = 10'b1000000000;\n\n// Internal registers\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg Write_Read;\nreg Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST;\nreg [6:0] CRC_IN;\nwire [6:0] CRC_VAL;\nreg CRC_Enable;\nreg CRC_OUT;\nreg CRC_Check_On;\nreg Crc_Buffering;\nreg CRC_Valid;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg [9:0] state;\nreg [9:0] next_state;\nreg block_write;\nreg block_read;\nreg [1:0] word_select;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\n\n// CRC submodule\nsd_crc_7 crc7 (\n    .BITVAL(CRC_OUT),\n    .Enable(CRC_Enable),\n    .CLK(SD_CLK_IN),\n    .RST(CRC_RST),\n    .CRC(CRC_VAL)\n);\n\n// FSM_COMBO: Combinational logic for next state\nalways @(*) begin\n    case (state)\n        INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n        IDLE: begin\n            if (Write_Read) next_state = WRITE_WR;\n            else if (Write_Only) next_state = WRITE_WO;\n            else next_state = IDLE;\n        end\n        WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n        WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n        DLY_WR: begin\n            if (Delay_Cnt >= NCR && !cmd_dat_i) next_state = READ_WR;\n            else next_state = DLY_WR;\n        end\n        DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n        READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n        DLY_READ: next_state = (Ack_internal_in) ? ACK_WR : DLY_READ;\n        ACK_WO: next_state = IDLE;\n        ACK_WR: next_state = IDLE;\n        default: next_state = INIT;\n    endcase\nend\n\n// FSM_SEQ: Sequential state transition\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC: Synchronize REQ_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC: Synchronize ACK_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Delay_Cycler <= 0;\n        Response_Size <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        CRC_Check_On <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else begin\n        if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            \n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            \n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\nend\n\n// FSM_OUT\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            \n            IDLE: begin\n                cmd_oe_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                st_dat_t <= 0;\n                word_select_counter <= 0;\n            end\n            \n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000000000000001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                        CRC_OUT <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                        CRC_OUT <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    \n                    if (block_read) begin\n                        st_dat_t <= 2'b10;\n                    end else if (block_write) begin\n                        st_dat_t <= 2'b01;\n                    end\n                    \n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Delay_Cnt < 3'b111) begin\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                \n                Crc_Buffering <= 0;\n            end\n            \n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0100;\n                    STATUS[5] <= 0;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            \n            READ_WR: begin\n                Delay_Cnt <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Cmd_Cnt == 1) begin\n                    STATUS[3:0] <= 4'b0101;\n                    REQ_OUT <= 1;\n                    Out_Buff[39] <= 0;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Cmd_Cnt < Response_Size) begin\n                    Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                    CRC_OUT <= cmd_dat_i;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                    CRC_Enable <= 0;\n                end else begin\n                    if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                        CRC_Enable <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                        CRC_Enable <= 0;\n                    end\n                    \n                    if (block_read && block_write) begin\n                        st_dat_t <= 2'b11;\n                    end else if (block_write) begin\n                        st_dat_t <= 2'b01;\n                    end\n                end\n                \n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            \n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0110;\n                    STATUS[5] <= CRC_Valid;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                CMD_OUT <= Out_Buff;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            \n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            \n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\n// ACK_OUT generation\nalways @(*) begin\n    ACK_OUT = FSM_ACK & DECODER_ACK;\nend\n\nendmodule\n\n// CRC-7 submodule\nmodule sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nreg [6:0] CRC_Reg;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC_Reg <= 0;\n    end else if (Enable) begin\n        CRC_Reg[0] <= BITVAL ^ CRC_Reg[6];\n        CRC_Reg[1] <= CRC_Reg[0];\n        CRC_Reg[2] <= CRC_Reg[1];\n        CRC_Reg[3] <= CRC_Reg[2] ^ (BITVAL ^ CRC_Reg[6]);\n        CRC_Reg[4] <= CRC_Reg[3];\n        CRC_Reg[5] <= CRC_Reg[4];\n        CRC_Reg[6] <= CRC_Reg[5];\n    end\nend\n\nassign CRC = CRC_Reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 14, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input         wb_clk_i,\n    input         wb_rst_i,\n    input  [3:0]  wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0]  wb_adr_i,\n    input         wb_we_i,\n    input         wb_cyc_i,\n    input         wb_stb_i,\n    output        wb_ack_o,\n    \n    // Wishbone Master Interface\n    output [31:0] m_wb_adr_o,\n    output        m_wb_sel_o,\n    output        m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    \n    // SDC IO\n    input         sd_cmd_dat_i,\n    output        sd_cmd_out_o,\n    output        sd_cmd_oe_o,\n    input  [3:0]  sd_dat_dat_i,\n    output [3:0]  sd_dat_out_o,\n    output        sd_dat_oe_o,\n    output        sd_clk_o_pad,\n    input         sd_clk_i_pad,\n    input         card_detect,\n    \n    // Interrupts\n    output        int_a,\n    output        int_b,\n    output        int_c\n);\n\n    // Internal signals\n    wire        we_m_tx_bd;\n    wire        we_m_rx_bd;\n    wire        new_cmd;\n    wire        we_ack;\n    wire        int_ack;\n    wire        cmd_int_busy;\n    wire        int_busy;\n    wire        write_req_s;\n    wire [15:0] cmd_set_s;\n    wire [31:0] cmd_arg_s;\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0]  software_reset_reg;\n    wire [16:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0]  clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0]  Bd_isr_reg;\n    wire [7:0]  Bd_isr_enable_reg;\n    wire        bd_isr_reset;\n    wire        normal_isr_reset;\n    wire        error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n    \n    // Data master signals\n    wire        re_s_tx;\n    wire        a_cmp_tx;\n    wire        re_s_rx;\n    wire        a_cmp_rx;\n    wire        we_req;\n    wire        d_write;\n    wire        d_read;\n    wire [31:0] cmd_arg;\n    wire [15:0] cmd_set;\n    wire        start_tx_fifo;\n    wire        start_rx_fifo;\n    wire [31:0] sys_adr;\n    wire        ack_transfer;\n    wire [7:0]  Dat_Int_Status;\n    wire        CIDAT;\n    \n    // CMD master signals\n    wire [15:0] settings;\n    wire        go_idle_o;\n    wire [39:0] cmd_out;\n    wire        req_out;\n    wire        ack_out;\n    wire        req_in;\n    wire        ack_in;\n    wire [39:0] cmd_in;\n    wire [7:0]  serial_status;\n    \n    // Data serial host signals\n    wire        rd;\n    wire [3:0]  data_out;\n    wire        we;\n    wire        busy_n;\n    wire        transm_complete;\n    wire        crc_ok;\n    \n    // FIFO signals\n    wire        tx_empt;\n    wire        tx_full;\n    wire        rx_full;\n    \n    // Clock signals\n    wire        sd_clk_i;\n    wire        sd_clk_o;\n    \n    // Assign clock based on configuration\n`ifdef SDC_CLK_BUS_CLK\n    assign sd_clk_i = wb_clk_i;\n`else\n    assign sd_clk_i = sd_clk_i_pad;\n`endif\n\n`ifdef SDC_CLK_DYNAMIC\n    assign sd_clk_o = sd_clk_div;\n`else\n    assign sd_clk_o = sd_clk_i;\n`endif\n\n    assign sd_clk_o_pad = sd_clk_o;\n    \n    // Instantiate submodules\n    \n    // Wishbone interface\n    sd_controller_wb wb_interface (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n    \n    // Clock divider\n`ifdef SDC_CLK_DYNAMIC\n    sd_clock_divider clk_div (\n        .CLK(sd_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i | software_reset_reg[0]),\n        .SD_CLK(sd_clk_div)\n    );\n`endif\n    \n    // CMD master\n    sd_cmd_master cmd_master (\n        .CLK_PAD_IO(sd_clk_o),\n        .RST_PAD_I(wb_rst_i | software_reset_reg[0] | go_idle_o),\n        .New_CMD(new_cmd),\n        .data_write(d_write),\n        .data_read(d_read),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(settings),\n        .go_idle_o(go_idle_o),\n        .cmd_out(cmd_out),\n        .req_out(req_out),\n        .ack_out(ack_out),\n        .req_in(req_in),\n        .ack_in(ack_in),\n        .cmd_in(cmd_in),\n        .serial_status(serial_status),\n        .card_detect(card_detect)\n    );\n    \n    // CMD serial host\n    sd_cmd_serial_host cmd_serial (\n        .SD_CLK_IN(sd_clk_o),\n        .RST_IN(wb_rst_i | software_reset_reg[0] | go_idle_o),\n        .SETTING_IN(settings),\n        .CMD_IN(cmd_out),\n        .REQ_IN(req_out),\n        .ACK_IN(ack_out),\n        .cmd_dat_i(sd_cmd_dat_i),\n        .CMD_OUT(cmd_in),\n        .ACK_OUT(ack_in),\n        .REQ_OUT(req_in),\n        .STATUS(serial_status),\n        .cmd_oe_o(sd_cmd_oe_o),\n        .cmd_out_o(sd_cmd_out_o),\n        .st_dat_t()\n    );\n    \n    // Data master\n    sd_data_master data_master (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .dat_in_tx(dat_in_m_tx_bd),\n        .free_tx_bd(Bd_Status_reg[7:0]),\n        .ack_i_s_tx(a_cmp_tx),\n        .dat_in_rx(dat_in_m_rx_bd),\n        .free_rx_bd(Bd_Status_reg[15:8]),\n        .ack_i_s_rx(a_cmp_rx),\n        .cmd_busy(cmd_int_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(),\n        .card_status(status_reg[4:0]),\n        .tx_empt(tx_empt),\n        .tx_full(tx_full),\n        .rx_full(rx_full),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok),\n        .Dat_Int_Status_rst(bd_isr_reset),\n        .transfer_type(),\n        .re_s_tx(re_s_tx),\n        .a_cmp_tx(a_cmp_tx),\n        .re_s_rx(re_s_rx),\n        .a_cmp_rx(a_cmp_rx),\n        .we_req(we_req),\n        .d_write(d_write),\n        .d_read(d_read),\n        .cmd_arg(cmd_arg),\n        .cmd_set(cmd_set),\n        .start_tx_fifo(start_tx_fifo),\n        .start_rx_fifo(start_rx_fifo),\n        .sys_adr(sys_adr),\n        .ack_transfer(ack_transfer),\n        .Dat_Int_Status(Dat_Int_Status),\n        .CIDAT(CIDAT)\n    );\n    \n    // Data serial host\n    sd_data_serial_host data_serial (\n        .sd_clk(sd_clk_o),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .data_in(),\n        .start_dat({d_read, d_write}),\n        .ack_transfer(ack_transfer),\n        .DAT_dat_i(sd_dat_dat_i),\n        .rd(rd),\n        .data_out(data_out),\n        .we(we),\n        .DAT_oe_o(sd_dat_oe_o),\n        .DAT_dat_o(sd_dat_out_o),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok)\n    );\n    \n    // TX BD\n    sd_bd tx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_tx_bd),\n        .dat_in_m(dat_in_m_tx_bd),\n        .free_bd(Bd_Status_reg[7:0]),\n        .re_s(re_s_tx),\n        .ack_o_s(a_cmp_tx),\n        .a_cmp(a_cmp_tx),\n        .dat_out_s()\n    );\n    \n    // RX BD\n    sd_bd rx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_rx_bd),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(Bd_Status_reg[15:8]),\n        .re_s(re_s_rx),\n        .ack_o_s(a_cmp_rx),\n        .a_cmp(a_cmp_rx),\n        .dat_out_s()\n    );\n    \n    // TX FIFO Filler\n    sd_fifo_tx_filler tx_filler (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(start_tx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_o(),\n        .rd(rd),\n        .empty(tx_empt),\n        .fe(tx_full)\n    );\n    \n    // RX FIFO Filler\n    sd_fifo_rx_filler rx_filler (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(),\n        .m_wb_we_o(),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(),\n        .m_wb_stb_o(),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(),\n        .m_wb_bte_o(),\n        .en(start_rx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_i(data_out),\n        .wr(we),\n        .full(rx_full)\n    );\n    \n    // Master interface mux\n    assign m_wb_sel_o = 4'b1111;\n    \n    // Interrupt generation\n`ifdef SDC_IRQ_ENABLE\n    assign int_a = |(normal_int_status_reg & normal_int_signal_enable_reg);\n    assign int_b = |(error_int_status_reg & error_int_signal_enable_reg);\n    assign int_c = |(Bd_isr_reg & Bd_isr_enable_reg);\n`else\n    assign int_a = 1'b0;\n    assign int_b = 1'b0;\n    assign int_c = 1'b0;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 20, "code": "module sd_cmd_serial_host (\n    input SD_CLK_IN,\n    input RST_IN,\n    input [15:0] SETTING_IN,\n    input [39:0] CMD_IN,\n    input REQ_IN,\n    input ACK_IN,\n    input cmd_dat_i,\n    \n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [15:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n// Parameters\nparameter INIT_DELAY = `SIM ? 2 : 64;\nparameter NCR = 2;\nparameter SEND_SIZE = 48;\nparameter SIZE = 10;\nparameter CONTENT_SIZE = 40;\nparameter Read_Delay = 7;\nparameter EIGHT_PAD = 8;\n\n// FSM states\nparameter INIT     = 10'b0000000001;\nparameter IDLE     = 10'b0000000010;\nparameter WRITE_WR = 10'b0000000100;\nparameter DLY_WR   = 10'b0000001000;\nparameter READ_WR  = 10'b0000010000;\nparameter DLY_READ = 10'b0000100000;\nparameter ACK_WR   = 10'b0001000000;\nparameter WRITE_WO = 10'b0010000000;\nparameter DLY_WO   = 10'b0100000000;\nparameter ACK_WO   = 10'b1000000000;\n\n// Internal registers\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg Write_Read;\nreg Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST;\nreg [6:0] CRC_IN;\nwire [6:0] CRC_VAL;\nreg CRC_Enable;\nreg CRC_OUT;\nreg CRC_Check_On;\nreg Crc_Buffering;\nreg CRC_Valid;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nreg block_write;\nreg block_read;\nreg [1:0] word_select;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\n\n// Instantiate CRC module\nsd_crc_7 crc7 (\n    .BITVAL(CRC_OUT),\n    .Enable(CRC_Enable),\n    .CLK(SD_CLK_IN),\n    .RST(CRC_RST),\n    .CRC(CRC_VAL)\n);\n\n// FSM_COMBO: Combinational logic for next state\nalways @(*) begin\n    case (state)\n        INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n        IDLE: begin\n            if (Write_Read)\n                next_state = WRITE_WR;\n            else if (Write_Only)\n                next_state = WRITE_WO;\n            else\n                next_state = IDLE;\n        end\n        WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n        WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n        DLY_WR: begin\n            if (Delay_Cnt >= NCR && !cmd_dat_i)\n                next_state = READ_WR;\n            else\n                next_state = DLY_WR;\n        end\n        DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n        READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n        DLY_READ: next_state = (Ack_internal_in) ? ACK_WR : DLY_READ;\n        ACK_WO: next_state = IDLE;\n        ACK_WR: next_state = IDLE;\n        default: next_state = INIT;\n    endcase\nend\n\n// FSM_SEQ: Sequential state transition\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC: Synchronize REQ_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC: Synchronize ACK_IN\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER: Decode settings and command\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Delay_Cycler <= 0;\n        Response_Size <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        CRC_Check_On <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else begin\n        if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            \n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            \n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\nend\n\n// FSM_OUT: Output logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            \n            IDLE: begin\n                cmd_oe_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                st_dat_t <= 0;\n                word_select_counter <= 0;\n            end\n            \n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000000000000001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    \n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    \n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                \n                if (Cmd_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    \n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - 2)];\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    \n                    st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            \n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Delay_Cnt < 3'b111) begin\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                \n                Crc_Buffering <= 0;\n            end\n            \n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0100;\n                    STATUS[5] <= 0;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            \n            READ_WR: begin\n                Delay_Cnt <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                \n                if (Cmd_Cnt == 1) begin\n                    STATUS[3:0] <= 4'b0101;\n                    REQ_OUT <= 1;\n                    Out_Buff[39] <= 0;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                if (Cmd_Cnt < Response_Size) begin\n                    case (word_select)\n                        2'b00: Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        2'b01: Out_Buff[31 - (Cmd_Cnt % 32)] <= cmd_dat_i;\n                        2'b10: Out_Buff[15 - (Cmd_Cnt % 16)] <= cmd_dat_i;\n                        2'b11: Out_Buff[7 - (Cmd_Cnt % 8)] <= cmd_dat_i;\n                    endcase\n                    \n                    CRC_OUT <= cmd_dat_i;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                    CRC_Enable <= 0;\n                end else begin\n                    if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                        CRC_Enable <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                        CRC_Enable <= 0;\n                    end\n                    \n                    if (block_read && block_write) begin\n                        st_dat_t <= 2'b11;\n                    end else if (block_write) begin\n                        st_dat_t <= 2'b01;\n                    end\n                end\n                \n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            \n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0110;\n                    STATUS[5] <= CRC_Valid;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                \n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                CMD_OUT <= Out_Buff;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            \n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            \n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\n// ACK_OUT assignment\nalways @(*) begin\n    ACK_OUT = FSM_ACK & DECODER_ACK;\nend\n\nendmodule\n\n// CRC-7 module\nmodule sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 0;\n    end else if (Enable) begin\n        CRC[0] <= BITVAL ^ CRC[6];\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= BITVAL ^ CRC[6] ^ CRC[2];\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 15, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input         wb_clk_i,\n    input         wb_rst_i,\n    input  [3:0]  wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0]  wb_adr_i,\n    input         wb_we_i,\n    input         wb_cyc_i,\n    input         wb_stb_i,\n    output        wb_ack_o,\n    \n    // Wishbone Master Interface\n    output [31:0] m_wb_adr_o,\n    output        m_wb_sel_o,\n    output        m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    \n    // SDC IO\n    input         sd_cmd_dat_i,\n    output        sd_cmd_out_o,\n    output        sd_cmd_oe_o,\n    input  [3:0]  sd_dat_dat_i,\n    output [3:0]  sd_dat_out_o,\n    output        sd_dat_oe_o,\n    output        sd_clk_o_pad,\n    input         sd_clk_i_pad,\n    \n    // Interrupts\n    output        int_a,\n    output        int_b,\n    output        int_c,\n    \n    // Card detect\n    input         card_detect\n);\n\n    // Internal signals\n    wire        we_m_tx_bd;\n    wire        we_m_rx_bd;\n    wire        new_cmd;\n    wire        we_ack;\n    wire        int_ack;\n    wire        cmd_int_busy;\n    wire        int_busy;\n    wire        write_req_s;\n    wire [15:0] cmd_set_s;\n    wire [31:0] cmd_arg_s;\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0]  software_reset_reg;\n    wire [16:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0]  clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0]  Bd_isr_reg;\n    wire [7:0]  Bd_isr_enable_reg;\n    wire        bd_isr_reset;\n    wire        normal_isr_reset;\n    wire        error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n    \n    // Data master signals\n    wire        re_s_tx;\n    wire        a_cmp_tx;\n    wire        re_s_rx;\n    wire        a_cmp_rx;\n    wire        we_req;\n    wire        d_write;\n    wire        d_read;\n    wire [31:0] cmd_arg;\n    wire [15:0] cmd_set;\n    wire        start_tx_fifo;\n    wire        start_rx_fifo;\n    wire [31:0] sys_adr;\n    wire        ack_transfer;\n    wire [7:0]  Dat_Int_Status;\n    wire        CIDAT;\n    \n    // FIFO signals\n    wire        tx_empt;\n    wire        tx_full;\n    wire        rx_full;\n    wire        busy_n;\n    wire        transm_complete;\n    wire        crc_ok;\n    wire [1:0]  transfer_type;\n    \n    // CMD master signals\n    wire        go_idle_o;\n    wire [39:0] cmd_out;\n    wire        req_out;\n    wire        ack_out;\n    wire        req_in;\n    wire        ack_in;\n    wire [39:0] cmd_in;\n    wire [7:0]  serial_status;\n    \n    // Data serial host signals\n    wire [31:0] data_in;\n    wire [1:0]  start_dat;\n    wire [3:0]  data_out;\n    wire        rd;\n    wire        we;\n    \n    // Clock signals\n    wire        sd_clk_i;\n    wire        sd_clk_o;\n    \n    // Assign clock outputs\n    assign sd_clk_o_pad = sd_clk_o;\n    \n    // Assign master byte select\n    assign m_wb_sel_o = 4'b1111;\n    \n    // Instantiate submodules\n    \n    // Wishbone interface\n    sd_controller_wb wb_interface (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n    \n    // Clock divider\n    sd_clock_divider clk_div (\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i | software_reset_reg[0]),\n        .SD_CLK(sd_clk_o)\n    );\n    \n    // CMD master\n    sd_cmd_master cmd_master (\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i | software_reset_reg[0]),\n        .New_CMD(new_cmd),\n        .data_write(d_write),\n        .data_read(d_read),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(cmd_setting_reg),\n        .go_idle_o(go_idle_o),\n        .cmd_out(cmd_out),\n        .req_out(req_out),\n        .ack_out(ack_out),\n        .req_in(req_in),\n        .ack_in(ack_in),\n        .cmd_in(cmd_in),\n        .serial_status(serial_status),\n        .card_detect(card_detect)\n    );\n    \n    // CMD serial host\n    sd_cmd_serial_host cmd_serial (\n        .SD_CLK_IN(sd_clk_o),\n        .RST_IN(wb_rst_i | software_reset_reg[0] | go_idle_o),\n        .SETTING_IN(cmd_setting_reg),\n        .CMD_IN(cmd_out),\n        .REQ_IN(req_out),\n        .ACK_IN(ack_out),\n        .cmd_dat_i(sd_cmd_dat_i),\n        .CMD_OUT(cmd_in),\n        .ACK_OUT(ack_in),\n        .REQ_OUT(req_in),\n        .STATUS(serial_status),\n        .cmd_oe_o(sd_cmd_oe_o),\n        .cmd_out_o(sd_cmd_out_o),\n        .st_dat_t(transfer_type)\n    );\n    \n    // Data master\n    sd_data_master data_master (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .dat_in_tx(dat_in_m_tx_bd),\n        .free_tx_bd(Bd_Status_reg[7:0]),\n        .ack_i_s_tx(a_cmp_tx),\n        .dat_in_rx(dat_in_m_rx_bd),\n        .free_rx_bd(Bd_Status_reg[15:8]),\n        .ack_i_s_rx(a_cmp_rx),\n        .cmd_busy(cmd_int_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(serial_status[0]),\n        .card_status(status_reg[4:0]),\n        .tx_empt(tx_empt),\n        .tx_full(tx_full),\n        .rx_full(rx_full),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok),\n        .Dat_Int_Status_rst(bd_isr_reset),\n        .transfer_type(transfer_type),\n        .re_s_tx(re_s_tx),\n        .a_cmp_tx(a_cmp_tx),\n        .re_s_rx(re_s_rx),\n        .a_cmp_rx(a_cmp_rx),\n        .we_req(we_req),\n        .d_write(d_write),\n        .d_read(d_read),\n        .cmd_arg(cmd_arg),\n        .cmd_set(cmd_set),\n        .start_tx_fifo(start_tx_fifo),\n        .start_rx_fifo(start_rx_fifo),\n        .sys_adr(sys_adr),\n        .ack_transfer(ack_transfer),\n        .Dat_Int_Status(Dat_Int_Status),\n        .CIDAT(CIDAT)\n    );\n    \n    // Data serial host\n    sd_data_serial_host data_serial (\n        .sd_clk(sd_clk_o),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .data_in(data_in),\n        .start_dat(start_dat),\n        .ack_transfer(ack_transfer),\n        .DAT_dat_i(sd_dat_dat_i),\n        .rd(rd),\n        .data_out(data_out),\n        .we(we),\n        .DAT_oe_o(sd_dat_oe_o),\n        .DAT_dat_o(sd_dat_out_o),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok)\n    );\n    \n    // TX BD\n    tx_bd tx_buffer (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_tx_bd),\n        .dat_in_m(dat_in_m_tx_bd),\n        .free_bd(Bd_Status_reg[7:0]),\n        .re_s(re_s_tx),\n        .ack_o_s(a_cmp_tx),\n        .a_cmp(a_cmp_tx),\n        .dat_out_s(data_in)\n    );\n    \n    // RX BD\n    rx_bd rx_buffer (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_rx_bd),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(Bd_Status_reg[15:8]),\n        .re_s(re_s_rx),\n        .ack_o_s(a_cmp_rx),\n        .a_cmp(a_cmp_rx),\n        .dat_out_s(data_out)\n    );\n    \n    // TX FIFO\n    sd_fifo_tx_filler tx_fifo (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(start_tx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_o(data_in),\n        .rd(rd),\n        .empty(tx_empt),\n        .fe(tx_full)\n    );\n    \n    // RX FIFO\n    sd_fifo_rx_filler rx_fifo (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(start_rx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_i(data_out),\n        .wr(we),\n        .full(rx_full)\n    );\n    \n    // Interrupt generation\n    assign int_a = |(normal_int_status_reg & normal_int_signal_enable_reg);\n    assign int_b = |(error_int_status_reg & error_int_signal_enable_reg);\n    assign int_c = |(Bd_isr_reg & Bd_isr_enable_reg);\n    \n    // Clock selection\n    generate\n        if (SDC_CLK_SEP) begin\n            assign sd_clk_i = sd_clk_i_pad;\n        end else begin\n            assign sd_clk_i = wb_clk_i;\n        end\n    endgenerate\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 16, "code": "sd_bd u_tx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_i(we_m_tx_bd),\n        .dat_i(dat_in_m_tx_bd),\n        .re_i(re_s_tx),\n        .a_cmp_i(a_cmp_tx),\n        .dat_o(dat_out_s_tx),\n        .ack_o(ack_o_s_tx),\n        .free_bd(free_tx_bd)\n    );\n    \n    sd_bd u_rx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_i(we_m_rx_bd),\n        .dat_i(dat_in_m_rx_bd),\n        .re_i(re_s_rx),\n        .a_cmp_i(a_cmp_rx),\n        .dat_o(dat_out_s_rx),\n        .ack_o(ack_o_s_rx),\n        .free_bd(free_rx_bd)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 17, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input         wb_clk_i,\n    input         wb_rst_i,\n    input  [3:0]  wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0]  wb_adr_i,\n    input         wb_we_i,\n    input         wb_cyc_i,\n    input         wb_stb_i,\n    output        wb_ack_o,\n    \n    // Wishbone Master Interface\n    output [31:0] m_wb_adr_o,\n    output        m_wb_sel_o,\n    output        m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    \n    // SDC IO\n    input         sd_cmd_dat_i,\n    output        sd_cmd_out_o,\n    output        sd_cmd_oe_o,\n    input  [3:0]  sd_dat_dat_i,\n    output [3:0]  sd_dat_out_o,\n    output        sd_dat_oe_o,\n    output        sd_clk_o_pad,\n    input         sd_clk_i_pad,\n    input         card_detect,\n    \n    // Interrupts\n    output        int_a,\n    output        int_b,\n    output        int_c\n);\n\n    // Internal signals\n    wire        we_m_tx_bd;\n    wire        we_m_rx_bd;\n    wire        new_cmd;\n    wire        we_ack;\n    wire        int_ack;\n    wire        cmd_int_busy;\n    wire        int_busy;\n    wire        write_req_s;\n    wire [15:0] cmd_set_s;\n    wire [31:0] cmd_arg_s;\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0]  software_reset_reg;\n    wire [16:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0]  clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0]  Bd_isr_reg;\n    wire [7:0]  Bd_isr_enable_reg;\n    wire        bd_isr_reset;\n    wire        normal_isr_reset;\n    wire        error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n    \n    // Data master signals\n    wire        re_s_tx;\n    wire        a_cmp_tx;\n    wire        re_s_rx;\n    wire        a_cmp_rx;\n    wire        we_req;\n    wire        d_write;\n    wire        d_read;\n    wire [31:0] cmd_arg;\n    wire [15:0] cmd_set;\n    wire        start_tx_fifo;\n    wire        start_rx_fifo;\n    wire [31:0] sys_adr;\n    wire        ack_transfer;\n    wire [7:0]  Dat_Int_Status;\n    wire        CIDAT;\n    \n    // FIFO signals\n    wire        tx_empt;\n    wire        tx_full;\n    wire        rx_full;\n    wire        busy_n;\n    wire        transm_complete;\n    wire        crc_ok;\n    \n    // SD Clock signals\n    wire        sd_clk_i;\n    wire        sd_clk_o;\n    \n    // Assign SD clock\n    assign sd_clk_o_pad = sd_clk_o;\n    \n    // Instantiate sd_controller_wb\n    sd_controller_wb wb_interface (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n    \n    // Instantiate sd_clock_divider\n    sd_clock_divider clk_div (\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i | software_reset_reg[0]),\n        .SD_CLK(sd_clk_o)\n    );\n    \n    // Instantiate sd_cmd_master\n    sd_cmd_master cmd_master (\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i | software_reset_reg[0]),\n        .New_CMD(new_cmd),\n        .data_write(d_write),\n        .data_read(d_read),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(cmd_set_s),\n        .go_idle_o(go_idle_o),\n        .cmd_out(cmd_out),\n        .req_out(req_out),\n        .ack_out(ack_out),\n        .req_in(req_in),\n        .ack_in(ack_in),\n        .cmd_in(cmd_in),\n        .serial_status(serial_status),\n        .card_detect(card_detect)\n    );\n    \n    // Instantiate sd_cmd_serial_host\n    sd_cmd_serial_host cmd_serial (\n        .SD_CLK_IN(sd_clk_o),\n        .RST_IN(wb_rst_i | software_reset_reg[0] | go_idle_o),\n        .SETTING_IN(cmd_set_s),\n        .CMD_IN(cmd_out),\n        .REQ_IN(req_out),\n        .ACK_IN(ack_out),\n        .cmd_dat_i(sd_cmd_dat_i),\n        .CMD_OUT(cmd_in),\n        .ACK_OUT(ack_in),\n        .REQ_OUT(req_in),\n        .STATUS(serial_status),\n        .cmd_oe_o(sd_cmd_oe_o),\n        .cmd_out_o(sd_cmd_out_o),\n        .st_dat_t(st_dat_t)\n    );\n    \n    // Instantiate sd_data_master\n    sd_data_master data_master (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .dat_in_tx(dat_in_m_tx_bd),\n        .free_tx_bd(Bd_Status_reg[7:0]),\n        .ack_i_s_tx(a_cmp_tx),\n        .dat_in_rx(dat_in_m_rx_bd),\n        .free_rx_bd(Bd_Status_reg[15:8]),\n        .ack_i_s_rx(a_cmp_rx),\n        .cmd_busy(cmd_int_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(cmd_tsf_err),\n        .card_status(status_reg[4:0]),\n        .tx_empt(tx_empt),\n        .tx_full(tx_full),\n        .rx_full(rx_full),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok),\n        .Dat_Int_Status_rst(bd_isr_reset),\n        .transfer_type(st_dat_t),\n        .re_s_tx(re_s_tx),\n        .a_cmp_tx(a_cmp_tx),\n        .re_s_rx(re_s_rx),\n        .a_cmp_rx(a_cmp_rx),\n        .we_req(we_req),\n        .d_write(d_write),\n        .d_read(d_read),\n        .cmd_arg(cmd_arg),\n        .cmd_set(cmd_set),\n        .start_tx_fifo(start_tx_fifo),\n        .start_rx_fifo(start_rx_fifo),\n        .sys_adr(sys_adr),\n        .ack_transfer(ack_transfer),\n        .Dat_Int_Status(Dat_Int_Status),\n        .CIDAT(CIDAT)\n    );\n    \n    // Instantiate tx_bd\n    sd_bd tx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_tx_bd),\n        .dat_in_m(dat_in_m_tx_bd),\n        .free_bd(Bd_Status_reg[7:0]),\n        .re_s(re_s_tx),\n        .ack_o_s(a_cmp_tx),\n        .a_cmp(a_cmp_tx),\n        .dat_out_s(dat_out_s_tx)\n    );\n    \n    // Instantiate rx_bd\n    sd_bd rx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_rx_bd),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(Bd_Status_reg[15:8]),\n        .re_s(re_s_rx),\n        .ack_o_s(a_cmp_rx),\n        .a_cmp(a_cmp_rx),\n        .dat_out_s(dat_out_s_rx)\n    );\n    \n    // Instantiate sd_fifo_tx_filler\n    sd_fifo_tx_filler tx_filler (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(start_tx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_o(dat_o_tx),\n        .rd(rd_tx),\n        .empty(tx_empt),\n        .fe(tx_full)\n    );\n    \n    // Instantiate sd_fifo_rx_filler\n    sd_fifo_rx_filler rx_filler (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(start_rx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_i(sd_dat_dat_i),\n        .wr(wr_rx),\n        .full(rx_full)\n    );\n    \n    // Instantiate sd_data_serial_host\n    sd_data_serial_host data_serial (\n        .sd_clk(sd_clk_o),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .data_in(dat_o_tx),\n        .start_dat({start_tx_fifo, start_rx_fifo}),\n        .ack_transfer(ack_transfer),\n        .DAT_dat_i(sd_dat_dat_i),\n        .rd(rd_tx),\n        .data_out(data_out_rx),\n        .we(wr_rx),\n        .DAT_oe_o(sd_dat_oe_o),\n        .DAT_dat_o(sd_dat_out_o),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok)\n    );\n    \n    // Interrupt generation\n    assign int_a = |(normal_int_status_reg & normal_int_signal_enable_reg);\n    assign int_b = |(error_int_status_reg & error_int_signal_enable_reg);\n    assign int_c = |(Bd_isr_reg & Bd_isr_enable_reg);\n    \n    // Master Wishbone select\n    assign m_wb_sel_o = 4'b1111;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 18, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input         wb_clk_i,\n    input         wb_rst_i,\n    input  [3:0]  wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0]  wb_adr_i,\n    input         wb_we_i,\n    input         wb_cyc_i,\n    input         wb_stb_i,\n    output        wb_ack_o,\n    \n    // Wishbone Master Interface\n    output [31:0] m_wb_adr_o,\n    output        m_wb_sel_o,\n    output        m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    \n    // SDC IO\n    input         sd_cmd_dat_i,\n    output        sd_cmd_out_o,\n    output        sd_cmd_oe_o,\n    input  [3:0]  sd_dat_dat_i,\n    output [3:0]  sd_dat_out_o,\n    output        sd_dat_oe_o,\n    output        sd_clk_o_pad,\n    input         sd_clk_i_pad,\n    input         card_detect,\n    \n    // Interrupts\n    output        int_a,\n    output        int_b,\n    output        int_c\n);\n\n    // Internal signals\n    wire        we_m_tx_bd;\n    wire        we_m_rx_bd;\n    wire        new_cmd;\n    wire        we_ack;\n    wire        int_ack;\n    wire        cmd_int_busy;\n    wire        int_busy;\n    wire        write_req_s;\n    wire [15:0] cmd_set_s;\n    wire [31:0] cmd_arg_s;\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0]  software_reset_reg;\n    wire [16:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0]  clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0]  Bd_isr_reg;\n    wire [7:0]  Bd_isr_enable_reg;\n    wire        bd_isr_reset;\n    wire        normal_isr_reset;\n    wire        error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n    \n    // Data master signals\n    wire        re_s_tx;\n    wire        a_cmp_tx;\n    wire        re_s_rx;\n    wire        a_cmp_rx;\n    wire        we_req;\n    wire        d_write;\n    wire        d_read;\n    wire [31:0] cmd_arg;\n    wire [15:0] cmd_set;\n    wire        start_tx_fifo;\n    wire        start_rx_fifo;\n    wire [31:0] sys_adr;\n    wire        ack_transfer;\n    wire [7:0]  Dat_Int_Status;\n    wire        CIDAT;\n    \n    // FIFO signals\n    wire        tx_empt;\n    wire        tx_full;\n    wire        rx_full;\n    wire        busy_n;\n    wire        transm_complete;\n    wire        crc_ok;\n    \n    // CMD serial host signals\n    wire [39:0] cmd_out;\n    wire        req_out;\n    wire        ack_out;\n    wire        req_in;\n    wire        ack_in;\n    wire [39:0] cmd_in;\n    wire [7:0]  serial_status;\n    \n    // Data serial host signals\n    wire [31:0] data_in;\n    wire [1:0]  start_dat;\n    wire [3:0]  data_out;\n    wire        rd;\n    wire        we;\n    \n    // Clock signals\n    wire        sd_clk_i;\n    wire        sd_clk_o;\n    \n    // Assign clock outputs\n    assign sd_clk_o_pad = sd_clk_o;\n    \n    // Assign master byte select\n    assign m_wb_sel_o = 4'b1111;\n    \n    // Instantiate sd_controller_wb\n    sd_controller_wb wb_interface (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n    \n    // Instantiate sd_cmd_master\n    sd_cmd_master cmd_master (\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i | software_reset_reg[0]),\n        .New_CMD(new_cmd),\n        .data_write(d_write),\n        .data_read(d_read),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(cmd_setting_reg),\n        .go_idle_o(go_idle_o),\n        .cmd_out(cmd_out),\n        .req_out(req_out),\n        .ack_out(ack_out),\n        .req_in(req_in),\n        .ack_in(ack_in),\n        .cmd_in(cmd_in),\n        .serial_status(serial_status),\n        .card_detect(card_detect)\n    );\n    \n    // Instantiate sd_cmd_serial_host\n    sd_cmd_serial_host cmd_serial (\n        .SD_CLK_IN(sd_clk_o),\n        .RST_IN(wb_rst_i | software_reset_reg[0] | go_idle_o),\n        .SETTING_IN(cmd_setting_reg),\n        .CMD_IN(cmd_out),\n        .REQ_IN(req_out),\n        .ACK_IN(ack_out),\n        .cmd_dat_i(sd_cmd_dat_i),\n        .CMD_OUT(cmd_in),\n        .ACK_OUT(ack_in),\n        .REQ_OUT(req_in),\n        .STATUS(serial_status),\n        .cmd_oe_o(sd_cmd_oe_o),\n        .cmd_out_o(sd_cmd_out_o),\n        .st_dat_t(start_dat)\n    );\n    \n    // Instantiate sd_data_master\n    sd_data_master data_master (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .dat_in_tx(dat_in_m_tx_bd),\n        .free_tx_bd(Bd_Status_reg[7:0]),\n        .ack_i_s_tx(a_cmp_tx),\n        .dat_in_rx(dat_in_m_rx_bd),\n        .free_rx_bd(Bd_Status_reg[15:8]),\n        .ack_i_s_rx(a_cmp_rx),\n        .cmd_busy(cmd_int_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(1'b0), // TODO: Connect properly\n        .card_status(status_reg[4:0]),\n        .tx_empt(tx_empt),\n        .tx_full(tx_full),\n        .rx_full(rx_full),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok),\n        .Dat_Int_Status_rst(bd_isr_reset),\n        .transfer_type(start_dat),\n        .re_s_tx(re_s_tx),\n        .a_cmp_tx(a_cmp_tx),\n        .re_s_rx(re_s_rx),\n        .a_cmp_rx(a_cmp_rx),\n        .we_req(we_req),\n        .d_write(d_write),\n        .d_read(d_read),\n        .cmd_arg(cmd_arg),\n        .cmd_set(cmd_set),\n        .start_tx_fifo(start_tx_fifo),\n        .start_rx_fifo(start_rx_fifo),\n        .sys_adr(sys_adr),\n        .ack_transfer(ack_transfer),\n        .Dat_Int_Status(Dat_Int_Status),\n        .CIDAT(CIDAT)\n    );\n    \n    // Instantiate tx_bd\n    sd_bd tx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_tx_bd),\n        .dat_in_m(dat_in_m_tx_bd),\n        .free_bd(Bd_Status_reg[7:0]),\n        .re_s(re_s_tx),\n        .ack_o_s(a_cmp_tx),\n        .a_cmp(a_cmp_tx),\n        .dat_out_s(dat_out_s_tx)\n    );\n    \n    // Instantiate rx_bd\n    sd_bd rx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_rx_bd),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(Bd_Status_reg[15:8]),\n        .re_s(re_s_rx),\n        .ack_o_s(a_cmp_rx),\n        .a_cmp(a_cmp_rx),\n        .dat_out_s(dat_out_s_rx)\n    );\n    \n    // Instantiate sd_fifo_tx_filler\n    sd_fifo_tx_filler tx_filler (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(start_tx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_o(data_in),\n        .rd(rd),\n        .empty(tx_empt),\n        .fe(tx_full)\n    );\n    \n    // Instantiate sd_fifo_rx_filler\n    sd_fifo_rx_filler rx_filler (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(start_rx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_i(data_out),\n        .wr(we),\n        .full(rx_full)\n    );\n    \n    // Instantiate sd_data_serial_host\n    sd_data_serial_host data_serial (\n        .sd_clk(sd_clk_o),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .data_in(data_in),\n        .start_dat(start_dat),\n        .ack_transfer(ack_transfer),\n        .DAT_dat_i(sd_dat_dat_i),\n        .rd(rd),\n        .data_out(data_out),\n        .we(we),\n        .DAT_oe_o(sd_dat_oe_o),\n        .DAT_dat_o(sd_dat_out_o),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok)\n    );\n    \n    // Instantiate sd_clock_divider\n    sd_clock_divider clk_div (\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i | software_reset_reg[0]),\n        .SD_CLK(sd_clk_o)\n    );\n    \n    // Interrupt generation\n    assign int_a = |(normal_int_status_reg & normal_int_signal_enable_reg);\n    assign int_b = |(error_int_status_reg & error_int_signal_enable_reg);\n    assign int_c = |(Bd_isr_reg & Bd_isr_enable_reg);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 19, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input         wb_clk_i,\n    input         wb_rst_i,\n    input  [3:0]  wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0]  wb_adr_i,\n    input         wb_we_i,\n    input         wb_cyc_i,\n    input         wb_stb_i,\n    output        wb_ack_o,\n    \n    // Wishbone Master Interface\n    output [31:0] m_wb_adr_o,\n    output        m_wb_sel_o,\n    output        m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    \n    // SDC IO\n    input         sd_cmd_dat_i,\n    output        sd_cmd_out_o,\n    output        sd_cmd_oe_o,\n    input  [3:0]  sd_dat_dat_i,\n    output [3:0]  sd_dat_out_o,\n    output        sd_dat_oe_o,\n    output        sd_clk_o_pad,\n    input         sd_clk_i_pad,\n    input         card_detect,\n    \n    // Interrupts\n    output        int_a,\n    output        int_b,\n    output        int_c\n);\n\n    // Internal signals\n    wire        we_m_tx_bd;\n    wire        we_m_rx_bd;\n    wire        new_cmd;\n    wire        we_ack;\n    wire        int_ack;\n    wire        cmd_int_busy;\n    wire        int_busy;\n    wire        write_req_s;\n    wire [15:0] cmd_set_s;\n    wire [31:0] cmd_arg_s;\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0]  software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0]  clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0]  Bd_isr_reg;\n    wire [7:0]  Bd_isr_enable_reg;\n    wire        bd_isr_reset;\n    wire        normal_isr_reset;\n    wire        error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n    \n    // Data master signals\n    wire        data_write;\n    wire        data_read;\n    wire        re_s_tx;\n    wire        a_cmp_tx;\n    wire        re_s_rx;\n    wire        a_cmp_rx;\n    wire        start_tx_fifo;\n    wire        start_rx_fifo;\n    wire [31:0] sys_adr;\n    wire        ack_transfer;\n    wire        CIDAT;\n    \n    // FIFO signals\n    wire        tx_empt;\n    wire        tx_full;\n    wire        rx_full;\n    wire        busy_n;\n    wire        transm_complete;\n    wire        crc_ok;\n    \n    // SD clock signals\n    wire        sd_clk_i;\n    wire        sd_clk_o;\n    \n    // Assign SD clock\n    assign sd_clk_o_pad = sd_clk_o;\n    \n    // Instantiate sd_controller_wb\n    sd_controller_wb wb_interface (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n    \n    // Instantiate sd_clock_divider\n    sd_clock_divider clk_div (\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_o)\n    );\n    \n    // Instantiate sd_cmd_master\n    sd_cmd_master cmd_master (\n        .CLK_PAD_IO(sd_clk_o),\n        .RST_PAD_I(wb_rst_i),\n        .New_CMD(new_cmd),\n        .data_write(data_write),\n        .data_read(data_read),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(),\n        .go_idle_o(),\n        .cmd_out(),\n        .req_out(),\n        .ack_out(),\n        .req_in(),\n        .ack_in(),\n        .cmd_in(),\n        .serial_status(),\n        .card_detect(card_detect)\n    );\n    \n    // Instantiate sd_cmd_serial_host\n    sd_cmd_serial_host cmd_serial (\n        .SD_CLK_IN(sd_clk_o),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(cmd_setting_reg),\n        .CMD_IN(),\n        .REQ_IN(),\n        .ACK_IN(),\n        .cmd_dat_i(sd_cmd_dat_i),\n        .CMD_OUT(),\n        .ACK_OUT(),\n        .REQ_OUT(),\n        .STATUS(),\n        .cmd_oe_o(sd_cmd_oe_o),\n        .cmd_out_o(sd_cmd_out_o),\n        .st_dat_t()\n    );\n    \n    // Instantiate sd_data_master\n    sd_data_master data_master (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_tx(),\n        .free_tx_bd(),\n        .ack_i_s_tx(),\n        .dat_in_rx(),\n        .free_rx_bd(),\n        .ack_i_s_rx(),\n        .cmd_busy(cmd_int_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(),\n        .card_status(),\n        .tx_empt(tx_empt),\n        .tx_full(tx_full),\n        .rx_full(rx_full),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok),\n        .Dat_Int_Status_rst(bd_isr_reset),\n        .transfer_type(),\n        .re_s_tx(re_s_tx),\n        .a_cmp_tx(a_cmp_tx),\n        .re_s_rx(re_s_rx),\n        .a_cmp_rx(a_cmp_rx),\n        .we_req(write_req_s),\n        .d_write(data_write),\n        .d_read(data_read),\n        .cmd_arg(cmd_arg_s),\n        .cmd_set(cmd_set_s),\n        .start_tx_fifo(start_tx_fifo),\n        .start_rx_fifo(start_rx_fifo),\n        .sys_adr(sys_adr),\n        .ack_transfer(ack_transfer),\n        .Dat_Int_Status(Bd_isr_reg),\n        .CIDAT(CIDAT)\n    );\n    \n    // Instantiate tx_bd\n    sd_bd tx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(we_m_tx_bd),\n        .dat_in_m(dat_in_m_tx_bd),\n        .free_bd(),\n        .re_s(re_s_tx),\n        .ack_o_s(),\n        .a_cmp(a_cmp_tx),\n        .dat_out_s()\n    );\n    \n    // Instantiate rx_bd\n    sd_bd rx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(we_m_rx_bd),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(),\n        .re_s(re_s_rx),\n        .ack_o_s(),\n        .a_cmp(a_cmp_rx),\n        .dat_out_s()\n    );\n    \n    // Instantiate sd_fifo_tx_filler\n    sd_fifo_tx_filler tx_fifo (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(),\n        .m_wb_we_o(),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(),\n        .m_wb_stb_o(),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(),\n        .m_wb_bte_o(),\n        .en(start_tx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_o(),\n        .rd(),\n        .empty(tx_empt),\n        .fe(tx_full)\n    );\n    \n    // Instantiate sd_fifo_rx_filler\n    sd_fifo_rx_filler rx_fifo (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(start_rx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o),\n        .dat_i(sd_dat_dat_i),\n        .wr(),\n        .full(rx_full)\n    );\n    \n    // Instantiate sd_data_serial_host\n    sd_data_serial_host data_serial (\n        .sd_clk(sd_clk_o),\n        .rst(wb_rst_i),\n        .data_in(),\n        .start_dat(),\n        .ack_transfer(ack_transfer),\n        .DAT_dat_i(sd_dat_dat_i),\n        .rd(),\n        .data_out(),\n        .we(),\n        .DAT_oe_o(sd_dat_oe_o),\n        .DAT_dat_o(sd_dat_out_o),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok)\n    );\n    \n    // Interrupt generation\n    assign int_a = |(normal_int_status_reg & normal_int_signal_enable_reg);\n    assign int_b = |(error_int_status_reg & error_int_signal_enable_reg);\n    assign int_c = |(Bd_isr_reg & Bd_isr_enable_reg);\n    \n    // Master Wishbone select\n    assign m_wb_sel_o = 4'b1111;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 20, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input         wb_clk_i,\n    input         wb_rst_i,\n    input  [3:0]  wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0]  wb_adr_i,\n    input         wb_we_i,\n    input         wb_cyc_i,\n    input         wb_stb_i,\n    output        wb_ack_o,\n    \n    // Wishbone Master Interface\n    output [31:0] m_wb_adr_o,\n    output        m_wb_sel_o,\n    output        m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    \n    // SD Card Interface\n    input         sd_cmd_dat_i,\n    output        sd_cmd_out_o,\n    output        sd_cmd_oe_o,\n    input  [3:0]  sd_dat_dat_i,\n    output [3:0]  sd_dat_out_o,\n    output        sd_dat_oe_o,\n    output        sd_clk_o_pad,\n    input         sd_clk_i_pad,\n    input         card_detect,\n    \n    // Interrupts\n    output        int_a,\n    output        int_b,\n    output        int_c\n);\n\n    // Internal signals\n    wire        we_m_tx_bd;\n    wire        we_m_rx_bd;\n    wire        new_cmd;\n    wire        we_ack;\n    wire        int_ack;\n    wire        cmd_int_busy;\n    wire        int_busy;\n    wire        write_req_s;\n    wire [15:0] cmd_set_s;\n    wire [31:0] cmd_arg_s;\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0]  software_reset_reg;\n    wire [16:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0]  clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0]  Bd_isr_reg;\n    wire [7:0]  Bd_isr_enable_reg;\n    wire        bd_isr_reset;\n    wire        normal_isr_reset;\n    wire        error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n    \n    // Data master signals\n    wire        re_s_tx;\n    wire        a_cmp_tx;\n    wire        re_s_rx;\n    wire        a_cmp_rx;\n    wire        we_req;\n    wire        d_write;\n    wire        d_read;\n    wire [31:0] cmd_arg;\n    wire [15:0] cmd_set;\n    wire        start_tx_fifo;\n    wire        start_rx_fifo;\n    wire [31:0] sys_adr;\n    wire        ack_transfer;\n    wire [7:0]  Dat_Int_Status;\n    wire        CIDAT;\n    \n    // FIFO signals\n    wire        tx_empt;\n    wire        tx_full;\n    wire        rx_full;\n    wire        busy_n;\n    wire        transm_complete;\n    wire        crc_ok;\n    \n    // SD clock signals\n    wire        sd_clk;\n    \n    // Instantiate sd_controller_wb\n    sd_controller_wb u_wb_controller (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n    \n    // Instantiate sd_clock_divider\n    sd_clock_divider u_clock_divider (\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i | software_reset_reg[0]),\n        .SD_CLK(sd_clk)\n    );\n    \n    // Assign SD clock output\n    assign sd_clk_o_pad = sd_clk;\n    \n    // Instantiate sd_cmd_master\n    sd_cmd_master u_cmd_master (\n        .CLK_PAD_IO(sd_clk),\n        .RST_PAD_I(wb_rst_i | software_reset_reg[0]),\n        .New_CMD(new_cmd),\n        .data_write(d_write),\n        .data_read(d_read),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(),\n        .go_idle_o(),\n        .cmd_out(),\n        .req_out(),\n        .ack_out(),\n        .req_in(),\n        .ack_in(),\n        .cmd_in(),\n        .serial_status(),\n        .card_detect(card_detect)\n    );\n    \n    // Instantiate sd_data_master\n    sd_data_master u_data_master (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .dat_in_tx(),\n        .free_tx_bd(),\n        .ack_i_s_tx(),\n        .dat_in_rx(),\n        .free_rx_bd(),\n        .ack_i_s_rx(),\n        .cmd_busy(cmd_int_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(),\n        .card_status(),\n        .tx_empt(tx_empt),\n        .tx_full(tx_full),\n        .rx_full(rx_full),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok),\n        .Dat_Int_Status_rst(bd_isr_reset),\n        .transfer_type(),\n        .re_s_tx(re_s_tx),\n        .a_cmp_tx(a_cmp_tx),\n        .re_s_rx(re_s_rx),\n        .a_cmp_rx(a_cmp_rx),\n        .we_req(we_req),\n        .d_write(d_write),\n        .d_read(d_read),\n        .cmd_arg(cmd_arg),\n        .cmd_set(cmd_set),\n        .start_tx_fifo(start_tx_fifo),\n        .start_rx_fifo(start_rx_fifo),\n        .sys_adr(sys_adr),\n        .ack_transfer(ack_transfer),\n        .Dat_Int_Status(Dat_Int_Status),\n        .CIDAT(CIDAT)\n    );\n    \n    // Instantiate tx_bd\n    sd_bd u_tx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_tx_bd),\n        .dat_in_m(dat_in_m_tx_bd),\n        .free_bd(),\n        .re_s(re_s_tx),\n        .ack_o_s(),\n        .a_cmp(a_cmp_tx),\n        .dat_out_s()\n    );\n    \n    // Instantiate rx_bd\n    sd_bd u_rx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .we_m(we_m_rx_bd),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(),\n        .re_s(re_s_rx),\n        .ack_o_s(),\n        .a_cmp(a_cmp_rx),\n        .dat_out_s()\n    );\n    \n    // Instantiate sd_fifo_tx_filler\n    sd_fifo_tx_filler u_tx_filler (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(),\n        .m_wb_we_o(),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(),\n        .m_wb_stb_o(),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(),\n        .m_wb_bte_o(),\n        .en(start_tx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk),\n        .dat_o(),\n        .rd(),\n        .empty(tx_empt),\n        .fe(tx_full)\n    );\n    \n    // Instantiate sd_fifo_rx_filler\n    sd_fifo_rx_filler u_rx_filler (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i | software_reset_reg[0]),\n        .m_wb_adr_o(),\n        .m_wb_we_o(),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(),\n        .m_wb_stb_o(),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(),\n        .m_wb_bte_o(),\n        .en(start_rx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk),\n        .dat_i(),\n        .wr(),\n        .full(rx_full)\n    );\n    \n    // Master Wishbone Interface Mux\n    assign m_wb_adr_o = start_tx_fifo ? u_tx_filler.m_wb_adr_o : \n                       (start_rx_fifo ? u_rx_filler.m_wb_adr_o : 32'b0);\n    assign m_wb_we_o = start_tx_fifo ? u_tx_filler.m_wb_we_o : \n                      (start_rx_fifo ? u_rx_filler.m_wb_we_o : 1'b0);\n    assign m_wb_cyc_o = start_tx_fifo ? u_tx_filler.m_wb_cyc_o : \n                       (start_rx_fifo ? u_rx_filler.m_wb_cyc_o : 1'b0);\n    assign m_wb_stb_o = start_tx_fifo ? u_tx_filler.m_wb_stb_o : \n                       (start_rx_fifo ? u_rx_filler.m_wb_stb_o : 1'b0);\n    assign m_wb_cti_o = start_tx_fifo ? u_tx_filler.m_wb_cti_o : \n                       (start_rx_fifo ? u_rx_filler.m_wb_cti_o : 3'b0);\n    assign m_wb_bte_o = start_tx_fifo ? u_tx_filler.m_wb_bte_o : \n                       (start_rx_fifo ? u_rx_filler.m_wb_bte_o : 2'b0);\n    assign m_wb_sel_o = 4'b1111; // Always select all bytes\n    \n    // Interrupt generation\n    assign int_a = |(normal_int_status_reg & normal_int_signal_enable_reg);\n    assign int_b = |(error_int_status_reg & error_int_signal_enable_reg);\n    assign int_c = |(Bd_isr_reg & Bd_isr_enable_reg);\n\nendmodule\n\n// Sub-module definitions would be included here\n// (sd_controller_wb, sd_clock_divider, sd_cmd_master, sd_data_master, sd_bd, etc.)", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
